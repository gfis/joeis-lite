# CR.xpat - Mapping table seqdb -> irvine.math.cr.CR infix expression generation
# @(#) $Id$
# 2025-02-07: all trigon. functions in REALS.; *KFF=1
# 2021-07-27: Gamma, lnGamma
# 2021-07-19: root
# 2021-07-08, Georg Fischer
#
# 0	numb	0	CR.ZERO	0
# 1	numb	0	CR.ONE	0
# 2	numb	0	CR.TWO	0
# 3	numb	0	CR.THREE	0
# 4	numb	0	CR.FOUR	0
# 5	numb	0	CR.FIVE	0
# 6	numb	0	CR.SIX	0
# 7	numb	0	CR.SEVEN	0
# 8	numb	0	CR.EIGHT	0
# 9	numb	0	CR.NINE	0
# 10	numb	0	CR.TEN	0
01234567	numb	0	CR.valueOf(01234567)	0

n	name	0	CR.valueOf(mN)	0
#b	name	0	mB	0
#c	name	0	mC	0
#d	name	0	mD	0
#f	name	0	mF	0
#h	name	0	mH	0
#k	name	0	mK	0
#r	name	0	mR	0
#s	name	0	mS	0
#t	name	0	mT	0
#u	name	0	mU	0
#v	name	0	mV	0
#w	name	0	mW	0
#x	name	0	mX	0
Pi	name	0	CR.PI	0
pi	name	0	CR.PI	0
E	name	0	CR.E	0
e	name	0	CR.E	0
phi	name	0	CR.PHI	0
gamma	name	0	CR.GAMMA	0
eulergamma	name	0	CR.GAMMA
EulerGamma	name	0	CR.GAMMA
sqrt_2	name	0	CR.SQRT2

+	meth	2	.add(	0
-	meth	2	.subtract(	0
-.	meth	1	.negate(	0
*	meth	2	.multiply(	0
/	meth	2	.divide(	0
%	meth	2	.mod(	0
^	meth	2	.pow(	1

abs)	meth	1	.abs(	0
agm)	meth	2	.agm(	0
AGM)	meth	2	.agm(	0
besselI0)	meth	1	.besselI0(	0
besselJ0)	meth	1	.besselJ0(	0
besselY0)	meth	1	.besselY0(	0
ceil)	meth	1	.ceil(	0
ei)	meth	1	.ei(	0
getcr)	meth	1	.getCR(	0
Gamma)	meth	1	.gamma(	1
GAMMA)	meth	1	.gamma(	0
lnGamma)	meth	1	.lnGamma(	1
li)	meth	1	.li(	0
si)	meth	1	.si(	0
Ei)	meth	1	.ei(	0
Li)	meth	1	.li(	0
Si)	meth	1	.si(	0
erf)	meth	1	.erf(	0
erfc)	meth	1	.erfc(	0
exp)	meth	1	.exp(	0
floor)	meth	1	.floor(	0
frac)	meth	1	.frac(	0
ln)	meth	1	.log(	0
log)	meth	1	.log(	0
log2)	meth	1	.log().divide(CR.TWO.log()	0
log_2)	meth	1	.log().divide(CR.TWO.log()	0
log_3)	meth	1	.log().divide(CR.THREE.log()	0
log_5)	meth	1	.log().divide(CR.FIVE.log()	0
log10)	meth	1	.log().divide(CR.TEN.log()	0
log_10)	meth	1	.log().divide(CR.TEN.log()	0
# Psi)	func	1	REALS.psi(	1
# psi)	func	1	REALS.psi(	1
root)	meth	2	.root(	0
round)	meth	1	.round(	0
sqrt)	meth	1	.sqrt(	0
Sqrt)	meth	1	.sqrt(	0

sin)	func	1	REALS.sin(	1
cos)	func	1	REALS.cos(	1
tan)	func	1	REALS.tan(	1
cot)	func	1	REALS.cot(	1
sec)	func	1	REALS.sec(	1
csc)	func	1	REALS.csc(	1
arcsin)	func	1	REALS.asin(	1
arccos)	func	1	REALS.acos(	1
arctan)	func	1	REALS.atan(	1
arccot)	func	1	REALS.acot(	1
arcsec)	func	1	REALS.asec(	1
arccsc)	func	1	REALS.acsc(	1
asin)	func	1	REALS.asin(	1
acos)	func	1	REALS.acos(	1
atan)	func	1	REALS.atan(	1
acot)	func	1	REALS.acot(	1
asec)	func	1	REALS.asec(	1
acsc)	func	1	REALS.acsc(	1
sinh)	func	1	REALS.sinh(	1
cosh)	func	1	REALS.cosh(	1
tanh)	func	1	REALS.tanh(	1
coth)	func	1	REALS.coth(	1
sech)	func	1	REALS.sech(	1
csch)	func	1	REALS.csch(	1
cosech)	func	1	REALS.csch(	1
arcsinh)	func	1	REALS.asinh(
arccosh)	func	1	REALS.acosh(
arctanh)	func	1	REALS.atanh(
arccoth)	func	1	REALS.acoth(
arcsech)	func	1	REALS.asech(
arccsch)	func	1	REALS.acsch(
arsinh)	func	1	REALS.asinh(
arcosh)	func	1	REALS.acosh(
artanh)	func	1	REALS.atanh(
arcoth)	func	1	REALS.acoth(
arsech)	func	1	REALS.asech(
arcsch)	func	1	REALS.acsch(

zeta)	func	1	Zeta.zeta(	1
Zeta)	func	1	Zeta.zeta(	1

omega)	func	1	Functions.OMEGA.z(
sigma)	func	1	Functions.SIGMA.z(
