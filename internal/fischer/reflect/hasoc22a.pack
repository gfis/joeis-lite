#!queue	A000560	1	->	2	A000682	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000560 Number of ways of folding a strip of n labeled stamps.
 * @author Sean A. Irvine
 */
public class A000560 extends AbstractSequence {

  private final A000682 mSeq1 = new A000682();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A000763	0	->	1	A052894	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a052.A052894;
import irvine.oeis.AbstractSequence;

/**
 * A000763 Number of interval orders constructed from n intervals of generic lengths.
 * @author Sean A. Irvine
 */
public class A000763 extends AbstractSequence {

  private final A052894 mSeq1 = new A052894();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private final ArrayList<Q> mCoeff = new ArrayList<>();
  private Z mF = Z.ONE;
  private int mN = 0;

  {
    mCoeff.add(new Q(mSeq1.next()));
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mCoeff.add(new Q(mSeq1.next(), mF));
    final Polynomial<Q> rootSquared = RING.pow(RING.create(mCoeff), 2, mN);
    final Polynomial<Q> integral = RING.integrate(rootSquared);
    final Polynomial<Q> egf = RING.exp(integral, mN);
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A000901	0	->	1	A037223	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a037.A037223;
import irvine.oeis.a122.A122670;
import irvine.oeis.AbstractSequence;

/**
 * A000901 Number of solutions to the rook problem on a 2n X 2n board having a certain symmetry group (see Robinson for details).
 * @author Sean A. Irvine
 */
public class A000901 extends AbstractSequence {

  private final A037223 mSeq1 = new A037223();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA898 = new A000898();
  private final Sequence mA122670 = new A122670();

  {
    mA898.next();
    mA122670.next();
    mA122670.next();
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    mSeq1.next();
    mA122670.next();
    return mSeq1.next().subtract(mA898.next()).subtract(mA122670.next()).divide(4);
  }
}

#!queue	A000903	0	->	1	A037223	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a037.A037223;
import irvine.oeis.a122.A122670;
import irvine.oeis.AbstractSequence;

/**
 * A000903 Number of inequivalent ways of placing n nonattacking rooks on n X n board up to rotations and reflections of the board.
 * @author Sean A. Irvine
 */
public class A000903 extends AbstractSequence {

  private final A037223 mSeq1 = new A037223();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA85 = new A000085();
  private final Sequence mA122670 = new A122670();
  private final Sequence mA142 = new A000142();

  {
    mA85.next();
    mA142.next();
    mA122670.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.ONE.max(mSeq1.next()
                     .add(mA142.next())
                     .add(mA122670.next().multiply2())
                     .add(mA85.next().multiply2())
                     .divide(8));
  }
}

#!queue	A001572	1	->	0	A000084	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.a000.A000084;
import irvine.oeis.AbstractSequence;

/**
 * A001572 Related to series-parallel networks.
 * @author Sean A. Irvine
 */
public class A001572 extends AbstractSequence {

  private final A000084 mSeq1 = new A000084();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final ArrayList<Z> mA84 = new ArrayList<>();
  {
    mA84.add(Z.ONE);
  }
  private int mN = -1;

  @Override
  public Z next() {
    // INVERTi transform of A000084
    mA84.add(mSeq1.next());
    return RING.coeff(RING.one(), RING.create(mA84), ++mN).abs();
  }
}
#!queue	A001626	0	->	1	A000186	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000186;
import irvine.oeis.AbstractSequence;

/**
 * A001626 Number of 3-line Latin rectangles.
 * @author Sean A. Irvine
 */
public class A001626 extends AbstractSequence {

  private final A000186 mSeq1 = new A000186();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  private int mN = -1;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    mA = mA.multiply(++mN).multiply2().add(mSeq1.next());
    return mA;
  }
}

#!queue	A001677	1	->	2	A000084	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a000.A000084;
import irvine.oeis.AbstractSequence;

/**
 * A001677 Number of series-parallel networks with n edges.
 * @author Sean A. Irvine
 */
public class A001677 extends AbstractSequence {

  private final A000084 mSeq1 = new A000084();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final ArrayList<Z> mA84 = new ArrayList<>();
  {
    mA84.add(mSeq1.next());
  }

  private int mN = 0;

  @Override
  public Z next() {
    final Z t = mSeq1.next();
    mA84.add(t);
    ++mN;
    Z s = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      s = s.add(mA84.get(k).multiply(mA84.get(mN - 1 - k)));
    }
    if ((mN & 1) != 0) {
      s = s.add(mA84.get(mN / 2));
    }
    return t.subtract(s.divide2());
  }
}
#!queue	A001758	0	->	2	A001250	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001758 Number of quasi-alternating permutations of length n.
 * @author Sean A. Irvine
 */
public class A001758 extends AbstractSequence {

  private final A001250 mSeq1 = new A001250();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  protected Z mT = mSeq1.next();
  protected Z mA1758;

  @Override
  public Z next() {
    final Z t = mSeq1.next();
    final Z r = t.subtract(mT.multiply2());
    mT = t;
    mA1758 = r;
    return r;
  }
}
#!queue	A002112	0	->	1	A002114	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002112 Glaisher's H numbers.
 * @author Sean A. Irvine
 */
public class A002112 extends AbstractSequence {

  private final A002114 mSeq1 = new A002114();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().multiply(3);
  }
}
#!queue	A002114	0	->	1	A000436	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000436;
import irvine.oeis.AbstractSequence;

/**
 * A002114 Glaisher's H' numbers.
 * @author Sean A. Irvine
 */
public class A002114 extends AbstractSequence {

  private final A000436 mSeq1 = new A000436();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 1;

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    mN += 2;
    return mSeq1.next().shiftRight(mN);
  }
}
#!queue	A002468	2	->	1	A002469	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a001.A001563;
import irvine.oeis.AbstractSequence;

/**
 * A002468 The game of Mousetrap with n cards: the number of permutations of n cards having at least one hit after 2.
 * @author Sean A. Irvine
 */
public class A002468 extends AbstractSequence {

  private final A002469 mSeq1 = new A002469();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final A001563 mA1563 = new A001563();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return mA1563.next().subtract(mSeq1.next());
  }

}
#!queue	A002824	0	->	2	A001035	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a001.A001035;
import irvine.oeis.AbstractSequence;

/**
 * A002824 Number of precomplete Post functions.
 * @author Sean A. Irvine
 */
public class A002824 extends AbstractSequence {

  private final A001035 mSeq1 = new A001035();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;

  @Override
  public Z next() {
    return mSeq1.next().multiply(Binomial.binomial(++mN, 2));
  }
}
#!queue	A002857	0	->	1	A000612	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000612;
import irvine.oeis.AbstractSequence;

/**
 * A002857 Number of Post functions of n variables.
 * @author Sean A. Irvine
 */
public class A002857 extends AbstractSequence {

  private final A000612 mSeq1 = new A000612();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A003083	0	->	1	A000088	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000088;
import irvine.oeis.AbstractSequence;

/**
 * A003083 Sum a(n) x^n / n = log (1 + Sum g(n) x^n ), where g(n) is # graphs on n nodes (A000088).
 * @author Sean A. Irvine
 */
public class A003083 extends AbstractSequence {

  private final A000088 mSeq1 = new A000088();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mA88 = new ArrayList<>();
  {
    // skip 0th term
    mSeq1.next();
    mA88.add(Q.ZERO);
  }

  @Override
  public Z next() {
    final int n = mA88.size();
    mA88.add(new Q(mSeq1.next()));
    return RING.log1p(RING.create(mA88), n).coeff(n).multiply(n).toZ();
  }
}
#!queue	A003265	0	->	1	A000073	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a000.A000073;
import irvine.util.array.LongDynamicBooleanArray;
import irvine.oeis.AbstractSequence;

/**
 * A003265 Not representable by truncated tribonacci sequence 2, 4, 7, 13, 24, 44, 81, ....
 * @author Sean A. Irvine
 */
public class A003265 extends AbstractSequence {

  private final A000073 mSeq1 = new A000073();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final LongDynamicBooleanArray mSeen = new LongDynamicBooleanArray();
  {
    mSeen.set(0);
  }
  private long mTribonacci = -1;
  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (mN >= mTribonacci) {
        do {
          mTribonacci = mSeq1.next().longValueExact();
        } while (mTribonacci <= 1);
        for (long k = mSeen.length() - 1, j = k + mTribonacci; k >= 0; --k, --j) {
          if (mSeen.isSet(k)) {
            mSeen.set(j);
          }
        }
      }
      if (!mSeen.isSet(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A004016	1	->	0	A002324	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.a002.A002324;
import irvine.oeis.AbstractSequence;

/**
 * A004016 Theta series of planar hexagonal lattice A_2.
 * @author Sean A. Irvine
 */
public class A004016 extends AbstractSequence {

  private final A002324 mSeq1 = new A002324();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return mSeq1.next().multiply(6);
  }
}
#!queue	A005219	0	->	1	A007122	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a007.A007122;
import irvine.oeis.AbstractSequence;

/**
 * A005219 Number of unlabeled identity unit interval graphs.
 * @author Sean A. Irvine
 */
public class A005219 extends AbstractSequence {

  private final A007122 mSeq1 = new A007122();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = 0;
  private final List<Q> mA = new ArrayList<>();
  {
    mA.add(Q.ZERO);
  }

  @Override
  public Z next() {
    ++mN;
    mA.add(new Q(mSeq1.next()));
    final Polynomial<Q> c = RING.create(mA);
    Polynomial<Q> e = RING.zero();
    for (int k = 1; k <= mN; ++k) {
      e = RING.signedAdd((k & 1) == 1, e, RING.divide(c.substitutePower(k, mN), new Q(k)));
    }
    return RING.exp(e, mN).coeff(mN).toZ();
  }
}
#!queue	A005633	0	->	1	A122748	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a122.A122748;
import irvine.oeis.a123.A123071;
import irvine.oeis.AbstractSequence;

/**
 * A005633 Bishops on an n X n board (see Robinson paper for details).
 * @author Sean A. Irvine
 */
public class A005633 extends AbstractSequence {

  private final A122748 mSeq1 = new A122748();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mS = new A123071();
  private long mN = -1;

  {
    next();
  }

  @Override
  public Z next() {
    ++mN;
    if ((mN & 1) == 1) {
      return mSeq1.next().subtract(mS.next()).divide2();
    } else {
      return mSeq1.next().divide2();
    }
  }
}
#!queue	A005738	0	->	1	A005616	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005738 Number of fanout-free Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A005738 extends AbstractSequence {

  private final A005616 mSeq1 = new A005616();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected final ArrayList<Z> mTerms = new ArrayList<>();

  @Override
  public Z next() {
    mTerms.add(mSeq1.next());
    Z sum = Z.ZERO;
    for (int k = 0; k < mTerms.size(); ++k) {
      sum = sum.add(Binomial.binomial(mTerms.size(), k).multiply(mTerms.get(k)));
    }
    return sum;
  }

}

#!queue	A005740	0	->	1	A005617	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005740 Number of fanout-free Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A005740 extends AbstractSequence {

  private final A005617 mSeq1 = new A005617();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected final ArrayList<Z> mTerms = new ArrayList<>();

  @Override
  public Z next() {
    mTerms.add(mSeq1.next());
    Z sum = Z.ZERO;
    for (int k = 0; k < mTerms.size(); ++k) {
      sum = sum.add(Binomial.binomial(mTerms.size(), k).multiply(mTerms.get(k)));
    }
    return sum;
  }

}

#!queue	A005742	0	->	1	A005615	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005742 Number of degenerate fanout-free Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A005742 extends AbstractSequence {

  private final A005615 mSeq1 = new A005615();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected final ArrayList<Z> mTerms = new ArrayList<>();

  @Override
  public Z next() {
    mTerms.add(mSeq1.next());
    Z sum = Z.ZERO;
    for (int k = 0; k < mTerms.size(); ++k) {
      sum = sum.add(Binomial.binomial(mTerms.size(), k).multiply(mTerms.get(k)));
    }
    return sum;
  }

}

#!queue	A005850	0	->	1	A002315	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a002.A002315;
import irvine.oeis.AbstractSequence;

/**
 * A005850 Primes p such that the NSW number A002315((p-1)/2) is prime.
 * @author Sean A. Irvine
 */
public class A005850 extends AbstractSequence {

  private final A002315 mSeq1 = new A002315();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      final Z v = mSeq1.next();
      final Z p = mN.multiply2().add(1);
      if (v.isProbablePrime() && p.isProbablePrime()) {
        return p;
      }
    }
  }
}
#!queue	A005991	2	->	1	A003509	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a003.A003509;
import irvine.oeis.AbstractSequence;

/**
 * A005991 Let k(m) denote the least integer such that every m X m (0,1)-matrix with exactly k(m) ones in each row and in each column contains a 2 X 2 submatrix without zeros. The sequence gives the index n of the last term in each string of equal entries in the {k(m)} sequence (see A155934).
 * @author Sean A. Irvine
 */
public class A005991 extends AbstractSequence {

  private final A003509 mSeq1 = new A003509();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(1);
  }
}
#!queue	A006544	1	->	0	A003426	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a003.A003426;
import irvine.oeis.AbstractSequence;

/**
 * A006544 Number of stable forests with n nodes.
 * @author Sean A. Irvine
 */
public class A006544 extends AbstractSequence {

  private final A003426 mSeq1 = new A003426();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private int mN = -1;
  private final List<Q> mS = new ArrayList<>();
  {
    mS.add(Q.ZERO);
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mS.add(new Q(mSeq1.next()));
    final Polynomial<Q> s = RING.create(mS);
    Q r = Q.ZERO;
    for (int k = 1; k <= mN; ++k) {
      r = r.add(SymmetricGroup.create(k).cycleIndex().apply(s, mN).coeff(mN));
    }
    return r.toZ();
  }
}
#!queue	A006648	1	->	2	A001433	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001433;
import irvine.oeis.a001.A001434;
import irvine.oeis.AbstractSequence;

/**
 * A006648 Number of graphs with n nodes, n-1 edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006648 extends AbstractSequence {

  private final A001433 mSeq1 = new A001433();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Sequence mA = new A001434();
  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next());
  }
}
#!queue	A006649	1	->	3	A001434	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001434;
import irvine.oeis.a048.A048179;
import irvine.oeis.AbstractSequence;

/**
 * A006649 Number of graphs with n nodes, n edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006649 extends AbstractSequence {

  private final A001434 mSeq1 = new A001434();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 2;
  private Sequence mA = new A048179();
  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(++mN < 5 ? Z.ZERO : mA.next());
  }
}
#!queue	A006767	0	->	1	A068870	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a038.A038119;
import irvine.oeis.a068.A068870;
import irvine.oeis.AbstractSequence;

/**
 * A006767 Number of 4-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006767 extends AbstractSequence {

  private final A068870 mSeq1 = new A068870();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  private final A038119 mA = new A038119();

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next());
  }
}
#!queue	A006931	1	->	3	A002997	--------------------------------
package irvine.oeis.a006;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002997;
import irvine.util.array.DynamicArray;
import irvine.oeis.AbstractSequence;

/**
 * A006931 Least Carmichael number with n prime factors, or 0 if no such number exists.
 * @author Sean A. Irvine
 */
public class A006931 extends AbstractSequence {

  private final A002997 mSeq1 = new A002997();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final DynamicArray<Z> mLeast = new DynamicArray<>();
  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    while (mLeast.get(mN) == null) {
      final Z n = mSeq1.next();
      final int o = Jaguar.factor(n).omega();
      if (mLeast.get(o) == null) {
        mLeast.set(o, n);
      }
    }
    return mLeast.get(mN);
  }
}
#!queue	A007122	0	->	1	A005043	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a005.A005043;
import irvine.oeis.a005.A005213;
import irvine.oeis.AbstractSequence;

/**
 * A007122 Number of unlabeled identity connected unit interval graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A007122 extends AbstractSequence {

  private final A005043 mSeq1 = new A005043();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final A005213 mA = new A005213();
  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return mSeq1.next().subtract(mA.next()).divide2();
  }
}
#!queue	A007164	0	->	1	A007163	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a003.A003169;
import irvine.oeis.AbstractSequence;

/**
 * A007164 Number of P-graphs with 2n edges.
 * @author Sean A. Irvine
 */
public class A007164 extends AbstractSequence {

  private final A007163 mSeq1 = new A007163();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final A003169 mP = new A003169();
  private final A007165 mH = new A007165();

  @Override
  public Z next() {
    return mSeq1.next().add(mP.next()).add(mH.next().multiply2()).divide(4);
  }
}
#!queue	A007384	0	->	1	A001687	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a001.A001687;
import irvine.oeis.AbstractSequence;

/**
 * A007384 Number of strict 3rd-order maximal independent sets in path graph.
 * @author Sean A. Irvine
 */
public class A007384 extends AbstractSequence {

  private final A001687 mSeq1 = new A001687();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    for (int k = 0; k < 7; ++k) {
      next();
    }
  }

  private long mN = 1;
  private boolean mAlternate = true;

  @Override
  public Z next() {
    if (mAlternate) {
      ++mN;
    }
    mAlternate = !mAlternate;
    return mSeq1.next().subtract(mAlternate ? mN : 1);
  }
}
#!queue	A008844	1	->	0	A001653	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.a001.A001653;
import irvine.oeis.AbstractSequence;

/**
 * A008844 Squares of sequence A001653: y^2 such that x^2 - 2*y^2 = -1 for some x.
 * @author Sean A. Irvine
 */
public class A008844 extends AbstractSequence {

  private final A001653 mSeq1 = new A001653();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A008845	1	->	0	A008844	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008845 Numbers k such that k+1 and k/2+1 are squares.
 * @author Sean A. Irvine
 */
public class A008845 extends AbstractSequence {

  private final A008844 mSeq1 = new A008844();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(1).multiply2();
  }
}
#!queue	A011787	0	->	1	A065128	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a065.A065128;
import irvine.oeis.AbstractSequence;

/**
 * A011787 Number of n X n matrices over Z_4 whose determinant is 1.
 * @author Sean A. Irvine
 */
public class A011787 extends AbstractSequence {

  private final A065128 mSeq1 = new A065128();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A011918	0	->	1	A011916	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A011918 a(n) = A011916(n) + A011922(n) - 1.
 * @author Sean A. Irvine
 */
public class A011918 extends AbstractSequence {

  private final A011916 mSeq1 = new A011916();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final A011922 mA = new A011922();
  {
    next(); // skip 0th term
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mA.next()).subtract(1);
  }
}
#!queue	A014727	1	->	0	A014428	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014727 Squares of even elements in Pascal's triangle A007318.
 * @author Sean A. Irvine
 */
public class A014727 extends AbstractSequence {

  private final A014428 mSeq1 = new A014428();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A014748	1	->	0	A014467	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014748 Squares of numbers in array formed from elements to the right of middle of rows of triangle of Eulerian numbers.
 * @author Sean A. Irvine
 */
public class A014748 extends AbstractSequence {

  private final A014467 mSeq1 = new A014467();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A014760	1	->	0	A014475	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014760 Squares of numbers in array formed from odd elements to the right of middle of rows of Pascal triangle that are not 1.
 * @author Sean A. Irvine
 */
public class A014760 extends AbstractSequence {

  private final A014475 mSeq1 = new A014475();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (t.isOdd() && !Z.ONE.equals(t)) {
        return t.square();
      }
    }
  }
}
#!queue	A014765	0	->	1	A014630	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014765 Squares of distinct elements in triangle of Eulerian numbers.
 * @author Sean A. Irvine
 */
public class A014765 extends AbstractSequence {

  private final A014630 mSeq1 = new A014630();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A014773	0	->	1	A014637	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014773 Squares of odd heptagonal numbers.
 * @author Sean A. Irvine
 */
public class A014773 extends AbstractSequence {

  private final A014637 mSeq1 = new A014637();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A014798	1	->	0	A015222	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a015.A015222;
import irvine.oeis.AbstractSequence;

/**
 * A014798 Squares of even square pyramidal numbers.
 * @author Sean A. Irvine
 */
public class A014798 extends AbstractSequence {

  private final A015222 mSeq1 = new A015222();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A014801	1	->	0	A015225	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a015.A015225;
import irvine.oeis.AbstractSequence;

/**
 * A014801 Squares of odd hexagonal pyramidal numbers.
 * @author Sean A. Irvine
 */
public class A014801 extends AbstractSequence {

  private final A015225 mSeq1 = new A015225();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A020950	0	->	1	A020946	--------------------------------
package irvine.oeis.a020;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A020950 a(n) = k-1, where k is smallest number such that A002487(k) = n.
 * @author Sean A. Irvine
 */
public class A020950 extends AbstractSequence {

  private final A020946 mSeq1 = new A020946();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(1);
  }
}
#!queue	A020999	1	->	0	A014097	--------------------------------
package irvine.oeis.a020;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.oeis.a014.A014097;
import irvine.util.array.LongDynamicArray;
import irvine.oeis.AbstractSequence;

/**
 * A020999 Conjectured number of irreducible multiple zeta values of depth n and weight 3n (confirmed up to n=7).
 * @author Sean A. Irvine
 */
public class A020999 extends AbstractSequence {

  private final A014097 mSeq1 = new A014097();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final LongDynamicArray<Z> mA = new LongDynamicArray<>();
  private long mN = 0;
  {
    mA.set(0, Z.ZERO);
  }

  private Z get(final long d) {
    while (d >= mA.length()) {
      mA.set(mA.length(), mSeq1.next());
    }
    return mA.get(d);
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(mN).divisors()) {
      final long d = dd.longValue();
      sum = sum.add(get(d).multiply(Mobius.mobius(mN / d)));
    }
    return sum.divide(mN);
  }
}
#!queue	A022298	1	->	0	A006928	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.a006.A006928;
import irvine.oeis.AbstractSequence;

/**
 * A022298 Exactly half of first n terms of A006928 are 1's (not known to be infinite).
 * @author Sean A. Irvine
 */
public class A022298 extends AbstractSequence {

  private final A006928 mSeq1 = new A006928();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mA = 0; // Counts 2 * the number of 1s
  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(mSeq1.next())) {
        mA += 2;
      }
      if (Z.ONE.equals(mSeq1.next())) {
        mA += 2;
      }
      mN += 2;
      if (mA == mN) {
        return Z.valueOf(mA);
      }
    }
  }
}
#!queue	A022299	1	->	0	A022298	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A022299 Sequence A022298 divided by 2.
 * @author Sean A. Irvine
 */
public class A022299 extends AbstractSequence {

  private final A022298 mSeq1 = new A022298();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A023896	2	->	1	A023022	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A023896 Sum of positive integers in smallest positive reduced residue system modulo n. a(1) = 1 by convention.
 * @author Sean A. Irvine
 */
public class A023896 extends AbstractSequence {

  private final A023022 mSeq1 = new A023022();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return ++mN <= 2 ? Z.ONE : mSeq1.next().multiply(mN);
  }
}

#!queue	A024528	1	->	0	A008578	--------------------------------
package irvine.oeis.a024;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002110;
import irvine.oeis.a008.A008578;
import irvine.oeis.AbstractSequence;

/**
 * A024528 a(n) = n-th elementary symmetric function of {1, prime(1), prime(2), ..., prime(n)}.
 * @author Sean A. Irvine
 */
public class A024528 extends AbstractSequence {

  private final A008578 mSeq1 = new A008578();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Q mSum = Q.ZERO;
  private Sequence mA2110 = new A002110();

  @Override
  public Z next() {
    mSum = mSum.add(new Q(Z.ONE, mSeq1.next()));
    return mSum.multiply(mA2110.next()).num();
  }
}
#!queue	A025488	1	->	0	A025487	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025488 Number of distinct prime signatures of the positive integers up to 2^n.
 * @author Sean A. Irvine
 */
public class A025488 extends AbstractSequence {

  private final A025487 mSeq1 = new A025487();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mSignatures = 0;
  private Z mLimit = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mSignatures;
    } while (mSeq1.next().compareTo(mLimit) < 0);
    mLimit = mLimit.multiply2();
    return Z.valueOf(mSignatures);
  }
}

#!queue	A025506	1	->	0	A006928	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a006.A006928;
import irvine.oeis.AbstractSequence;

/**
 * A025506 Least k such that first k terms of A006928 contain n more 1's than 2's.
 * @author Sean A. Irvine
 */
public class A025506 extends AbstractSequence {

  private final A006928 mSeq1 = new A006928();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mRunningDelta = 0;
  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.TWO;
    }
    while (mRunningDelta != mN) {
      mRunningDelta -= mSeq1.next().longValue() * 2 - 3;
      ++mM;
    }
    return Z.valueOf(mM);
  }
}
#!queue	A025543	1	->	0	A018252	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a018.A018252;
import irvine.oeis.AbstractSequence;

/**
 * A025543 Least common multiple of the first n composite numbers.
 * @author Sean A. Irvine
 */
public class A025543 extends AbstractSequence {

  private final A018252 mSeq1 = new A018252();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mL = Z.ONE;

  @Override
  public Z next() {
    mL = mL.lcm(mSeq1.next());
    return mL;
  }
}
#!queue	A025700	1	->	0	A025616	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025700 Index of 3^n within sequence of numbers of form 3^i * 10^j.
 * @author Sean A. Irvine
 */
public class A025700 extends AbstractSequence {

  private final A025616 mSeq1 = new A025616();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(mSeq1.next()));
    mA = mA.multiply(3);
    return Z.valueOf(mN);
  }
}
#!queue	A026059	0	->	4	A026057	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.recur.PeriodicSequence;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A026059 a(n) = (d(n)-r(n))/5, where d = A026057 and r is the periodic sequence with fundamental period (1,0,3,1,0).
 * @author Sean A. Irvine
 */
public class A026059 extends AbstractSequence {

  private final A026057 mSeq1 = new A026057();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mS = new PeriodicSequence(1, 0, 3, 1, 0);
  {
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mS.next()).divide(5);
  }
}

#!queue	A026141	1	->	2	A026139	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026141 a(n) = (s(n)-s(n-1))/2, where s = A026139.
 * @author Sean A. Irvine
 */
public class A026141 extends AbstractSequence {

  private final A026139 mSeq1 = new A026139();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.subtract(t).abs().divide2();
  }
}
#!queue	A026146	1	->	3	A026145	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026146 a(n) = (1/2)*|s(n) - s(n-1)|, where s = A026145.
 * @author Sean A. Irvine
 */
public class A026146 extends AbstractSequence {

  private final A026145 mSeq1 = new A026145();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.subtract(t).abs().divide2();
  }
}
#!queue	A026181	1	->	3	A026180	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026181 a(n) = (1/2)*(s(n) - s(n-1)), where s = A026180.
 * @author Sean A. Irvine
 */
public class A026181 extends AbstractSequence {

  private final A026180 mSeq1 = new A026180();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.subtract(t).divide2();
  }
}
#!queue	A026298	1	->	7	A039919	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a039.A039919;
import irvine.oeis.AbstractSequence;

/**
 * A026298 Number of polyhexes of class PF2.
 * @author Sean A. Irvine
 */
public class A026298 extends AbstractSequence {

  private final A039919 mSeq1 = new A039919();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mS = new A002212();
  {
    mSeq1.next();
    mS.next();
    mS.next();
    mS.next();
  }

  private Z mB = mS.next();
  private Z mC = mS.next();
  private Z mT = null;

  @Override
  public Z next() {
    final Z a = mB;
    mB = mC;
    mC = mS.next();
    final Z m;
    if (mT != null) {
      m = mT;
      mT = null;
    } else {
      mT = mSeq1.next();
      m = mT;
    }
    //System.out.println(mA + " " + mB + " " + mC + " " + m);
    return mC.subtract(mB.multiply(6)).add(a.multiply(8)).multiply(3).add(m);
  }
}
#!queue	A026909	0	->	1	A026908	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026909 (1/2)*T(2n,n), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026909 extends AbstractSequence {

  private final A026908 mSeq1 = new A026908();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A027057	1	->	2	A027056	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027057 a(n) = (1/2) * A027052(n, 2n-1).
 * @author Sean A. Irvine
 */
public class A027057 extends AbstractSequence {

  private final A027056 mSeq1 = new A027056();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A027830	0	->	1	A027622	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027830 Numbers k such that k + (k+1)^2 + (k+2)^3 + (k+3)^4 + (k+4)^5 is prime.
 * @author Sean A. Irvine
 */
public class A027830 extends AbstractSequence {

  private final A027622 mSeq1 = new A027622();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (mSeq1.next().isProbablePrime()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A028265	0	->	1	A028264	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A028265 Odd elements in 3-Pascal triangle A028262 (by row) that are not 1.
 * @author Sean A. Irvine
 */
public class A028265 extends AbstractSequence {

  private final A028264 mSeq1 = new A028264();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (!Z.ONE.equals(t)) {
        return t;
      }
    }
  }
}
#!queue	A028274	0	->	1	A028272	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A028274 Odd elements (greater than 1) to right of central elements in 3-Pascal triangle A028262.
 * @author Sean A. Irvine
 */
public class A028274 extends AbstractSequence {

  private final A028272 mSeq1 = new A028272();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (t.isOdd()) {
        return t;
      }
    }
  }
}
#!queue	A028815	1	->	0	A008578	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a008.A008578;
import irvine.oeis.AbstractSequence;

/**
 * A028815 a(n) = n-th prime + 1 (starting with 1).
 * @author Sean A. Irvine
 */
public class A028815 extends AbstractSequence {

  private final A008578 mSeq1 = new A008578();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(1);
  }
}
#!queue	A029607	0	->	1	A029605	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A029607 Even numbers in the (2,3)-Pascal triangle A029600 that are different from 2.
 * @author Sean A. Irvine
 */
public class A029607 extends AbstractSequence {

  private final A029605 mSeq1 = new A029605();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    Z t;
    do {
      t = mSeq1.next();
    } while (Z.TWO.equals(t));
    return t;
  }
}
#!queue	A029615	0	->	1	A029614	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A029615 Numbers to the right of the central elements of the (2,3)-Pascal triangle A029600 that are different from 3.
 * @author Sean A. Irvine
 */
public class A029615 extends AbstractSequence {

  private final A029614 mSeq1 = new A029614();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    Z t;
    do {
      t = mSeq1.next();
    } while (Z.THREE.equals(t));
    return t;
  }
}
#!queue	A029639	1	->	0	A029638	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A029639 Odd numbers in the (1,2)-Pascal triangle A029635 that are different from 1.
 * @author Sean A. Irvine
 */
public class A029639 extends AbstractSequence {

  private final A029638 mSeq1 = new A029638();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    Z t;
    do {
      t = mSeq1.next();
    } while (t.isEven());
    return t;
  }
}
#!queue	A029641	1	->	0	A029640	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A029641 Even numbers in the (1,2)-Pascal triangle A029635 that are different from 2.
 * @author Sean A. Irvine
 */
public class A029641 extends AbstractSequence {

  private final A029640 mSeq1 = new A029640();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    Z t;
    do {
      t = mSeq1.next();
    } while (Z.TWO.equals(t));
    return t;
  }
}
#!queue	A029642	1	->	0	A029636	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A029642 Distinct odd numbers in the (1,2)-Pascal triangle A029635.
 * @author Sean A. Irvine
 */
public class A029642 extends AbstractSequence {

  private final A029636 mSeq1 = new A029636();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    Z t;
    do {
      t = mSeq1.next();
    } while (t.isEven());
    return t;
  }
}
#!queue	A029657	1	->	0	A029656	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A029657 Odd numbers in (2,1)-Pascal triangle A029653 that are different from 1.
 * @author Sean A. Irvine
 */
public class A029657 extends AbstractSequence {

  private final A029656 mSeq1 = new A029656();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    Z t;
    do {
      t = mSeq1.next();
    } while (t.isEven());
    return t;
  }
}
#!queue	A033292	0	->	1	A143689	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.oeis.a143.A143689;
import irvine.oeis.AbstractSequence;

/**
 * A033292 A Connell-like sequence: take 1 number = 1 (mod Q), 2 numbers = 2 (mod Q), 3 numbers = 3 (mod Q), etc., where Q = 3.
 * @author Sean A. Irvine
 */
public class A033292 extends AbstractSequence {

  private final A143689 mSeq1 = new A143689();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;
  private Z mT = null;

  @Override
  public Z next() {
    if (--mM < 0) {
      mM = mN++;
      mT = mSeq1.next();
    } else {
      mT = mT.add(3);
    }
    return mT;
  }
}

#!queue	A033293	0	->	1	A054552	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.oeis.a054.A054552;
import irvine.oeis.AbstractSequence;

/**
 * A033293 A Connell-like sequence: take 1 number = 1 (mod Q), 2 numbers = 2 (mod Q), 3 numbers = 3 (mod Q), etc., where Q = 8.
 * @author Sean A. Irvine
 */
public class A033293 extends AbstractSequence {

  private final A054552 mSeq1 = new A054552();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;
  private Z mT = null;

  @Override
  public Z next() {
    if (--mM < 0) {
      mM = mN++;
      mT = mSeq1.next();
    } else {
      mT = mT.add(8);
    }
    return mT;
  }
}

#!queue	A033867	0	->	1	A033866	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A033867 Palindrome reached from A033866(n) by Reverse-then-add.
 * @author Sean A. Irvine
 */
public class A033867 extends AbstractSequence {

  private final A033866 mSeq1 = new A033866();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z s = mSeq1.next();
    for (int k = 0; k < mN; ++k) {
      s = s.add(ZUtils.reverse(s));
    }
    return s;
  }
}
#!queue	A034981	0	->	1	A034980	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A034981 Smallest square starting with a string of n 2's.
 * @author Sean A. Irvine
 */
public class A034981 extends AbstractSequence {

  private final A034980 mSeq1 = new A034980();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A035488	1	->	0	A035487	--------------------------------
package irvine.oeis.a035;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A035488 3rd column of Stolarsky array.
 * @author Sean A. Irvine
 */
public class A035488 extends AbstractSequence {

  private final A035487 mSeq1 = new A035487();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return CR.valueOf(mSeq1.next()).multiply(CR.PHI).round();
  }
}

#!queue	A036359	0	->	1	A002216	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.PrependSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001998;
import irvine.oeis.a002.A002216;
import irvine.oeis.AbstractSequence;

/**
 * A036359 Number of branched catafusenes with n condensed hexagons.
 * @author Sean A. Irvine
 */
public class A036359 extends AbstractSequence {

  private final A002216 mSeq1 = new A002216();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next(); // skip 0
  }

  private final Sequence mA = new PrependSequence(new A001998(), 1);

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next());
  }
}
#!queue	A036451	1	->	0	A002182	--------------------------------
package irvine.oeis.a036;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a002.A002182;
import irvine.oeis.AbstractSequence;

/**
 * A036451 Maximal value of d(x) (the number of divisors of x, A000005) if the binary order (see A029837) of x, the value g(x) = n.
 * @author Sean A. Irvine
 */
public class A036451 extends AbstractSequence {

  private final A002182 mSeq1 = new A002182();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final PrimeDivision mFactor = new PrimeDivision();
  private Z mLim = null;
  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    mLim = mLim == null ? Z.ONE : mLim.multiply2();
    Z sigma0 = Z.ZERO;
    while (mA.compareTo(mLim) <= 0) {
      sigma0 = sigma0.max(mFactor.factorize(mA).sigma0());
      mA = mSeq1.next();
    }
    return sigma0;
  }
}

#!queue	A036484	1	->	0	A002182	--------------------------------
package irvine.oeis.a036;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a002.A002182;
import irvine.oeis.AbstractSequence;

/**
 * A036484 a(n) is the minimal number of binary order n which has maximal number of divisors in this interval.
 * @author Sean A. Irvine
 */
public class A036484 extends AbstractSequence {

  private final A002182 mSeq1 = new A002182();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final PrimeDivision mFactor = new PrimeDivision();
  private Z mLim = null;
  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    mLim = mLim == null ? Z.ONE : mLim.multiply2();
    Z sigma0 = Z.ZERO;
    Z bestA = Z.ZERO;
    while (mA.compareTo(mLim) <= 0) {
      final Z s = mFactor.factorize(mA).sigma0();
      if (s.compareTo(sigma0) > 0) {
        sigma0 = s;
        bestA = mA;
      }
      mA = mSeq1.next();
    }
    return bestA;
  }
}

#!queue	A036497	1	->	0	A008578	--------------------------------
package irvine.oeis.a036;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a008.A008578;
import irvine.oeis.AbstractSequence;

/**
 * A036497 Number of partitions of n into distinct primes (counting 1 as a prime).
 * @author Sean A. Irvine
 */
public class A036497 extends AbstractSequence {

  private final A008578 mSeq1 = new A008578();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private int mN = -1;
  private int mP = 0;
  private Polynomial<Z> mPoly = RING.one();

  @Override
  public Z next() {
    ++mN;
    while (mN > mP) {
      mP = mSeq1.next().intValueExact();
      mPoly = RING.multiply(mPoly, RING.onePlusXToTheN(mP));
    }
    return mPoly.coeff(mN);
  }
}

#!queue	A036655	1	->	0	A000084	--------------------------------
package irvine.oeis.a036;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000084;
import irvine.oeis.AbstractSequence;

/**
 * A036655 Numbers d_n used in recurrence for series-parallel numbers.
 * @author Sean A. Irvine
 */
public class A036655 extends AbstractSequence {

  private final A000084 mSeq1 = new A000084();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Polynomial<Z> mS = RING.empty();
  private final Polynomial<Z> mSp = RING.empty();
  private final Polynomial<Z> mSm = RING.empty();
  {
    mS.add(Z.ZERO);
    mSp.add(Z.ONE);
    mSm.add(Z.ONE);
  }

  @Override
  public Z next() {
    ++mN;
    final Z s = mSeq1.next();
    mS.add(s);
    mSp.add(s);
    mSm.add(s.negate());
    final Polynomial<Z> sp = RING.diff(mS);
    final Polynomial<Z> num = RING.multiply(sp, mSm, mN);
    return RING.coeff(num, mSp, mN);
  }
}
#!queue	A036676	1	->	0	A000621	--------------------------------
package irvine.oeis.a036;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000621;
import irvine.oeis.AbstractSequence;

/**
 * A036676 Used by Polya in calculating A000598.
 * @author Sean A. Irvine
 */
public class A036676 extends AbstractSequence {

  private final A000621 mSeq1 = new A000621();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  protected final Polynomial<Z> mQ = RING.empty();
  protected int mBonds = -1;

  @Override
  public Z next() {
    ++mBonds;
    mQ.add(mSeq1.next());
    final Polynomial<Z> q3 = RING.pow(mQ, 3, mBonds);
    final Polynomial<Z> qqs2 = RING.multiply(RING.multiply(mQ, mQ.substitutePower(2, mBonds), mBonds), Z.THREE);
    final Polynomial<Z> qs3 = RING.multiply(mQ.substitutePower(3, mBonds), Z.TWO);
    return RING.multiply(RING.add(RING.subtract(q3, qqs2), qs3), mQ.shift(1), mBonds).coeff(mBonds).divide(6);
  }
}
#!queue	A038009	1	->	0	A038007	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A038009 Values of A038007 not ending in 6 or 8.
 * @author Sean A. Irvine
 */
public class A038009 extends AbstractSequence {

  private final A038007 mSeq1 = new A038007();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      final long r = t.mod(10);
      if (r != 6 && r != 8) {
        return t;
      }
    }
  }
}
#!queue	A038011	1	->	0	A038007	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A038011 Values of A038007 ending in 2.
 * @author Sean A. Irvine
 */
public class A038011 extends AbstractSequence {

  private final A038007 mSeq1 = new A038007();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (t.mod(10) == 2) {
        return t;
      }
    }
  }
}
#!queue	A038013	1	->	0	A038007	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A038013 Values of A038005 ending in 3.
 * @author Sean A. Irvine
 */
public class A038013 extends AbstractSequence {

  private final A038007 mSeq1 = new A038007();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (t.mod(10) == 3) {
        return t;
      }
    }
  }
}
#!queue	A038078	1	->	0	A038077	--------------------------------
package irvine.oeis.a038;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A038078 Number of identity trees with 2-colored nodes.
 * @author Sean A. Irvine
 */
public class A038078 extends AbstractSequence {

  private final A038077 mSeq1 = new A038077();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final Polynomial<Z> mB = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Z.ZERO);
      return Z.ONE;
    }
    mB.add(mSeq1.next());
    return mB.coeff(mN).subtract(mB.substitutePower(2, mN).coeff(mN).add(RING.multiply(mB, mB, mN).coeff(mN)).divide2());
  }
}
#!queue	A038089	1	->	6	A038084	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A038089 Number of n-node rooted identity trees of height 5.
 * @author Sean A. Irvine
 */
public class A038089 extends AbstractSequence {

  private final A038084 mSeq1 = new A038084();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A038083();
  {
    for (int k = 0; k < 5; ++k) {
      next();
    }
  }

  @Override
  public Z next() {
    final Z u = mSeq1.next();
    if (u == null) {
      return null;
    }
    final Z t = mA.next();
    return t == null ? u : u.subtract(t);
  }
}
#!queue	A038090	1	->	7	A038085	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A038090 Number of n-node rooted identity trees of height 6.
 * @author Sean A. Irvine
 */
public class A038090 extends AbstractSequence {

  private final A038085 mSeq1 = new A038085();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A038084();
  {
    for (int k = 0; k < 6; ++k) {
      next();
    }
  }

  @Override
  public Z next() {
    final Z u = mSeq1.next();
    if (u == null) {
      return null;
    }
    final Z t = mA.next();
    return t == null ? u : u.subtract(t);
  }
}
#!queue	A038091	1	->	8	A038086	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A038091 Number of n-node rooted identity trees of height 7.
 * @author Sean A. Irvine
 */
public class A038091 extends AbstractSequence {

  private final A038086 mSeq1 = new A038086();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A038085();
  {
    for (int k = 0; k < 7; ++k) {
      next();
    }
  }

  @Override
  public Z next() {
    final Z u = mSeq1.next();
    if (u == null) {
      return null;
    }
    final Z t = mA.next();
    return t == null ? u : u.subtract(t);
  }
}
#!queue	A038092	1	->	9	A038087	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A038092 Number of n-node rooted identity trees of height 8.
 * @author Sean A. Irvine
 */
public class A038092 extends AbstractSequence {

  private final A038087 mSeq1 = new A038087();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A038086();
  {
    for (int k = 0; k < 8; ++k) {
      next();
    }
  }

  @Override
  public Z next() {
    final Z u = mSeq1.next();
    if (u == null) {
      return null;
    }
    final Z t = mA.next();
    return t == null ? u : u.subtract(t);
  }
}
#!queue	A039657	1	->	0	A040025	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a040.A040025;
import irvine.oeis.AbstractSequence;

/**
 * A039657 Number of digits in all (2n+1)-digit palindromic primes.
 * @author Sean A. Irvine
 */
public class A039657 extends AbstractSequence {

  private final A040025 mSeq1 = new A040025();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  public Z next() {
    mN += 2;
    return mSeq1.next().multiply(mN);
  }
}
#!queue	A039801	1	->	2	A038498	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a038.A038498;
import irvine.oeis.AbstractSequence;

/**
 * A039801 Column 2 of Inverse partition triangle A038498.
 * @author Sean A. Irvine
 */
public class A039801 extends AbstractSequence {

  private final A038498 mSeq1 = new A038498();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    for (long k = 0; k < mN; ++k) {
      mSeq1.next();
    }
    ++mN;
    return mSeq1.next();
  }
}
#!queue	A039802	1	->	3	A038498	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a038.A038498;
import irvine.oeis.AbstractSequence;

/**
 * A039802 Column 3 of Inverse partition triangle A038498.
 * @author Sean A. Irvine
 */
public class A039802 extends AbstractSequence {

  private final A038498 mSeq1 = new A038498();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;
  {
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    for (long k = 0; k < mN; ++k) {
      mSeq1.next();
    }
    ++mN;
    return mSeq1.next();
  }
}
#!queue	A039803	1	->	4	A038498	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a038.A038498;
import irvine.oeis.AbstractSequence;

/**
 * A039803 Column 4 of inverse partition triangle A038498.
 * @author Sean A. Irvine
 */
public class A039803 extends AbstractSequence {

  private final A038498 mSeq1 = new A038498();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 2;
  {
    for (int k = 0; k < 7; ++k) {
      mSeq1.next();
    }
  }

  @Override
  public Z next() {
    for (long k = 0; k < mN; ++k) {
      mSeq1.next();
    }
    ++mN;
    return mSeq1.next();
  }
}
#!queue	A039804	1	->	5	A038498	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a038.A038498;
import irvine.oeis.AbstractSequence;

/**
 * A039804 Column 5 of Inverse partition triangle A038498.
 * @author Sean A. Irvine
 */
public class A039804 extends AbstractSequence {

  private final A038498 mSeq1 = new A038498();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 3;
  {
    for (int k = 0; k < 11; ++k) {
      mSeq1.next();
    }
  }

  @Override
  public Z next() {
    for (long k = 0; k < mN; ++k) {
      mSeq1.next();
    }
    ++mN;
    return mSeq1.next();
  }
}
#!queue	A039968	0	->	1	A005043	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a005.A005043;
import irvine.oeis.AbstractSequence;

/**
 * A039968 An example of a d-perfect sequence.
 * @author Sean A. Irvine
 */
public class A039968 extends AbstractSequence {

  private final A005043 mSeq1 = new A005043();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mMult = -1;

  @Override
  public Z next() {
    final long r = mSeq1.next().mod(3);
    mMult = -mMult;
    return Z.valueOf((3 + r * mMult) % 3);
  }
}

#!queue	A040025	1	->	0	A016115	--------------------------------
package irvine.oeis.a040;

import irvine.math.z.Z;
import irvine.oeis.a016.A016115;
import irvine.oeis.AbstractSequence;

/**
 * A040025 a(n) is the number of prime palindromes with 2n+1 digits.
 * @author Sean A. Irvine
 */
public class A040025 extends AbstractSequence {

  private final A016115 mSeq1 = new A016115();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z r = mSeq1.next();
    mSeq1.next();
    return r;
  }
}
#!queue	A045905	1	->	0	A045829	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a039.A039660;
import irvine.oeis.AbstractSequence;

/**
 * A045905 Catafusenes (see reference for precise definition).
 * @author Sean A. Irvine
 */
public class A045905 extends AbstractSequence {

  private final A045829 mSeq1 = new A045829();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mB = new A045445();
  private final Sequence mC = new A002212();
  private final Sequence mD = new A039660();
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mC.next();
      return Z.ZERO;
    }
    Z t = mSeq1.next().add(mD.next().multiply2());
    if ((mN & 1) == 0) {
      t = t.add(mB.next().multiply(3));
      if ((mN & 3) == 0) {
        t = t.add(mC.next().multiply2());
      }
    }
    return t.divide(8);
  }
}
#!queue	A046102	0	->	1	A005663	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a005.A005663;
import irvine.oeis.a005.A005664;
import irvine.oeis.AbstractSequence;

/**
 * A046102 Denominators of convergents to the comma of Pythagoras.
 * @author Sean A. Irvine
 */
public class A046102 extends AbstractSequence {

  private final A005663 mSeq1 = new A005663();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mD = new A005664();

  {
    next(); // skip 0th
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mD.next());
  }
}
#!queue	A046454	1	->	0	A046447	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A046454 Concatenation of the 5 prime factors of composite a(n) is a palindrome.
 * @author Sean A. Irvine
 */
public class A046454 extends AbstractSequence {

  private final A046447 mSeq1 = new A046447();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (Jaguar.factor(t).bigOmega() == 5) {
        return t;
      }
    }
  }
}
#!queue	A046457	1	->	0	A046447	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A046457 Concatenation of the 8 prime factors of composite a(n) is a palindrome.
 * @author Sean A. Irvine
 */
public class A046457 extends AbstractSequence {

  private final A046447 mSeq1 = new A046447();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (Jaguar.factor(t).bigOmega() == 8) {
        return t;
      }
    }
  }
}
#!queue	A046812	0	->	1	A046811	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A046812 Number of prime anagrams of A046811(n).
 * @author Sean A. Irvine
 */
public class A046812 extends AbstractSequence {

  private final A046811 mSeq1 = new A046811();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return Z.valueOf(A046810.numberOfPrimeAnagrams(mSeq1.next().toString()));
  }
}
#!queue	A046885	0	->	1	A046714	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A046885 Row sums of triangle A046658.
 * @author Sean A. Irvine
 */
public class A046885 extends AbstractSequence {

  private final A046714 mSeq1 = new A046714();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.TWO : mA.multiply(5);
    return mA.subtract(mSeq1.next());
  }
}
#!queue	A046996	0	->	2	A001181	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a001.A001181;
import irvine.oeis.AbstractSequence;

/**
 * A046996 Number of Baxter permutations: A001181/2.
 * @author Sean A. Irvine
 */
public class A046996 extends AbstractSequence {

  private final A001181 mSeq1 = new A001181();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A047763	1	->	0	A047762	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A047763 a(n) = A047762(2n+1).
 * @author Sean A. Irvine
 */
public class A047763 extends AbstractSequence {

  private final A047762 mSeq1 = new A047762();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z res = mSeq1.next();
    mSeq1.next();
    return res;
  }
}
#!queue	A047768	1	->	0	A047766	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A047768 a(n) = A047766(6n+2).
 * @author Sean A. Irvine
 */
public class A047768 extends AbstractSequence {

  private final A047766 mSeq1 = new A047766();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 4;

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (++mN == 6) {
        mN = 0;
        return t;
      }
    }
  }
}

#!queue	A047982	1	->	0	A047980	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A047982 a(n) = A047980(2n+1).
 *
 * @author Sean A. Irvine
 */
public class A047982 extends AbstractSequence {

  private final A047980 mSeq1 = new A047980();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z res = mSeq1.next();
    mSeq1.next();
    return res;
  }
}
#!queue	A048115	0	->	3	A048114	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048115 (1/2)*Sum{T(n,i): i=0,1,...,n}, where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048115 extends AbstractSequence {

  private final A048114 mSeq1 = new A048114();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A048117	1	->	2	A048116	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048117 a(n)=(1/2)*T(2n,n), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048117 extends AbstractSequence {

  private final A048116 mSeq1 = new A048116();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A048119	0	->	2	A048118	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048119 a(n)=(1/2)*T(2n+1,n+1), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048119 extends AbstractSequence {

  private final A048118 mSeq1 = new A048118();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A048202	1	->	2	A004978	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a004.A004978;
import irvine.oeis.AbstractSequence;

/**
 * A048202 a(n)=T(n,2), array T given by A048201.
 * @author Sean A. Irvine
 */
public class A048202 extends AbstractSequence {

  private final A004978 mSeq1 = new A004978();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();
  private Z mB = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mB;
    mB = mSeq1.next();
    return mB.subtract(t);
  }
}
#!queue	A048203	1	->	3	A004978	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a004.A004978;
import irvine.oeis.AbstractSequence;

/**
 * A048203 a(n)=T(n,3), array T given by A048201.
 * @author Sean A. Irvine
 */
public class A048203 extends AbstractSequence {

  private final A004978 mSeq1 = new A004978();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();
  private Z mB = mSeq1.next();
  private Z mC = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mB;
    mB = mC;
    mC = mSeq1.next();
    return mC.subtract(t);
  }
}
#!queue	A048401	0	->	1	A048406	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048401 Primes with consecutive digits that differ exactly by 4.
 * @author Sean A. Irvine
 */
public class A048401 extends AbstractSequence {

  private final A048406 mSeq1 = new A048406();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A048402	0	->	1	A048407	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048402 Primes with consecutive digits that differ exactly by 5.
 * @author Sean A. Irvine
 */
public class A048402 extends AbstractSequence {

  private final A048407 mSeq1 = new A048407();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A048404	0	->	1	A048409	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048404 Primes with consecutive digits that differ exactly by 7.
 * @author Sean A. Irvine
 */
public class A048404 extends AbstractSequence {

  private final A048409 mSeq1 = new A048409();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A048405	0	->	1	A048410	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048405 Primes with consecutive digits that differ exactly by 8.
 * @author Sean A. Irvine
 */
public class A048405 extends AbstractSequence {

  private final A048410 mSeq1 = new A048410();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A048558	1	->	0	A048557	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048558 a(n+1)^2 is next smallest nontrivial square beginning with a(n)^2, initial square is 1.
 * @author Sean A. Irvine
 */
public class A048558 extends AbstractSequence {

  private final A048557 mSeq1 = new A048557();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().sqrt();
  }
}
#!queue	A048560	1	->	0	A048559	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048560 a(n+1)^2 is next smallest nontrivial square beginning with a(n)^2, initial square is 4.
 * @author Sean A. Irvine
 */
public class A048560 extends AbstractSequence {

  private final A048559 mSeq1 = new A048559();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().sqrt();
  }
}
#!queue	A048562	1	->	0	A048561	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048562 a(n+1)^2 is next smallest nontrivial square beginning with a(n)^2, initial square is 9.
 * @author Sean A. Irvine
 */
public class A048562 extends AbstractSequence {

  private final A048561 mSeq1 = new A048561();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().sqrt();
  }
}
#!queue	A048982	1	->	0	A048868	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048982 Number of numbers which have a "prime-rich" reduced residue system (RRS) and binary order n.
 * @author Sean A. Irvine
 */
public class A048982 extends AbstractSequence {

  private final A048868 mSeq1 = new A048868();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();
  private Z mUpper = Z.ONE;

  @Override
  public Z next() {
    long cnt = 0;
    while (mA.compareTo(mUpper) <= 0) {
      ++cnt;
      mA = mSeq1.next();
    }
    mUpper = mUpper.multiply2();
    return Z.valueOf(cnt);
  }
}

#!queue	A049056	1	->	0	A049055	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049056 Number of minimal ordered covers of a labeled n-set.
 * @author Sean A. Irvine
 */
public class A049056 extends AbstractSequence {

  private final A049055 mSeq1 = new A049055();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.add(mSeq1.next());
    }
    return sum;
  }
}
#!queue	A049377	1	->	0	A049352	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049377 Row sums of triangle A049352.
 * @author Sean A. Irvine
 */
public class A049377 extends AbstractSequence {

  private final A049352 mSeq1 = new A049352();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(mSeq1.next());
    }
    return sum;
  }
}
#!queue	A049378	1	->	0	A049353	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049378 Row sums of triangle A049353.
 * @author Sean A. Irvine
 */
public class A049378 extends AbstractSequence {

  private final A049353 mSeq1 = new A049353();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(mSeq1.next());
    }
    return sum;
  }
}
#!queue	A049402	1	->	0	A049374	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049402 Row sums of triangle A049374.
 * @author Sean A. Irvine
 */
public class A049402 extends AbstractSequence {

  private final A049374 mSeq1 = new A049374();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(mSeq1.next());
    }
    return sum;
  }
}
#!queue	A049586	1	->	0	A051953	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a051.A051953;
import irvine.oeis.AbstractSequence;

/**
 * A049586 a(n) is the GCD of the cototients (A051953) of n and n+1.
 * @author Sean A. Irvine
 */
public class A049586 extends AbstractSequence {

  private final A051953 mSeq1 = new A051953();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.gcd(t);
  }
}

#!queue	A049709	0	->	3	A049708	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049709 a(n) = (1/2) * Sum_{i=0..n} T(i,n-i), array T as in A049704.
 * @author Sean A. Irvine
 */
public class A049709 extends AbstractSequence {

  private final A049708 mSeq1 = new A049708();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A049806	2	->	1	A023022	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a023.A023022;
import irvine.oeis.AbstractSequence;

/**
 * A049806 Number of Farey fractions of order n that are &lt;=1/2; cf. A049805.
 * @author Sean A. Irvine
 */
public class A049806 extends AbstractSequence {

  private final A023022 mSeq1 = new A023022();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mSum = null;

  @Override
  public Z next() {
    mSum = mSum == null ? Z.ONE : mSum.add(mSeq1.next());
    return mSum;
  }
}
#!queue	A049847	1	->	2	A049716	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049847 a(n) = (2*n + 1 - prevprime(2*n+1))/2.
 * @author Sean A. Irvine
 */
public class A049847 extends AbstractSequence {

  private final A049716 mSeq1 = new A049716();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A049848	2	->	1	A049843	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049848 a(n) is the number of primes q less than n-th prime p for which the Euclidean algorithm for p,q has exactly 2 nonzero remainders.
 * @author Sean A. Irvine
 */
public class A049848 extends AbstractSequence {

  private final A049843 mSeq1 = new A049843();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    long cnt = 0;
    for (long k = 0; k < mN; ++k) {
      if (mSeq1.next().equals(Z.TWO)) {
        ++cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A049849	2	->	1	A049843	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049849 a(n) is the number of primes q less than n-th prime p for which the Euclidean algorithm for p,q has exactly 3 nonzero remainders.
 * @author Sean A. Irvine
 */
public class A049849 extends AbstractSequence {

  private final A049843 mSeq1 = new A049843();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    long cnt = 0;
    for (long k = 0; k < mN; ++k) {
      if (mSeq1.next().equals(Z.THREE)) {
        ++cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A049850	2	->	1	A049843	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049850 a(n) is the number of primes q less than n-th prime p for which the Euclidean algorithm for p,q has exactly 4 nonzero remainders.
 * @author Sean A. Irvine
 */
public class A049850 extends AbstractSequence {

  private final A049843 mSeq1 = new A049843();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    long cnt = 0;
    for (long k = 0; k < mN; ++k) {
      if (mSeq1.next().equals(Z.FOUR)) {
        ++cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A050369	0	->	1	A074206	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a074.A074206;
import irvine.oeis.AbstractSequence;

/**
 * A050369 Number of ordered factorizations of n into 2 kinds of 2, 3 kinds of 3, ...
 * @author Sean A. Irvine
 */
public class A050369 extends AbstractSequence {

  private final A074206 mSeq1 = new A074206();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }
  private long mN = 0;

  @Override
  public Z next() {
    return mSeq1.next().multiply(++mN);
  }
}
#!queue	A051350	1	->	0	A141468	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a141.A141468;
import irvine.oeis.AbstractSequence;

/**
 * A051350 Sum of digit-sums of first n nonprimes.
 * @author Sean A. Irvine
 */
public class A051350 extends AbstractSequence {

  private final A141468 mSeq1 = new A141468();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    mA = mA.add(ZUtils.digitSum(mSeq1.next()));
    return mA;
  }
}
#!queue	A051466	1	->	2	A025487	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.memory.MemorySequence;
import irvine.oeis.closure.MultiplicativeClosureSequence;
import irvine.oeis.a002.A002110;
import irvine.oeis.a025.A025487;
import irvine.oeis.AbstractSequence;

/**
 * A051466 Largest product of primorials less than A025487(n) that divides A025487(n).
 * @author Sean A. Irvine
 */
public class A051466 extends AbstractSequence {

  private final A025487 mSeq1 = new A025487();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }
  private final MemorySequence mA = MemorySequence.cachedSequence(new MultiplicativeClosureSequence(new A002110().skip(1)));

  @Override
  public Z next() {
    final Z t = mSeq1.next();
    int k = -1;
    Z res = Z.ONE;
    while (true) {
      final Z a = mA.a(++k);
      if (a.compareTo(t) >= 0) {
        break;
      }
      if (t.mod(a).isZero()) {
        res = a;
      }
    }
    return res;
  }
}
#!queue	A051467	1	->	0	A029640	--------------------------------
package irvine.oeis.a051;
// manually div at 2021-08-20 23:03

import irvine.math.z.Z;
import irvine.oeis.a029.A029640;
import irvine.oeis.AbstractSequence;

/**
 * A051467 (Terms in A029640)/2.
 * @author Georg Fischer
 */
public class A051467 extends AbstractSequence {

  private final A029640 mSeq1 = new A029640();

  /** Construct the sequence. */
  public A051467() {
    super($(OFFSET));
    mSeq1.next(); // 2 was inserted
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A051468	1	->	0	A029641	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a029.A029641;
import irvine.oeis.AbstractSequence;

/**
 * A051468 (Terms in A029641)/2.
 * @author Georg Fischer
 */
public class A051468 extends AbstractSequence {

  private final A029641 mSeq1 = new A029641();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A051474	1	->	0	A014450	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014450;
import irvine.oeis.AbstractSequence;

/**
 * A051474 (Terms in A014450)/2.
 * @author Georg Fischer
 */
public class A051474 extends AbstractSequence {

  private final A014450 mSeq1 = new A014450();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A051475	1	->	0	A014472	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014472;
import irvine.oeis.AbstractSequence;

/**
 * A051475 (Terms in A014472)/2.
 * @author Georg Fischer
 */
public class A051475 extends AbstractSequence {

  private final A014472 mSeq1 = new A014472();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A051476	1	->	0	A014733	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014733;
import irvine.oeis.AbstractSequence;

/**
 * A051476 (Terms in A014733)/4.
 * @author Georg Fischer
 */
public class A051476 extends AbstractSequence {

  private final A014733 mSeq1 = new A014733();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide(4);
  }
}
#!queue	A051477	1	->	0	A014759	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014759;
import irvine.oeis.AbstractSequence;

/**
 * A051477 (Terms in A014759)/4.
 * @author Georg Fischer
 */
public class A051477 extends AbstractSequence {

  private final A014759 mSeq1 = new A014759();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide(4);
  }
}
#!queue	A051514	1	->	0	A014762	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014762;
import irvine.oeis.AbstractSequence;

/**
 * A051514 (Terms in A014762)/4.
 * @author Georg Fischer
 */
public class A051514 extends AbstractSequence {

  private final A014762 mSeq1 = new A014762();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide(4);
  }
}
#!queue	A051541	0	->	1	A051539	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A051541 Quotients of consecutive values of LCM {1, 5, 9, 13, 17, ..., (4n+1)}.
 * @author Sean A. Irvine
 */
public class A051541 extends AbstractSequence {

  private final A051539 mSeq1 = new A051539();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.divide(t);
  }
}
#!queue	A051544	0	->	1	A051536	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A051544 Quotients of consecutive values of lcm {1, 4, 7, 10, 13 ...,(3n+1)} (A016777).
 * @author Sean A. Irvine
 */
public class A051544 extends AbstractSequence {

  private final A051536 mSeq1 = new A051536();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.divide(t);
  }
}
#!queue	A051552	0	->	1	A051540	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A051552 Quotients of consecutive values of LCM {b(0), b(1) ...,b(n)}, b() = A016789.
 * @author Sean A. Irvine
 */
public class A051552 extends AbstractSequence {

  private final A051540 mSeq1 = new A051540();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.divide(t);
  }
}
#!queue	A051671	1	->	0	A048559	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a048.A048559;
import irvine.oeis.AbstractSequence;

/**
 * A051671 Smallest positive number whose digits concatenated with all previous terms forms a perfect square.
 * @author Sean A. Irvine
 */
public class A051671 extends AbstractSequence {

  private final A048559 mSeq1 = new A048559();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private String mA = "";

  @Override
  public Z next() {
    final String t = mA;
    mA = mSeq1.next().toString();
    return new Z(mA.substring(t.length()));
  }
}

#!queue	A052320	1	->	0	A052318	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A052320 Number of labeled trimmed trees with n nodes.
 * @author Sean A. Irvine
 */
public class A052320 extends AbstractSequence {

  private final A052318 mSeq1 = new A052318();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mB = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Q.ZERO);
      return Z.ONE;
    }
    mF = mF.multiply(mN);
    mB.add(new Q(mSeq1.next(), mF));
    if (mN <= 2) {
      return Z.ONE; // avoid need for "corrections" to e.g.f.
    } else if (mN == 3) {
      return Z.ZERO;
    } else if (mN == 4) {
      return Z.FOUR;
    } else {
      final Q t = mB.get(mN).subtract(RING.pow(mB, 2, mN).coeff(mN).divide(2));
      return t.multiply(mF).toZ();
    }
  }
}
#!queue	A052323	1	->	0	A052322	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A052323 Number of labeled trees with a forbidden limb of length 3.
 * @author Sean A. Irvine
 */
public class A052323 extends AbstractSequence {

  private final A052322 mSeq1 = new A052322();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Z[] SMALL = {Z.ONE, Z.ONE, Z.ONE, Z.THREE, Z.FOUR, Z.valueOf(65), Z.valueOf(576)};
  private final Polynomial<Q> mB = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Q.ZERO);
      return Z.ONE;
    }
    mF = mF.multiply(mN);
    mB.add(new Q(mSeq1.next(), mF));
    if (mN < SMALL.length) {
      return SMALL[mN]; // avoid need for "corrections" to e.g.f.
    } else {
      final Q t = mB.get(mN).subtract(RING.pow(mB, 2, mN).coeff(mN).divide(2));
      return t.multiply(mF).toZ();
    }
  }
}
#!queue	A052338	0	->	1	A050443	--------------------------------
package irvine.oeis.a052;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a050.A050443;
import irvine.oeis.AbstractSequence;

/**
 * A052338 a(n) = A050443(n-th prime)/(n-th prime).
 * @author Sean A. Irvine
 */
public class A052338 extends AbstractSequence {

  private final A050443 mSeq1 = new A050443();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Fast mPrime = new Fast();
  protected long mN = -1;

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (mPrime.isPrime(++mN)) {
        return t.divide(mN);
      }
    }
  }
}
#!queue	A053250	1	->	0	A027358	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a027.A027357;
import irvine.oeis.a027.A027358;
import irvine.oeis.AbstractSequence;

/**
 * A053250 Coefficients of the '3rd order' mock theta function phi(q).
 * @author Sean A. Irvine
 */
public class A053250 extends AbstractSequence {

  private final A027358 mSeq1 = new A027358();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Sequence mA = null;
  private boolean mSign = true;

  @Override
  public Z next() {
    if (mA == null) {
      mA = new A027357();
      return Z.ONE;
    }
    mSign = !mSign;
    return mSign ? mSeq1.next().subtract(mA.next()) : mA.next().subtract(mSeq1.next());
  }
}
#!queue	A053370	1	->	0	A039955	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039955;
import irvine.oeis.AbstractSequence;

/**
 * A053370 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of x for n == 1 mod 4.
 * @author Sean A. Irvine
 */
public class A053370 extends AbstractSequence {

  private final A039955 mSeq1 = new A039955();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    final Z[] unit = QuadraticFieldUtils.fundamentalUnitPair(mSeq1.next());
    return unit[0].subtract(unit[1]).divide2();
  }
}
#!queue	A053381	1	->	0	A209675	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a209.A209675;
import irvine.oeis.AbstractSequence;

/**
 * A053381 Maximal number of linearly independent smooth nowhere-zero vector fields on a (2n+1)-sphere.
 * @author Sean A. Irvine
 */
public class A053381 extends AbstractSequence {

  private final A209675 mSeq1 = new A209675();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(1);
  }
}
#!queue	A053878	1	->	2	A002182	--------------------------------
package irvine.oeis.a053;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a002.A002182;
import irvine.oeis.AbstractSequence;

/**
 * A053878 Difference between numerator and denominator of lowest terms fraction from division of a highly composite number (1) by its predecessor.
 * @author Sean A. Irvine
 */
public class A053878 extends AbstractSequence {

  private final A002182 mSeq1 = new A002182();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z b = mA;
    mA = mSeq1.next();
    final Q t = new Q(mA, b);
    return t.num().subtract(t.den());
  }
}
#!queue	A054351	1	->	0	A000002	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000002;
import irvine.oeis.AbstractSequence;

/**
 * A054351 Successive generations of the Kolakoski sequence A000002.
 * @author Sean A. Irvine
 */
public class A054351 extends AbstractSequence {

  private final A000002 mSeq1 = new A000002();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final StringBuilder mS = new StringBuilder();
  private final Sequence mRowLengths = new A054352();
  private long mN = 0;

  @Override
  public Z next() {
    final long mRowLength = mRowLengths.next().longValueExact();
    while (mN < mRowLength) {
      mS.append(mSeq1.next());
      ++mN;
    }
    return new Z(mS);
  }
}
#!queue	A054481	1	->	2	A002182	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a002.A002182;
import irvine.oeis.AbstractSequence;

/**
 * A054481 Highest common factor of successive highly composite numbers (1), A002182.
 * @author Sean A. Irvine
 */
public class A054481 extends AbstractSequence {

  private final A002182 mSeq1 = new A002182();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.gcd(t);
  }
}
#!queue	A054482	1	->	2	A002182	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a002.A002182;
import irvine.oeis.AbstractSequence;

/**
 * A054482 Denominator of lowest terms fraction from division of a highly composite number (1) by its predecessor.
 * @author Sean A. Irvine
 */
public class A054482 extends AbstractSequence {

  private final A002182 mSeq1 = new A002182();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return t.divide(mA.gcd(t));
  }
}
#!queue	A054483	1	->	2	A002182	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a002.A002182;
import irvine.oeis.AbstractSequence;

/**
 * A054483 Numerator of lowest terms fraction from division of a highly composite number (1) by its predecessor.
 * @author Sean A. Irvine
 */
public class A054483 extends AbstractSequence {

  private final A002182 mSeq1 = new A002182();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return mA.divide(mA.gcd(t));
  }
}
#!queue	A054916	0	->	1	A005177	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a005.A005176;
import irvine.oeis.a005.A005177;
import irvine.oeis.AbstractSequence;

/**
 * A054916 Number of connected unlabeled regular graphs with n nodes such that complement is also connected.
 * @author Sean A. Irvine
 */
public class A054916 extends AbstractSequence {

  private final A005177 mSeq1 = new A005177();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A005176();
  {
    next();
  }

  @Override
  public Z next() {
    return mSeq1.next().multiply2().subtract(mA.next());
  }
}
#!queue	A054949	0	->	1	A054948	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A054949 Number of labeled semi-strong digraphs on n nodes with an odd number of components.
 * @author Sean A. Irvine
 */
public class A054949 extends AbstractSequence {

  private final A054948 mSeq1 = new A054948();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A054947();
  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mA.next()).divide2();
  }
}
#!queue	A054950	0	->	1	A054948	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A054950 Number of labeled semi-strong digraphs on n nodes with an even number of components.
 * @author Sean A. Irvine
 */
public class A054950 extends AbstractSequence {

  private final A054948 mSeq1 = new A054948();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A054947();
  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next()).divide2();
  }
}
#!queue	A054960	0	->	1	A000088	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000088;
import irvine.oeis.a000.A000171;
import irvine.oeis.AbstractSequence;

/**
 * A054960 Number of unlabeled graphs with n nodes and an odd number of edges.
 * @author Sean A. Irvine
 */
public class A054960 extends AbstractSequence {

  private final A000088 mSeq1 = new A000088();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A000171();
  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next()).divide2();
  }
}
#!queue	A055019	0	->	1	A051885	--------------------------------
package irvine.oeis.a055;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a051.A051885;
import irvine.oeis.AbstractSequence;

/**
 * A055019 Numbers n such that A051885(p_n) is prime, where p_n=A000040(n) is the n-th prime.
 * @author Sean A. Irvine
 */
public class A055019 extends AbstractSequence {

  private final A051885 mSeq1 = new A051885();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Fast mPrime = new Fast();
  private long mN = -1;
  private long mPi = 0;

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (mPrime.isPrime(++mN)) {
        ++mPi;
        if (t.isProbablePrime()) {
          return Z.valueOf(mPi);
        }
      }
    }
  }
}
#!queue	A055026	0	->	1	A055028	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A055026 Number of Gaussian primes of successive norms (indexed by A055025).
 * @author Sean A. Irvine
 */
public class A055026 extends AbstractSequence {

  private final A055028 mSeq1 = new A055028();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = mSeq1.next();
      if (!t.isZero()) {
        return t;
      }
    }
  }
}
#!queue	A055131	1	->	0	A005098	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a005.A005098;
import irvine.oeis.AbstractSequence;

/**
 * A055131 Those composite s for which A055095[s] = 2.
 * @author Sean A. Irvine
 */
public class A055131 extends AbstractSequence {

  private final A005098 mSeq1 = new A005098();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().multiply(4).add(1).multiply(3);
  }
}
#!queue	A055152	0	->	1	A003180	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a003.A003180;
import irvine.oeis.AbstractSequence;

/**
 * A055152 Proper covers of an unlabeled n-set.
 * a(n) = (A003180(n) - 2*A003180(n-1))/4.
 * @author Georg Fischer
 */
public class A055152 extends AbstractSequence {

  private final A003180 mSeq1 = new A003180();

  private Z mA1;

  /** Construct the sequence. */
  public A055152() {
    super($(OFFSET));
    mA1 = mSeq1.next();
  }

  @Override
  public Z next() {
    final Z mA = mSeq1.next();
    final Z result = mA.subtract(mA1.multiply2()).divide(4);
    mA1 = mA;
    return result;
  }
}
#!queue	A055348	0	->	1	A055347	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A055348 Column 1 of triangle A055347.
 * @author Sean A. Irvine
 */
public class A055348 extends AbstractSequence {

  private final A055347 mSeq1 = new A055347();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -2;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k < mN; ++k) {
      mSeq1.next();
    }
    return mSeq1.next();
  }
}
#!queue	A055371	0	->	1	A055370	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A055371 Column 1 of triangle A055370.
 * @author Sean A. Irvine
 */
public class A055371 extends AbstractSequence {

  private final A055370 mSeq1 = new A055370();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -2;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k < mN; ++k) {
      mSeq1.next();
    }
    return mSeq1.next();
  }
}
#!queue	A055497	1	->	-1	A008578	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a008.A008578;
import irvine.oeis.AbstractSequence;

/**
 * A055497 a(-1) = 4, a(0) = 5; thereafter a(n) = 4 + (Product_{k=1..n} prime(k))^2.
 * @author Sean A. Irvine
 */
public class A055497 extends AbstractSequence {

  private final A008578 mSeq1 = new A008578();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
      return Z.FOUR;
    }
    mA = mA.multiply(mSeq1.next().square());
    return mA.add(4);
  }
}
#!queue	A055684	2	->	3	A023022	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a023.A023022;
import irvine.oeis.AbstractSequence;

/**
 * A055684 Number of different n-pointed stars.
 * @author Sean A. Irvine
 */
public class A055684 extends AbstractSequence {

  private final A023022 mSeq1 = new A023022();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(1);
  }
}
#!queue	A055724	1	->	0	A031158	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a031.A031158;
import irvine.oeis.AbstractSequence;

/**
 * A055724 Number of lucky twins &lt;= 10^n.
 * @author Sean A. Irvine
 */
public class A055724 extends AbstractSequence {

  private final A031158 mSeq1 = new A031158();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mLimit = 0;
  private long mCount = 0;

  @Override
  public Z next() {
    mLimit = mLimit == 0 ? 1 : mLimit * 10;
    while (mSeq1.next().longValueExact() <= mLimit) {
      ++mCount;
    }
    return Z.valueOf(mCount++);
  }
}
#!queue	A055728	1	->	0	A031157	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a031.A031157;
import irvine.oeis.AbstractSequence;

/**
 * A055728 Number of prime lucky numbers &lt;10^n.
 * @author Sean A. Irvine
 */
public class A055728 extends AbstractSequence {

  private final A031157 mSeq1 = new A031157();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mLimit = 0;
  private long mCount = 0;

  @Override
  public Z next() {
    mLimit = mLimit == 0 ? 1 : mLimit * 10;
    while (mSeq1.next().longValueExact() < mLimit) {
      ++mCount;
    }
    return Z.valueOf(mCount++);
  }
}
#!queue	A056136	0	->	1	A029578	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a029.A029578;
import irvine.oeis.AbstractSequence;

/**
 * A056136 Largest positive integer whose harmonic mean with another positive integer is n.
 * @author Sean A. Irvine
 */
public class A056136 extends AbstractSequence {

  private final A029578 mSeq1 = new A029578();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  {
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().multiply(++mN).divide2();
  }
}
#!queue	A056367	0	->	1	A056362	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000046;
import irvine.oeis.AbstractSequence;

/**
 * A056367 Number of primitive (period n) bracelet structures using exactly three different colored beads.
 * @author Sean A. Irvine
 */
public class A056367 extends AbstractSequence {

  private final A056362 mSeq1 = new A056362();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A000046();
  {
    next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next());
  }
}
#!queue	A056368	0	->	1	A056363	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A056368 Number of primitive (period n) bracelet structures using exactly four different colored beads.
 * @author Sean A. Irvine
 */
public class A056368 extends AbstractSequence {

  private final A056363 mSeq1 = new A056363();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A056362();
  {
    next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next());
  }
}
#!queue	A056369	0	->	1	A056364	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A056369 Number of primitive (period n) bracelet structures using exactly five different colored beads.
 * @author Sean A. Irvine
 */
public class A056369 extends AbstractSequence {

  private final A056364 mSeq1 = new A056364();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A056363();
  {
    next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next());
  }
}
#!queue	A056370	0	->	1	A056365	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A056370 Number of primitive (period n) bracelet structures using exactly six different colored beads.
 * @author Sean A. Irvine
 */
public class A056370 extends AbstractSequence {

  private final A056365 mSeq1 = new A056365();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A056364();
  {
    next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next());
  }
}
#!queue	A056485	0	->	1	A056479	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.AbstractSequence;

/**
 * A056485 Number of primitive (aperiodic) palindromic structures using exactly six different symbols.
 * @author Georg Fischer
 */
public class A056485 extends AbstractSequence {

  private final A056479 mSeq1 = new A056479();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mSeq = new A056480();

  {
    next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(mSeq1.next());
  }
}
#!queue	A056582	0	->	2	A000312	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000312;
import irvine.oeis.a002.A002109;
import irvine.oeis.AbstractSequence;

/**
 * A056582 Highest common factor (or GCD) of n^n and hyperfactorial(n-1), i.e., gcd(n^n, product(k^k) for k &lt; n).
 * @author Sean A. Irvine
 */
public class A056582 extends AbstractSequence {

  private final A000312 mSeq1 = new A000312();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A002109();
  {
    mSeq1.next();
    mSeq1.next();
    mA.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().gcd(mA.next());
  }
}
#!queue	A056835	1	->	0	A024619	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a024.A024619;
import irvine.oeis.AbstractSequence;

/**
 * A056835 a(n) = lcm(s(1),...,s(n)) where {s(n)} = A024619 and a(0) = 1.
 * @author Sean A. Irvine
 */
public class A056835 extends AbstractSequence {

  private final A024619 mSeq1 = new A024619();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mLcm = null;

  @Override
  public Z next() {
    mLcm = mLcm == null ? Z.ONE : mLcm.lcm(mSeq1.next());
    return mLcm;
  }
}
#!queue	A056898	0	->	1	A056897	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A056898 a(n) = smallest number m such that m^2+n is prime.
 * @author Sean A. Irvine
 */
public class A056898 extends AbstractSequence {

  private final A056897 mSeq1 = new A056897();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().sqrt();
  }
}
#!queue	A057596	-2	->	0	A039834	--------------------------------
package irvine.oeis.a057;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a039.A039834;
import irvine.oeis.AbstractSequence;

/**
 * A057596 E.g.f. is 1/E(x) where E(x) is e.g.f. for [1,0,1,1,2,3,5,8,...] with o.g.f. (1-x)/(1-x-x^2).
 * @author Sean A. Irvine
 */
public class A057596 extends AbstractSequence {

  private final A039834 mSeq1 = new A039834();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  {
    mSeq1.next();
  }
  private final Polynomial<Q> mE = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    mE.add(new Q(mSeq1.next().abs(), MemoryFactorial.SINGLETON.factorial(++mN)));
    return RING.coeff(RING.one(), mE, mN).multiply(MemoryFactorial.SINGLETON.factorial(mN)).toZ();
  }
}
#!queue	A057924	0	->	1	A057923	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057924 Sequence b(n) mentioned in A057923.
 * @author Sean A. Irvine
 */
public class A057924 extends AbstractSequence {

  private final A057923 mSeq1 = new A057923();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return t.or(mA);
  }
}
#!queue	A057927	0	->	1	A057926	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057927 Sequence b(n) mentioned in A057926.
 * @author Sean A. Irvine
 */
public class A057927 extends AbstractSequence {

  private final A057926 mSeq1 = new A057926();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return t.or(mA);
  }
}
#!queue	A057930	0	->	1	A057929	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057930 Sequence b(n) mentioned in A057929.
 * @author Sean A. Irvine
 */
public class A057930 extends AbstractSequence {

  private final A057929 mSeq1 = new A057929();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mSeq1.next();
    return t.or(mA);
  }
}
#!queue	A058352	1	->	0	A000084	--------------------------------
package irvine.oeis.a058;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000084;
import irvine.oeis.AbstractSequence;

/**
 * A058352 a(n) Sum_{d|n, 1&lt;=d&lt;n} d*A000084(d).
 * @author Sean A. Irvine
 */
public class A058352 extends AbstractSequence {

  private final A000084 mSeq1 = new A000084();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected final ArrayList<Z> mS = new ArrayList<>();
  {
    mS.add(Z.ZERO);
  }
  private int mN = 0;

  protected boolean accept(final int d) {
    return d < mN;
  }

  @Override
  public Z next() {
    mS.add(mSeq1.next());
    Z sum = Z.ZERO;
    if (++mN > 0) {
      for (final Z d : Jaguar.factor(mN).divisors()) {
        final int dd = d.intValueExact();
        if (accept(dd)) {
          sum = sum.add(mS.get(dd).multiply(d));
        }
      }
    }
    return sum;
  }
}

#!queue	A058756	1	->	0	A000084	--------------------------------
package irvine.oeis.a058;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000084;
import irvine.oeis.AbstractSequence;

/**
 * A058756 G.f. is (1-S)/(1+S), where S = g.f. for A000084.
 * @author Sean A. Irvine
 */
public class A058756 extends AbstractSequence {

  private final A000084 mSeq1 = new A000084();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final Polynomial<Z> mA = RING.empty();
  private final Polynomial<Z> mB = RING.empty();
  private int mN = -1;
  {
    mA.add(Z.ONE);
    mB.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z s = mSeq1.next();
    mA.add(s.negate());
    mB.add(s);
    return RING.coeff(mA, mB, ++mN);
  }
}
#!queue	A059126	1	->	0	A001511	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a001.A001511;
import irvine.oeis.AbstractSequence;

/**
 * A059126 A hierarchical sequence (W2{2} according to the description in the attached file - see link).
 * @author Sean A. Irvine
 */
public class A059126 extends AbstractSequence {

  private final A001511 mSeq1 = new A001511();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 3)) {
      case 0:
        mA = mSeq1.next().multiply2();
        return mA.subtract(1);
      case 1:
        return mA;
      case 2:
      default:
        return mA.subtract(1);
    }
  }
}

#!queue	A059127	1	->	0	A001511	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a001.A001511;
import irvine.oeis.AbstractSequence;

/**
 * A059127 A hierarchical sequence (W2{3} - see A059126).
 * @author Sean A. Irvine
 */
public class A059127 extends AbstractSequence {

  private final A001511 mSeq1 = new A001511();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 7)) {
      case 0:
        mA = mSeq1.next().multiply(3);
        return mA.subtract(2);
      case 3:
        return mA;
      case 2:
      case 4:
      case 6:
        return mA.subtract(2);
      case 1:
      case 5:
      default:
        return mA.subtract(1);
    }
  }
}

#!queue	A059128	1	->	0	A059126	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059128 A hierarchical sequence (W3{2,2} - see A059126).
 * @author Sean A. Irvine
 */
public class A059128 extends AbstractSequence {

  private final A059126 mSeq1 = new A059126();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 3)) {
      case 0:
        mA = mSeq1.next().multiply2();
        return mA.subtract(1);
      case 1:
        return mA;
      case 2:
      default:
        return mA.subtract(1);
    }
  }
}

#!queue	A059129	1	->	0	A001511	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a001.A001511;
import irvine.oeis.AbstractSequence;

/**
 * A059129 A hierarchical sequence (W2{2}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059129 extends AbstractSequence {

  private final A001511 mSeq1 = new A001511();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 3)) {
      case 0:
        do {
          mA = mSeq1.next();
        } while (Z.ONE.equals(mA));
        return mA.subtract(1);
      case 1:
        return mA;
      case 2:
      default:
        return mA.subtract(1);
    }
  }
}

#!queue	A059130	1	->	0	A001511	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a001.A001511;
import irvine.oeis.AbstractSequence;

/**
 * A059130 A hierarchical sequence (W2{3}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059130 extends AbstractSequence {

  private final A001511 mSeq1 = new A001511();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 7)) {
      case 0:
        do {
          mA = mSeq1.next();
        } while (mA.compareTo(Z.TWO) <= 0);
        return mA.subtract(2);
      case 3:
        return mA;
      case 2:
      case 4:
      case 6:
        return mA.subtract(2);
      case 1:
      case 5:
      default:
        return mA.subtract(1);
    }
  }
}

#!queue	A059131	1	->	0	A001511	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a001.A001511;
import irvine.oeis.AbstractSequence;

/**
 * A059131 A hierarchical sequence (W3{2,2}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059131 extends AbstractSequence {

  private final A001511 mSeq1 = new A001511();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 9)) {
      case 0:
        mA = mSeq1.next().add(2);
        return mA.subtract(2);
      case 4:
        return mA;
      case 2:
      case 6:
      case 8:
        return mA.subtract(2);
      case 1:
      case 3:
      case 5:
      case 7:
      default:
        return mA.subtract(1);
    }
  }
}

#!queue	A059132	1	->	0	A059126	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059132 A hierarchical sequence (W2{2}c - see A059126).
 * @author Sean A. Irvine
 */
public class A059132 extends AbstractSequence {

  private final A059126 mSeq1 = new A059126();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mSeq1.next()).add(mSeq1.next());
  }
}

#!queue	A059134	1	->	0	A059127	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059134 A hierarchical sequence (W2{3}c - see A059126).
 * @author Sean A. Irvine
 */
public class A059134 extends AbstractSequence {

  private final A059127 mSeq1 = new A059127();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mSeq1.next()).add(mSeq1.next()).add(mSeq1.next()).add(mSeq1.next()).add(mSeq1.next()).add(mSeq1.next());
  }
}

#!queue	A059135	1	->	0	A059127	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059135 A hierarchical sequence (S(W2{3}c) - see A059126).
 * @author Sean A. Irvine
 */
public class A059135 extends AbstractSequence {

  private final A059127 mSeq1 = new A059127();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    long m = 0;
    final long lim = 7L << mN;
    while (m < lim) {
      mSum = mSum.add(mSeq1.next());
      ++m;
    }
    return mSum;
  }
}

#!queue	A059136	1	->	0	A059128	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059136 A hierarchical sequence (W3{2,2}c - see A059126).
 * @author Sean A. Irvine
 */
public class A059136 extends AbstractSequence {

  private final A059128 mSeq1 = new A059128();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mSeq1.next()).add(mSeq1.next());
  }
}

#!queue	A059137	1	->	0	A059136	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059137 A hierarchical sequence (W3{2,2}cc - see A059126).
 * @author Sean A. Irvine
 */
public class A059137 extends AbstractSequence {

  private final A059136 mSeq1 = new A059136();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mSeq1.next()).add(mSeq1.next());
  }
}

#!queue	A059138	1	->	0	A059137	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059138 A hierarchical sequence (S(W3{2,2}cc) - see A059126).
 * @author Sean A. Irvine
 */
public class A059138 extends AbstractSequence {

  private final A059137 mSeq1 = new A059137();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    long m = 0;
    final long lim = 1L << mN;
    while (m < lim) {
      mSum = mSum.add(mSeq1.next());
      ++m;
    }
    return mSum;
  }
}

#!queue	A059139	1	->	0	A059129	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059139 A hierarchical sequence (W2{2}*c - see A059126).
 * @author Sean A. Irvine
 */
public class A059139 extends AbstractSequence {

  private final A059129 mSeq1 = new A059129();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mSeq1.next()).add(mSeq1.next());
  }
}

#!queue	A059140	1	->	0	A059139	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059140 A hierarchical sequence (S(W2{2}*c) - see A059126).
 * @author Sean A. Irvine
 */
public class A059140 extends AbstractSequence {

  private final A059139 mSeq1 = new A059139();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    long m = 0;
    final long lim = 1L << mN;
    while (m < lim) {
      mSum = mSum.add(mSeq1.next());
      ++m;
    }
    return mSum;
  }
}

#!queue	A059141	1	->	0	A059130	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059141 A hierarchical sequence (W2{3}*c - see A059126).
 * @author Sean A. Irvine
 */
public class A059141 extends AbstractSequence {

  private final A059130 mSeq1 = new A059130();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mSeq1.next()).add(mSeq1.next()).add(mSeq1.next()).add(mSeq1.next()).add(mSeq1.next()).add(mSeq1.next());
  }
}

#!queue	A059142	1	->	0	A059141	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059142 A hierarchical sequence (S(W2{3}*) - see A059126).
 * @author Sean A. Irvine
 */
public class A059142 extends AbstractSequence {

  private final A059141 mSeq1 = new A059141();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    long m = 0;
    final long lim = 1L << mN;
    while (m < lim) {
      mSum = mSum.add(mSeq1.next());
      ++m;
    }
    return mSum;
  }
}

#!queue	A059143	1	->	0	A059131	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059143 A hierarchical sequence (W3{2,2}*c - see A059126).
 * @author Sean A. Irvine
 */
public class A059143 extends AbstractSequence {

  private final A059131 mSeq1 = new A059131();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mSeq1.next()).add(mSeq1.next());
  }
}

#!queue	A059144	1	->	0	A059143	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059144 A hierarchical sequence (W3{2,2}*cc - see A059126).
 * @author Sean A. Irvine
 */
public class A059144 extends AbstractSequence {

  private final A059143 mSeq1 = new A059143();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(mSeq1.next()).add(mSeq1.next());
  }
}

#!queue	A059145	1	->	0	A059144	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059145 A hierarchical sequence (S(W3{2,2}*cc) - see A059126).
 * @author Sean A. Irvine
 */
public class A059145 extends AbstractSequence {

  private final A059144 mSeq1 = new A059144();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    long m = 0;
    final long lim = 1L << mN;
    while (m < lim) {
      mSum = mSum.add(mSeq1.next());
      ++m;
    }
    return mSum;
  }
}

#!queue	A059879	0	->	1	A059878	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059879 Those n for which the absolute value of A059878[n] is prime.
 * @author Sean A. Irvine
 */
public class A059879 extends AbstractSequence {

  private final A059878 mSeq1 = new A059878();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (mSeq1.next().abs().isProbablePrime()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A060206	1	->	0	A000682	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a000.A000682;
import irvine.oeis.AbstractSequence;

/**
 * A060206 Number of rotationally symmetric closed meanders of length 4n+2.
 * @author Sean A. Irvine
 */
public class A060206 extends AbstractSequence {

  private final A000682 mSeq1 = new A000682();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z t = mSeq1.next();
    mSeq1.next();
    return t;
  }
}
#!queue	A060465	1	->	0	A060464	--------------------------------
package irvine.oeis.a060;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A060465 Value of x of the solution to x^3 + y^3 + z^3 = A060464(n) (numbers not 4 or 5 mod 9) with smallest |z| and smallest |y|, 0 &lt;= |x| &lt;= |y| &lt;= |z|.
 * @author Sean A. Irvine
 */
public class A060465 extends AbstractSequence {

  private final A060464 mSeq1 = new A060464();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  static Z check(final Z x3, final long y, final long z, final Z n) {
    final Z x = x3.root(3);
    if (x3.auxiliary() != 1 || x.bitLength() > 63) {
      return null;
    }
    final long lx = x.longValue();
    if (Math.abs(lx) > y) {
      return null;
    }
    final long d = Math.abs(LongUtils.gcd(lx, y, z));
    return d == 1 || n.mod(d) != 0 ? x : null;
  }

  @Override
  public Z next() {
    final Z n = mSeq1.next();
    if (n.isZero()) {
      return Z.ZERO;
    }
    long z = 0;
    while (true) {
      final Z z3 = Z.valueOf(++z).pow(3);
      final Z nz3 = n.subtract(z3);
      if (nz3.isZero()) {
        return Z.ZERO;
      }
      final Z pz3 = n.add(z3);
      for (long y = 0; y <= z; ++y) {
        final Z y3 = Z.valueOf(y).pow(3);
        final Z x1 = check(nz3.subtract(y3), y, z, n);
        Z res = null;
        if (x1 != null) {
          res = x1;
        }
        final Z x2 = check(nz3.add(y3), y, z, n);
        if (x2 != null && (res == null || x2.abs().compareTo(res.abs()) < 0)) {
          res = x2;
        }
        final Z x3 = check(pz3.subtract(y3), y, z, n);
        if (x3 != null && (res == null || x3.abs().compareTo(res.abs()) < 0)) {
          res = x3;
        }
        final Z x4 = check(pz3.add(y3), y, z, n);
        if (x4 != null && (res == null || x4.abs().compareTo(res.abs()) < 0)) {
          res = x4;
        }
        if (res != null) {
          return res;
        }
      }
    }
  }
}
#!queue	A060466	1	->	0	A060464	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A060466 Value of y of the solution to x^3 + y^3 + z^3 = A060464(n) (numbers not 4 or 5 mod 9) with smallest |z| and smallest |y|, 0 &lt;= |x| &lt;= |y| &lt;= |z|.
 * @author Sean A. Irvine
 */
public class A060466 extends AbstractSequence {

  private final A060464 mSeq1 = new A060464();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z n = mSeq1.next();
    if (n.isZero()) {
      return Z.ZERO;
    }
    long z = 0;
    while (true) {
      final Z z3 = Z.valueOf(++z).pow(3);
      final Z nz3 = n.subtract(z3);
      if (nz3.isZero()) {
        return Z.ZERO;
      }
      final Z pz3 = n.add(z3);
      for (long y = 0; y <= z; ++y) {
        final Z y3 = Z.valueOf(y).pow(3);
        final Z x1 = A060465.check(nz3.subtract(y3), y, z, n);
        if (x1 != null) {
          return Z.valueOf(y);
        }
        final Z x2 = A060465.check(nz3.add(y3), y, z, n);
        if (x2 != null) {
          return Z.valueOf(-y);
        }
        final Z x3 = A060465.check(pz3.subtract(y3), y, z, n);
        if (x3 != null) {
          return Z.valueOf(y);
        }
        final Z x4 = A060465.check(pz3.add(y3), y, z, n);
        if (x4 != null) {
          return Z.valueOf(-y);
        }
      }
    }
  }
}
#!queue	A060467	1	->	0	A060464	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A060467 Value of z of the solution to x^3 + y^3 + z^3 = A060464(n) (numbers not 4 or 5 mod 9) with smallest |z| and smallest |y|, 0 &lt;= |x| &lt;= |y| &lt;= |z|.
 * @author Sean A. Irvine
 */
public class A060467 extends AbstractSequence {

  private final A060464 mSeq1 = new A060464();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z n = mSeq1.next();
    if (n.isZero()) {
      return Z.ZERO;
    }
    long z = 0;
    while (true) {
      final Z zz = Z.valueOf(++z);
      final Z z3 = zz.pow(3);
      final Z nz3 = n.subtract(z3);
      if (nz3.isZero()) {
        return zz;
      }
      final Z pz3 = n.add(z3);
      for (long y = 0; y <= z; ++y) {
        final Z y3 = Z.valueOf(y).pow(3);
        final Z x1 = A060465.check(nz3.subtract(y3), y, z, n);
        if (x1 != null) {
          return Z.valueOf(z);
        }
        final Z x2 = A060465.check(nz3.add(y3), y, z, n);
        if (x2 != null) {
          return Z.valueOf(z);
        }
        final Z x3 = A060465.check(pz3.subtract(y3), y, z, n);
        if (x3 != null) {
          return Z.valueOf(-z);
        }
        final Z x4 = A060465.check(pz3.add(y3), y, z, n);
        if (x4 != null) {
          return Z.valueOf(-z);
        }
      }
    }
  }
}
#!queue	A061358	1	->	0	A045917	--------------------------------
package irvine.oeis.a061;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a045.A045917;
import irvine.oeis.AbstractSequence;

/**
 * A061358 Number of ways of writing n = p+q with p, q primes and p &gt;= q.
 * @author Sean A. Irvine
 */
public class A061358 extends AbstractSequence {

  private final A045917 mSeq1 = new A045917();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    if (mN == 0 || (mN & 1) == 1) {
      return mPrime.isPrime(mN - 2) ? Z.ONE : Z.ZERO;
    } else {
      return mSeq1.next();
    }
  }
}

#!queue	A061769	1	->	0	A011778	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;
import irvine.oeis.a011.A011778;
import irvine.oeis.AbstractSequence;

/**
 * A061769 The least number k = a(n) &gt; a(n-1) for which k!/(k+1)^m for increasing m's.
 * @author Sean A. Irvine
 */
public class A061769 extends AbstractSequence {

  private final A011778 mSeq1 = new A011778();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(1);
  }
}
#!queue	A062018	0	->	1	A000312	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000312;
import irvine.oeis.AbstractSequence;

/**
 * A062018 a(n) = n^n written backwards.
 * @author Sean A. Irvine
 */
public class A062018 extends AbstractSequence {

  private final A000312 mSeq1 = new A000312();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return ZUtils.reverse(mSeq1.next());
  }
}
#!queue	A062320	1	->	0	A013929	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.oeis.a013.A013929;
import irvine.oeis.AbstractSequence;

/**
 * A062320 Nonsquarefree numbers squared. A013929(n)^2.
 * @author Sean A. Irvine
 */
public class A062320 extends AbstractSequence {

  private final A013929 mSeq1 = new A013929();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().square();
  }
}
#!queue	A062322	1	->	0	A013929	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.oeis.a013.A013929;
import irvine.oeis.AbstractSequence;

/**
 * A062322 Factorials of nonsquarefree numbers, or A013929(n)!, (including 1).
 * @author Sean A. Irvine
 */
public class A062322 extends AbstractSequence {

  private final A013929 mSeq1 = new A013929();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mF = null;
  private long mN = 2;

  @Override
  public Z next() {
    if (mF == null) {
      mF = Z.ONE;
      return Z.ONE;
    }
    final long t = mSeq1.next().longValueExact();
    while (mN <= t) {
      mF = mF.multiply(mN);
      ++mN;
    }
    return mF;
  }
}
#!queue	A062950	2	->	3	A023022	--------------------------------
package irvine.oeis.a062;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a023.A023022;
import irvine.oeis.AbstractSequence;

/**
 * A062950 C(H(n)), where C(n) is Chowla's function (A048050) and H(n) is the half-totient function (A023022).
 * @author Sean A. Irvine
 */
public class A062950 extends AbstractSequence {

  private final A023022 mSeq1 = new A023022();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    final Z n = mSeq1.next();
    return Jaguar.factor(n).sigma().subtract(n).subtract(1);
  }
}

#!queue	A062963	2	->	3	A023022	--------------------------------
package irvine.oeis.a062;

import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.oeis.a023.A023022;
import irvine.oeis.AbstractSequence;

/**
 * A062963 Mu(n) * H(n) where H(n) is A023022.
 * @author Sean A. Irvine
 */
public class A062963 extends AbstractSequence {

  private final A023022 mSeq1 = new A023022();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 2;
  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().multiply(Mobius.mobius(++mN));
  }
}

#!queue	A062976	2	->	3	A023022	--------------------------------
package irvine.oeis.a062;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a023.A023022;
import irvine.oeis.AbstractSequence;

/**
 * A062976 Half-totient function of n is divisible by the number of divisors of n.
 * @author Sean A. Irvine
 */
public class A062976 extends AbstractSequence {

  private final A023022 mSeq1 = new A023022();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;

  @Override
  public Z next() {
    while (true) {
      if (mSeq1.next().mod(Jaguar.factor(++mN).sigma0AsLong()) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A063535	1	->	0	A000040	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;
import irvine.oeis.a000.A000040;
import irvine.oeis.AbstractSequence;

/**
 * A063535 Primes prime(n) such that prime(n+1)^2 &lt; prime(n)*prime(n+2).
 * @author Sean A. Irvine
 */
public class A063535 extends AbstractSequence {

  private final A000040 mSeq1 = new A000040();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mP = mSeq1.next();
  private Z mQ = mSeq1.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mP;
      mP = mQ;
      mQ = mSeq1.next();
      if (mP.square().compareTo(t.multiply(mQ)) < 0) {
        return t;
      }
    }
  }
}
#!queue	A063689	0	->	1	A063687	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a058.A058870;
import irvine.oeis.AbstractSequence;

/**
 * A063689 Number of 2-trees rooted at a triangle with 3 similar edges.
 * @author Sean A. Irvine
 */
public class A063689 extends AbstractSequence {

  private final A063687 mSeq1 = new A063687();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;
  private final Sequence mXSeq = new A058870();

  @Override
  public Z next() {
    ++mN;
    return mSeq1.next().add(mN > 0 ? mXSeq.next() : Z.ZERO);
  }
}

#!queue	A063907	1	->	0	A045704	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;
import irvine.oeis.a045.A045704;
import irvine.oeis.AbstractSequence;

/**
 * A063907 Lesser of twin numbers (differing by 1) of the form F(i)^2 + F(j)^3 (A045704), where F() are Fibonacci numbers.
 * @author Sean A. Irvine
 */
public class A063907 extends AbstractSequence {

  private final A045704 mSeq1 = new A045704();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mA;
      mA = mSeq1.next();
      if (mA.subtract(t).equals(Z.ONE)) {
        return t;
      }
    }
  }
}
#!queue	A064064	1	->	0	A064002	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A064064 n-th step is to add a(n) to each previous number a(k) (including itself, i.e., k &lt;= n) to produce n+1 more terms of the sequence, starting with a(0)=1.
 * @author Sean A. Irvine
 */
public class A064064 extends AbstractSequence {

  private final A064002 mSeq1 = new A064002();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().add(1).divide2();
  }
}
#!queue	A064110	1	->	0	A007510	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;
import irvine.oeis.a007.A007510;
import irvine.oeis.AbstractSequence;

/**
 * A064110 Let s(n) = n-th single prime (cf. A007510). Sequence is defined by recurrence a(n+1) = s(a(n)), n = 0,1,2,..., a(0)=1.
 * @author Sean A. Irvine
 */
public class A064110 extends AbstractSequence {

  private final A007510 mSeq1 = new A007510();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mA = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (mA == 0) {
      mA = 1;
    } else {
      while (++mM < mA) {
        mSeq1.next();
      }
      mA = mSeq1.next().longValueExact();
    }
    return Z.valueOf(mA);
  }
}
#!queue	A064166	1	->	0	A002808	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.prime.Fast;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002808;
import irvine.oeis.AbstractSequence;

/**
 * A064166 Composite numbers the sum of the digits in the prime factors of which, with repetition, is prime.
 * @author Sean A. Irvine
 */
public class A064166 extends AbstractSequence {

  private final A002808 mSeq1 = new A002808();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    while (true) {
      final Z c = mSeq1.next();
      final FactorSequence fs = Jaguar.factor(c);
      long sum = 0;
      for (final Z p : fs.toZArray()) {
        sum += ZUtils.digitSum(p) * fs.getExponent(p);
      }
      if (mPrime.isPrime(sum)) {
        return c;
      }
    }
  }
}

#!queue	A064309	1	->	0	A064308	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A064309 Row sums of triangle A064308.
 * @author Sean A. Irvine
 */
public class A064309 extends AbstractSequence {

  private final A064308 mSeq1 = new A064308();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.add(mSeq1.next());
    }
    return sum;
  }
}
#!queue	A064369	0	->	1	A064284	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;
import irvine.util.array.DynamicLongArray;
import irvine.oeis.AbstractSequence;

/**
 * A064369 Smallest integer in Recam\u00e1n's sequence (A005132) to appear n times.
 * @author Sean A. Irvine
 */
public class A064369 extends AbstractSequence {

  private final A064284 mSeq1 = new A064284();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final DynamicLongArray mA = new DynamicLongArray();
  private long mM = -1;
  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ZERO;
    }
    while (mA.get(mN) == 0) {
      final int cnt = mSeq1.next().intValueExact();
      ++mM;
      if (mA.get(cnt) == 0) {
        mA.set(cnt, mM);
      }
    }
    return Z.valueOf(mA.get(mN));
  }
}

#!queue	A064447	0	->	1	A000312	--------------------------------
package irvine.oeis.a064;
// Generated by gen_seq4.pl knest/eulphi at 2023-03-01 20:54

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000312;
import irvine.oeis.AbstractSequence;

/**
 * A064447 a(n) = EulerPhi(n^n).
 * @author Georg Fischer
 */
public class A064447 extends AbstractSequence {

  private final A000312 mSeq1 = new A000312();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Euler.phi(mSeq1.next());
  }
}
#!queue	A064635	0	->	1	A064466	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A064635 Even numbers &gt; 6 not appearing in A064466. a(n) = A064466(A064634(n)) + 2 for n &gt; 0.
 * @author Sean A. Irvine
 */
public class A064635 extends AbstractSequence {

  private final A064466 mSeq1 = new A064466();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mA = mSeq1.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mA;
      mA = mSeq1.next();
      if (mA.subtract(t).compareTo(Z.TWO) > 0) {
        return t.add(2);
      }
    }
  }
}
#!queue	A067390	0	->	1	A062709	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a062.A062709;
import irvine.oeis.AbstractSequence;

/**
 * A067390 Number of distinct prime factors in 2^n + 3.
 * @author Georg Fischer
 */
public class A067390 extends AbstractSequence {

  private final A062709 mSeq1 = new A062709();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A068553	0	->	1	A048619	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a048.A048619;
import irvine.oeis.AbstractSequence;

/**
 * A068553 a(n) = lcm(1,2,...,2*n) / (n*binomial(2*n, n)).
 * @author Georg Fischer
 */
public class A068553 extends AbstractSequence {

  private final A048619 mSeq1 = new A048619();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    mSeq1.next();
    return mSeq1.next();
  }
}
#!queue	A068954	0	->	2	A007781	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007781;
import irvine.oeis.AbstractSequence;

/**
 * A068954 Smallest prime factor of n^n-(n-1)^(n-1).
 * @author Georg Fischer
 */
public class A068954 extends AbstractSequence {

  private final A007781 mSeq1 = new A007781();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).leastPrimeFactor();
  }
}
#!queue	A068955	0	->	2	A007781	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007781;
import irvine.oeis.AbstractSequence;

/**
 * A068955 Greatest prime factor of n^n - (n-1)^(n-1).
 * @author Georg Fischer
 */
public class A068955 extends AbstractSequence {

  private final A007781 mSeq1 = new A007781();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).largestPrimeFactor();
  }
}
#!queue	A068956	0	->	2	A007781	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007781;
import irvine.oeis.AbstractSequence;

/**
 * A068956 Number of distinct prime factors of n^n - (n-1)^(n-1).
 * @author Georg Fischer
 */
public class A068956 extends AbstractSequence {

  private final A007781 mSeq1 = new A007781();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A068957	0	->	2	A007781	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007781;
import irvine.oeis.AbstractSequence;

/**
 * A068957 Number of prime divisors of n^n - (n-1)^(n-1), counted with multiplicity.
 * @author Georg Fischer
 */
public class A068957 extends AbstractSequence {

  private final A007781 mSeq1 = new A007781();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).bigOmega());
  }
}
#!queue	A072670	1	->	0	A038548	--------------------------------
package irvine.oeis.a072;
// Generated by gen_seq4.pl dersimple at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a038.A038548;
import irvine.oeis.AbstractSequence;

/**
 * A072670 Number of ways to write n as i*j + i + j, 0 &lt; i &lt;= j.
 * @author Georg Fischer
 */
public class A072670 extends AbstractSequence {

  private final A038548 mSeq1 = new A038548();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(1);
  }
}
#!queue	A073219	0	->	1	A073211	--------------------------------
package irvine.oeis.a073;
// manually 2021-10-19

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A073219 The terms of A073211 (sums of two powers of 11) divided by 2.
 * @author Georg Fischer
 */
public class A073219 extends AbstractSequence {

  private final A073211 mSeq1 = new A073211();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A077020	0	->	3	A001607	--------------------------------
package irvine.oeis.a077;
// manually deris/essent at 2022-04-27 19:28

import irvine.math.z.Z;
import irvine.oeis.a001.A001607;
import irvine.oeis.AbstractSequence;

/**
 * A077020 a(n) is the unique odd positive solution x of 2^n = 7x^2+y^2.
 * @author Georg Fischer
 */
public class A077020 extends AbstractSequence {

  private final A001607 mSeq1 = new A001607();

  /** Construct the sequence. */
  public A077020() {
    super($(OFFSET));
    skip(1);
  }

  @Override
  public Z next() {
    return mSeq1.next().abs();
  }
}
#!queue	A081259	3	->	1	A151799	--------------------------------
package irvine.oeis.a081;
// manually n2/n3add1 at 2023-05-02 19:56

import irvine.math.z.Z;
import irvine.oeis.a151.A151799;
import irvine.oeis.AbstractSequence;

/**
 * A081259 a(n) is the smallest k such that C(3n,n) divides k!.
 * @author Georg Fischer
 */
public class A081259 extends AbstractSequence {

  private final A151799 mSeq1 = new A151799();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A084270	0	->	1	A047864	--------------------------------
package irvine.oeis.a084;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a047.A047864;
import irvine.oeis.AbstractSequence;

/**
 * A084270 Number of labeled 2-chromatic (i.e., chromatic number = 2) graphs on n nodes.
 * @author Georg Fischer
 */
public class A084270 extends AbstractSequence {

  private final A047864 mSeq1 = new A047864();

  /** Construct the sequence. */
  public A084270() {
    super($(OFFSET));
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(1);
  }
}
#!queue	A086221	0	->	1	A086652	--------------------------------
package irvine.oeis.a086;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A086221 Bisection of A086652.
 * @author Georg Fischer
 */
public class A086221 extends AbstractSequence {

  private final A086652 mSeq1 = new A086652();

  /** Construct the sequence. */
  public A086221() {
    super($(OFFSET));
    mSeq1.next();
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A093810	0	->	2	A036563	--------------------------------
package irvine.oeis.a093;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a036.A036563;
import irvine.oeis.AbstractSequence;

/**
 * A093810 Smallest prime factor of 2^n-3.
 * @author Georg Fischer
 */
public class A093810 extends AbstractSequence {

  private final A036563 mSeq1 = new A036563();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).leastPrimeFactor();
  }
}
#!queue	A097509	1	->	0	A006337	--------------------------------
package irvine.oeis.a097;
// manually knestm/knest at 2023-03-02 19:24

import irvine.math.z.Z;
import irvine.oeis.a006.A006337;
import irvine.oeis.AbstractSequence;

/**
 * A097509 a(n) is the number of times that n occurs as floor(k * sqrt(2)) - k.
 * @author Georg Fischer
 */
public class A097509 extends AbstractSequence {

  private final A006337 mSeq1 = new A006337();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;

  @Override
  public Z next() {
    return (++mN <= 0) ? Z.THREE : mSeq1.next().add(1);
  }
}
#!queue	A099057	1	->	0	A000396	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26

import irvine.math.z.Z;
import irvine.oeis.a000.A000396;
import irvine.oeis.AbstractSequence;

/**
 * A099057 A bisection of A000396.
 * @author Georg Fischer
 */
public class A099057 extends AbstractSequence {

  private final A000396 mSeq1 = new A000396();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A099058	1	->	0	A000396	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26

import irvine.math.z.Z;
import irvine.oeis.a000.A000396;
import irvine.oeis.AbstractSequence;

/**
 * A099058 A bisection of A000396.
 * @author Georg Fischer
 */
public class A099058 extends AbstractSequence {

  private final A000396 mSeq1 = new A000396();

  /** Construct the sequence. */
  public A099058() {
    super($(OFFSET));
    mSeq1.next();
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A102146	0	->	1	A002283	--------------------------------
package irvine.oeis.a102;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002283;
import irvine.oeis.AbstractSequence;

/**
 * A102146 a(n) = sigma(10^n - 1), where sigma(n) is the sum of positive divisors of n.
 * @author Georg Fischer
 */
public class A102146 extends AbstractSequence {

  private final A002283 mSeq1 = new A002283();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).sigma();
  }
}
#!queue	A102347	0	->	1	A002283	--------------------------------
package irvine.oeis.a102;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002283;
import irvine.oeis.AbstractSequence;

/**
 * A102347 Number of distinct prime factors of 10^n - 1.
 * @author Georg Fischer
 */
public class A102347 extends AbstractSequence {

  private final A002283 mSeq1 = new A002283();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A102360	0	->	1	A023000	--------------------------------
package irvine.oeis.a102;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a023.A023000;
import irvine.oeis.AbstractSequence;

/**
 * A102360 a(n) = sigma((7^n - 1)/6), where sigma(n) is the sum of positive divisors of n.
 * @author Georg Fischer
 */
public class A102360 extends AbstractSequence {

  private final A023000 mSeq1 = new A023000();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).sigma();
  }
}
#!queue	A103968	0	->	1	A023001	--------------------------------
package irvine.oeis.a103;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a023.A023001;
import irvine.oeis.AbstractSequence;

/**
 * A103968 Sigma((8^n - 1)/7), where sigma(n) is the sum of positive divisors of n.
 * @author Georg Fischer
 */
public class A103968 extends AbstractSequence {

  private final A023001 mSeq1 = new A023001();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).sigma();
  }
}
#!queue	A104411	0	->	3	A000078	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000078;
import irvine.oeis.AbstractSequence;

/**
 * A104411 Number of prime factors, with multiplicity, of the tetranacci numbers A000078.
 * @author Georg Fischer
 */
public class A104411 extends AbstractSequence {

  private final A000078 mSeq1 = new A000078();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).bigOmega());
  }
}
#!queue	A104412	0	->	4	A001591	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001591;
import irvine.oeis.AbstractSequence;

/**
 * A104412 Number of prime factors, with multiplicity, of the pentanacci numbers A001591.
 * @author Georg Fischer
 */
public class A104412 extends AbstractSequence {

  private final A001591 mSeq1 = new A001591();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    for (int i = 0; i < 4; ++i) {
      mSeq1.next();
    }
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).bigOmega());
  }
}
#!queue	A104413	0	->	5	A001592	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001592;
import irvine.oeis.AbstractSequence;

/**
 * A104413 Number of prime factors, with multiplicity, of the hexanacci numbers A001592.
 * @author Georg Fischer
 */
public class A104413 extends AbstractSequence {

  private final A001592 mSeq1 = new A001592();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    for (int i = 0; i < 5; ++i) {
      mSeq1.next();
    }
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).bigOmega());
  }
}
#!queue	A104415	0	->	1	A079262	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a079.A079262;
import irvine.oeis.AbstractSequence;

/**
 * A104415 Number of prime factors, with multiplicity, of the nonzero octanacci numbers A079262.
 * @author Georg Fischer
 */
public class A104415 extends AbstractSequence {

  private final A079262 mSeq1 = new A079262();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    for (int i = 0; i < 7; ++i) {
      mSeq1.next();
    }
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).bigOmega());
  }
}
#!queue	A104418	0	->	1	A104144	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A104418 Number of prime factors, with multiplicity, of the nonzero 9-acci numbers.
 * @author Georg Fischer
 */
public class A104418 extends AbstractSequence {

  private final A104144 mSeq1 = new A104144();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    for (int i = 0; i < 8; ++i) {
      mSeq1.next();
    }
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).bigOmega());
  }
}
#!queue	A104483	1	->	0	A173766	--------------------------------
package irvine.oeis.a104;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a173.A173766;
import irvine.oeis.AbstractSequence;

/**
 * A104483 Number of distinct prime divisors of 33...337 (with n 3s).
 * @author Georg Fischer
 */
public class A104483 extends AbstractSequence {

  private final A173766 mSeq1 = new A173766();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A104524	0	->	1	A178769	--------------------------------
package irvine.oeis.a104;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a178.A178769;
import irvine.oeis.AbstractSequence;

/**
 * A104524 Number of distinct prime divisors of 55...557 (with n 5s).
 * @author Georg Fischer
 */
public class A104524 extends AbstractSequence {

  private final A178769 mSeq1 = new A178769();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A105248	1	->	0	A173812	--------------------------------
package irvine.oeis.a105;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a173.A173812;
import irvine.oeis.AbstractSequence;

/**
 * A105248 Number of distinct prime divisors of 88...887 (with n 8's).
 * @author Georg Fischer
 */
public class A105248 extends AbstractSequence {

  private final A173812 mSeq1 = new A173812();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A105259	1	->	0	A170955	--------------------------------
package irvine.oeis.a105;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a170.A170955;
import irvine.oeis.AbstractSequence;

/**
 * A105259 Number of distinct prime divisors of 99..91 (with n 9's).
 * @author Georg Fischer
 */
public class A105259 extends AbstractSequence {

  private final A170955 mSeq1 = new A170955();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A105972	1	->	0	A173810	--------------------------------
package irvine.oeis.a105;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a173.A173810;
import irvine.oeis.AbstractSequence;

/**
 * A105972 Number of distinct prime divisors of 88...881 (with n 8's).
 * @author Georg Fischer
 */
public class A105972 extends AbstractSequence {

  private final A173810 mSeq1 = new A173810();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A105973	1	->	0	A173811	--------------------------------
package irvine.oeis.a105;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a173.A173811;
import irvine.oeis.AbstractSequence;

/**
 * A105973 Number of distinct prime divisors of 88...883 (with n 8's).
 * @author Georg Fischer
 */
public class A105973 extends AbstractSequence {

  private final A173811 mSeq1 = new A173811();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A107647	0	->	2	A000073	--------------------------------
package irvine.oeis.a107;
// manually knest/eulphi at 2023-03-01 16:41

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000073;
import irvine.oeis.AbstractSequence;

/**
 * A107647 Euler's totient function applied to tribonacci numbers.
 * @author Georg Fischer
 */
public class A107647 extends AbstractSequence {

  private final A000073 mSeq1 = new A000073();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Euler.phi(mSeq1.next());
  }
}
#!queue	A108572	0	->	1	A018783	--------------------------------
package irvine.oeis.a108;
// manually knestm/knest at 2023-03-02 16:06

import irvine.math.z.Z;
import irvine.oeis.a018.A018783;
import irvine.oeis.AbstractSequence;

/**
 * A108572 Number of partitions of n which, as multisets, are nontrivial repetitions of a multiset.
 * @author Georg Fischer
 */
public class A108572 extends AbstractSequence {

  private final A018783 mSeq1 = new A018783();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    final Z t = mSeq1.next().subtract(1);
    return (++mN == 1) ? Z.ZERO : t;
  }
}
#!queue	A109607	2	->	0	A023896	--------------------------------
package irvine.oeis.a109;
// manually dersimple at 2021-08-25 19:44

import irvine.math.z.Z;
import irvine.oeis.a023.A023896;
import irvine.oeis.AbstractSequence;

/**
 * A109607 Sum of coprimes of n greater than 1.
 * @author Georg Fischer
 */
public class A109607 extends AbstractSequence {

  private final A023896 mSeq1 = new A023896();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return mN <= 1 ? Z.ZERO : mSeq1.next().subtract(1);
  }
}
#!queue	A112362	0	->	2	A006967	--------------------------------
package irvine.oeis.a112;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a006.A006967;
import irvine.oeis.AbstractSequence;

/**
 * A112362 A006967(n)/2.
 * @author Georg Fischer
 */
public class A112362 extends AbstractSequence {

  private final A006967 mSeq1 = new A006967();

  /** Construct the sequence. */
  public A112362() {
    super($(OFFSET));
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A115794	1	->	0	A115793	--------------------------------
package irvine.oeis.a115;
// Generated by gen_seq4.pl inbase2 at 2022-04-08 22:28

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A115794 Sequence A115793 in binary.
 * @author Georg Fischer
 */
public class A115794 extends AbstractSequence {

  private final A115793 mSeq1 = new A115793();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return new Z(mSeq1.next().toString(2));
  }
}
#!queue	A115820	1	->	0	A115819	--------------------------------
package irvine.oeis.a115;
// Generated by gen_seq4.pl inbase2 at 2022-04-08 22:28

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A115820 Sequence A115819 in binary.
 * @author Georg Fischer
 */
public class A115820 extends AbstractSequence {

  private final A115819 mSeq1 = new A115819();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return new Z(mSeq1.next().toString(2));
  }
}
#!queue	A125811	1	->	0	A023536	--------------------------------
package irvine.oeis.a125;
// manually dersimple at 2021-08-25 19:44

import irvine.math.z.Z;
import irvine.oeis.a023.A023536;
import irvine.oeis.AbstractSequence;

/**
 * A125811 Number of coefficients in the n-th q-Bell number as a polynomial in q.
 * @author Georg Fischer
 */
public class A125811 extends AbstractSequence {

  private final A023536 mSeq1 = new A023536();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return mN <= 3 ? Z.ONE : mSeq1.next().add(1);
  }
}
#!queue	A128897	0	->	1	A083062	--------------------------------
package irvine.oeis.a128;
// Generated by gen_seq4.pl n2/n2sub1 at 2023-05-02 19:56

import irvine.math.z.Z;
import irvine.oeis.a083.A083062;
import irvine.oeis.AbstractSequence;

/**
 * A128897 a(n) = ((2n)^(2n-1)+1)/(2n+1).
 * @author Georg Fischer
 */
public class A128897 extends AbstractSequence {

  private final A083062 mSeq1 = new A083062();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    mSeq1.next();
    return mSeq1.next();
  }
}
#!queue	A131621	0	->	1	A000129	--------------------------------
package irvine.oeis.a131;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000129;
import irvine.oeis.AbstractSequence;

/**
 * A131621 Sum of all n-digit Pell numbers.
 * @author Georg Fischer
 */
public class A131621 extends AbstractSequence {

  private final A000129 mSeq1 = new A000129();

  protected Z mPell; // next Pell number
  protected Z mSum; // current sum
  protected Z mPow10; // least power of 10 > Pell number

  /** Construct the sequence. */
  public A131621() {
    super($(OFFSET));
    mPell = mSeq1.next();
    mSum = Z.ZERO;
    mPow10 = Z.TEN;
  }

  @Override
  public Z next() {
    while (mPell.compareTo(mPow10) < 0) {
      mSum = mSum.add(mPell);
      mPell = mSeq1.next();
    }
    final Z result = mSum;
    mSum = Z.ZERO;
    mPow10 = mPow10.multiply(Z.TEN);
    return result;
  }
}
#!queue	A144448	3	->	1	A061039	--------------------------------
package irvine.oeis.a144;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26

import irvine.math.z.Z;
import irvine.oeis.a061.A061039;
import irvine.oeis.AbstractSequence;

/**
 * A144448 First bisection of A061039.
 * @author Georg Fischer
 */
public class A144448 extends AbstractSequence {

  private final A061039 mSeq1 = new A061039();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A144450	3	->	1	A061039	--------------------------------
package irvine.oeis.a144;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26

import irvine.math.z.Z;
import irvine.oeis.a061.A061039;
import irvine.oeis.AbstractSequence;

/**
 * A144450 Second bisection of A061039.
 * @author Georg Fischer
 */
public class A144450 extends AbstractSequence {

  private final A061039 mSeq1 = new A061039();

  /** Construct the sequence. */
  public A144450() {
    super($(OFFSET));
    mSeq1.next();
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A145909	3	->	0	A061039	--------------------------------
package irvine.oeis.a145;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061039;
import irvine.oeis.AbstractSequence;

/**
 * A145909 First 6-fold decimation of A061039. First bisection of A144454.
 * @author Georg Fischer
 */
public class A145909 extends AbstractSequence {

  private final A061039 mSeq1 = new A061039();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A145911	3	->	0	A145909	--------------------------------
package irvine.oeis.a145;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A145911 a(n) = A145909(n)/8.
 * @author Georg Fischer
 */
public class A145911 extends AbstractSequence {

  private final A145909 mSeq1 = new A145909();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide(8);
  }
}
#!queue	A146539	1	->	0	A061045	--------------------------------
package irvine.oeis.a146;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061045;
import irvine.oeis.AbstractSequence;

/**
 * A146539 A061045 mod 9.
 * @author Georg Fischer
 */
public class A146539 extends AbstractSequence {

  private final A061045 mSeq1 = new A061045();

  /** Construct the sequence. */
  public A146539() {
    super($(OFFSET));
    for (int i = 1; i <= 5; ++i) {
      mSeq1.next();
    }
  }

  @Override
  public Z next() {
    return mSeq1.next().mod(Z.NINE);
  }

}
#!queue	A146975	5	->	0	A061043	--------------------------------
package irvine.oeis.a146;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061043;
import irvine.oeis.AbstractSequence;

/**
 * A146975 First quintisection of A061043: A061043(5n).
 * @author Georg Fischer
 */
public class A146975 extends AbstractSequence {

  private final A061043 mSeq1 = new A061043();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A147650	3	->	1	A061040	--------------------------------
package irvine.oeis.a147;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061040;
import irvine.oeis.AbstractSequence;

/**
 * A147650 First trisection of A061040.
 * @author Georg Fischer
 */
public class A147650 extends AbstractSequence {

  private final A061040 mSeq1 = new A061040();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A147661	0	->	1	A000312	--------------------------------
package irvine.oeis.a147;
// manually knest at 2023-06-02 20:44

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000312;
import irvine.oeis.AbstractSequence;

/**
 * A147661 a(n) = squarefree part of n^n.
 * @author Georg Fischer
 */
public class A147661 extends AbstractSequence {

  private final A000312 mSeq1 = new A000312();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).core();
  }
}
#!queue	A147792	4	->	0	A061042	--------------------------------
package irvine.oeis.a147;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061042;
import irvine.oeis.AbstractSequence;

/**
 * A147792 A quadrisection of A061042.
 * @author Georg Fischer
 */
public class A147792 extends AbstractSequence {

  private final A061042 mSeq1 = new A061042();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A158270	8	->	1	A061049	--------------------------------
package irvine.oeis.a158;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061049;
import irvine.oeis.AbstractSequence;

/**
 * A158270 Single-digit numbers in A061049.
 * @author Georg Fischer
 */
public class A158270 extends AbstractSequence {

  private final A061049 mSeq1 = new A061049();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z term = mSeq1.next();
      if (term.compareTo(Z.TEN) < 0) {
        return term;
      }
    }
  }
}
#!queue	A158273	8	->	1	A061049	--------------------------------
package irvine.oeis.a158;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061049;
import irvine.oeis.AbstractSequence;

/**
 * A158273 Indices of single-digit numbers in A061049.
 * @author Georg Fischer
 */
public class A158273 extends AbstractSequence {

  private final A061049 mSeq1 = new A061049();

  private int mN;

  /** Construct the sequence. */
  public A158273() {
    super($(OFFSET));
    mN = 7;
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (mSeq1.next().compareTo(Z.TEN) < 0) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A158280	1	->	0	A145511	--------------------------------
package irvine.oeis.a158;

import irvine.math.z.Z;
import irvine.oeis.a145.A145511;
import irvine.oeis.AbstractSequence;

/**
 * A158280 Octosection: A145511(8n+4) or A145501(8n+4).
 * @author Georg Fischer
 */
public class A158280 extends AbstractSequence {

  private final A145511 mSeq1 = new A145511();

  /** Construct the sequence. */
  public A158280() {
  super($(OFFSET));
    }

  @Override
  public Z next() {
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    final Z result = mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A158315	1	->	0	A158280	--------------------------------
package irvine.oeis.a158;
// Generated by gen_seq4.pl dersimple at 2022-12-15 23:30

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A158315 A158280(n)/7.
 * @author Georg Fischer
 */
public class A158315 extends AbstractSequence {

  private final A158280 mSeq1 = new A158280();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide(7);
  }
}
#!queue	A158650	4	->	1	A061041	--------------------------------
package irvine.oeis.a158;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061041;
import irvine.oeis.AbstractSequence;

/**
 * A158650 Indices of single-digit numbers in A061041.
 * @author Georg Fischer
 */
public class A158650 extends AbstractSequence {

  private final A061041 mSeq1 = new A061041();

  private int mN;

  /** Construct the sequence. */
  public A158650() {
    super($(OFFSET));
    mN = 3;
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (mSeq1.next().compareTo(Z.TEN) < 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A158907	0	->	1	A032741	--------------------------------
package irvine.oeis.a158;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a032.A032741;
import irvine.oeis.AbstractSequence;

/**
 * A158907 Row sums of triangle A158906.
 * @author Georg Fischer
 */
public class A158907 extends AbstractSequence {

  private final A032741 mSeq1 = new A032741();

  protected int mN;

  /** Construct the sequence. */
  public A158907() {
    super($(OFFSET));
    mN = 0;
    mSeq1.next();
  }

  @Override
  public Z next() {
    ++mN;
    return mSeq1.next().add(mN);
  }
}
#!queue	A160797	0	->	1	A160796	--------------------------------
package irvine.oeis.a160;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A160797 First differences of A160796.
 * @author Sean A. Irvine
 */
public class A160797 extends AbstractSequence {

  private final A160796 mSeq1 = new A160796();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z mPrev = mSeq1.next();

  @Override
  public Z next() {
    final Z t = mSeq1.next();
    final Z r = t.subtract(mPrev);
    mPrev = t;
    return r;
  }
}

#!queue	A161116	1	->	0	A070824	--------------------------------
package irvine.oeis.a161;
// manually n2 at 2023-05-02 19:36

import irvine.math.z.Z;
import irvine.oeis.a070.A070824;
import irvine.oeis.AbstractSequence;

/**
 * A161116 a(n) is the number of nontrivial positive divisors of 2n+3.
 * @author Georg Fischer
 */
public class A161116 extends AbstractSequence {

  private final A070824 mSeq1 = new A070824();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    mSeq1.next();
    return mSeq1.next();
  }
}
#!queue	A174621	0	->	2	A046145	--------------------------------
package irvine.oeis.a174;
// manually deris/essent at 2022-04-28 12:39

import irvine.math.z.Z;
import irvine.oeis.a046.A046145;
import irvine.oeis.AbstractSequence;

/**
 * A174621 a(n) is the smallest generator for the group of numbers relatively prime to n under multiplication mod n; a(n) = -1 if n is not a power of a prime or twice a power of a prime.
 * @author Georg Fischer
 */
public class A174621 extends AbstractSequence {

  private final A046145 mSeq1 = new A046145();

  /** Construct the sequence. */
  public A174621() {
    super($(OFFSET));
    skip(2);
  }

  @Override
  public Z next() {
    final Z t = mSeq1.next();
    return t.isZero() ? Z.NEG_ONE : t;
  }
}
#!queue	A178925	0	->	1	A000088	--------------------------------
package irvine.oeis.a178;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000088;
import irvine.oeis.a006.A006608;
import irvine.oeis.AbstractSequence;

/**
 * A178925 Number of n-node simple graphs that are determined by spectrum.
 * @author Sean A. Irvine
 */
public class A178925 extends AbstractSequence {

  private final A000088 mSeq1 = new A000088();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA = new A006608();
  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().subtract(mA.next());
  }
}

#!queue	A178978	3	->	0	A144448	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a144.A144448;
import irvine.oeis.AbstractSequence;

/**
 * A178978 a(n) = A144448(n+1)/8.
 * @author Georg Fischer
 */
public class A178978 extends AbstractSequence {

  private final A144448 mSeq1 = new A144448();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return mSeq1.next().divide(8);
  }
}
#!queue	A181572	0	->	1	A104745	--------------------------------
package irvine.oeis.a181;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a104.A104745;
import irvine.oeis.AbstractSequence;

/**
 * A181572 Number of distinct prime divisors of 5^n + n.
 * @author Georg Fischer
 */
public class A181572 extends AbstractSequence {

  private final A104745 mSeq1 = new A104745();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A185026	3	->	1	A002616	--------------------------------
package irvine.oeis.a185;
// Generated by gen_seq4.pl n2 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a002.A002616;
import irvine.oeis.AbstractSequence;

/**
 * A185026 The first bisection of the sequence A002616 of reduced totients.
 * @author Georg Fischer
 */
public class A185026 extends AbstractSequence {

  private final A002616 mSeq1 = new A002616();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A185828	0	->	1	A100886	--------------------------------
package irvine.oeis.a185;
// Generated by gen_seq4.pl n2/n2add1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a100.A100886;
import irvine.oeis.AbstractSequence;

/**
 * A185828 Half the number of n X 2 binary arrays with every element equal to exactly one or two of its horizontal and vertical neighbors.
 * @author Georg Fischer
 */
public class A185828 extends AbstractSequence {

  private final A100886 mSeq1 = new A100886();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    mSeq1.next();
    return mSeq1.next();
  }
}
#!queue	A190839	0	->	1	A066138	--------------------------------
package irvine.oeis.a190;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a066.A066138;
import irvine.oeis.AbstractSequence;

/**
 * A190839 a(n) is the maximal prime divisor of 10^(2*n)+10^n+1.
 * @author Georg Fischer
 */
public class A190839 extends AbstractSequence {

  private final A066138 mSeq1 = new A066138();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).largestPrimeFactor();
  }
}
#!queue	A213594	0	->	1	A048784	--------------------------------
package irvine.oeis.a213;
// manually valuation/valuat at 2022-03-16 13:50

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a048.A048784;
import irvine.oeis.AbstractSequence;

/**
 * A213594 Greatest number k such that A048784(n) / 2^k is an integer.
 * @author Georg Fischer
 */
public class A213594 extends AbstractSequence {

  private final A048784 mSeq1 = new A048784();

  /** Construct the sequence. */
  public A213594() {
    super($(OFFSET));
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(mSeq1.next(), Z.TWO));
  }
}
#!queue	A213595	0	->	1	A048784	--------------------------------
package irvine.oeis.a213;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a048.A048784;
import irvine.oeis.AbstractSequence;

/**
 * A213595 A048784(n) / 2^A213594(n).
 * @author Georg Fischer
 */
public class A213595 extends AbstractSequence {

  private final A048784 mSeq1 = new A048784();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mSeq = new A213594();

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide(Z.ONE.shiftLeft(mSeq.next().longValue()));
  }
}
#!queue	A227838	0	->	1	A005132	--------------------------------
package irvine.oeis.a227;
// manually valuation/valuat at 2022-03-16 18:05

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a005.A005132;
import irvine.oeis.AbstractSequence;

/**
 * A227838 2^a(n) is the highest power of 2 dividing A005132(n).
 * @author Georg Fischer
 */
public class A227838 extends AbstractSequence {

  private final A005132 mSeq1 = new A005132();

  /** Construct the sequence. */
  public A227838() {
    super($(OFFSET));
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(mSeq1.next(), Z.TWO));
  }
}
#!queue	A227839	0	->	1	A005132	--------------------------------
package irvine.oeis.a227;
// manually valuation/valuat at 2022-03-16 18:05

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a005.A005132;
import irvine.oeis.AbstractSequence;

/**
 * A227839 3^a(n) is the highest power of 3 dividing A005132(n).
 * @author Georg Fischer
 */
public class A227839 extends AbstractSequence {

  private final A005132 mSeq1 = new A005132();

  /** Construct the sequence. */
  public A227839() {
    super($(OFFSET));
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(mSeq1.next(), Z.THREE));
  }
}
#!queue	A229747	1	->	0	A207262	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a207.A207262;
import irvine.oeis.AbstractSequence;

/**
 * A229747 Largest prime factor of 4^(2*n+1)+1.
 * @author Georg Fischer
 */
public class A229747 extends AbstractSequence {

  private final A207262 mSeq1 = new A207262();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).largestPrimeFactor();
  }
}
#!queue	A246556	0	->	2	A000129	--------------------------------
package irvine.oeis.a246;

import java.util.Arrays;
import java.util.HashSet;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000129;
import irvine.oeis.AbstractSequence;

/**
 * A246556 a(n) = smallest prime which divides Pell(n) = A000129(n) but does not divide any Pell(k) for k&lt;n, or -1 if no such prime exists.
 * @author Sean A. Irvine
 */
public class A246556 extends AbstractSequence {

  private final A000129 mSeq1 = new A000129();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final HashSet<Z> mPrimitives = new HashSet<>();
  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    final Z[] factors = Jaguar.factor(mSeq1.next()).toZArray();
    for (final Z p : factors) {
      if (!mPrimitives.contains(p)) {
        mPrimitives.addAll(Arrays.asList(factors));
        return p;
      }
    }
    return Z.NEG_ONE;
  }
}
#!queue	A250292	0	->	1	A000129	--------------------------------
package irvine.oeis.a250;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a000.A000129;
import irvine.oeis.AbstractSequence;

/**
 * A250292 Numbers k such that Pell(k) is a semiprime.
 * @author Sean A. Irvine
 */
public class A250292 extends AbstractSequence {

  private final A000129 mSeq1 = new A000129();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;
  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final FactorSequence fs = Jaguar.factorAllowIncomplete(mSeq1.next());
      final int semi = fs.isSemiprime();
      if (semi == FactorSequence.YES) {
        return Z.valueOf(mN);
      } else if (semi == FactorSequence.UNKNOWN) {
        throw new UnsupportedOperationException("Unknown status, Pell(" + mN + ")=" + fs);
      }
    }
  }
}
#!queue	A253254	0	->	2	A051682	--------------------------------
package irvine.oeis.a253;
// manually knest/jaguar at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a051.A051682;
import irvine.oeis.AbstractSequence;

/**
 * A253254 Largest prime factor of the n-th 11-gonal number.
 * @author Georg Fischer
 */
public class A253254 extends AbstractSequence {

  private final A051682 mSeq1 = new A051682();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).largestPrimeFactor();
  }
}
#!queue	A254046	0	->	1	A087289	--------------------------------
package irvine.oeis.a254;
// Generated by gen_seq4.pl valuation/valuat at 2022-03-17 22:13

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a087.A087289;
import irvine.oeis.AbstractSequence;

/**
 * A254046 Column index of n in A191450: a(3n) = 1, a(3n+1) = 1, a(3n+2) = 1 + a(n+1).
 * @author Georg Fischer
 */
public class A254046 extends AbstractSequence {

  private final A087289 mSeq1 = new A087289();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(mSeq1.next(), Z.THREE));
  }
}
#!queue	A255832	0	->	1	A255852	--------------------------------
package irvine.oeis.a255;
// Generated by gen_seq4.pl n2/n2add1 at 2022-10-25 22:41

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A255832 Least m &gt; 0 such that gcd(m^(2n+1)+2, (m+1)^(2n+1)+2) &gt; 1.
 * @author Georg Fischer
 */
public class A255832 extends AbstractSequence {

  private final A255852 mSeq1 = new A255852();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    next();
  }

  @Override
  public Z next() {
    mSeq1.next();
    return mSeq1.next();
  }
}
#!queue	A256970	0	->	1	A053755	--------------------------------
package irvine.oeis.a256;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a053.A053755;
import irvine.oeis.AbstractSequence;

/**
 * A256970 Smallest prime divisor of 4*n^2+1.
 * @author Georg Fischer
 */
public class A256970 extends AbstractSequence {

  private final A053755 mSeq1 = new A053755();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).leastPrimeFactor();
  }
}
#!queue	A259362	0	->	1	A253641	--------------------------------
package irvine.oeis.a259;
// manually sigman0/sigma0 at 2023-02-28 16:08

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a253.A253641;
import irvine.oeis.AbstractSequence;

/**
 * A259362 a(1) = 1, for n &gt; 1: a(n) is the number of ways to write n as a nontrivial perfect power.
 * @author Georg Fischer
 */
public class A259362 extends AbstractSequence {

  private final A253641 mSeq1 = new A253641();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    ++mN;
    final Z result = Jaguar.factor(mSeq1.next()).sigma0().subtract(1);
    return (mN == 1) ? Z.ONE : result;
  }
}
#!queue	A259368	0	->	1	A000312	--------------------------------
package irvine.oeis.a259;
// Generated by gen_seq4.pl knest at 2023-03-02 20:46

import irvine.math.z.Z;
import irvine.oeis.a000.A000312;
import irvine.oeis.AbstractSequence;

/**
 * A259368 Number of digits in n^n when written in binary.
 * @author Georg Fischer
 */
public class A259368 extends AbstractSequence {

  private final A000312 mSeq1 = new A000312();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mSeq1.next().bitLength());
  }
}
#!queue	A260669	0	->	1	A054440	--------------------------------
package irvine.oeis.a260;
// manually dersimple at 2022-12-15 22:48

import irvine.math.z.Z;
import irvine.oeis.a054.A054440;
import irvine.oeis.AbstractSequence;

/**
 * A260669 Number of unordered pairs of partitions of n with no common parts.
 * @author Georg Fischer
 */
public class A260669 extends AbstractSequence {

  private final A054440 mSeq1 = new A054440();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return mSeq1.next().divide2();
  }
}
#!queue	A264137	0	->	2	A000129	--------------------------------
package irvine.oeis.a264;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000129;
import irvine.oeis.AbstractSequence;

/**
 * A264137 Largest prime factor of the n-th Pell number, A000129(n).
 * @author Georg Fischer
 */
public class A264137 extends AbstractSequence {

  private final A000129 mSeq1 = new A000129();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).largestPrimeFactor();
  }
}
#!queue	A271319	0	->	2	A060354	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a060.A060354;
import irvine.oeis.AbstractSequence;

/**
 * A271319 Number of distinct prime factors of the n-th n-gonal number (A060354).
 * @author Georg Fischer
 */
public class A271319 extends AbstractSequence {

  private final A060354 mSeq1 = new A060354();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).omega());
  }
}
#!queue	A271320	0	->	2	A060354	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a060.A060354;
import irvine.oeis.AbstractSequence;

/**
 * A271320 Number of prime factors, with multiplicity, of the n-th n-gonal number (A060354).
 * @author Georg Fischer
 */
public class A271320 extends AbstractSequence {

  private final A060354 mSeq1 = new A060354();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(mSeq1.next()).bigOmega());
  }
}
#!queue	A271321	0	->	2	A060354	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a060.A060354;
import irvine.oeis.AbstractSequence;

/**
 * A271321 Smallest prime factor of the n-th n-gonal number (A060354).
 * @author Georg Fischer
 */
public class A271321 extends AbstractSequence {

  private final A060354 mSeq1 = new A060354();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).leastPrimeFactor();
  }
}
#!queue	A271322	0	->	2	A060354	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a060.A060354;
import irvine.oeis.AbstractSequence;

/**
 * A271322 Largest prime factor of the n-th n-gonal number (A060354).
 * @author Georg Fischer
 */
public class A271322 extends AbstractSequence {

  private final A060354 mSeq1 = new A060354();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).largestPrimeFactor();
  }
}
#!queue	A272040	0	->	1	A000129	--------------------------------
package irvine.oeis.a272;
// manually knest/eulphi at 2023-03-01 16:41

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000129;
import irvine.oeis.AbstractSequence;

/**
 * A272040 a(n) = A000010(A000129(n)).
 * @author Georg Fischer
 */
public class A272040 extends AbstractSequence {

  private final A000129 mSeq1 = new A000129();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Euler.phi(mSeq1.next());
  }
}
#!queue	A280101	1	->	0	A139041	--------------------------------
package irvine.oeis.a280;
// manually sigman1/sigma1 at 2023-02-28 22:58

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a139.A139041;
import irvine.oeis.AbstractSequence;

/**
 * A280101 a(n) = sigma(sigma(p(n)) = sum of the divisors of the sum of the divisors of number of partitions of n.
 * @author Georg Fischer
 */
public class A280101 extends AbstractSequence {

  private final A139041 mSeq1 = new A139041();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  public Z next() {
    return (++mN == 1) ? Z.ONE : Jaguar.factor(mSeq1.next()).sigma();
  }
}
#!queue	A283156	2	->	1	A048138	--------------------------------
package irvine.oeis.a283;
// Generated by gen_seq4.pl n2 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a048.A048138;
import irvine.oeis.AbstractSequence;

/**
 * A283156 Number of preimages of even integers under the sum-of-proper-divisors function.
 * @author Georg Fischer
 */
public class A283156 extends AbstractSequence {

  private final A048138 mSeq1 = new A048138();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A294614	0	->	1	A017653	--------------------------------
package irvine.oeis.a294;
// manually sigman1/sigma1 at 2023-02-28 22:58

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a017.A017653;
import irvine.oeis.AbstractSequence;

/**
 * A294614 Sum of the divisors of 12*n - 1, divided by 12, minus n.
 * @author Georg Fischer
 */
public class A294614 extends AbstractSequence {

  private final A017653 mSeq1 = new A017653();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(mSeq1.next()).sigma().divide(12).subtract(++mN);
  }
}
#!queue	A295503	0	->	1	A002283	--------------------------------
package irvine.oeis.a295;
// manually knest/eulphi at 2023-03-01 16:41

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a002.A002283;
import irvine.oeis.AbstractSequence;

/**
 * A295503 a(n) = phi(10^n-1), where phi is Euler's totient function (A000010).
 * @author Georg Fischer
 */
public class A295503 extends AbstractSequence {

  private final A002283 mSeq1 = new A002283();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  {
    mSeq1.next();
  }

  @Override
  public Z next() {
    return Euler.phi(mSeq1.next());
  }
}
#!queue	A333681	1	->	0	A000519	--------------------------------
package irvine.oeis.a333;
// manually dersimple at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a000.A000519;
import irvine.oeis.AbstractSequence;

/**
 * A333681 Number of non-isomorphic n X n binary matrices with all row and column sums equal up to permutation of rows and columns.
 * @author Georg Fischer
 */
public class A333681 extends AbstractSequence {

  private final A000519 mSeq1 = new A000519();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return mN <= 1 ? Z.ONE : mSeq1.next().add(1);
  }
}
#!queue	A345444	1	->	0	A344005	--------------------------------
package irvine.oeis.a345;
// manually n2/n2add1 at 2023-05-02 19:56

import irvine.math.z.Z;
import irvine.oeis.a344.A344005;
import irvine.oeis.AbstractSequence;

/**
 * A345444 a(n) = A344005(2*n+1).
 * @author Georg Fischer
 */
public class A345444 extends AbstractSequence {

  private final A344005 mSeq1 = new A344005();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    final Z result = mSeq1.next();
    mSeq1.next();
    return result;
  }
}
#!queue	A354542	2	->	1	A354543	--------------------------------
package irvine.oeis.a354;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A354542 Primes in A354543.
 * @author Georg Fischer
 */
public class A354542 extends AbstractSequence {

  private final A354543 mSeq1 = new A354543();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    while (true) {
      final Z result = mSeq1.next();
      if (result.isProbablePrime()) {
        return result;
      }
    }
  }
}
#!queue	A999999	0	0	0	0
