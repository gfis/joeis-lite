#!queue	A000094	0	->	1	A000041	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000094 Number of trees of diameter 4.
 * @author Sean A. Irvine
 */
public class A000094 extends A000041 {

  @Override
  public Z next() {
    final Z z = super.next().add(-mN);
    return mN == 0 ? Z.ZERO : z;
  }
}

#!queue	A000181	3	->	4	A000159	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000181 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A000181 extends A000159 {

  private int mA181 = 3;

  @Override
  public Z next() {
    return menageHitPolynomial(++mA181).coeff(4);
  }
}
#!queue	A000184	0	->	2	A029887	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a029.A029887;

/**
 * A000184 Number of genus 0 rooted maps with 3 faces with n vertices.
 * @author Sean A. Irvine
 */
public class A000184 extends A029887 {

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}

#!queue	A000185	3	->	5	A000159	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000185 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A000185 extends A000159 {

  private int mA185 = 4;

  @Override
  public Z next() {
    return menageHitPolynomial(++mA185).coeff(5);
  }
}
#!queue	A000187	1	->	0	A000233	--------------------------------
package irvine.oeis.a000;

/**
 * A000187 Generalized Euler numbers, c(5,n).
 * @author Sean A. Irvine
 */
public class A000187 extends A000233 {

  @Override
  protected int getA() {
    return 5;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A000191	1	->	0	A000061	--------------------------------
package irvine.oeis.a000;

/**
 * A000191 Generalized tangent numbers d(3, n).
 * @author Sean A. Irvine
 */
public class A000191 extends A000061 {

  @Override
  protected int getA() {
    return 3;
  }

  @Override
  protected int getN() {
    return ++mT;
  }
}
#!queue	A000192	1	->	0	A000233	--------------------------------
package irvine.oeis.a000;

/**
 * A000192 Generalized Euler numbers c(6,n).
 * @author Sean A. Irvine
 */
public class A000192 extends A000233 {

  @Override
  protected int getA() {
    return 6;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A000199	0	->	1	A000025	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000199 Coefficient of q^(2n-1) in the series expansion of Ramanujan's mock theta function f(q).
 * @author Sean A. Irvine
 */
public class A000199 extends A000025 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A000239	0	->	1	A000130	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000239 One-half of number of permutations of [n] with exactly one run of adjacent symbols differing by 1.
 * @author Sean A. Irvine
 */
public class A000239 extends A000130 {

  /** Construct the sequence. */
  public A000239() {
    super.next();
  }

  private Z mS = Z.ZERO;

  @Override
  public Z next() {
    mS = mS.add(super.next());
    return mS.max(Z.ONE);
  }
}
#!queue	A000250	0	->	1	A000666	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000250 Number of symmetric reflexive relations on n nodes: (1/2)*A000666.
 * @author Sean A. Irvine
 */
public class A000250 extends A000666 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A000281	1	->	0	A000233	--------------------------------
package irvine.oeis.a000;

/**
 * A000281 Expansion of cos(x)/cos(2x).
 * @author Sean A. Irvine
 */
public class A000281 extends A000233 {

  @Override
  protected int getA() {
    return 2;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A000363	0	->	4	A008971	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a008.A008971;

/**
 * A000363 Number of permutations of [n] with exactly 2 increasing runs of length at least 2.
 * @author Sean A. Irvine
 */
public class A000363 extends A008971 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}

#!queue	A000373	0	->	1	A000275	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A000373 Conjectured dimension of a module associated with the free commutative Moufang loop with n generators.
 * @author Sean A. Irvine
 */
public class A000373 extends A000275 {

  {
    super.next();
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  private Z a(final int n) {
    return n == 1 ? Z.ZERO : mA.get(n);
  }

  @Override
  public Z next() {
    super.next();
    Z sum = Z.ZERO;
    final Z nf = mF.factorial(mN);
    for (int k = 1; k <= (mN - 1) / 2; ++k) {
      final Z f2k = mF.factorial(2 * k + 1);
      for (int p = 0; p <= mN - 2 * k - 1; ++p) {
        sum = sum.add(a(k).add(Binomial.binomial(p + k - 1, k - 1))
                      .multiply(nf)
                      .divide(mF.factorial(p))
                      .divide(f2k)
                      .divide(mF.factorial(mN - p - 2 * k - 1)));
      }
    }
    return sum;
  }
}
#!queue	A000401	0	->	1	A000394	--------------------------------
package irvine.oeis.a000;

/**
 * A000401 Numbers of form x^2 + y^2 + 2z^2.
 * @author Sean A. Irvine
 */
public class A000401 extends A000394 {

  @Override
  protected int multiplier() {
    return 2;
  }
}

#!queue	A000425	3	->	1	A000159	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000425 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A000425 extends A000159 {

  private int mA425 = 0;

  @Override
  public Z next() {
    return menageHitPolynomial(++mA425).coeff(1);
  }
}
#!queue	A000436	1	->	0	A000233	--------------------------------
package irvine.oeis.a000;

/**
 * A000436 Generalized Euler numbers c(3,n).
 * @author Sean A. Irvine
 */
public class A000436 extends A000233 {

  @Override
  protected int getA() {
    return 3;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A000440	3	->	4	A000380	--------------------------------
package irvine.oeis.a000;

/**
 * A000440 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-4 places.
 * @author Sean A. Irvine
 */
public class A000440 extends A000380 {

  @Override
  protected int coeff() {
    return 4;
  }
}
#!queue	A000464	1	->	0	A000061	--------------------------------
package irvine.oeis.a000;

/**
 * A000464 Expansion of sin x /cos 2x.
 * @author Sean A. Irvine
 */
public class A000464 extends A000061 {

  @Override
  protected int getA() {
    return 2;
  }

  @Override
  protected int getN() {
    return ++mT;
  }
}
#!queue	A000470	3	->	5	A000380	--------------------------------
package irvine.oeis.a000;

/**
 * A000470 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-5 places.
 * @author Sean A. Irvine
 */
public class A000470 extends A000380 {

  @Override
  protected int coeff() {
    return 5;
  }
}
#!queue	A000479	1	->	0	A000315	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000479 Number of 1-factorizations of K_{n,n}.
 * @author Sean A. Irvine
 */
public class A000479 extends A000315 {

  private int mN = -1;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    if (mN > 2) {
      mF = mF.multiply(mN - 1);
    }
    return super.next().multiply(mF);
  }
}
#!queue	A000486	0	->	5	A060158	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a060.A060158;

/**
 * A000486 One half of the number of permutations of [n] such that the differences have 4 runs with the same signs.
 * @author Sean A. Irvine
 */
public class A000486 extends A060158 {

  {
    super.next();
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A000492	3	->	6	A000380	--------------------------------
package irvine.oeis.a000;

/**
 * A000492 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-6 places.
 * @author Sean A. Irvine
 */
public class A000492 extends A000380 {

  @Override
  protected int coeff() {
    return 6;
  }
}
#!queue	A000500	3	->	7	A000380	--------------------------------
package irvine.oeis.a000;

/**
 * A000500 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-7 places.
 * @author Sean A. Irvine
 */
public class A000500 extends A000380 {

  @Override
  protected int coeff() {
    return 7;
  }
}
#!queue	A000506	2	->	6	A008970	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a008.A008970;

/**
 * A000506 One half of the number of permutations of [n] such that the differences have 5 runs with the same signs.
 * @author Sean A. Irvine
 */
public class A000506 extends A008970 {

  private int mN = 4;

  @Override
  public Z next() {
    return get(++mN, 5).divide2();
  }
}
#!queue	A000551	1	->	3	A074728	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a074.A074728;

/**
 * A000551 Number of labeled rooted trees of height 2 with n nodes.
 * @author Sean A. Irvine
 */
public class A000551 extends A074728 {

  protected int mN = 2;

  @Override
  public Z next() {
    return super.next().multiply(mN).multiply(++mN);
  }
}
#!queue	A000599	0	->	1	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A000599 Number of secondary alcohols (alkanols or alkyl alcohols C_n H_{2n+1} OH) with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000599 extends A000598 {

  @Override
  public Z next() {
    super.next();
    final Polynomial<Q> f = RING.subtract(mG, RING.one());
    return RING.add(RING.pow(f, 2, mN), f.substitutePower(2, mN)).coeff(mN).toZ().divide2();
  }
}

#!queue	A000618	-1	->	0	A000616	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000618 Number of nondegenerate Boolean functions of n variables: For n &gt; 0, a(n) = A000616(n) - A000616(n-1).
 * @author Sean A. Irvine
 */
public class A000618 extends A000616 {

  private Z mPrev = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    final Z r = t.subtract(mPrev);
    mPrev = t;
    return r;
  }
}
#!queue	A000632	0	->	2	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000632 Number of esters with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000632 extends A000598 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return RING.multiply(mG, RING.subtract(mG, RING.one()), mN).coeff(mN).toZ();
  }
}

#!queue	A000633	0	->	4	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.PolynomialRingField;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A000633 Number of acyclic quaternary ammonium ions with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000633 extends A000598 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final CycleIndex S4 = SymmetricGroup.create(4).cycleIndex();
  private final Polynomial<Q> mG = RING.empty();
  private int mN = -1;
  {
    super.next();
  }

  @Override
  public Z next() {
    mG.add(new Q(super.next()));
    return S4.apply(mG, ++mN).coeff(mN).toZ();
  }
}
#!queue	A000639	0	->	1	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A000639 Number of alkyl benzenes with n carbon atoms: C(n)H(2n-6).
 * @author Sean A. Irvine
 */
public class A000639 extends A000598 {

  private static final Q FOUR = Q.FOUR;
  private int mL = 0;


  @Override
  public Z next() {
    if (mL < 5) {
      ++mL;
      return Z.ZERO;
    }
    super.next();
    final Polynomial<Q> g2 = mG.substitutePower(2, mN);
    return RING.add(RING.add(RING.add(RING.add(RING.pow(mG, 6, mN),
      RING.multiply(RING.pow(g2, 3, mN), FOUR)),
      RING.multiply(RING.pow(mG.substitutePower(3, mN), 2, mN), Q.TWO)),
      RING.multiply(RING.multiply(RING.pow(mG, 2, mN), RING.pow(g2, 2, mN), mN), Q.THREE)),
      RING.multiply(mG.substitutePower(6, mN), Q.TWO))
      .coeff(mN).divide(12).toZ();
  }
}

#!queue	A000642	0	->	1	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A000642 a(1)=0; for n&gt;1, a(n) = number of isomeric hydrocarbons of the acetylene series with carbon content n.
 * @author Sean A. Irvine
 */
public class A000642 extends A000598 {

  @Override
  public Polynomial<Q> g() {
    return RING.multiply(RING.add(mG.substitutePower(2, mN), RING.pow(mG, 2, mN)), Q.HALF);
  }

  @Override
  public Z next() {
    super.next();
    if (mN == 0) {
      return Z.ZERO;
    }
    return g().coeff(mN - 1).toZ();
  }
}

#!queue	A000662	0	->	1	A000595	--------------------------------
package irvine.oeis.a000;

import irvine.math.IntegerUtils;

/**
 * A000662 Number of relations with 3 arguments on n nodes.
 * @author Sean A. Irvine
 */
public class A000662 extends A000595 {

  {
    super.next();
  }

  @Override
  protected int t(final int[] s) {
    int sum = 0;
    for (int i = 1; i < s.length; ++i) {
      for (int j = 1; j < s.length; ++j) {
        final int ij = i * j;
        final int lij = IntegerUtils.lcm(i, j);
        for (int k = 1; k < s.length; ++k) {
          final int lcm = IntegerUtils.lcm(lij, k);
          sum += (ij * k / lcm) * s[i] * s[j] * s[k];
        }
      }
    }
    return sum;
  }
}
#!queue	A000682	0	->	1	A005316	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a005.A005316;

/**
 * A000682 Semi-meanders: number of ways a semi-infinite directed curve can cross a straight line n times.
 * @author Sean A. Irvine
 */
public class A000682 extends A005316 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final SimpleProcessor<Z> processor = new SimpleProcessor<>();
    processor.setCreateStateMachine(BasicMeanderProblem::new);
    return processor.process(mN, new BasicMeanderProblem(mN).semiMeanderInitialStates());
  }
}

#!queue	A000683	0	->	1	A047863	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a047.A047863;

/**
 * A000683 Number of colorings of labeled graphs on n nodes using exactly 2 colors, divided by 4.
 * @author Sean A. Irvine
 */
public class A000683 extends A047863 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(2).shiftRight(2);
  }
}
#!queue	A000685	0	->	1	A047863	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a047.A047863;

/**
 * A000685 Number of 3-colored labeled graphs on n nodes, divided by 3.
 * @author Sean A. Irvine
 */
public class A000685 extends A047863 {

  private final ArrayList<Z> mC = new ArrayList<>();

  {
    mC.add(super.next());
  }

  @Override
  public Z next() {
    mC.add(super.next());
    Z s = Z.ZERO;
    for (int j = 0; j <= mN; ++j) {
      s = s.add(Binomial.binomial(mN, j).shiftLeft(j * (mN - j)).multiply(mC.get(j)));
    }
    return s.divide(3);
  }
}
#!queue	A000702	0	->	1	A000700	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000702 a(n) is the number of conjugacy classes in the alternating group A_n.
 * @author Sean A. Irvine
 */
public class A000702 extends A000700 {

  private final A000041 mA41 = new A000041();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      super.next();
      mA41.next();
      super.next();
      mA41.next();
      return Z.ONE;
    }
    return mA41.next().add(super.next().multiply(3)).divide2();
  }
}

#!queue	A000742	1	->	4	A000741	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000742 Number of compositions of n into 4 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A000742 extends A000741 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  protected Z p(final Z n) {
    final Z nm = n.subtract(1);
    final Z ns = nm.square();
    return ns.multiply(nm).subtract(ns.multiply(3)).add(n.multiply2()).divide(6);
  }
}
#!queue	A000743	1	->	5	A000741	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A000743 Number of compositions of n into 5 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A000743 extends A000741 {

  {
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 4);
  }
}
#!queue	A000760	0	->	1	A000759	--------------------------------
package irvine.oeis.a000;

/**
 * A000760 Number of n-step self-avoiding walks on cubic lattice ending at point with x=1.
 * @author Sean A. Irvine
 */
public class A000760 extends A000759 {

  {
    super.next();
  }

  @Override
  protected long targetX() {
    return 1;
  }
}
#!queue	A000761	0	->	2	A000759	--------------------------------
package irvine.oeis.a000;

/**
 * A000761 Number of n-step self-avoiding walks on cubic lattice ending at point with x=2.
 * @author Sean A. Irvine
 */
public class A000761 extends A000759 {

  {
    super.next();
    super.next();
  }

  @Override
  protected long targetX() {
    return 2;
  }
}
#!queue	A000762	0	->	3	A000759	--------------------------------
package irvine.oeis.a000;

/**
 * A000762 Number of n-step self-avoiding walks on cubic lattice ending at point with x=3.
 * @author Sean A. Irvine
 */
public class A000762 extends A000759 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  protected long targetX() {
    return 3;
  }
}
#!queue	A000766	0	->	1	A000765	--------------------------------
package irvine.oeis.a000;

/**
 * A000766 Number of n-step self-avoiding walks on f.c.c. lattice ending at point with x = 1.
 * @author Sean A. Irvine
 */
public class A000766 extends A000765 {

  {
    super.next();
  }

  @Override
  protected long targetX() {
    return 1;
  }
}
#!queue	A000767	0	->	2	A000765	--------------------------------
package irvine.oeis.a000;

/**
 * A000767 Number of n-step self-avoiding walks on f.c.c. lattice ending at point with x = 2.
 * @author Sean A. Irvine
 */
public class A000767 extends A000765 {

  {
    super.next();
    super.next();
  }

  @Override
  protected long targetX() {
    return 2;
  }
}
#!queue	A000768	0	->	3	A000765	--------------------------------
package irvine.oeis.a000;

/**
 * A000768 Number of n-step self-avoiding walks on f.c.c. lattice ending at point with x = 3.
 * @author Sean A. Irvine
 */
public class A000768 extends A000765 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  protected long targetX() {
    return 3;
  }
}
#!queue	A000919	4	->	1	A000453	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000919 a(n) = 4^n - C(4,3)*3^n + C(4,2)*2^n - C(4,1).
 * @author Sean A. Irvine
 */
public class A000919 extends A000453 {

  private int mN = 3;

  @Override
  public Z next() {
    if (mN > 0) {
      --mN;
      return Z.ZERO;
    }
    return super.next().multiply(24);
  }
}
#!queue	A000928	0	->	1	A000367	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;

/**
 * A000928 Irregular primes: primes p such that at least one of the numerators of the Bernoulli numbers B_2, B_4, ..., B_{p-3} (A000367) is divisible by p.
 * @author Sean A. Irvine
 */
public class A000928 extends A000367 {

  private final ArrayList<Z> mB = new ArrayList<>();
  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      final long q = mP / 2;
      while (mB.size() < q) {
        mB.add(super.next());
      }
      for (int k = 1; k <= (mP - 3) / 2; ++k) {
        if (mB.get(k).mod(mP) == 0) {
          return Z.valueOf(mP);
        }
      }
    }
  }
}
#!queue	A000947	5	->	7	A000063	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000947 Number of free nonplanar polyenoids with n nodes and symmetry point group C_{2v}.
 * @author Sean A. Irvine
 */
public class A000947 extends A000063 {

  private final A000936 mPlanar = new A000936();

  {
    for (int k = 1; k < 7; ++k) {
      mPlanar.next();
    }
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mPlanar.next());
  }
}

#!queue	A000950	0	->	1	A000949	--------------------------------
package irvine.oeis.a000;

import java.util.Arrays;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A000950 Number of forests with n nodes and height at most 3.
 * @author Sean A. Irvine
 */
public class A000950 extends A000949 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private Polynomial<Q> mS = RING.create(Arrays.asList(Q.ZERO, new Q(super.next())));
  protected Z mF = Z.ONE;

  protected Q nextEgf() {
    final Z t = super.next();
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    mS = RING.add(mS, RING.monomial(new Q(t, mF), mN + 1));
    return RING.exp(mS, mN).coeff(mN);
  }

  @Override
  public Z next() {
    return nextEgf().multiply(mF).toZ();
  }
}
#!queue	A000953	1	->	7	A000207	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000953 Number of free nonplanar polyenoids with n nodes.
 * @author Sean A. Irvine
 */
public class A000953 extends A000207 {

  private final A000942 mPlanar = new A000942();

  {
    for (int k = 1; k < 7; ++k) {
      super.next();
      mPlanar.next();
    }
  }

  @Override
  public Z next() {
    return super.next().subtract(mPlanar.next());
  }
}

#!queue	A001036	0	->	1	A001037	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001036 Partial sums of A001037, omitting A001037(1).
 * @author Sean A. Irvine
 */
public class A001036 extends A001037 {

  private Z mSum = null;

  @Override
  public Z next() {
    if (mSum == null) {
      super.next();
      super.next();
      mSum = Z.ONE;
    } else {
      mSum = mSum.add(super.next());
    }
    return mSum;
  }
}
#!queue	A001173	0	->	1	A000595	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000595;

/**
 * A001173 Half the number of binary relations on n unlabeled points.
 * @author Sean A. Irvine
 */
public class A001173 extends A000595 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}

#!queue	A001225	0	->	2	A003141	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a003.A003141;

/**
 * A001225 Number of consistent arcs in a tournament with n nodes.
 * @author Sean A. Irvine
 */
public class A001225 extends A003141 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return Binomial.binomial(mN, 2).subtract(t);
  }

}

#!queue	A001266	0	->	2	A002464	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a002.A002464;

/**
 * A001266 One-half the number of permutations of length n without rising or falling successions.
 * @author Sean A. Irvine
 */
public class A001266 extends A002464 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A001270	0	->	1	A001265	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001270 Table of prime factors of 10^n - 1 (with multiplicity).
 * @author Sean A. Irvine
 */
public class A001270 extends A001265 {

  {
    super.next();
  }

  @Override
  protected Z base() {
    return Z.TEN;
  }
}
#!queue	A001279	4	->	6	A001278	--------------------------------
package irvine.oeis.a001;

/**
 * A001279 Number of permutations of length n by rises.
 * @author Sean A. Irvine
 */
public class A001279 extends A001278 {

  @Override
  protected int order() {
    return 3;
  }
}
#!queue	A001280	4	->	8	A001278	--------------------------------
package irvine.oeis.a001;

/**
 * A001280 Number of permutations of length n by rises.
 * @author Sean A. Irvine
 */
public class A001280 extends A001278 {

  @Override
  protected int order() {
    return 4;
  }
}
#!queue	A001331	0	->	1	A001329	--------------------------------
package irvine.oeis.a001;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;

/**
 * A001331 Number of n-element algebras with 1 ternary operation.
 * @author Sean A. Irvine
 */
public class A001331 extends A001329 {

  @Override
  protected int start() {
    return 0;
  }

  @Override
  protected Z fix(final int[] j) {
    Z prod = Z.ONE;
    for (int r = 1; r < j.length; ++r) {
      for (int s = 1; s < j.length; ++s) {
        final int g = IntegerUtils.gcd(r, s);
        final int l = IntegerUtils.lcm(r, s);
        for (int t = 1; t < j.length; ++t) {
          prod = prod.multiply(innerSum(j, IntegerUtils.lcm(l, t)).pow(scale() * j[r] * j[s] * j[t] * IntegerUtils.gcd(g, t)));
        }
      }
    }
    return prod;
  }
}
#!queue	A001374	0	->	1	A004105	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a004.A004105;

/**
 * A001374 Number of relational systems on n nodes. Also number of directed 3-multigraphs with loops on n nodes.
 * @author Sean A. Irvine
 */
public class A001374 extends A004105 {

  {
    super.next();
  }

  @Override
  protected Z base() {
    return Z.FOUR;
  }
}

#!queue	A001375	0	->	1	A004105	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a004.A004105;

/**
 * A001375 Relational systems on n nodes.
 * @author Sean A. Irvine
 */
public class A001375 extends A004105 {

  {
    super.next();
  }

  @Override
  protected Z base() {
    return Z.EIGHT;
  }
}

#!queue	A001377	0	->	1	A000595	--------------------------------
package irvine.oeis.a001;

import irvine.math.IntegerUtils;
import irvine.oeis.a000.A000595;

/**
 * A001377 Number of relations with 4 arguments on n nodes.
 * @author Sean A. Irvine
 */
public class A001377 extends A000595 {

  {
    super.next();
  }

  @Override
  protected int t(final int[] s) {
    int sum = 0;
    for (int i = 1; i < s.length; ++i) {
      for (int j = 1; j < s.length; ++j) {
        final int ij = i * j;
        final int lij = IntegerUtils.lcm(i, j);
        for (int k = 1; k < s.length; ++k) {
          final int ijk = ij * k;
          final int lijk = IntegerUtils.lcm(lij, k);
          for (int l = 1; l < s.length; ++l) {
            final int lcm = IntegerUtils.lcm(lijk, l);
            sum += (ijk * l / lcm) * s[i] * s[j] * s[k] * s[l];
          }
        }
      }
    }
    return sum;
  }
}
#!queue	A001395	1	->	0	A007180	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a007.A007180;

/**
 * A001395 Number of (2n+1)-step self-avoiding walks on diamond lattice ending at point with x = 1.
 * @author Sean A. Irvine
 */
public class A001395 extends A007180 {

  private boolean mFirst = true;

  @Override
  protected boolean check(final long point, final int n) {
    return !contains(point, n);
  }

  @Override
  protected long count(final long point) {
    final long t = x(point) + y(point) - z(point) - t(point);
    return Math.abs(t) == 1 ? 1 : 0;
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      ++mN;
      return Z.TWO;
    }
    mN += 2;
    setPathLength(mN);
    setPathElement(0, ORIGIN);
    return Z.valueOf(count(ORIGIN + 1, -1, 1)).multiply2();
  }
}
#!queue	A001396	1	->	0	A007180	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a007.A007180;

/**
 * A001396 Number of 2n-step self-avoiding walks on diamond lattice ending at point with x = 0.
 * @author Sean A. Irvine
 */
public class A001396 extends A007180 {
  private boolean mFirst = true;

  @Override
  protected boolean check(final long point, final int n) {
    return !contains(point, n);
  }

  @Override
  protected long count(final long point) {
    final long t = x(point) + y(point) - z(point) - t(point);
    return t == 0 ? 1 : 0;
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    mN += 2;
    setPathLength(mN);
    setPathElement(0, ORIGIN);
    return Z.valueOf(count(ORIGIN + 1, -1, 1)).shiftLeft(2);
  }
}
#!queue	A001454	1	->	3	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001454 Number of permutations of length n with longest increasing subsequence of length 3.
 * @author Sean A. Irvine
 */
public class A001454 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(3);
    return g(mN, Math.min(mN, 3), l);
  }
}
#!queue	A001455	1	->	4	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001455 Number of permutations of length n with longest increasing subsequence of length 4.
 * @author Sean A. Irvine
 */
public class A001455 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(4);
    return g(mN, Math.min(mN, 4), l);
  }
}
#!queue	A001456	1	->	5	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001456 Number of permutations of length n with longest increasing subsequence of length 5.
 * @author Sean A. Irvine
 */
public class A001456 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(5);
    return g(mN, Math.min(mN, 5), l);
  }
}
#!queue	A001457	1	->	6	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001457 Number of permutations of length n with longest increasing subsequence of length 6.
 * @author Sean A. Irvine
 */
public class A001457 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(6);
    return g(mN, Math.min(mN, 6), l);
  }
}
#!queue	A001458	1	->	7	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001458 Number of permutations of length n with longest increasing subsequence of length 7.
 * @author Sean A. Irvine
 */
public class A001458 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(7);
    return g(mN, Math.min(mN, 7), l);
  }
}
#!queue	A001511	0	->	1	A000120	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000120;

/**
 * A001511 The ruler function: 2^a(n) divides 2n. Or, a(n) = 2-adic valuation of 2n.
 * @author Sean A. Irvine
 */
public class A001511 extends A000120 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return Z.TWO.add(t).subtract(mA);
  }
}
#!queue	A001560	0	->	1	A000041	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A001560 Numbers with an even number of partitions.
 * @author Sean A. Irvine
 */
public class A001560 extends A000041 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isEven()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A001632	0	->	1	A000230	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A001632 Smallest prime p such that there is a gap of 2n between p and previous prime.
 * @author Sean A. Irvine
 */
public class A001632 extends A000230 {

  private long mN = 0;

  {
    super.next();
  }

  @Override
  public Z next() {
    mN += 2;
    return super.next().add(mN);
  }
}
#!queue	A001766	2	->	1	A000114	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000114;

/**
 * A001766 Index of (the image of) the modular group Gamma(n) in PSL_2(Z).
 * @author Sean A. Irvine
 */
public class A001766 extends A000114 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    } else {
      return super.next().multiply(mN);
    }
  }
}
#!queue	A001853	2	->	1	A034781	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a034.A034781;

/**
 * A001853 Total height of trees with n nodes.
 * @author Sean A. Irvine
 */
public class A001853 extends A034781 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k < mN; ++k) {
      s = s.add(t(mN, k).multiply(k));
    }
    return s;
  }
}
#!queue	A001854	2	->	1	A034855	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a034.A034855;

/**
 * A001854 Total height of all rooted trees on n labeled nodes.
 * @author Sean A. Irvine
 */
public class A001854 extends A034855 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k < mN; ++k) {
      s = s.add(r(mN, k).multiply(k));
    }
    return s;
  }
}
#!queue	A001880	0	->	4	A001497	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001880 Coefficients of Bessel polynomials y_n (x).
 * @author Sean A. Irvine
 */
public class A001880 extends A001497 {

  private int mN = 3;

  @Override
  public Z next() {
    return t(++mN, 4);
  }
}
#!queue	A001881	0	->	5	A001497	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001881 Coefficients of Bessel polynomials y_n (x).
 * @author Sean A. Irvine
 */
public class A001881 extends A001497 {

  private int mN = 4;

  @Override
  public Z next() {
    return t(++mN, 5);
  }
}
#!queue	A001885	1	->	2	A001884	--------------------------------
package irvine.oeis.a001;

/**
 * A001885 Hit polynomials.
 * @author Sean A. Irvine
 */
public class A001885 extends A001884 {

  @Override
  protected int coeff() {
    return 2;
  }
}
#!queue	A001886	1	->	3	A001884	--------------------------------
package irvine.oeis.a001;

/**
 * A001886 Hit polynomials.
 * @author Sean A. Irvine
 */
public class A001886 extends A001884 {

  @Override
  protected int coeff() {
    return 3;
  }
}
#!queue	A001893	2	->	3	A001892	--------------------------------
package irvine.oeis.a001;

/**
 * A001893 Number of permutations of (1,...,n) having n-3 inversions (n&gt;=3).
 * @author Sean A. Irvine
 */
public class A001893 extends A001892 {

  @Override
  protected int delta() {
    return 2;
  }
}
#!queue	A001894	2	->	4	A001892	--------------------------------
package irvine.oeis.a001;

/**
 * A001894 Number of permutations of {1,...,n} having n-4 inversions (n&gt;=4).
 * @author Sean A. Irvine
 */
public class A001894 extends A001892 {

  @Override
  protected int delta() {
    return 3;
  }
}
#!queue	A001985	1	->	3	A002223	--------------------------------
package irvine.oeis.a001;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.a002.A002223;

/**
 * A001985 Class numbers of quadratic fields.
 * @author Sean A. Irvine
 */
public class A001985 extends A002223 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z np = super.next();
    return Z.valueOf(LongUtils.hurwitzClassNumber(-np.longValueExact()));
  }
}
#!queue	A002051	0	->	1	A000670	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000670;

/**
 * A002051 Steffensen's bracket function [n,2].
 * @author Sean A. Irvine
 */
public class A002051 extends A000670 {

  private Z mT = Z.ONE;

  @Override
  public Z next() {
    final Z t = super.next();
    if (!Z.ONE.equals(t)) {
      mT = mT.multiply2();
    }
    return t.subtract(mT);
  }
}
#!queue	A002076	1	->	0	A002075	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A002076 Number of equivalence classes of base-3 necklaces of length n, where necklaces are considered equivalent under both rotations and permutations of the symbols.
 * @author Sean A. Irvine
 */
public class A002076 extends A002075 {

  private final ArrayList<Z> mA = new ArrayList<>();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    mA.add(super.next());
    Z s = Z.ZERO;
    for (final Z dd : Jaguar.factor(mA.size()).divisors()) {
      final int d = dd.intValue();
      s = s.add(mA.get(d - 1));
    }
    return s;
  }
}
#!queue	A002136	0	->	3	A002135	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002136 Matrices with 2 rows.
 * @author Sean A. Irvine
 */
public class A002136 extends A002135 {

  private Z mPP = Z.ZERO;
  private Z mP = Z.ZERO;

  @Override
  public Z next() {
    super.next();
    final Z t = mB.multiply(mN).add(mC).add(mPP.multiply(mN).multiply(mN - 1));
    mPP = mP;
    mP = t;
    return mP;
  }
}
#!queue	A002139	0	->	1	A002326	--------------------------------
package irvine.oeis.a002;

import irvine.factor.prime.Fast;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A002139 Shuffling 2n cards.
 * @author Sean A. Irvine
 */
public class A002139 extends A002326 {

  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    final Z f = super.next();
    if (!mN.equals(Z.ONE) && ZUtils.isPrimitiveRoot(Z.TWO, mN)) {
      if (mPrime.isPrime(mN)) {
        return f.add(1);
      }
      // 2n-1 must have the form q^k, k>1
      final Z q = mN.isPower();
      return f.add(1).multiply(Euler.phi(mN.divide(q)));
    } else {
      return f.lcm(f.add(1));
    }
  }
}
#!queue	A002179	1	->	2	A002176	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a100.A100640;

/**
 * A002179 Numerators of Cotesian numbers (not in lowest terms): A002176*C(n,2).
 * @author Sean A. Irvine
 */
public class A002179 extends A002176 {

  @Override
  public Z next() {
    final Z t = super.next();
    return A100640.cotesian(mN, 2).multiply(t).toZ();
  }
}
#!queue	A002180	1	->	2	A002202	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002180 Values taken by the half-totient function phi(m)/2.
 * @author Sean A. Irvine
 */
public class A002180 extends A002202 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A002216	1	->	0	A002215	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A002216 Harary-Read numbers: restricted hexagonal polyominoes (cata-polyhexes) with n cells.
 * @author Sean A. Irvine
 */
public class A002216 extends A002215 {

  private final Sequence mA002214 = new A002214();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().add(mA002214.next()).divide2();
  }
}
#!queue	A002303	3	->	4	A002302	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002303 Generalized tangent numbers.
 * @author Sean A. Irvine
 */
public class A002303 extends A002302 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    return get(mN + 6, mN);
  }
}
#!queue	A002311	0	->	1	A000292	--------------------------------
package irvine.oeis.a002;

import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.a000.A000292;

/**
 * A002311 n-th tetrahedral number is the sum of 2 tetrahedral numbers.
 * @author Sean A. Irvine
 */
public class A002311 extends A000292 {

  private long mN = 0;
  private final HashSet<Z> mSum = new HashSet<>();

  {
    super.next(); // skip leading 0
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z n = super.next();
      final A000292 tetra = new A000292();
      tetra.next(); // skip leading 0
      while (true) {
        final Z q = tetra.next();
        mSum.add(n.add(q));
        if (q.equals(n)) {
          break;
        }
      }
      if (mSum.contains(n)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A002318	0	->	1	A001934	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a001.A001934;

/**
 * A002318 Expansion of (1/theta_4(q)^2 -1)/4 in powers of q.
 * @author Sean A. Irvine
 */
public class A002318 extends A001934 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(4);
  }
}
#!queue	A002367	1	->	2	A007645	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a007.A007645;

/**
 * A002367 Let p = A007645(n) be the n-th generalized cuban prime and write p^2 =  x^2 + 3*y^2 with y &gt; 0; a(n) = x.
 * @author Sean A. Irvine
 */
public class A002367 extends A007645 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z p2 = super.next().square();
    Z y = Z.ZERO;
    while (true) {
      y = y.add(1);
      final Z x2 = p2.subtract(y.square().multiply(3));
      final Z[] x = x2.sqrtAndRemainder();
      if (x[1].isZero()) {
        return x[0];
      }
    }
  }
}
#!queue	A002368	1	->	2	A007645	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a007.A007645;

/**
 * A002368 Let p = A007645(n) be the n-th generalized cuban prime and write p^2 =  x^2 + 3*y^2 with y&gt;0; a(n) = y.
 * @author Sean A. Irvine
 */
public class A002368 extends A007645 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z p2 = super.next().square();
    Z y = Z.ZERO;
    while (true) {
      y = y.add(1);
      final Z x2 = p2.subtract(y.square().multiply(3));
      final Z[] x = x2.sqrtAndRemainder();
      if (x[1].isZero()) {
        return y;
      }
    }
  }
}
#!queue	A002399	0	->	1	A002398	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002399 Coefficients for step-by-step integration.
 * @author Sean A. Irvine
 */
public class A002399 extends A002398 {

  private int mN = 0;

  @Override
  public Z next() {
    return delta(1, ++mN).abs();
  }
}
#!queue	A002400	0	->	2	A002398	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002400 Coefficients for step-by-step integration.
 * @author Sean A. Irvine
 */
public class A002400 extends A002398 {

  private int mN = 1;

  @Override
  public Z next() {
    return delta(2, ++mN).abs();
  }
}
#!queue	A002402	0	->	1	A002398	--------------------------------
package irvine.oeis.a002;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A002402 Coefficients for step-by-step integration.
 * @author Sean A. Irvine
 */
public class A002402 extends A002398 {

  private int mN = 0;

  Z alefStar(final int n) {
    Polynomial<Z> a = RING.one();
    for (int i = 0; i < n; ++i) {
      a = RING.multiply(a, Polynomial.create(i, 1));
    }
    Z x = Z.ZERO;
    for (int d = 0; d <= a.degree(); ++d) {
      final Z b = a.coeff(d);
      if (!Z.ZERO.equals(b)) {
        x = x.signedAdd((d & 1) == 0, b.multiply(l(n).divide(d + 1)));
      }
    }
    return x;
  }

  Z deltaStar(final int p, final int j) {
    Z sum = Z.ZERO;
    for (int k = p; k <= j; ++k) {
      sum = sum.add(gamma(p, k).multiply(bigA(k, j)).multiply(alefStar(k)));
    }
    return sum;
  }

  @Override
  public Z next() {
    return deltaStar(1, ++mN);
  }
}

#!queue	A002438	0	->	1	A000364	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A002438 Multiples of Euler numbers.
 * @author Sean A. Irvine
 */
public class A002438 extends A000364 {

  private Z mMul = null;

  @Override
  public Z next() {
    mMul = mMul == null ? Z.ONE : mMul.multiply(9);
    return super.next().multiply(mMul.add(1)).divide2();
  }
}
#!queue	A002461	0	->	2	A002596	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002461 Coefficients of Legendre polynomials.
 * @author Sean A. Irvine
 */
public class A002461 extends A002596 {

  private int mN = 1;

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    if (++mN == 2) {
      return Z.ONE;
    } else {
      return super.next().abs().multiply(mN);
    }
  }
}
#!queue	A002469	0	->	2	A000166	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000166;

/**
 * A002469 The game of Mousetrap with n cards: the number of permutations of n cards in which 2 is the only hit.
 * @author Sean A. Irvine
 */
public class A002469 extends A000166 {

  private long mN = -3;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    final Z t = mA;
    mA = super.next();
    return Z.ZERO.max(t.multiply(mN).add(mA.multiply(mN + 1)));
  }

}
#!queue	A002500	1	->	0	A002499	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002500 Number of self-converse relations on n points.
 * @author Sean A. Irvine
 */
public class A002500 extends A002499 {

  private boolean mFirst = true;
  
  private int sum3(final int[] j) {
    int s = 0;
    for (final int q : j) {
      s += q;
    }
    return s;
  }

  @Override
  protected int epsilon(final int p, final int[] j) {
    return super.epsilon(p, j) + sum3(j);
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next();
  }
}
#!queue	A002539	1	->	0	A002538	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002539 Eulerian numbers of the second kind: &lt;&lt;n+3, n&gt;&gt;.
 * @author Sean A. Irvine
 */
public class A002539 extends A002538 {

  private Z mA = Z.ZERO;
  private long mN = 0;

  @Override
  public Z next() {
    mA = super.next().multiply(++mN).add(mA.multiply(mN + 4));
    return mA;
  }
}
#!queue	A002546	3	->	1	A002545	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002546 Denominator of Sum_{i+j+k=n; i,j,k &gt; 0} 1/(i*j*k).
 * @author Sean A. Irvine
 */
public class A002546 extends A002545 {

  @Override
  public Z next() {
    return step().den();
  }
}
#!queue	A002548	1	->	2	A002547	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002548 Denominators of coefficients for numerical differentiation.
 * @author Sean A. Irvine
 */
public class A002548 extends A002547 {

  @Override
  public Z next() {
    return step().den();
  }
}
#!queue	A002554	0	->	1	A001824	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a001.A001824;

/**
 * A002554 Numerators of coefficients for numerical differentiation.
 * @author Sean A. Irvine
 */
public class A002554 extends A001824 {

  private Z mF = Z.ONE;
  private long mN = 0;

  protected Q step() {
    if (++mN > 1) {
      mF = mF.multiply(2 * mN).multiply(2 * mN - 1).shiftLeft(2).negate();
    }
    return new Q(super.next(), mF);
  }

  @Override
  public Z next() {
    return step().num();
  }
}
#!queue	A002562	0	->	1	A000170	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000170;

/**
 * A002562 Number of ways of placing n nonattacking queens on n X n board (symmetric solutions count only once).
 * @author Sean A. Irvine
 */
public class A002562 extends A000170 {

  {
    next();
  }

  private int[] rotate90(final int[] q) {
    final int n = q.length;
    final int[] r = new int[n];
    for (int x = 0; x < n; ++x) {
      r[q[x]] = n - x - 1;
    }
    return r;
  }

  private int[] reflect(final int[] q) {
    final int n = q.length;
    final int[] r = new int[n];
    for (int x = 0; x < n; ++x) {
      r[x] = n - q[x] - 1;
    }
    return r;
  }

  private boolean checkFlip(final int[] q) {
    final int n = q.length;
    for (int x = 0; x < n; ++x) {
      final int y = q[x];
      final int otherY = n - y - 1;
      if (y < otherY) {
        return false;
      } else if (y > otherY) {
        return true;
      }
    }
    return false; // symmetric
  }

  private boolean lt(final int[] a, final int[] b) {
    for (int x = 0; x < a.length; ++x) {
      if (a[x] < b[x]) {
        return true;
      } else if (a[x] > b[x]) {
        return false;
      }
    }
    return false;
  }

  @Override
  protected Z count(final int[] q) {
    if (checkFlip(q)) {
      return Z.ZERO;
    }
    // All these explicit rotations are probably slow.  But doing these
    // checks was error prone when I first tried to implement it that
    // way.
    final int[] q1 = rotate90(q);
    if (lt(q1, q) || lt(reflect(q1), q)) {
      return Z.ZERO;
    }
    final int[] q2 = rotate90(q1);
    if (lt(q2, q) || lt(reflect(q2), q)) {
      return Z.ZERO;
    }
    final int[] q3 = rotate90(q2);
    if (lt(q3, q) || lt(reflect(q3), q)) {
      return Z.ZERO;
    }
    return Z.ONE;
  }
}
#!queue	A002575	0	->	2	A125790	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.Conjectural;
import irvine.oeis.a125.A125790;

/**
 * A002575 Coefficients of Bell's formula for making change.
 * @author Sean A. Irvine
 */
public class A002575 extends A125790 implements Conjectural {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, 2L);
  }
}
#!queue	A002576	1	->	3	A262554	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a262.A262554;

/**
 * A002576 Coefficients of Bell's formula for making change.
 * @author Sean A. Irvine
 */
public class A002576 extends A262554 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}

#!queue	A002597	1	->	0	A002599	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;


/**
 * A002597 Number of partitions into one kind of 1's, two kinds of 2's, and three kinds of 3's.
 * @author Sean A. Irvine
 */
public class A002597 extends A002599 {

  private boolean mFirst = true;

  @Override
  protected int limit() {
    return 3;
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next();
  }
}
#!queue	A002615	0	->	1	A002288	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A002615 Glaisher's function T_1(n).
 * @author Sean A. Irvine
 */
public class A002615 extends A002288 {

  {
    super.next(); // skip 0th
  }

  private final Sequence mA = new A002614();

  @Override
  public Z next() {
    return super.next().multiply(19).subtract(mA.next());
  }
}
#!queue	A002616	1	->	3	A002322	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002616 Reduced totient function (divided by 2).
 * @author Sean A. Irvine
 */
public class A002616 extends A002322 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A002634	1	->	3	A000183	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000183;

/**
 * A002634 From discordant permutations.
 * @author Sean A. Irvine
 */
public class A002634 extends A000183 {

  private Z mB1 = null;
  private Z mB2 = null;

  private long mAdd = -4;
  private Z mA = null;
  private Z mB = null;
  private Z mC = null;
  private Z mD = null;

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z b0 = mB1;
    mB1 = mB2;
    mB2 = super.next();
    mAdd = -mAdd;
    final Z t;
    if (mA == null) {
      if (mD == null) {
        t = Z.valueOf(-2);
      } else if (mC == null) {
        t = Z.THREE;
      } else if (mB == null) {
        t = Z.ZERO;
      } else {
        t = Z.valueOf(25);
      }
    } else {
      t = mB2.subtract(mB1.multiply2()).add(b0).add(mD.multiply2()).add(mC.multiply2()).subtract(mB.multiply2()).add(mA).add(mAdd);
    }
    mA = mB;
    mB = mC;
    mC = mD;
    mD = t;
    return mD;
  }
}
#!queue	A002638	0	->	1	A000568	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000568;

/**
 * A002638 a(n) = (number of nonisomorphic nontransitive prime tournaments on n nodes) - Moebius(n).
 * @author Sean A. Irvine
 */
public class A002638 extends A000568 {

  private final ArrayList<Z> mA = new ArrayList<>();
  private final ArrayList<Z> mB = new ArrayList<>();
  {
    mA.add(super.next());
    mB.add(null);
  }
  private int mN = 0;

  @Override
  public Z next() {
    mA.add(super.next());
    if (++mN == 1) {
      mB.add(Z.NEG_ONE);
    } else {
      Z s = mA.get(mN);
      for (final Z dd : Jaguar.factor(mN).divisors()) {
        final int d = dd.intValueExact();
        if (d != 1 && d != mN) {
          s = s.subtract(mA.get(mN / d).multiply(mB.get(d)));
        }
      }
      mB.add(s);
    }
    return mB.get(mB.size() - 1);
  }
}
#!queue	A002669	0	->	1	A265607	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a265.A265607;

/**
 * A002669 Numerator of constant term in polynomial arising from numerical integration formula.
 * @author Sean A. Irvine
 */
public class A002669 extends A265607 {

  private int mN = 0;
  private Z mF = Z.ONE;

  {
    super.next();
  }

  protected Z select(final Q n) {
    return n.num();
  }

  @Override
  public Z next() {
    ++mN;
    mF = mF.multiply(mN).multiply(mN);
    Z sum = Z.ZERO;
    Z v = Z.ONE;
    for (int j = 0; j <= mN; ++j) {
      sum = sum.add(super.next().multiply(v));
      v = v.multiply(-mN);
    }
    return select(new Q(sum, mF));
  }
}
#!queue	A002675	1	->	2	A002672	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002675 Numerators of coefficients for central differences M_{4}^(2*n).
 * @author Sean A. Irvine
 */
public class A002675 extends A002672 {

  private int mN = 2;

  @Override
  public Z next() {
    mN += 2;
    return bigM(4, mN).num();
  }
}
#!queue	A002676	1	->	2	A002672	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002676 Denominators of coefficients for central differences M_{4}^(2*n).
 * @author Sean A. Irvine
 */
public class A002676 extends A002672 {

  private int mN = 2;

  @Override
  public Z next() {
    mN += 2;
    return bigM(4, mN).den();
  }
}
#!queue	A002701	0	->	2	A002455	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A002701 Coefficients for numerical differentiation.
 * @author Sean A. Irvine
 */
public class A002701 extends A002455 {

  private int mN = -1;
  private Z mDen = Z.SIX;

  {
    super.next();
  }

  protected Q computeNext() {
    if (++mN > 0) {
      mDen = mDen.multiply(2 * mN + 3).multiply(2 * mN + 2).shiftLeft(2);
    }
    return new Q(super.next().multiply(6), mDen);
  }

  @Override
  public Z next() {
    return computeNext().num();
  }
}
#!queue	A002730	0	->	1	A002729	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;

/**
 * A002730 Number of equivalence classes of binary sequences of primitive period n.
 * @author Sean A. Irvine
 */
public class A002730 extends A002729 {

  private final ArrayList<Z> mA2729 = new ArrayList<>();
  {
    mA2729.add(super.next());
  }

  @Override
  public Z next() {
    final int n = mA2729.size();
    mA2729.add(super.next());
    Z s = Z.ZERO;
    for (final Z dd : Jaguar.factor(n).divisors()) {
      final int d = dd.intValueExact();
      s = s.add(mA2729.get(d).multiply(Mobius.mobius(n / d)));
    }
    return s;
  }
}
#!queue	A002748	1	->	0	A000203	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A002748 Sum of logarithmic numbers.
 * @author Sean A. Irvine
 */
public class A002748 extends A000203 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = -1;
  private Z mF = Z.ONE;
  private final ArrayList<Q> mSeq = new ArrayList<>();

  @Override
  public Z next() {
    mSeq.add(new Q(super.next()));
    final Polynomial<Q> egf = RING.series(RING.create(mSeq), RING.exp(RING.x(), ++mN), mN);
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A002749	1	->	0	A000005	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000005;

/**
 * A002749 Sum of logarithmic numbers.
 * @author Sean A. Irvine
 */
public class A002749 extends A000005 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = -1;
  private Z mF = Z.ONE;
  private final ArrayList<Q> mSeq = new ArrayList<>();

  @Override
  public Z next() {
    mSeq.add(new Q(super.next()));
    final Polynomial<Q> egf = RING.series(RING.create(mSeq), RING.exp(RING.x(), ++mN), mN);
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A002750	1	->	0	A000203	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A002750 Sum of logarithmic numbers.
 * @author Sean A. Irvine
 */
public class A002750 extends A000203 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = -1;
  private Z mF = Z.ONE;
  private final ArrayList<Q> mSeq = new ArrayList<>();

  @Override
  public Z next() {
    mSeq.add(new Q(super.next()));
    final Polynomial<Q> egf = RING.multiply(RING.create(mSeq), RING.exp(RING.x(), ++mN), mN);
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A002751	1	->	0	A000005	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000005;

/**
 * A002751 Sum of logarithmic numbers.
 * @author Sean A. Irvine
 */
public class A002751 extends A000005 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = -1;
  private Z mF = Z.ONE;
  private final ArrayList<Q> mSeq = new ArrayList<>();

  @Override
  public Z next() {
    mSeq.add(new Q(super.next()));
    final Polynomial<Q> egf = RING.multiply(RING.create(mSeq), RING.exp(RING.x(), ++mN), mN);
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A002766	0	->	1	A002762	--------------------------------
package irvine.oeis.a002;

/**
 * A002766 Number of bipartite partitions.
 * @author Sean A. Irvine
 */
public class A002766 extends A002762 {

  @Override
  protected int m() {
    return 9;
  }

  @Override
  protected int k() {
    return 3;
  }
}
#!queue	A002770	1	->	2	A002306	--------------------------------
package irvine.oeis.a002;

import irvine.factor.prime.Fast;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A002770 Integers connected with coefficients in expansion of Weierstrass P-function.
 * @author Sean A. Irvine
 */
public class A002770 extends A002306 {

  private final Fast mPrime = new Fast();
  private int mN = 1;

  @Override
  public Z next() {
    final Q e = hurwitz(++mN);
    final A002172 glaisher = new A002172(); // Glaisher, 2 * a
    long p = 3; // first prime to consider is 5
    Q sum = Q.ZERO;
    final long n4 = 4L * mN;
    while ((p = mPrime.nextPrime(p)) - 1 <= n4) {
      if ((p & 3) == 1) {
        // i.e. p steps through index for chi(p)
        final Z a2 = glaisher.next();
        if (n4 % (p - 1) == 0) {
          final Q t = new Q(a2.pow(n4 / (p - 1)), Z.valueOf(p));
          sum = sum.add(t);
        }
      }
    }
    //System.out.println(e + " " + mSum);
    return e.subtract(Q.HALF).subtract(sum).toZ();
  }
}
#!queue	A002772	1	->	2	A002771	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.z.Z;

/**
 * A002772 Number of terms in a bordered skew determinant.
 * @author Sean A. Irvine
 */
public class A002772 extends A002771 {

  private final ArrayList<Z> mSkew = new ArrayList<>();
  {
    mSkew.add(Z.ONE); // easier to keep indexes in sync
    mSkew.add(super.next());
  }
  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    mSkew.add(super.next());
    Z s = Z.ZERO;
    Z f = Z.ONE;
    for (int k = 1; k <= mN; ++k) {
      s = s.add(mSkew.get(mN - k).multiply(f));
      f = f.multiply(mN - k);
    }
    return s;
  }
}
#!queue	A002809	0	->	1	A000793	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000793;

/**
 * A002809 Increasing values of A000793 (largest order of permutation of n elements).
 * @author Sean A. Irvine
 */
public class A002809 extends A000793 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.compareTo(mA) <= 0);
    mA = t;
    return mA;
  }
}
#!queue	A002815	1	->	0	A000720	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A002815 a(n) = n + Sum_{k=1..n} pi(k), where pi() = A000720.
 * @author Sean A. Irvine
 */
public class A002815 extends A000720 {

  private Z mSum = Z.ZERO;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN > 0) {
      mSum = mSum.add(super.next());
    }
    return mSum.add(mN);
  }
}

#!queue	A002848	1	->	0	A002849	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002848 Number of maximal collections of pairwise disjoint subsets {X,Y,Z} of {1, 2, ..., n} with X + Y = Z (as in A002849), with the property that n is in one of the subsets.
 * @author Sean A. Irvine
 */
public class A002848 extends A002849 {

  // After Franklin T. Adams-Watters

  private int mN = -1;
  private Z mPrev = super.next();

  @Override
  public Z next() {
    if (++mN <= 1) {
      return Z.ZERO;
    }
    final Z t = super.next();
    final int r = mN % 12;
    final Z res;
    if (r == 0 || r == 3 || r == 7 || r == 10) {
      res = t;
    } else {
      res = t.subtract(mPrev);
    }
    mPrev = t;
    return res;
  }
}
#!queue	A002869	1	->	0	A019538	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a019.A019538;

/**
 * A002869 Largest number in n-th row of triangle A019538.
 * @author Sean A. Irvine
 */
public class A002869 extends A019538 {

  private long mN = -1;

  @Override
  public Z next() {
    Z m = Z.ONE;
    ++mN;
    for (int k = 1; k <= mN; ++k) {
      m = m.max(super.next());
    }
    return m;
  }
}
#!queue	A002878	1	->	0	A000204	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000204;

/**
 * A002878 Bisection of Lucas sequence: a(n) = L(2*n+1).
 * @author Sean A. Irvine
 */
public class A002878 extends A000204 {

  @Override
  public Z next() {
    final Z res = super.next();
    super.next();
    return res;
  }
}

#!queue	A002902	0	->	1	A001412	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a001.A001412;

/**
 * A002902 Number of n-step self-avoiding walks on a cubic lattice with a first step along the positive x, y, or z axis.
 * @author Sean A. Irvine
 */
public class A002902 extends A001412 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A002966	0	->	1	A000058	--------------------------------
package irvine.oeis.a002;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a000.A000058;

/**
 * A002966 Egyptian fractions: number of solutions of 1 = 1/x_1 + ... + 1/x_n where 0 &lt; x_1 &lt;= ... &lt;= x_n.
 * @author Sean A. Irvine
 */
public class A002966 extends A000058 {

  // Based on a C++ implementation by Jacques Le Normand
  // Correctly calculates to a(8) -- there might be overflow beyond that -- not tested

  private static final class FastVector {
    // todo make this dynamic in mSize?
    private final int[] mPrime = new int[14];
    private final int[] mExponent = new int[14];
    private int mSize;

    private FastVector() {
      mSize = 0;
    }

    private void add(final int a, final int value) {
      for (int i = 0; i < mSize; ++i) {
        if (mPrime[i] == a) {
          mExponent[i] += value;
          return;
        }
      }
      mPrime[mSize] = a;
      mExponent[mSize] = value;
      ++mSize;
    }

    private int get(final int a) {
      for (int i = 0; i < mSize; ++i) {
        if (mPrime[i] == a) {
          return mExponent[i];
        }
      }
      mPrime[mSize] = a;
      mExponent[mSize] = 0;
      ++mSize;
      return 0;
    }

    private void erase(final int a) {
      for (int i = 0; i < mSize; ++i) {
        if (mPrime[i] == a) {
          mPrime[i] = mPrime[mSize - 1];
          mExponent[i] = mExponent[mSize - 1];
          --mSize;
          return;
        }
      }
    }

  }

  private final FastVector mSoFar = new FastVector();
  private final FastVector mTempFar = new FastVector();

  // This is the meat. it generates all the divisors of denum, and then tests using Polytope's test.
  // mSoFar contains all the prime divisors of denum and their multiplicity. mSoFar is like a map.
  int getDivisors(final long[] num, final long[] denum, long d, final int c, final int start) {
    if (c >= mTempFar.mSize) {
      return (denum[0] + d) % num[0] == 0 && (denum[0] + d) / num[0] >= start ? 1 : 0;
    }
    while (num[0] % mTempFar.mPrime[c] == 0 && mTempFar.mExponent[c] > 0) {
      num[0] /= mTempFar.mPrime[c];
      denum[0] /= mTempFar.mPrime[c];
      mTempFar.mExponent[c]--;
    }
    int ret = 0;
    for (int i = 0; i <= mTempFar.mExponent[c] * 2; ++i) {
      ret += getDivisors(num, denum, d, c + 1, start);
      d *= mTempFar.mPrime[c];
      if (d > denum[0]) {
        break;
      }
    }
    return ret;
  }

  // Recursive with a special case when n = 2.
  private long count(final int n, final long num, final long denum, int start) {
    if (n == 2) {
      System.arraycopy(mSoFar.mPrime, 0, mTempFar.mPrime, 0, mSoFar.mSize);
      System.arraycopy(mSoFar.mExponent, 0, mTempFar.mExponent, 0, mSoFar.mSize);
      mTempFar.mSize = mSoFar.mSize;
      return getDivisors(new long[] {num}, new long[] {denum}, 1, 0, start);
    }
    final long least = denum % num != 0 ? (denum + num - 1) / num : (denum / num) + 1;
    if (start < least) {
      start = (int) least;
    }
    long ret = 0;
    for (int toCheck = (int) ((denum * n) / num); toCheck >= start; --toCheck) {
      final long top = num * toCheck - denum;
      final long bot = toCheck * denum;
      final FactorSequence fs = Jaguar.factor(toCheck);
      for (final Z p : fs.toZArray()) {
        mSoFar.add(p.intValueExact(), fs.getExponent(p));
      }
      ret += count(n - 1, top, bot, toCheck);
      if ((ret >> 32) > 0) { // was 32 in C version
        throw new RuntimeException("overflow");
      }
      for (final Z p : fs.toZArray()) {
        final int pi = p.intValueExact();
        mSoFar.add(pi, -fs.getExponent(p));
        if (mSoFar.get(pi) <= 0) {
          mSoFar.erase(pi);
        }
      }
    }
    return ret;
  }


  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return Z.valueOf(count(mN, 1, 1, 2));
  }
}
#!queue	A003026	1	->	2	A058876	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a058.A058876;

/**
 * A003026 Number of n-node labeled acyclic digraphs with 2 out-points.
 * @author Sean A. Irvine
 */
public class A003026 extends A058876 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}
#!queue	A003033	2	->	3	A003032	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003033 Smallest integer m such that the product of every 4 consecutive integers &gt; m has a prime factor &gt; prime(n).
 * @author Sean A. Irvine
 */
public class A003033 extends A003032 {

  @Override
  protected int getNumberOfConsecutivePrimes() {
    return 4;
  }

  @Override
  protected Z firstPrime() {
    return Z.THREE;
  }

}
#!queue	A003040	0	->	1	A060240	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a060.A060240;

/**
 * A003040 Highest degree of an irreducible representation of symmetric group S_n of degree n.
 * @author Sean A. Irvine
 */
public class A003040 extends A060240 {

  private int mN = 0;

  @Override
  public Z next() {
    Z max = Z.ZERO;
    for (final Z r : representations(++mN)) {
      max = max.max(r);
    }
    return max;
  }
}
#!queue	A003065	1	->	0	A003313	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.util.array.DynamicLongArray;

/**
 * A003065 Number of integers with a shortest addition chain of length n.
 * @author Sean A. Irvine
 */
public class A003065 extends A003313 {

  private final DynamicLongArray mCounts = new DynamicLongArray();
  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    ++mN;
    final int limit = 1 << mN;
    while (mM <= limit) {
      final int length = super.next().intValueExact();
      mCounts.set(length, mCounts.get(length) + 1);
      ++mM;
    }
    return Z.valueOf(mCounts.get(mN));
  }
}
#!queue	A003069	0	->	1	A126067	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a126.A126067;

/**
 * A003069 Number of n-node digraphs with same converse as complement.
 * @author Sean A. Irvine
 */
public class A003069 extends A126067 {

  private int mN = 0;

  @Override
  public Z next() {
    return i(++mN).apply(0, 1).toZ();
  }
}
#!queue	A003084	0	->	1	A000273	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000273;

/**
 * A003084 Related to number of digraphs.
 * @author Sean A. Irvine
 */
public class A003084 extends A000273 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mA = new ArrayList<>();
  {
    // skip 0th term
    super.next();
    mA.add(Q.ZERO);
  }

  @Override
  public Z next() {
    final int n = mA.size();
    mA.add(new Q(super.next()));
    return RING.log1p(RING.create(mA), n).coeff(n).multiply(n).toZ();
  }
}
#!queue	A003089	0	->	1	A002905	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a002.A002905;

/**
 * A003089 Number of connected line graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A003089 extends A002905 {

  {
    super.next(); // skip 0th term
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return mN == 4 ? Z.TWO : t;
  }
}
#!queue	A003144	0	->	1	A080843	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a080.A080843;

/**
 * A003144 Positions of letter a in the tribonacci word abacabaabacababac... generated by a-&gt;ab, b-&gt;ac, c-&gt;a (cf. A092782).
 * @author Sean A. Irvine
 */
public class A003144 extends A080843 {

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A003145	0	->	1	A080843	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a080.A080843;

/**
 * A003145 Positions of letter b in the tribonacci word abacabaabacababac... generated by a-&gt;ab, b-&gt;ac, c-&gt;a (cf. A092782).
 * @author Sean A. Irvine
 */
public class A003145 extends A080843 {

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A003146	0	->	1	A080843	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a080.A080843;

/**
 * A003146 Positions of letter c in the tribonacci word abacabaabacababac... generated by a-&gt;ab, b-&gt;ac, c-&gt;a (cf. A092782).
 * @author Sean A. Irvine
 */
public class A003146 extends A080843 {

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A003270	0	->	1	A099054	--------------------------------
package irvine.oeis.a003;

import irvine.oeis.Conjectural;
import irvine.oeis.a099.A099054;

/**
 * A003270 A nonrepetitive sequence.
 * @author Sean A. Irvine
 */
public class A003270 extends A099054 implements Conjectural {
}
#!queue	A003289	2	->	1	A003290	--------------------------------
package irvine.oeis.a003;

/**
 * A003289 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (0,1).
 * @author Sean A. Irvine
 */
public class A003289 extends A003290 {

  @Override
  protected int first() {
    return 1;
  }

  @Override
  protected long search() {
    final int tx = 2;
    final int ty = 0;
    // return search(0, 0, tx, ty, mN, 1); // Basic search
    // Expanding first few links to exploit symmetries
    use(0, 0);
    long total = search(2, 0, tx, ty, mN - 1, 1);
    total += search(1, 1, tx, ty, mN - 1, 2);
    total += search(-1, 1, tx, ty, mN - 1, 2);
    use(-2, 0);
    total += search(-4, 0, tx, ty, mN - 2, 1);
    total += search(-1, 1, tx, ty, mN - 2, 2);
    total += search(-3, 1, tx, ty, mN - 2, 2);
    clear(-2, 0);
    clear(0, 0);
    return total;
  }

}
#!queue	A003304	1	->	2	A002931	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A003304 Number of figure 8's with 2n edges on the square lattice.
 * @author Sean A. Irvine
 */
public class A003304 extends A002931 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));

  {
    super.next(); // skip size 2, there are no figure 8s of this size
  }

  private Polygon augment(final int... coords) {
    Polygon p = null;
    for (int k = 0; k < coords.length; k += 2) {
      p = new Polygon(p, new Point(coords[k], coords[k + 1]));
    }
    return p;
  }

  private String latexPolygon(final Polygon polygon) {
    final StringBuilder sb = new StringBuilder("\\draw ");
    Point first = null;
    for (final Point pt : polygon) {
      if (first == null) {
        first = pt;
      } else {
        sb.append(" -- ");
      }
      sb.append(pt);
    }
    sb.append(" -- ").append(first).append(";\n");
    for (final Point pt : polygon) {
      sb.append("\\fill ").append(pt).append(" circle (3pt);\n");
    }
    return sb.toString();
  }

  private void dump(final Polygon polygon, final int... coords) {
    System.out.println("\\begin{tikzpicture}[scale=0.3]");
    System.out.print(latexPolygon(polygon));
    System.out.print(latexPolygon(augment(coords)));
    System.out.println("\\end{tikzpicture}");
  }

  @Override
  protected Z postFilter() {
    if (mN == 4) {
      // This is the only case where translation of the polygon could get you the same thing
      // after adding a simple square.  Rather than slowing down all the calculations by
      // checking for this, special case this smallest value.
      return Z.TWO;
    }
    // Need to try adding a square at each position of each polygon
    long c = 0;
    for (final Polygon polygon : mPolygons) {
      for (final Point pt : polygon) {
        final int x = pt.left();
        final int y = pt.right();
        if (!polygon.contains(new Point(x + 1, y))) {
          if (!polygon.contains(new Point(x + 1, y + 1)) && !polygon.contains(new Point(x, y + 1))) {
            ++c;
            if (mVerbose) {
              dump(polygon, x, y, x + 1, y, x + 1, y + 1, x, y + 1);
            }
          }
          if (!polygon.contains(new Point(x + 1, y - 1)) && !polygon.contains(new Point(x, y - 1))) {
            ++c;
            if (mVerbose) {
              dump(polygon, x, y, x + 1, y, x + 1, y - 1, x, y - 1);
            }
          }
        }
        if (!polygon.contains(new Point(x - 1, y))) {
          if (!polygon.contains(new Point(x - 1, y + 1)) && !polygon.contains(new Point(x, y + 1))) {
            ++c;
            if (mVerbose) {
              dump(polygon, x, y, x - 1, y, x - 1, y + 1, x, y + 1);
            }
          }
          if (!polygon.contains(new Point(x - 1, y - 1)) && !polygon.contains(new Point(x, y - 1))) {
            ++c;
            if (mVerbose) {
              dump(polygon, x, y, x - 1, y, x - 1, y - 1, x, y - 1);
            }
          }
        }
      }
    }
    return Z.valueOf(c);
  }
}

#!queue	A003305	1	->	4	A002931	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;
import java.util.Collection;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A003305 Figure 8's with 2n edges on the square lattice.
 * @author Sean A. Irvine
 */
public class A003305 extends A002931 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private final ArrayList<Collection<Polygon>> mFigures = new ArrayList<>();

  {
    mFigures.add(null); // No polygons of length 0
    super.next();
    mFigures.add(null); // No polygons of length 2
  }

  private boolean juxtapose(final Polygon big, final Polygon small, final int crossX, final int crossY, final int dx, final int dy) {
    for (final Point pt : small) {
      final int x = pt.left() + dx;
      final int y = pt.right() + dy;
      if (x != crossX || y != crossY) {
        final Point p = new Point(x, y);
        if (big.contains(p)) {
          return false;
        }
      }
    }
    return true;
  }

  private long juxtapose(final Polygon big, final Polygon small) {
    // Add s to big in all possible ways
    long count = 0;
    for (final Point pt : big) {
      // Select the point where the two polygons will intersect
      final int crossX = pt.left();
      final int crossY = pt.right();
      for (final Point pt2 : small) {
        final int sx = pt2.left();
        final int sy = pt2.right();
        // Compute translation to adjoin small to big at selected points
        final int dx = crossX - sx;
        final int dy = crossY - sy;
        if (juxtapose(big, small, crossX, crossY, dx, dy)) {
          ++count;
        }
      }
    }
    return count;
  }

  private long count(final int k, final int j) {
    assert k >= j;
    long count = 0;
    final Collection<Polygon> small = mFigures.get(j / 2);
    final Collection<Polygon> big = mFigures.get(k / 2);
    for (final Polygon b : big) {
      for (final Polygon s : small) {
        count += juxtapose(b, s);
      }
    }
    if (k == j) {
      // If k == j we will have counted each figure twice, so make the correction here
      assert (count & 1) == 0;
      count /= 2;
    }
    if (mVerbose) {
      System.out.println("(" + k + "," + j + ")=" + count);
    }
    return count;
  }

  @Override
  public Z next() {
    super.next(); // Adds one more set of polygons to mFigures
    mFigures.add(new ArrayList<>(mPolygons));
    final int n = mN + 4;
    Z sum = Z.ZERO;
    for (int k = n - 4; 2 * k >= n; k -= 2) {
      // k tracks the larger of the two polygons in the figure
      sum = sum.add(count(k, n - k));
    }
    return sum;
  }

}

#!queue	A003426	0	->	1	A000055	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a000.A000055;
import irvine.oeis.a002.A002988;

/**
 * A003426 Number of stable trees with n nodes.
 * @author Sean A. Irvine
 */
public class A003426 extends A000055 {

  private long mN = 0;
  private final A002988 mB = new A002988();
  {
    super.next();
    mB.next();
  }

  @Override
  public Z next() {
    final Z v = super.next().subtract(mB.next());
    return ++mN <= 2 ? v.add(1) : v;
  }
}
#!queue	A003437	0	->	1	A007474	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a007.A007474;

/**
 * A003437 Number of unlabeled Hamiltonian circuits on n-octahedron (cross polytope); also number of circular chord diagrams with n chords, modulo symmetries.
 * @author Sean A. Irvine
 */
public class A003437 extends A007474 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply2().add(get(mN, 2L)).subtract(get(mN - 1, 2L)).add(get(mN - 2, 2L)).divide(4);
  }
}

#!queue	A003443	4	->	5	A003442	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003443 Number of nonequivalent dissections of an n-gon into n-4 polygons by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A003443 extends A003442 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return f(mN, mN + 4).coeff(mN + 4).toZ();
  }
}

#!queue	A003454	4	->	3	A003442	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003454 Number of nonequivalent dissections of an n-gon by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A003454 extends A003442 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      s = s.add(f(k, mN + 2).coeff(mN + 2).toZ());
    }
    return s;
  }
}

#!queue	A003651	1	->	2	A003658	--------------------------------
package irvine.oeis.a003;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;

/**
 * A003651 Class number of real quadratic field with discriminant 4n, n == 2,3 ( mod 4).
 * @author Sean A. Irvine
 */
public class A003651 extends A003658 {

  @Override
  public Z next() {
    while (true) {
      final Z n = super.next();
      if (n.mod(4) == 0) {
        return Z.valueOf(QuadraticFieldUtils.classNumber(n));
      }
    }
  }
}
#!queue	A003652	1	->	2	A003658	--------------------------------
package irvine.oeis.a003;

import irvine.oeis.Conjectural;
import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;

/**
 * A003652 Class number of real quadratic field with discriminant A003658(n), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A003652 extends A003658 implements Conjectural {

  // contains heuristics.

  {
    super.next(); // skip 1
  }

  @Override
  public Z next() {
    return Z.valueOf(QuadraticFieldUtils.classNumber(super.next()));
  }
}
#!queue	A003923	1	->	0	A003920	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003923 Order of universal Chevalley group B_n (2) or symplectic group Sp(2n,2).
 * @author Sean A. Irvine
 */
public class A003923 extends A003920 {

  @Override
  protected Z q() {
    return Z.TWO;
  }

  @Override
  protected int start() {
    return -1;
  }
}
#!queue	A003924	1	->	0	A003920	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003924 Order of universal Chevalley group B_n (7).
 * @author Sean A. Irvine
 */
public class A003924 extends A003920 {

  @Override
  protected Z q() {
    return Z.SEVEN;
  }
}
#!queue	A003928	2	->	1	A003927	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003928 Order of simple Chevalley group B_n (5).
 * @author Sean A. Irvine
 */
public class A003928 extends A003927 {

  @Override
  protected Z q() {
    return Z.FIVE;
  }

  @Override
  protected int start() {
    return 0;
  }
}
#!queue	A004005	5	->	2	A032428	--------------------------------
package irvine.oeis.a004;

import irvine.oeis.a032.A032428;

/**
 * A004005 Coefficients of elliptic function sn.
 * @author Sean A. Irvine
 */
public class A004005 extends A032428 {

  @Override
  protected int j() {
    return 2;
  }
}
#!queue	A004017	0	->	1	A007331	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.a007.A007331;

/**
 * A004017 Theta series of E_8 lattice with respect to deep hole.
 * @author Sean A. Irvine
 */
public class A004017 extends A007331 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().shiftLeft(4);
  }
}
#!queue	A004102	1	->	0	A063841	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.a063.A063841;

/**
 * A004102 Number of signed graphs with n nodes. Also number of 2-multigraphs on n nodes.
 * @author Sean A. Irvine
 */
public class A004102 extends A063841 {

  private int mN = -1;

  @Override
  public Z next() {
    return t(++mN, 2);
  }
}

#!queue	A004114	1	->	0	A004113	--------------------------------
package irvine.oeis.a004;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A004114 Number of trees with n nodes and 2-colored internal (non-leaf) nodes.
 * @author Sean A. Irvine
 */
public class A004114 extends A004113 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final ArrayList<Z> mB = new ArrayList<>();
  {
    mB.add(Z.ZERO);
  }
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mB.add(super.next());
    final Polynomial<Z> g = RING.create(mB);
    return RING.add(RING.subtract(RING.add(RING.one(), g), g.shift(1)), RING.divide(RING.subtract(g.substitutePower(2), RING.pow(g, 2, mN)), Z.TWO)).coeff(mN);
  }
}
#!queue	A004160	0	->	1	A000292	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000292;

/**
 * A004160 Sum of digits of tetrahedral numbers.
 * @author Sean A. Irvine
 */
public class A004160 extends A000292 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()));
  }
}
#!queue	A004162	0	->	1	A000326	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000326;

/**
 * A004162 Sum of digits of pentagonal numbers.
 * @author Sean A. Irvine
 */
public class A004162 extends A000326 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()));
  }
}
#!queue	A004250	0	->	1	A000041	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A004250 Number of partitions of n into 3 or more parts.
 * @author Sean A. Irvine
 */
public class A004250 extends A000041 {

  private long mN = 2;

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(++mN / 2);
  }
}
#!queue	A004287	1	->	0	A004283	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;

/**
 * A004287 Least positive multiple of n written in base 7 using only 0 and 1.
 * @author Sean A. Irvine
 */
public class A004287 extends A004283 {

  @Override
  protected Z init() {
    return Z.NEG_ONE;
  }

  @Override
  protected int base() {
    return 7;
  }
}
#!queue	A004288	1	->	0	A004283	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;

/**
 * A004288 Least positive multiple of n written in base 8 using only 0 and 1.
 * @author Sean A. Irvine
 */
public class A004288 extends A004283 {

  @Override
  protected Z init() {
    return Z.NEG_ONE;
  }

  @Override
  protected int base() {
    return 8;
  }
}
#!queue	A004290	1	->	0	A004283	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;

/**
 * A004290 Least positive multiple of n that when written in base 10 uses only 0's and 1's.
 * @author Sean A. Irvine
 */
public class A004290 extends A004283 {

  @Override
  protected Z init() {
    return Z.NEG_ONE;
  }

  @Override
  protected int base() {
    return 10;
  }
}
#!queue	A005033	0	->	1	A001764	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.CyclicGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a001.A001764;

/**
 * A005033 Number of nonequivalent dissections of a polygon into n quadrilaterals by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A005033 extends A001764 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final CycleIndex mC4 = new CyclicGroup(4).cycleIndex();
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    mU.add(new Q(super.next()));
    return mC4.apply(RING.create(mU), ++mN).coeff(mN).toZ();
  }
}

#!queue	A005035	0	->	1	A001764	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a001.A001764;

/**
 * A005035 Number of nonequivalent dissections of a polygon into n quadrilaterals by nonintersecting diagonals rooted at a cell up to rotation and reflection.
 * @author Sean A. Irvine
 */
public class A005035 extends A001764 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = -1;

  {
    mU.add(new Q(super.next()));
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mU.add(new Q(super.next()));
    final Polynomial<Q> u = RING.create(mU);
    final Q a = RING.pow(u, 4, mN).coeff(mN);
    final Polynomial<Q> u2 = u.substitutePower(2);
    final Q b = RING.pow(u2, 2, mN).coeff(mN).multiply(3);
    final Q c = u.substitutePower(4).coeff(mN).multiply(2);
    final Polynomial<Q> den = RING.pow(RING.subtract(RING.one(), u2.shift(1)), 2, mN);
    final Q d = RING.coeff(u2, den, mN).multiply(2);
    return a.add(b).add(c).add(d).divide(8).toZ();
  }
}

#!queue	A005037	0	->	1	A002293	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.CyclicGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002293;

/**
 * A005037 Number of nonequivalent dissections of a polygon into n pentagons by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A005037 extends A002293 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final CycleIndex mC4 = new CyclicGroup(5).cycleIndex();
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    mU.add(new Q(super.next()));
    return mC4.apply(RING.create(mU), ++mN).coeff(mN).toZ();
  }
}

#!queue	A005038	0	->	1	A002293	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.CyclicGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002293;

/**
 * A005038 Number of nonequivalent dissections of a polygon into n pentagons by nonintersecting diagonals up to rotation..
 * @author Sean A. Irvine
 */
public class A005038 extends A002293 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final CycleIndex mC5 = new CyclicGroup(5).cycleIndex();
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    mU.add(new Q(super.next()));
    final Polynomial<Q> u = RING.create(mU);
    final Polynomial<Q> u2 = u.substitutePower(2, mN);
    final Z a = RING.pow(u, 2, mN).coeff(mN).subtract(u2.coeff(mN)).toZ().divide2();
    return mC5.apply(u, mN).coeff(mN - 1).toZ().subtract(a);
  }
}

#!queue	A005039	0	->	1	A002293	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002293;

/**
 * A005039 Number of nonequivalent dissections of a polygon into n pentagons by nonintersecting diagonals rooted at a cell up to rotation and reflection.
 * @author Sean A. Irvine
 */
public class A005039 extends A002293 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = -1;

  {
    mU.add(new Q(super.next()));
  }

  @Override
  public Z next() {
    ++mN;
    mU.add(new Q(super.next()));
    final Polynomial<Q> u = RING.create(mU);
    final Polynomial<Q> u2 = u.substitutePower(2, mN);
    final Q a = RING.pow(u, 5, mN).coeff(mN);
    final Q b = u.substitutePower(5, mN).coeff(mN).multiply(4);
    final Q c = RING.pow(u2, 2, mN).coeff(mN).multiply(5);
    final Q d = RING.pow(u2, 4, mN).shift(1).coeff(mN).multiply(5);
    return a.add(b).add(c).add(d).toZ().divide(10);
  }
}

#!queue	A005049	4	->	5	A005048	--------------------------------
package irvine.oeis.a005;

/**
 * A005049 Minimal span of set of n elements with no 5-term arithmetic progression.
 * @author Sean A. Irvine
 */
public class A005049 extends A005048 {

  @Override
  protected int getProgressionLength() {
    return 5;
  }
}

#!queue	A005050	4	->	6	A005048	--------------------------------
package irvine.oeis.a005;

/**
 * A005050 Minimal span of set of n elements with no 6-term arithmetic progression.
 * @author Sean A. Irvine
 */
public class A005050 extends A005048 {

  @Override
  protected int getProgressionLength() {
    return 6;
  }
}

#!queue	A005263	1	->	0	A005264	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A005263 Number of labeled Greg trees.
 * @author Sean A. Irvine
 */
public class A005263 extends A005264 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private final List<Q> mB = new ArrayList<>();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Q.ZERO);
    } else {
      mF = mF.multiply(mN);
      mB.add(new Q(super.next(), mF));
    }
    final Polynomial<Q> b = RING.create(mB);
    return RING.subtract(RING.add(RING.one(), b), RING.pow(b, 2, mN)).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A005291	0	->	1	A005290	--------------------------------
package irvine.oeis.a005;

/**
 * A005291 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005291 extends A005290 {

  @Override
  protected int degree() {
    return 1;
  }
}
#!queue	A005292	0	->	2	A005290	--------------------------------
package irvine.oeis.a005;

/**
 * A005292 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005292 extends A005290 {

  @Override
  protected int degree() {
    return 2;
  }
}
#!queue	A005293	0	->	3	A005290	--------------------------------
package irvine.oeis.a005;

/**
 * A005293 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005293 extends A005290 {

  @Override
  protected int degree() {
    return 3;
  }
}
#!queue	A005294	0	->	4	A005290	--------------------------------
package irvine.oeis.a005;

/**
 * A005294 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005294 extends A005290 {

  @Override
  protected int degree() {
    return 4;
  }
}
#!queue	A005304	0	->	1	A005303	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005304 Representation degeneracies for Ramond strings.
 * @author Sean A. Irvine
 */
public class A005304 extends A005303 {

  // I'm not sure that the continuation of this power function is correct.

  private static final int[] IRREGULAR_POWERS = {0, 1, 1, 3, 3, 4, 3, 4};

  @Override
  protected int power(final int n) {
    return n < IRREGULAR_POWERS.length ? IRREGULAR_POWERS[n] : ((n & 1) == 0 ? 2 : 4);
  }

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A005308	0	->	1	A005303	--------------------------------
package irvine.oeis.a005;

/**
 * A005308 Bosonic string states.
 * @author Sean A. Irvine
 */
public class A005308 extends A005303 {

  @Override
  protected int power(final int n) {
    return n <= 1 ? 0 : (n - 2) / 2;
  }
}
#!queue	A005321	1	->	0	A005327	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.List;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005321 Upper triangular n X n (0,1)-matrices with no zero rows or columns.
 * @author Sean A. Irvine
 */
public class A005321 extends A005327 {

  private final List<Z> mA = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mA.add(super.next());
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      sum = sum.add(Binomial.binomial(mN, k).multiply(mA.get(k)));
    }
    return sum;
  }
}
#!queue	A005334	2	->	1	A123301	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a123.A123301;

/**
 * A005334 Number of labeled nonseparable (or 2-connected) bicolored graphs with n nodes of the first color and n nodes of the second color.
 * @author Sean A. Irvine
 */
public class A005334 extends A123301 {

  protected int mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A005347	2	->	1	A005579	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005347 First differences of A005579.
 * @author Sean A. Irvine
 */
public class A005347 extends A005579 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z a = super.next();
    final Z b = a.subtract(mA);
    mA = a;
    return b;
  }
}

#!queue	A005396	0	->	2	A006774	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a006.A006774;

/**
 * A005396 Number of 2n-step polygons on honeycomb.
 * @author Sean A. Irvine
 */
public class A005396 extends A006774 {

  @Override
  public Z next() {
    return super.next().multiply(Math.max(1, mN));
  }
}
#!queue	A005398	2	->	3	A003288	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a003.A003288;

/**
 * A005398 Number of n-step polygons on f.c.c. lattice.
 * @author Sean A. Irvine
 */
public class A005398 extends A003288 {

  @Override
  protected long search() {
    return search(0, 0, 0, 1, 1, 0, mN, 3);
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(search()).multiply2().divide(mN + 1);
  }

}
#!queue	A005438	0	->	1	A005437	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005438 Column of Kempner tableau.
 * @author Sean A. Irvine
 */
public class A005438 extends A005437 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return mPrev[(mPrev.length - 1) / 2 + 1];
  }
}

#!queue	A005513	12	->	6	A005516	--------------------------------
package irvine.oeis.a005;

/**
 * A005513 Number of n-bead bracelets (turnover necklaces) of two colors with 6 red beads and n-6 black beads.
 * @author Sean A. Irvine
 */
public class A005513 extends A005516 {

  @Override
  protected int beads() {
    return 6;
  }
}
#!queue	A005514	12	->	8	A005516	--------------------------------
package irvine.oeis.a005;

/**
 * A005514 Number of n-bead bracelets (turnover necklaces) with 8 red beads and n-8 black beads.
 * @author Sean A. Irvine
 */
public class A005514 extends A005516 {

  @Override
  protected int beads() {
    return 8;
  }
}
#!queue	A005515	12	->	10	A005516	--------------------------------
package irvine.oeis.a005;

/**
 * A005515 Number of n-bead bracelets (turnover necklaces) of two colors with 10 red beads and n-10 black beads.
 * @author Sean A. Irvine
 */
public class A005515 extends A005516 {

  @Override
  protected int beads() {
    return 10;
  }
}
#!queue	A005545	2	->	3	A003288	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003288;

/**
 * A005545 Number of n-step self-avoiding walks on f.c.c. lattice from (0,0,0) to (0,1,3).
 * @author Sean A. Irvine
 */
public class A005545 extends A003288 {

  @Override
  protected int first() {
    return 3;
  }

  @Override
  protected long search() {
    final int tx = 0;
    final int ty = 1;
    final int tz = 3;
    // todo Cf. A003288 there are probably exploitable symmetries here
    return search(0, 0, 0, tx, ty, tz, mN, 1); // Basic search
  }
}
#!queue	A005546	2	->	3	A003288	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003288;

/**
 * A005546 Number of n-step self-avoiding walks on f.c.c. lattice from (0,0,0) to (0,3,3).
 * @author Sean A. Irvine
 */
public class A005546 extends A003288 {

  @Override
  protected int first() {
    return 3;
  }

  @Override
  protected long search() {
    final int tx = 0;
    final int ty = 3;
    final int tz = 3;
    //return search(0, 0, 0, tx, ty, tz, mN, 1); // Basic search
    use(0, 0, 0);
    return search(0, 1, 1, tx, ty, tz, mN - 1, 1)
      + search(0, -1, -1, tx, ty, tz, mN - 1, 1)
      + search(0, 1, -1, tx, ty, tz, mN - 1, 2)
      + search(1, -1, 0, tx, ty, tz, mN - 1, 4)
      + search(1, 1, 0, tx, ty, tz, mN - 1, 4);
  }
}
#!queue	A005549	2	->	3	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005549 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (0,3).
 * @author Sean A. Irvine
 */
public class A005549 extends A003290 {

  @Override
  protected int first() {
    return 3;
  }

  @Override
  protected long search() {
    final int tx = 6;
    final int ty = 0;
    // return search(0, 0, tx, ty, mN, 1); // Basic search
    // Expanding first few links to exploit symmetries
    use(0, 0);
    long total = search(1, 1, tx, ty, mN - 1, 2);
    total += search(-1, 1, tx, ty, mN - 1, 2);
    use(-2, 0);
    total += search(-4, 0, tx, ty, mN - 2, 1);
    total += search(-1, 1, tx, ty, mN - 2, 2);
    total += search(-3, 1, tx, ty, mN - 2, 2);
    clear(-2, 0);
    use(2, 0);
    total += search(4, 0, tx, ty, mN - 2, 1);
    total += search(1, 1, tx, ty, mN - 2, 2);
    total += search(3, 1, tx, ty, mN - 2, 2);
    clear(2, 0);
    clear(0, 0);
    return total;
  }

}
#!queue	A005550	2	->	3	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005550 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (1,2).
 * @author Sean A. Irvine
 */
public class A005550 extends A003290 {

  @Override
  protected int first() {
    return 3;
  }

  @Override
  protected long search() {
    return search(0, 0, 5, 1, mN, 1);
  }

}
#!queue	A005551	2	->	4	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005551 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (0,4).
 * @author Sean A. Irvine
 */
public class A005551 extends A003290 {

  @Override
  protected int first() {
    return 4;
  }

  @Override
  protected long search() {
    final int tx = 8;
    final int ty = 0;
    // return search(0, 0, tx, ty, mN, 1); // Basic search
    // Expanding first few links to exploit symmetries
    use(0, 0);
    long total = search(1, 1, tx, ty, mN - 1, 2);
    total += search(-1, 1, tx, ty, mN - 1, 2);
    use(-2, 0);
    total += search(-4, 0, tx, ty, mN - 2, 1);
    total += search(-1, 1, tx, ty, mN - 2, 2);
    total += search(-3, 1, tx, ty, mN - 2, 2);
    clear(-2, 0);
    use(2, 0);
    total += search(4, 0, tx, ty, mN - 2, 1);
    total += search(1, 1, tx, ty, mN - 2, 2);
    total += search(3, 1, tx, ty, mN - 2, 2);
    clear(2, 0);
    clear(0, 0);
    return total;
  }

}
#!queue	A005552	2	->	4	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005552 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (1,3).
 * @author Sean A. Irvine
 */
public class A005552 extends A003290 {

  @Override
  protected int first() {
    return 4;
  }

  @Override
  protected long search() {
    return search(0, 0, 7, 1, mN, 1);
  }

}
#!queue	A005553	2	->	4	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005553 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (2,2).
 * @author Sean A. Irvine
 */
public class A005553 extends A003290 {

  @Override
  protected int first() {
    return 4;
  }

  @Override
  protected long search() {
    //return search(0, 0, 6, 2, mN, 1);
    use(0, 0);
    return search(1, 1, 6, 2, mN - 1, 2) + search(-2, 0, 6, 2, mN - 1, 2) + search(-1, 1, 6, 2, mN - 1, 2);
  }

}
#!queue	A005576	1	->	0	A259095	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a259.A259095;

/**
 * A005576 The limiting sequence [A259095(r(r+1)/2-s,r), s=0,1,2,...,r-1] for very large r.
 * @author Sean A. Irvine
 */
public class A005576 extends A259095 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final int r = mN + 1;
    return a259095(r * (r + 1) / 2 - mN, r);
  }
}

#!queue	A005588	0	->	1	A002658	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a002.A002658;

/**
 * A005588 Number of free binary trees admitting height n.
 * @author Sean A. Irvine
 */
public class A005588 extends A002658 {

  private int mN = 0;
  private final ArrayList<Z> mP = new ArrayList<>();
  private final ArrayList<Z> mQ = new ArrayList<>();

  {
    mP.add(Z.ZERO);
    mP.add(super.next());
    mQ.add(Z.ZERO);
    mQ.add(Z.ONE);
    super.next();
  }

  private Z bin2(final Z n) {
    return n.multiply(n.subtract(1)).divide2();
  }

  private Z bin3(final Z n) {
    return n.multiply(n.subtract(1)).multiply(n.subtract(2)).divide(6);
  }

  private Z p(final int h) {
    return mP.get(h);
  }

  private Z q(final int h) {
    while (h >= mQ.size()) {
      final int ha = mQ.size() - 1;
      mQ.add(mQ.get(ha).add(p(ha)));
    }
    return mQ.get(h);
  }

  private Z a(final int h) {
    return bin3(p(h).add(2)).add(bin2(p(h).add(1)).multiply(q(h)));
  }

  private Z b(final int h) {
    return bin2(p(h).add(1));
  }

  private Z d(final int h, final int i) {
    if (i == h) {
      return Z.ZERO;
    }
    if (i > h) {
      return p(h);
    }
    if (i == 1) {
      return p(h).subtract(p(h - 1));
    }
    final Z d = d(h - 1, i - 1);
    return bin2(d.add(1)).add(d.multiply(e(h - 1, i - 1)));
  }

  private Z e(final int h, final int i) {
    if (i == 1) {
      return p(h - 1);
    }
    Z sum = Z.ONE;
    for (int j = 1; j < h; ++j) {
      sum = sum.add(d(j, i));
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    Z sum = bin2(p(mN).add(1));
    for (int i = 1; i <= mN / 2; ++i) {
      final int hi = mN - i;
      sum = sum.add(a(hi));
      sum = sum.subtract(bin3(d(hi, i).add(2)));
      sum = sum.subtract(bin2(d(hi, i).add(1)).multiply(e(hi, i)));
    }
    for (int i = 1; i <= (mN + 1) / 2; ++i) {
      sum = sum.add(b(mN - i + 1));
      sum = sum.subtract(bin2(d(mN - i + 1, i).add(1)));
    }
    return sum;
  }
}

#!queue	A005618	1	->	0	A005608	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005618 a(n) = 6*a(n-1) - 8.
 * @author Sean A. Irvine
 */
public class A005618 extends A005608 {

  private int mN = -1;

  @Override
  public Z next() {
    return butlerN(++mN, 2, 2);
  }
}

#!queue	A005632	0	->	1	A122693	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a122.A122693;
import irvine.oeis.a122.A122747;
import irvine.oeis.a123.A123071;

/**
 * A005632 Bishops on a 2n+1 X 2n+1 board (see Robinson paper for details).
 * @author Sean A. Irvine
 */
public class A005632 extends A122693 {

  private final Sequence mS = new A123071();
  private final Sequence mQ = new A122747();
  private long mN = -1;

  {
    next();
  }

  @Override
  public Z next() {
    ++mN;
    if ((mN & 3) == 0) {
      return super.next().subtract(mS.next()).subtract(mQ.next()).divide(4);
    } else {
      return super.next().subtract(mS.next()).divide(4);
    }
  }
}
#!queue	A005635	2	->	0	A122749	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a122.A122693;
import irvine.oeis.a122.A122747;
import irvine.oeis.a122.A122748;
import irvine.oeis.a122.A122749;

/**
 * A005635 Number of ways of placing n non-attacking bishops on an n X n board so that every square is attacked (or occupied).
 * @author Sean A. Irvine
 */
public class A005635 extends A122749 {

  private final Sequence mC = new A122693();
  private final Sequence mQ = new A122747();
  private final Sequence mM = new A122748();
  private long mN = -1;

  private Z e() {
    return mN < 2 ? Z.EIGHT : super.next();
  }

  private Z q() {
    return (mN & 7) != 1 ? Z.ZERO : mQ.next();
  }

  private Z c() {
    return (mN & 1) == 0 ? Z.ZERO : mC.next();
  }

  @Override
  public Z next() {
    ++mN;
    return e().add(c()).add(q().add(mM.next()).multiply2()).divide(8);
  }
}
#!queue	A005655	1	->	0	A005654	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005655 Number of board configurations in Mu Torere (for one player).
 * @author Sean A. Irvine
 */
public class A005655 extends A005654 {

  private A005648 mA5648 = new A005648();
  private boolean mFirst = true;

  @Override
  public Z next() {
    final Z t;
    if (mFirst) {
      t = Z.ZERO;
      mFirst = false;
    } else {
      t = super.next().multiply2();
    }
    return t.add(mA5648.next());
  }
}
#!queue	A005671	1	->	0	A002386	--------------------------------
package irvine.oeis.a005;

import irvine.math.cr.CR;
import irvine.math.cr.ComputableReals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002386;

/**
 * A005671 Nearest integer to tan(n)^2.
 * @author Sean A. Irvine
 */
public class A005671 extends A002386 {

  private long mN = -1;

  @Override
  public Z next() {
    final CR tan = ComputableReals.SINGLETON.tan(CR.valueOf(++mN));
    return tan.multiply(tan).round();
  }
}

#!queue	A005680	0	->	1	A001285	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a001.A001285;

/**
 * A005680 A squarefree ternary sequence.
 * @author Sean A. Irvine
 */
public class A005680 extends A001285 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    final Z prev = mA;
    mA = super.next();
    if (mA.equals(prev)) {
      return Z.THREE;
    }
    return mA;
  }
}
#!queue	A005681	0	->	1	A001285	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a001.A001285;

/**
 * A005681 A squarefree quaternary sequence.
 * @author Sean A. Irvine
 */
public class A005681 extends A001285 {

  private int mPrev = super.next().intValueExact();

  @Override
  public Z next() {
    final int t = mPrev;
    mPrev = super.next().intValueExact();
    switch (t * 10 + mPrev) {
      case 11:
        return Z.ONE;
      case 12:
        return Z.TWO;
      case 21:
        return Z.THREE;
      default: // 22
        return Z.FOUR;
    }
  }
}

#!queue	A005723	0	->	1	A005190	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005723 Quadrinomial coefficients.
 * @author Sean A. Irvine
 */
public class A005723 extends A005190 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A005724	0	->	1	A008287	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a008.A008287;

/**
 * A005724 Quadrinomial coefficients.
 * @author Sean A. Irvine
 */
public class A005724 extends A008287 {

  private long mN = 0;

  @Override
  public Z next() {
    mN += 2;
    return quadrinomial(mN, 3 * mN / 2 - 1);
  }
}

#!queue	A005726	0	->	1	A008287	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a008.A008287;

/**
 * A005726 Quadrinomial coefficients.
 * @author Sean A. Irvine
 */
public class A005726 extends A008287 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return quadrinomial(mN, mN - 1);
  }
}

#!queue	A005756	1	->	2	A225171	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a225.A225171;

/**
 * A005756 Number of non-degenerate fanout-free Boolean functions of n variables having AND rank 2.
 * @author Sean A. Irvine
 */
public class A005756 extends A225171 {

  private int mN = 1;

  @Override
  public Z next() {
    return and(++mN, 2);
  }
}
#!queue	A005777	0	->	1	A259985	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a259.A259985;

/**
 * A005777 Rook polynomials.
 * @author Sean A. Irvine
 */
public class A005777 extends A259985 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return get(mN, mN - 1);
  }
}
#!queue	A005778	0	->	1	A259985	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a259.A259985;

/**
 * A005778 Rook polynomials.
 * @author Sean A. Irvine
 */
public class A005778 extends A259985 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    return get(mN, mN - 2);
  }
}
#!queue	A005870	0	->	1	A004012	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a004.A004012;

/**
 * A005870 Numbers represented by hexagonal close-packing.
 * @author Sean A. Irvine
 */
public class A005870 extends A004012 {

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (!super.next().isZero()) {
        return mN;
      }
    }
  }
}
#!queue	A005947	1	->	0	A005946	--------------------------------
package irvine.oeis.a005;

import irvine.math.MemoryFunction2;
import irvine.math.partitions.IntegerPartition;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A005947 Tumbling distance for n-input mappings with 2 steps.
 * @author Sean A. Irvine
 */
public class A005947 extends A005946 {

  protected class QFunction extends MemoryFunction2<Integer, Q> {

    private Q lambdaPar(final int[] lambda, final int n, final int m) {
      // Eqn (20)
      Q sum = Q.ZERO;
      for (int i = 1; i <= n; ++i) {
        sum = sum.add(get(i, m - 1).multiply(i).multiply(i).add(m * (long) (n - i) * i).multiply(lambda[i]));
      }
      return sum.divide(n).divide(n);
    }

    @Override
    protected Q compute(final Integer n, final Integer m) {
      if (m == 1) {
        return new Q(n - 1, n);
      }
      if (n == 2) {
        return new Q(m + 1, 4);
      }
      final Z hnm = A005947.this.get(n, m);
      // Eqn (21) Hogg & Huberman
      Q sum = Q.ZERO;
      final IntegerPartition part = new IntegerPartition(n);
      final int[] lambda = new int[n + 1];
      int[] p;
      while ((p = part.next()) != null) {
        IntegerPartition.toCountForm(p, lambda);
        Q t = Q.ONE;
        for (int k = 1; k < lambda.length; ++k) {
          t = t.multiply(A005947.this.get(k, m - 1).pow(lambda[k]));
        }
        t = t.multiply(lambdaPar(lambda, n, m));
        t = t.multiply(FACTORIAL.factorial(n));
        t = t.divide(per(lambda));
        sum = sum.add(t);
      }
      return sum.divide(hnm);
    }
  }

  protected final QFunction mQ = new QFunction();

  @Override
  public Z next() {
//    for (int m = 1; m < 5; ++m) {
//      for (int n = 1; n < 5; ++n) {
//        System.out.println("m=" + m + " n=" + n + " " + mQ.get(n, m));
//      }
//    }
    return mQ.get(++mN, 2).multiply(get(mN, 2)).multiply(mN).toZ();
  }
}
#!queue	A006080	0	->	1	A003239	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a003.A003239;

/**
 * A006080 Number of rooted projective plane trees with n nodes.
 * @author Sean A. Irvine
 */
public class A006080 extends A003239 {

  @Override
  public Z next() {
    return Z.ONE.max(super.next().divide2().add(Z.ONE.shiftLeft(mN - 2)));
  }
}

#!queue	A006141	0	->	1	A003114	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a003.A003106;
import irvine.oeis.a003.A003114;

/**
 * A006141 Number of integer partitions of n whose smallest part is equal to the number of parts.
 * @author Sean A. Irvine
 */
public class A006141 extends A003114 {

  private A003106 mOther = new A003106();

  {
    next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mOther.next());
  }
}
#!queue	A006152	0	->	1	A000262	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000262;

/**
 * A006152 Exponential generating function x*exp(x/(1-x)).
 * @author Sean A. Irvine
 */
public class A006152 extends A000262 {

  private long mN = 0;

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}

#!queue	A006197	0	->	1	A000984	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A006197 Least number not dividing binomial(2n,n).
 * @author Sean A. Irvine
 */
public class A006197 extends A000984 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z a = super.next();
    long k = 1;
    while (a.mod(++k) == 0) {
      // do nothing
    }
    return Z.valueOf(k);
  }
}
#!queue	A006198	0	->	1	A000806	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000806;

/**
 * A006198 Number of partitions into pairs.
 * @author Sean A. Irvine
 */
public class A006198 extends A000806 {

  private Z mA = super.next().abs();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next().abs();
    return mA.add(t);
  }
}
#!queue	A006199	0	->	1	A000806	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000806;

/**
 * A006199 Bessel polynomial {y_n}'(-1).
 * @author Sean A. Irvine
 */
public class A006199 extends A000806 {

  private Z mA = super.next();
  private long mN = -1;

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.add(t.multiply(++mN));
  }
}
#!queue	A006200	0	->	1	A079267	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a079.A079267;

/**
 * A006200 Number of partitions into pairs.
 * @author Sean A. Irvine
 */
public class A006200 extends A079267 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3);
  }
}
#!queue	A006220	3	->	1	A006219	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006220 From descending subsequences of permutations.
 * @author Sean A. Irvine
 */
public class A006220 extends A006219 {

  private int mN = 0;

  @Override
  public Z next() {
    return f(++mN, mN);
  }
}
#!queue	A006230	0	->	4	A000392	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000392;

/**
 * A006230 Bitriangular permutations.
 * @author Sean A. Irvine
 */
public class A006230 extends A000392 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(12).add(1);
  }
}
#!queue	A006231	0	->	1	A000522	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000522;

/**
 * A006231 a(n) = Sum_{k=2..n} n(n-1)...(n-k+1)/k.
 * @author Sean A. Irvine
 */
public class A006231 extends A000522 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    mA = mA.add(super.next()).subtract(1);
    return mA;
  }
}
#!queue	A006297	0	->	2	A269920	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A006297 Number of rooted genus-1 maps with n edges.
 * @author Sean A. Irvine
 */
public class A006297 extends A269920 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN, 1, (mN + 1) / 2);
  }
}
#!queue	A006299	0	->	4	A269920	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A006299 Number of rooted genus-2 maps with n edges.
 * @author Sean A. Irvine
 */
public class A006299 extends A269920 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2, (mN - 1) / 2);
  }
}
#!queue	A006300	0	->	2	A269920	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A006300 Number of rooted maps with n edges on torus.
 * @author Sean A. Irvine
 */
public class A006300 extends A269920 {

  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 1, k));
    }
    return sum;
  }
}
#!queue	A006312	2	->	3	A006308	--------------------------------
package irvine.oeis.a006;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A006312 Discriminants of period polynomials.
 * @author Sean A. Irvine
 */
public class A006312 extends A006308 {

//  private CR p(final int p, final int q, final int k) {
//    CR pk = CR.ONE;
//    for (int i = 0; i < p; ++i) {
//      pk = pk.multiply(etaStar(p, q, i).subtract(etaStar(p, q, i + k)));
//    }
//    return pk;
//  }

  @Override
  public Z next() {
    mP = (int) mPrime.nextPrime(mP);
    final long p2 = mP * mP;
    final Z g = ZUtils.leastPrimitiveRoot(Z.valueOf(p2));
    final int q = g.modPow(Z.valueOf(mP), Z.valueOf(p2)).intValueExact();
    final CR[] etaStar = new CR[mP];
    for (int i = 0; i < etaStar.length; ++i) {
      etaStar[i] = etaStar(mP, q, i);
    }
    // The paper gives multiple expressions for D, some where the individual
    // terms in the product are squared.  But it seems to me that the
    // squaring is unnecessary except strangely for p == 3.
    CR d = CR.ONE;
    for (int i = 0; i < mP; ++i) {
      for (int j = i + 1; j < mP; ++j) {
        d = d.multiply(etaStar[i].subtract(etaStar[j]));
      }
    }
    final Z z = d.toZ();
    return mP == 3 ? z.square() : z.abs();
  }
}

#!queue	A006326	0	->	3	A079502	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a079.A079502;

/**
 * A006326 Total preorders.
 * @author Sean A. Irvine
 */
public class A006326 extends A079502 {

  private int mN = 2;

  @Override
  public Z next() {
    return u(++mN, mN - 1);
  }
}

#!queue	A006328	0	->	3	A079502	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a079.A079502;

/**
 * A006328 Total preorders.
 * @author Sean A. Irvine
 */
public class A006328 extends A079502 {

  private int mN = 3;

  @Override
  public Z next() {
    return u(++mN, 4);
  }
}

#!queue	A006329	0	->	3	A079502	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a079.A079502;

/**
 * A006329 Total preorders.
 * @author Sean A. Irvine
 */
public class A006329 extends A079502 {

  private int mN = 3;

  @Override
  public Z next() {
    return u(++mN, mN - 2);
  }
}

#!queue	A006351	0	->	1	A000311	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000311;

/**
 * A006351 Number of series-parallel networks with n labeled edges. Also called yoke-chains by Cayley and MacMahon.
 * @author Sean A. Irvine
 */
public class A006351 extends A000311 {

  {
    super.next();
    super.next();
  }

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().multiply2();
  }
}

#!queue	A006352	1	->	0	A000203	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A006352 Coefficients in expansion of Eisenstein series E_2 (also called E_1 or G_2).
 * @author Sean A. Irvine
 */
public class A006352 extends A000203 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().multiply(-24);
  }
}

#!queue	A006380	1	->	0	A000721	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000721;

/**
 * A006380 Number of equivalence classes of 4 X n binary matrices when one can permute rows, permute columns and complement columns.
 * @author Sean A. Irvine
 */
public class A006380 extends A000721 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  protected Z t(final int n, final int m) {
    if (n == 0) {
      return Z.ONE;
    }
    final CycleIndex ci = f(n);
    final ArrayList<Polynomial<Q>> polys = new ArrayList<>();
    for (int k = 1; k <= Z.ONE.shiftLeft(n).min(Z.valueOf(m)).longValueExact(); ++k) {
      polys.add(RING.series(RING.one(), RING.oneMinusXToTheN(k), m));
    }
    final Polynomial<Q> p = ci.apply(polys, Z.valueOf(m));
    return p.coeff(m).toZ();
  }

  private int mN = -1;

  @Override
  public Z next() {
    return t(++mN, 4);
  }
}
#!queue	A006388	0	->	1	A006385	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006388 Number of planar maps with n edges and without faces of degree 1.
 * @author Sean A. Irvine
 */
public class A006388 extends A006385 {

  protected boolean isBracketPair(final int start, final int end) {
    return isPair(start, end, OPEN_BRACKET, CLOSE_BRACKET);
  }

  @Override
  protected boolean reject(final int e) {
    // Reject anything containing an adjacent pair of brackets
    for (int k = 2; k <= 2 * e; ++k) {
      if (mS[k - 1] == OPEN_BRACKET && mS[k] == CLOSE_BRACKET) {
        return true;
      }
    }
    return isBracketPair(1, 2 * e);
  }

  @Override
  public Z next() {
    planarCount(1, ++mN + 1, 1, mN + 2, mVerbose);
    return Z.valueOf(mTotalSensed);
  }
}
#!queue	A006391	0	->	1	A006385	--------------------------------
package irvine.oeis.a006;

/**
 * A006391 Number of unsensed planar maps with n edges and without loops.
 * @author Sean A. Irvine
 */
public class A006391 extends A006385 {

  {
    next();
  }

  static boolean hasLoop(final int e, final int[] s) {
    for (int k = 1; k <= 2 * e; ++k) {
      if (s[k] == OPEN_BRACKET) {
        int bopen = 1;
        int popen = 0;
        for (int j = k + 1; j <= 2 * e; ++j) {
          if (s[j] == CLOSE_BRACKET && --bopen == 0) {
            if (popen == 0) {
              return true;
            } else {
              break;
            }
          } else if (s[j] == OPEN_PAREN) {
            ++popen;
          } else if (s[j] == OPEN_BRACKET) {
            ++bopen;
          } else if (s[j] == CLOSE_PAREN && --popen < 0) {
            break;
          }
        }
      }
    }
    return false;
  }
  @Override
  protected boolean reject(final int e) {
    return hasLoop(e, mS);
  }
}
#!queue	A006395	0	->	1	A006385	--------------------------------
package irvine.oeis.a006;

import java.util.HashSet;

import irvine.util.Pair;

/**
 * A006395 Number of unsensed connected planar maps with n nodes and without loops or parallel edges.
 * @author Sean A. Irvine
 */
public class A006395 extends A006385 {

  /** Construct the sequence. */
  public A006395() {
    next();
  }

  private final HashSet<Pair<Integer, Integer>> mSeen = new HashSet<>();

  @Override
  protected boolean rejectDecode(final int e, final int[] vert) {
    mSeen.clear();
    for (int k = 1; k <= e; ++k) {
      final int j = 2 * e + 1 - k;
      final int vk = vert[k];
      final int vj = vert[j];
      if (vk == vj) {
        return true; // loop
      }
      if (!mSeen.add(new Pair<>(Math.min(vk, vj), Math.max(vk, vj)))) {
        return true; // parallel
      }
    }
    return false;
  }
}
#!queue	A006402	0	->	2	A000139	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000139;

/**
 * A006402 Number of sensed 2-connected (nonseparable) planar maps with n edges.
 * @author Sean A. Irvine
 */
public class A006402 extends A000139 {

  private final ArrayList<Z> mB = new ArrayList<>();
  {
    mB.add(null);
    mB.add(super.next());
  }

  @Override
  public Z next() {
    final int n = mB.size();
    mB.add(super.next());
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(n).divisors()) {
      final int d = dd.intValue();
      if (d != n) {
        sum = sum.add(mB.get(d).multiply(Euler.phiAsLong(n / d)).multiply(9L * d * d - 9L * d + 2L));
      }
    }
    sum = sum.add(mB.get(n).multiply2()).divide(n);
    sum = sum.add((n & 1) == 0 ? mB.get(n / 2).multiply(3 * n - 4).divide(4) : mB.get((n + 1) / 2).multiply(n + 1));
    return sum.divide(4);
  }
}
#!queue	A006403	0	->	1	A006385	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006403 Number of 2-connected planar maps with n edges.
 * @author Sean A. Irvine
 */
public class A006403 extends A006385 {

  static boolean hasCutVertex(final int e, final int[] s) {
    for (int k = 1; k <= 2 * e; ++k) {
      if (s[k] == OPEN_BRACKET || s[k] == OPEN_PAREN) {
        int bopen = s[k] == OPEN_BRACKET ? 1 : 0;
        int popen = 1 - bopen;
        for (int j = k + 1; j <= 2 * e; ++j) {
          if (popen < 0 || bopen < 0) {
            break;
          }
          if (popen == 0 && bopen == 0) {
            if (k != 1 || j != 2 * e) {
              return true;
            }
          }
          switch (s[j]) {
            case OPEN_BRACKET:
              ++bopen;
              break;
            case CLOSE_BRACKET:
              --bopen;
              break;
            case OPEN_PAREN:
              ++popen;
              break;
            case CLOSE_PAREN:
              --popen;
              break;
            default:
              throw new RuntimeException();
          }
        }
      }
    }
    return false;
  }

  @Override
  protected boolean reject(final int e) {
    // Check for a cut-vertex
    return hasCutVertex(e, mS);
  }

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ZERO;
    }
    return Z.valueOf(planarCount(2, mN, 2, mN, mVerbose));
  }
}
#!queue	A006447	0	->	1	A170896	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a170.A170896;
import irvine.util.Pair;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A006447 Consider a 2-D cellular automaton generated by the Schrandt-Ulam rule of A170896, but confined to a semi-infinite strip of width n, starting with one ON cell at the top left corner; a(n) is the period of the resulting structure.
 * @author Sean A. Irvine
 */
public class A006447 extends A170896 {

  private int mN = 0;

  @Override
  protected boolean accept(final Pair<Integer, Integer> pt) {
    return pt.left() >= 0 && pt.right() >= 0 && pt.right() < mN;
  }

  @Override
  public Z next() {
    mN++;
    reset();
    // Might be better to convert each column of image into an integer and look for period of that sequence
    final LongDynamicBooleanArray[] plane = new LongDynamicBooleanArray[mN];
    for (int k = 0; k < mN; ++k) {
      plane[k] = new LongDynamicBooleanArray();
    }
    int iter = -1;
    for (int k = 0; k < 2 * mN; ++k) {
      // A little initial run up before we even begin looking
      stepAutomata(plane);
    }
    while (true) {
      ++iter;
      stepAutomata(plane);
      for (int period = 1; period < iter; ++period) {
        boolean ok = true;
        final int start = iter / 2;
        for (int i = 0; i < mN; ++i) {
          if (plane[i].isSet(start) != plane[i].isSet(start + period) || plane[i].isSet(start) != plane[i].isSet(start + 2 * period)) {
            ok = false;
            break;
          }
        }
        if (ok) {
          // Do a more careful check
          for (int s = start + 1; s < period; ++s) {
            for (int i = 0; i < mN; ++i) {
              if (plane[i].isSet(start) != plane[i].isSet(start + period)) {
                ok = false;
                break;
              }
            }
          }
          if (ok) {
            return Z.valueOf(period);
          }
        }
      }
    }
  }

  private void stepAutomata(final LongDynamicBooleanArray[] plane) {
    super.next();
    for (final Pair<Integer, Integer> pt : mNewlyOn) {
      plane[pt.right()].set(pt.left());
    }
  }
}
#!queue	A006540	1	->	0	A006538	--------------------------------
package irvine.oeis.a006;

/**
 * A006540 Denominators of worst case for Engel expansion.
 * @author Sean A. Irvine
 */
public class A006540 extends A006538 {

  @Override
  protected long v(final long a, final long k) {
    return (k - a % k) % k;
  }
}
#!queue	A006572	1	->	0	A111999	--------------------------------
package irvine.oeis.a006;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a111.A111999;

/**
 * A006572 Numerators of an asymptotic expansion for the number of forests on n nodes (A001858).
 * @author Sean A. Irvine
 */
public class A006572 extends A111999 {

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = -1;

  protected Z select(final Q n) {
    return n.num();
  }

  @Override
  public Z next() {
    ++mN;
    Q sum = Q.ZERO;
    for (int k = 1; k <= mN / 2; ++k) {
      final Q v = new Q(get((long) mN, 2L * k - 1).abs(), mF.factorial(mN - k).shiftLeft(mN - k));
      sum = sum.signedAdd((k & 1) != 0, v);
      //System.out.println(mN + " k= " + k + " adding " + v + " sum now: " + sum);
    }
    return select(sum);
  }
}
#!queue	A006589	0	->	-1	A001792	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a001.A001792;

/**
 * A006589 a(n) = (n+3)*2^n - 1.
 * @author Sean A. Irvine
 */
public class A006589 extends A001792 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A006614	3	->	4	A006613	--------------------------------
package irvine.oeis.a006;

/**
 * A006614 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006614 extends A006613 {

  @Override
  protected int j() {
    return 4;
  }
}

#!queue	A006617	3	->	2	A006613	--------------------------------
package irvine.oeis.a006;

/**
 * A006617 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006617 extends A006613 {

  @Override
  protected int cols() {
    return mN + 1;
  }

  @Override
  protected int init() {
    return 1;
  }
}

#!queue	A006620	3	->	2	A006613	--------------------------------
package irvine.oeis.a006;

/**
 * A006620 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006620 extends A006613 {

  @Override
  protected int j() {
    return 2;
  }

  @Override
  protected int cols() {
    return mN + 1;
  }
}

#!queue	A006623	3	->	4	A006613	--------------------------------
package irvine.oeis.a006;

/**
 * A006623 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006623 extends A006613 {

  @Override
  protected int cols() {
    return mN - 1;
  }

  @Override
  protected int init() {
    return 3;
  }
}

#!queue	A006647	1	->	4	A001430	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001430;
import irvine.oeis.a001.A001433;

/**
 * A006647 Number of graphs with n nodes, n-2 edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006647 extends A001430 {

  private Sequence mA = new A001433();
  {
    mA.next();
    mA.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A006651	1	->	4	A001430	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001430;
import irvine.oeis.a048.A048180;

/**
 * A006651 Number of graphs with n nodes, n+2 edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006651 extends A001430 {

  private Sequence mA = new A048180();

  @Override
  public Z next() {
    return mA.next().subtract(numberLinearGraphs(++mN + 2, mN + 5));
  }
}
#!queue	A006657	0	->	2	A005316	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;
import java.util.Collections;

import irvine.math.z.Z;
import irvine.oeis.a005.A005316;
import irvine.util.Pair;

/**
 * A006657 Number of closed meanders with 2 components and 2n bridges.
 * @author Andrew Howroyd
 * @author Sean A. Irvine (Java port)
 */
public class A006657 extends A005316 {

  /**
   * Processing component to count meander systems or semi-meander systems by number of component.
   * A006657, A006658, A008828, A046721, A046726
   */
  public static class MeandersByComponents extends MeanderProblem implements StateMachine<Pair<Integer, Z>> {
    private final Z mLimit;
    private final Integer mMaxComponents;
    private final int mRemainingBridges;

    /**
     * Construct meanders by components.
     * @param remainingBridges remaining bridges
     * @param maxComponents maximum number of components
     */
    public MeandersByComponents(final int remainingBridges, final Integer maxComponents) {
      super(remainingBridges);
      mRemainingBridges = remainingBridges;
      mLimit = Z.ONE.shiftLeft(2 + (WORD_SHIFT * remainingBridges));
      mMaxComponents = remainingBridges == 0 || maxComponents == null ? null : maxComponents - 1;
    }

    /**
     * Initial states for semi-meander systems.
     * @param windingPredicate winding predicate
     * @return initial states
     */
    public Iterable<Pair<Integer, Z>> semiMeanderInitialStates(final Func<Integer, Boolean> windingPredicate) {
      final ArrayList<Pair<Integer, Z>> res = new ArrayList<>();
      Z bits = Z.ONE;
      Z state = pack(bits, bits);
      int winding = 0;
      while (state.compareTo(mLimit) < 0) {
        if ((winding & 1) == (mRemainingBridges & 1) && (windingPredicate == null || windingPredicate.f(winding))) {
          res.add(new Pair<>(0, state));
        }
        ++winding;
        bits = bits.shiftLeft(WORD_SHIFT).or(Z.ONE);
        state = pack(bits, bits);
      }
      return res;
    }

    @Override
    public Iterable<Pair<Integer, Z>> enumerate(final Pair<Integer, Z> state) {
      final int n = state.left();
      final ArrayList<Pair<Integer, Z>> res = new ArrayList<>();
      for (final Pair<Integer, Z> next : enumeratePossibilities(state.right(), (action, lower, upper) -> new Pair<>(action == Action.CLOSE_LOOP ? n + 1 : n, packSymmetrical(lower, upper)))) {
        if ((mLimit.signum() < 0 || next.right().compareTo(mLimit) < 0) && (mMaxComponents == null || state.left() <= mMaxComponents)) {
          res.add(next);
        }
      }
      return res;
    }
  }

  private int mN = components() * 2 - 2;

  protected Iterable<Pair<Integer, Z>> initialStates(final MeandersByComponents mbc) {
    // Initial states for closed meander systems.
    return Collections.singleton(new Pair<>(0, DEFAULT_INITIAL_STATE));
  }

  protected int components() {
    return 2;
  }

  @Override
  public Z next() {
    mN += 2;
    final SimpleProcessor<Pair<Integer, Z>> processor = new SimpleProcessor<Pair<Integer, Z>>() {
      @Override
      protected Z total(final Iterable<Pair<Pair<Integer, Z>, Z>> counts) {
        Z count = Z.ZERO;
        for (final Pair<Pair<Integer, Z>, Z> e : counts) {
          if (e.left().left() == components()) {
            count = count.add(e.right());
          }
        }
        return count;
      }
    };
    processor.setCreateStateMachine(k -> new MeandersByComponents(k, components()));
    return processor.process(mN, initialStates(new MeandersByComponents(mN, components())));
  }
}
#!queue	A006760	0	->	1	A255487	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a038.A038119;
import irvine.oeis.a255.A255487;

/**
 * A006760 Number of one-sided 4-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006760 extends A255487 {

  private final A038119 mA = new A038119();

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A006761	0	->	1	A290305	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a068.A068870;
import irvine.oeis.a290.A290305;

/**
 * A006761 Number of one-sided 5-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006761 extends A290305 {

  private final A068870 mA = new A068870();

  {
    next(); // skip 0th term
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A006762	0	->	1	A001168	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a001.A001168;

/**
 * A006762 Number of strictly 2-dimensional fixed polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006762 extends A001168 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.ZERO.max(super.next().subtract(2));
  }
}
#!queue	A006765	0	->	1	A000105	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000105;

/**
 * A006765 Number of strictly 2-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006765 extends A000105 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A006768	0	->	1	A290305	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a068.A068870;
import irvine.oeis.a290.A290305;

/**
 * A006768 Number of 5-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006768 extends A290305 {

  private final A068870 mA = new A068870();

  {
    next(); // skip 0th term
  }

  @Override
  public Z next() {
    final Z c = super.next();
    long sym = 0;
    for (final FiveDPackedPolyomino p : mPolysB) {
      if (p.isSymmetric()) {
        ++sym;
      }
    }
    return Z.ONE.max(c.add(sym).divide2()).subtract(mA.next());
  }
}
#!queue	A006802	0	->	1	A000055	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000055;

/**
 * A006802 Log of e.g.f. for trees A000055(n-1).
 * @author Sean A. Irvine
 */
public class A006802 extends A000055 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mA55 = new ArrayList<>();
  private Z mF = Z.ONE;

  private int mN = 0;

  {
    mA55.add(Q.ZERO);
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mA55.add(new Q(super.next(), mF));
    return RING.log1p(RING.create(mA55), mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A006827	0	->	1	A000041	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;
import irvine.oeis.a002.A002219;

/**
 * A006827 Number of partitions of 2n with all subsums different from n.
 * @author Sean A. Irvine
 */
public class A006827 extends A000041 {

  private final A002219 mA = new A002219();

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next().subtract(mA.next());
  }
}
#!queue	A006854	0	->	1	A006853	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A006854 Nonantipodal balanced colorings of n-cube.
 * @author Sean A. Irvine
 */
public class A006854 extends A006853 {

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN <= 2) {
      return Z.ONE;
    }
    Z sum = Z.ONE; // A_{n,0} = 1
    final ArrayList<Z> prev = new ArrayList<>();
    prev.add(Z.ONE);
    for (int k = 1; k <= (1L << mN) / 4; ++k) {
      Z t = bigN(mN, 2 * k);
      for (int i = 0; i < k; ++i) {
        t = t.subtract(Binomial.binomial((1L << (mN - 1)) - 2 * i, k - i).multiply(prev.get(i)));
      }
      prev.add(t);
      sum = sum.add(t);
    }
    return sum;
  }
}
#!queue	A006967	1	->	0	A084894	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a084.A084894;

/**
 * A006967 Number of graceful permutations of length n.
 * @author Sean A. Irvine
 */
public class A006967 extends A084894 {

  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mF = mF.multiply(mN);
    return mF.subtract(super.next());
  }
}
#!queue	A006978	0	->	1	A006977	--------------------------------
package irvine.oeis.a006;

/**
 * A006978 Successive states of the Rule 110 cellular automaton defined by 000, 001, 010, 011, ..., 111 -&gt; 0,1,1,1,0,1,1,0 when started with a single ON cell.
 * @author Sean A. Irvine
 */
public class A006978 extends A006977 {

  private static final boolean[] A = {false, true, true, true, false, true, true, false};

  @Override
  protected boolean isSet(final int v) {
    return A[v];
  }
}
#!queue	A007042	0	->	1	A000041	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A007042 Left diagonal of partition triangle A047812.
 * @author Sean A. Irvine
 */
public class A007042 extends A000041 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(2);
  }
}
#!queue	A007045	1	->	2	A047812	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a047.A047812;

/**
 * A007045 Second (lower) diagonal of partition triangle A047812.
 * @author Sean A. Irvine
 */
public class A007045 extends A047812 {

  private int mN = 1;

  @Override
  public Z next() {
    if (++mN == 2) {
      return Z.ZERO;
    }
    return get(mN).coeff((mN - 3) * (mN + 1));
  }
}
#!queue	A007049	1	->	3	A007048	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007049 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007049 extends A007048 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2L);
  }
}
#!queue	A007050	1	->	6	A007048	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007050 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007050 extends A007048 {

  private long mN = 5;

  @Override
  public Z next() {
    return get(++mN, 3L);
  }
}
#!queue	A007075	3	->	1	A007046	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007075 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007075 extends A007046 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 1L);
  }
}
#!queue	A007076	3	->	6	A007046	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007076 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007076 extends A007046 {

  private long mN = 5;

  @Override
  public Z next() {
    return get(++mN, 3L);
  }
}
#!queue	A007150	0	->	1	A000568	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a000.A000568;

/**
 * A007150 2-part of number of tournaments on n nodes.
 * @author Sean A. Irvine
 */
public class A007150 extends A000568 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    t.makeOdd();
    return Z.valueOf(t.auxiliary());
  }
}
#!queue	A007161	1	->	0	A007165	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A007161 Number of blobs with vertical symmetry.
 * @author Sean A. Irvine
 */
public class A007161 extends A007165 {

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private Polynomial<Z> mH = RING.zero();
  private Polynomial<Z> mC = RING.x();
  private int mN = 0;

  protected Z select(final Polynomial<Z> c, final Polynomial<Z> d, final int n) {
    return c.coeff(2 * n - 1);
  }

  @Override
  public Z next() {
    ++mN;
    final int n = 2 * mN;
    mH = RING.add(mH, RING.monomial(super.next(), n));
    final Polynomial<Z> d = RING.add(RING.x(), RING.multiply(mH, mC, n));
    mC = RING.add(RING.x(), RING.series(RING.pow(d, 3, n), RING.subtract(RING.one(), RING.pow(d, 2, n)), n));
    return select(mC, d, mN);
  }
}
#!queue	A007168	0	->	1	A007166	--------------------------------
package irvine.oeis.a007;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A007168 P-graphs with 2n edges.
 * @author Sean A. Irvine
 */
public class A007168 extends A007166 {

  @Override
  protected Z select(final Polynomial<Z> s, final Polynomial<Z> b, final int n) {
    Polynomial<Z> a = RING.one();
    for (int i = 1; i < 2 * n; i += 2) {
      a = RING.multiply(a, RING.pow(RING.oneMinusXToTheN(i), s.coeff(i), 2 * n));
    }
    return RING.coeff(RING.one(), a, 2 * n);
  }
}
#!queue	A007169	0	->	1	A003168	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.CyclicGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a003.A003168;

/**
 * A007169 Number of Q-graphs rooted at a polygon.
 * @author Sean A. Irvine
 */
public class A007169 extends A003168 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private int mN = 0;
  private CycleIndex mCycleIndexSum = new CycleIndex("C");
  private Polynomial<Q> mB = RING.monomial(new Q(super.next()), 1);

  @Override
  public Z next() {
    mN += 2;
    mCycleIndexSum.add(new CyclicGroup(mN + 2).cycleIndex());
    mB = RING.add(mB, RING.monomial(new Q(super.next()), mN + 1));
    //System.out.println("u=" + u);
    final Polynomial<Q> u = mCycleIndexSum.apply(mB, mN + 1);
    return u.coeff(mN).toZ();
  }
}
#!queue	A007219	0	->	1	A006718	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a006.A006718;

/**
 * A007219 Number of golygons of order 8n (or serial isogons of order 8n).
 * @author Sean A. Irvine
 */
public class A007219 extends A006718 {

  {
    super.next(); // skip 0th term
  }

  @Override
  public Z next() {
    return super.next().divide(4);
  }
}
#!queue	A007224	2	->	4	A007223	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007224 Number of distinct perforation patterns for deriving (v,b) = (n+3,n) punctured convolutional codes from (2,1).
 * @author Sean A. Irvine
 */
public class A007224 extends A007223 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2).coeff(mN + 3);
  }
}
#!queue	A007225	2	->	5	A007223	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007225 Number of distinct perforation patterns for deriving (v,b) = (n+4,n) punctured convolutional codes from (2,1).
 * @author Sean A. Irvine
 */
public class A007225 extends A007223 {

  private int mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2).coeff(mN + 4);
  }
}
#!queue	A007242	-1	->	0	A000521	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000521;

/**
 * A007242 McKay-Thompson series of class 2a for the Monster group.
 * @author Sean A. Irvine
 */
public class A007242 extends A000521 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final List<Q> mJ = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    final Z j = super.next();
    mJ.add(new Q(++mN == 1 ? j.subtract(1728) : j));
    return RING.sqrt(RING.create(mJ), mN).coeff(mN).toZ();
  }
}
#!queue	A007312	0	->	1	A000041	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A007312 Reversion of g.f. (with constant term omitted) for partition numbers.
 * @author Sean A. Irvine
 */
public class A007312 extends A000041 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final ArrayList<Z> mP = new ArrayList<>();
  private int mN = 0;
  {
    mP.add(Z.ZERO);
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    return RING.reversion(RING.create(mP), mN).coeff(mN);
  }
}

#!queue	A007313	0	->	1	A000364	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A007313 Reversion of g.f. for Euler (secant) numbers A000364.
 * @author Sean A. Irvine
 */
public class A007313 extends A000364 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final ArrayList<Z> mP = new ArrayList<>();
  private int mN = 0;
  {
    mP.add(Z.ZERO);
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    return RING.reversion(RING.create(mP), mN).coeff(mN);
  }
}

#!queue	A007315	0	->	1	A000055	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000055;

/**
 * A007315 Reversion of g.f. (beginning with constant term) for number of trees with n nodes.
 * @author Sean A. Irvine
 */
public class A007315 extends A000055 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final Polynomial<Z> mP = RING.empty();
  private int mN = 0;
  {
    mP.add(Z.ZERO);
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    return RING.reversion(mP, mN).coeff(mN);
  }
}

#!queue	A007316	0	->	1	A000111	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.a000.A000111;

/**
 * A007316 Reversion of g.f. for Euler numbers A000111(n-1).
 * @author Sean A. Irvine
 */
public class A007316 extends A000111 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final ArrayList<Z> mP = new ArrayList<>();
  private int mN = 0;
  {
    mP.add(Z.ZERO);
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    return RING.reversion(RING.create(mP), mN).coeff(mN);
  }
}

#!queue	A007344	3	->	4	A007343	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007344 Number of homogeneous primitive partition identities of degree 6 with largest part n.
 * @author Sean A. Irvine
 */
public class A007344 extends A007343 {

  private int mN = 3;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    mA = mA.add(get(mN, 3));
    return mA;
  }
}
#!queue	A007360	0	->	1	A051424	--------------------------------
package irvine.oeis.a007;

import java.util.Collections;

import irvine.math.z.Z;
import irvine.oeis.a051.A051424;

/**
 * A007360 Number of partitions of n into distinct and pairwise relatively prime parts.
 * @author Sean A. Irvine
 */
public class A007360 extends A051424 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return b(mN, mN, Collections.emptySet())
      .subtract(b(mN - 2, mN - 2, Collections.emptySet()));
  }
}
#!queue	A007383	0	->	1	A000931	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A007383 Number of strict first-order maximal independent sets in path graph.
 * @author Sean A. Irvine
 */
public class A007383 extends A000931 {

  {
    for (int k = 0; k < 7; ++k) {
      next();
    }
  }

  private long mN = 1;
  private boolean mAlternate = true;

  @Override
  public Z next() {
    if (mAlternate) {
      ++mN;
    }
    mAlternate = !mAlternate;
    return super.next().subtract(mAlternate ? mN : 1);
  }
}
#!queue	A007391	0	->	1	A001608	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a001.A001608;

/**
 * A007391 Number of strict first-order maximal independent sets in cycle graph.
 * @author Sean A. Irvine
 */
public class A007391 extends A001608 {

  {
    super.next();
  }

  private long mN = -2;
  private boolean mAlternate = false;

  @Override
  public Z next() {
    mAlternate = !mAlternate;
    if (mAlternate) {
      mN += mN == 0 ? 3 : 2;
    }
    return super.next().subtract(mAlternate ? mN : 2);
  }
}
#!queue	A007454	0	->	1	A003430	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a003.A003430;

/**
 * A007454 Number of unlabeled disconnected series-parallel posets with n nodes.
 * @author Sean A. Irvine
 */
public class A007454 extends A003430 {

  private final Sequence mConnected = new A007453();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.ONE.max(super.next().subtract(mConnected.next()));
  }
}

#!queue	A007536	0	->	1	A000384	--------------------------------
package irvine.oeis.a007;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A007536 Numbers that are not the sum of 3 hexagonal numbers (probably finite).
 * @author Sean A. Irvine
 */
public class A007536 extends A000384 {

  // This sequence is likely finite and this generates all the terms

  private long mN = 3;
  private long mR = 0;
  private final TreeSet<Long> mForbidden = new TreeSet<>();

  @Override
  public Z next() {
    while (true) {
      ++mN;
      while (mN >= mR) {
        mR = super.next().longValueExact();
        final A000384 a = new A000384();
        long s;
        while ((s = a.next().longValueExact()) <= mR) {
          final A000384 b = new A000384();
          long t;
          while ((t = b.next().longValueExact()) <= s) {
            mForbidden.add(mR + s + t);
          }
        }
      }
      if (!mForbidden.remove(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A007665	0	->	1	A056556	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a056.A056556;

/**
 * A007665 Tower of Hanoi with 5 pegs.
 * @author Sean A. Irvine
 */
public class A007665 extends A056556 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    final Z a = super.next();
    return Z.ONE
      .add(a.multiply(a.subtract(1)).divide2())
      .add(mN)
      .subtract(a.multiply(a.add(1)).multiply(a.add(2)).divide(6))
      .shiftLeft(a.longValueExact())
      .subtract(1);
  }
}
#!queue	A007704	0	->	1	A006277	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a006.A006277;

/**
 * A007704 a(n+2) = (a(n) - 1)*a(n+1) + 1.
 * @author Sean A. Irvine
 */
public class A007704 extends A006277 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A007717	1	->	0	A318951	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A007717 Number of symmetric polynomial functions of degree n of a symmetric matrix (of indefinitely large size) under joint row and column permutations. Also number of multigraphs with n edges (allowing loops) on an infinite set of nodes.
 * @author Sean A. Irvine
 */
public class A007717 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : rowSumMats(mN, 2 * mN, 2);
  }
}
#!queue	A007752	0	->	1	A007750	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007752 Odd bisection of A007750.
 * @author Sean A. Irvine
 */
public class A007752 extends A007750 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A007822	0	->	1	A001415	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a001.A001415;

/**
 * A007822 Number of symmetric foldings of 2n+1 stamps.
 * @author Sean A. Irvine (Java port)
 */
public class A007822 extends A001415 {

  private int mN = 1;
  private long mCount = 0;

  private boolean isSymmetric(final int[] c, final int delta) {
    for (int k = 0; k < (c.length - 1) / 2; ++k) {
      if (c[(delta + k) % c.length] != c[(delta + c.length - 2 - k) % c.length]) {
        return false;
      }
    }
    return true;
  }

  @Override
  protected void process(final int[] a, final int[] b, final int n) {
    final int[] c = new int[a.length];
    int j = 0;
    for (int k = 0; k < b.length; k++) {
      c[k] = b[j] - j;
      j = b[j];
    }
    for (int k = 0; k < a.length; ++k) {
      if (isSymmetric(c, k)) {
        ++mCount;
      }
    }
  }

  @Override
  public Z next() {
    mN += 2;
    mCount = 0;
    foldings(new int[] {mN - 1}, true, 0, 0);
    return Z.valueOf((mCount + 1) / 2);
  }
}
#!queue	A007827	1	->	0	A000669	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000669;

/**
 * A007827 Number of homeomorphically irreducible (or series-reduced) trees with n pendant nodes, or continua with n non-cut points, or leaves.
 * @author Sean A. Irvine
 */
public class A007827 extends A000669 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private static final Polynomial<Z> X1 = Polynomial.create(1, 1);
  private Polynomial<Z> mB = RING.zero();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mB = RING.add(mB, RING.monomial(super.next(), mN));
    return RING.multiply(RING.subtract(X1, mB), mB, mN).coeff(mN);
  }
}
#!queue	A007857	0	->	1	A007226	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a000.A000108;

/**
 * A007857 Number of independent sets in rooted plane trees on n nodes.
 * @author Sean A. Irvine
 */
public class A007857 extends A007226 {

  private final A000108 mC = new A000108();

  @Override
  public Z next() {
    return super.next().subtract(mC.next());
  }
}
#!queue	A007952	1	->	0	A002491	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a002.A002491;

/**
 * A007952 Generated by a sieve: keep first number, drop every 2nd, keep first, drop every 3rd, keep first, drop every 4th, etc.
 * @author Sean A. Irvine
 */
public class A007952 extends A002491 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A007969	0	->	1	A007968	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007969 Rectangular numbers.
 * @author Sean A. Irvine
 */
public class A007969 extends A007968 {

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A007970	0	->	1	A007968	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007970 Rhombic numbers.
 * @author Sean A. Irvine
 */
public class A007970 extends A007968 {

  @Override
  public Z next() {
    while (true) {
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A007973	4	->	2	A007975	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007973 Number of permutations that are n-2 "block reversals" away from 12...n.
 * @author Sean A. Irvine
 */
public class A007973 extends A007975 {

  @Override
  protected int start() {
    return 1;
  }

  @Override
  public Z next() {
    init();
    for (int k = 0; k < mN - 2; ++k) {
      step();
    }
    return Z.valueOf(mPrev.size());
  }
}
#!queue	A007974	4	->	3	A007975	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007974 Number of permutations that are n-3 "block reversals" away from 12...n.
 * @author Sean A. Irvine
 */
public class A007974 extends A007975 {

  @Override
  protected int start() {
    return 2;
  }

  @Override
  public Z next() {
    init();
    for (int k = 0; k < mN - 3; ++k) {
      step();
    }
    return Z.valueOf(mPrev.size());
  }
}
#!queue	A008282	0	->	1	A008281	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008282 Triangle of Euler-Bernoulli or Entringer numbers read by rows: T(n,k) is the number of down-up permutations of n+1 starting with k+1.
 * @author Sean A. Irvine
 */
public class A008282 extends A008281 {

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A008283	0	->	3	A008281	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008283 Read across rows of Euler-Bernoulli or Entringer triangle.
 * @author Sean A. Irvine
 */
public class A008283 extends A008281 {

  private long mN = 2;
  private long mM = 2;

  @Override
  public Z next() {
    if (++mM >= mN - 1) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A008291	0	->	2	A008290	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008291 Triangle of rencontres numbers.
 * @author Sean A. Irvine
 */
public class A008291 extends A008290 {

  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM >= mN - 1) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A008518	1	->	0	A008292	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008518 Triangle of Eulerian numbers with rows multiplied by 1 + x.
 * @author Sean A. Irvine
 */
public class A008518 extends A008292 {

  private long mN = 0;
  private long mM = 1;

  @Override
  public Z next() {
    if (++mM > mN) {
      mM = 1;
      if (++mN == 1) {
        return Z.ONE;
      }
    }
    return get(mN - 1, mM).add(get(mN - 1, mM - 1));
  }
}
#!queue	A008912	2	->	1	A008867	--------------------------------
package irvine.oeis.a008;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A008912 Truncated triangular numbers (of form n*(n-3)/2 - k^2+k*n+1 for 1&lt;=k&lt;n).
 * @author Sean A. Irvine
 */
public class A008912 extends A008867 {

  private Z mPrev = Z.ZERO;
  private int mLookahead = 0; // Heuristic lookahead
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    ++mLookahead;
    while (mSet.size() < mLookahead) {
      final Z t = super.next();
      if (t.compareTo(mPrev) > 0) {
        mSet.add(t);
      }
    }
    mPrev = mSet.pollFirst();
    return mPrev;
  }
}

#!queue	A008965	0	->	1	A000031	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.a000.A000031;

/**
 * A008965 Number of necklaces of sets of beads containing a total of n beads.
 * @author Sean A. Irvine
 */
public class A008965 extends A000031 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A009561	1	->	2	A006987	--------------------------------
package irvine.oeis.a009;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a006.A006987;

/**
 * A009561 Index of central binomial coefficient C(2n,n) within A006987.
 * @author Sean A. Irvine
 */
public class A009561 extends A006987 {

  private long mN = 1;
  private long mC = 0;

  @Override
  public Z next() {
    ++mN;
    final Z target = Binomial.binomial(2 * mN, mN);
    Z v;
    do {
      v = super.next();
      ++mC;
    } while (!v.equals(target));
    return Z.valueOf(mC);
  }
}
#!queue	A010026	1	->	2	A211318	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.a211.A211318;

/**
 * A010026 Triangle read by rows: number of permutations of 1..n by length of longest run.
 * @author Sean A. Irvine
 */
public class A010026 extends A211318 {

  private int mN = 1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM >= mN - 1) {
      ++mN;
      mM = 0;
    }
    return a(mN, mN - mM);
  }
}
#!queue	A010372	0	->	1	A000602	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.a000.A000602;

/**
 * A010372 Number of unrooted quartic trees with n (unlabeled) nodes and possessing a centroid; number of n-carbon alkanes C(n)H(2n +2) with a centroid ignoring stereoisomers.
 * @author Sean A. Irvine
 */
public class A010372 extends A000602 {

  private final A010373 mA = new A010373();
  private boolean mOdd = false;

  {
    super.next();
  }

  @Override
  public Z next() {
    mOdd = !mOdd;
    return mOdd ? super.next() : super.next().subtract(mA.next());
  }
}
#!queue	A010373	0	->	1	A000598	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.a000.A000598;

/**
 * A010373 Number of unrooted quartic trees with 2n (unlabeled) nodes and possessing a bicentroid; number of 2n-carbon alkanes C(2n)H(4n+2) with a bicentroid, ignoring stereoisomers.
 * @author Sean A. Irvine
 */
public class A010373 extends A000598 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z b = super.next();
    return b.multiply(b.add(1)).divide2();
  }
}
#!queue	A010527	1	->	0	A002193	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.a002.A002193;

/**
 * A010527 Decimal expansion of sqrt(3)/2.
 * @author Sean A. Irvine
 */
public class A010527 extends A002193 {

  @Override
  protected Z n() {
    return Z.valueOf(75);
  }
}
#!queue	A010796	0	->	1	A010790	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;

/**
 * A010796 a(n) = n!*(n+1)!/2.
 * @author Sean A. Irvine
 */
public class A010796 extends A010790 {

  {
    next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A011796	0	->	1	A051168	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a051.A051168;

/**
 * A011796 Number of irreducible alternating Euler sums of depth 6 and weight 6+2n.
 * @author Sean A. Irvine
 */
public class A011796 extends A051168 {

  protected long mN = 6;

  @Override
  public Z next() {
    return t(++mN, 6);
  }
}
#!queue	A011957	0	->	1	A001037	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a000.A000048;
import irvine.oeis.a001.A001037;
import irvine.oeis.a165.A165920;

/**
 * A011957 Number of ZnS polytypes that repeat after n layers.
 * @author Sean A. Irvine
 */
public class A011957 extends A001037 {

  // After Joerg Arndt

  private final A000048 mA48 = new A000048();
  private final A165920 mA165920 = new A165920();
  private long mN = 0;
  {
    super.next(); // skip 0th term
  }

  @Override
  public Z next() {
    if (++mN <= 2) {
      super.next(); // discard
      mA48.next(); // discard
      return Z.valueOf(mN - 1);
    }
    Z res = super.next();
    if ((mN & 1) == 0) {
      res = res.add(mA48.next().multiply(3));
    }
    if (mN % 3 == 0) {
      res = res.add(mA165920.next().multiply(4));
    }
    return res.divide(6);
  }
}
#!queue	A013583	0	->	1	A000119	--------------------------------
package irvine.oeis.a013;

import irvine.math.z.Z;
import irvine.oeis.a000.A000119;
import irvine.util.array.DynamicLongArray;

/**
 * A013583 Smallest positive number that can be written as sum of distinct Fibonacci numbers in n ways.
 * @author Sean A. Irvine
 */
public class A013583 extends A000119 {

  private long mM = -1;
  private int mN = 0;
  private final DynamicLongArray mFirst = new DynamicLongArray();

  @Override
  public Z next() {
    ++mN;
    while (mFirst.get(mN) == 0) {
      ++mM;
      final int v = super.next().intValueExact();
      if (mFirst.get(v) == 0) {
        mFirst.set(v, mM);
      }
    }
    return Z.valueOf(mFirst.get(mN));
  }
}
#!queue	A013925	4	->	5	A013924	--------------------------------
package irvine.oeis.a013;

import irvine.math.z.Z;

/**
 * A013925 Number of labeled connected graphs with n nodes and 3 cutpoints.
 * @author Sean A. Irvine
 */
public class A013925 extends A013924 {

  private int mN = 4;

  @Override
  public Z next() {
    return get(3, ++mN);
  }
}
#!queue	A014000	1	->	2	A003658	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a003.A003658;

/**
 * A014000 First coordinate of fundamental unit of real quadratic field with discriminant A003658(n), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A014000 extends A003658 {

  // Based on Keith Matthews
  // http://www.numbertheory.org/gnubc/unit
  // Looks to be almost the same as QuadraticFieldUtils.fundamentalUnit

  // Returns the fundamental unit and the norm
  protected Z[] fundamentalUnit(final Z bigD) {
    final Z d = bigD.mod(4) == 0 ? bigD.divide(4) : bigD;
    if (Z.FIVE.equals(d)) {
      return new Z[] {Z.ZERO, Z.ONE, Z.NEG_ONE};
    }
    final Z[] sqrt = d.sqrtAndRemainder();
    if (sqrt[0].isZero()) {
      // d is a perfect square, undefined
      return null;
    }
    final Z p = sqrt[0];
    final Z h = p.subtract(1).divide2();
    final Z t = h.multiply2().add(1);
    final long z = d.mod(4);
    Z b;
    Z c;
    if (z == 1) {
      b = t;
      c = Z.TWO;
    } else {
      b = p;
      c = Z.ONE;
    }
    if (d.equals(p.square().add(1))) {
      // period 1, exceptional case
      if (z == 1) {
        return new Z[] {p.subtract(1), Z.TWO, Z.NEG_ONE};
      } else {
        return new Z[] {p, Z.ONE, Z.NEG_ONE};
      }
    }
    if (d.equals(t.square().add(4))) {
      // period 1, exceptional case
      return new Z[] {h, Z.ONE, Z.NEG_ONE};
    }

    // Continued fraction expansion
    b = p.add(b).divide(c).multiply(c).subtract(b);
    c = d.subtract(b.square()).divide(c);
    Z u1 = Z.ONE;
    Z u2 = d.mod(4) == 1 ? h : p;
    Z v1 = Z.ZERO;
    Z v2 = Z.ONE;

    boolean even = true;
    while (true) {
      even = !even;
      final Z q = p.add(b).divide(c);
      final Z b0 = b;
      b = q.multiply(c).subtract(b);
      final Z c0 = c;
      c = d.subtract(b.square()).divide(c);
      final Z u0 = u1;
      final Z v0 = v1;
      final Z u = u2.multiply(q).add(u1);
      final Z v = v2.multiply(q).add(v1);
      u1 = u2;
      v1 = v2;
      u2 = u;
      v2 = v;
      // u/v is the ith convergent to sqrt(d) or (sqrt(d)-1)/2
      if (b.equals(b0)) {
        // Even period
        return new Z[] {v1.multiply(u.add(u0)).signedAdd(even, Z.ONE), v1.multiply(v.add(v0)), Z.ONE};
      }
      if (c.equals(c0)) {
        // Odd period
        return new Z[] {u.multiply(v).add(u1.multiply(v1)), v.square().add(v1.square()), Z.NEG_ONE};
      }
    }
  }

  protected Z select(final Z[] res) {
    return res[0];
  }

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    //System.out.println("Q:" + QuadraticFieldUtils.fundamentalUnitPair(n)[0] + "n=" + n);
    return select(fundamentalUnit(n));
  }
}
#!queue	A014046	1	->	2	A003658	--------------------------------
package irvine.oeis.a014;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a003.A003658;

/**
 * A014046 Second coordinate of fundamental unit of real quadratic field with discriminant A003658(n), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A014046 extends A003658 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[1];
  }
}
#!queue	A014077	1	->	2	A003658	--------------------------------
package irvine.oeis.a014;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a003.A003658;

/**
 * A014077 Norm of fundamental unit of real quadratic field with discriminant A003658(n), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A014077 extends A003658 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitNorm(super.next());
  }
}
#!queue	A014250	0	->	1	A002379	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.ComplementSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002379;

/**
 * A014250 a(n) = b(n) - c(n) where b(n) = [ (3/2)^n ] and c(n) is the n-th number not in sequence b.
 * @author Sean A. Irvine
 */
public class A014250 extends A002379 {

  private final Sequence mA = new ComplementSequence(new A002379(), Z.ONE);
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A014428	0	->	1	A007318	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a007.A007318;

/**
 * A014428 Even elements in Pascal's triangle.
 * @author Sean A. Irvine
 */
public class A014428 extends A007318 {

  @Override
  public Z next() {
    while (true) {
      final Z b = super.next();
      if (b.isEven()) {
        return b;
      }
    }
  }
}
#!queue	A014465	0	->	1	A063691	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a063.A063691;

/**
 * A014465 A063691 without zeros.
 * @author Sean A. Irvine
 */
public class A014465 extends A063691 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.signum() != 0) {
        return t;
      }
    }
  }
}
#!queue	A014531	0	->	1	A002426	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001006;
import irvine.oeis.a002.A002426;

/**
 * A014531 Form array in which n-th row is obtained by expanding (1+x+x^2)^n and taking the 2nd column from the center.
 * @author Sean A. Irvine
 */
public class A014531 extends A002426 {

  private final Sequence mA = new A001006().skip(2);

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A014537	0	->	1	A002387	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a002.A002387;

/**
 * A014537 Number of books required for n book-lengths of overhang in the harmonic book stacking problem. Sum_{i=1..a(n)} 1/i &gt;= 2n and Sum_{i=1..a(n)-1} 1/i &lt; 2n.
 * @author Sean A. Irvine
 */
public class A014537 extends A002387 {

  @Override
  public Z next() {
    if (Z.ONE.equals(super.next())) {
      super.next();
    }
    return super.next();
  }
}
#!queue	A014546	0	->	1	A000058	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a000.A000058;

/**
 * A014546 Primes in Sylvester's sequence A000058.
 * @author Sean A. Irvine
 */
public class A014546 extends A000058 {

  @Override
  public Z next() {
    while (true) {
      final Z s = super.next();
      if (s.isProbablePrime()) {
        return s;
      }
    }
  }
}
#!queue	A014547	0	->	1	A000364	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A014547 n-th Euler (secant, zig) number A000364(n) is prime.
 * @author Sean A. Irvine
 */
public class A014547 extends A000364 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z s = super.next();
      if (s.isProbablePrime()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A014578	1	->	0	A007949	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a007.A007949;

/**
 * A014578 Binary expansion of Thue constant (or Roth's constant).
 * @author Sean A. Irvine
 */
public class A014578 extends A007949 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return Z.ONE.subtract(super.next().mod(2));
  }
}
#!queue	A014600	1	->	0	A000003	--------------------------------
package irvine.oeis.a014;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.a000.A000003;

/**
 * A014600 Class numbers h(D) of imaginary quadratic orders with discriminant D == 0 or 1 mod 4, D&lt;0.
 * @author Sean A. Irvine
 */
public class A014600 extends A000003 {

  // Interleave A000003 and A014599

  private long mD = 0;
  private long mDelta = 3;

  @Override
  public Z next() {
    mD -= mDelta;
    mDelta = 4 - mDelta;
    return Z.valueOf(LongUtils.classNumber(mD));
  }
}
#!queue	A014736	1	->	0	A014493	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014736 Squares of odd triangular numbers.
 * @author Sean A. Irvine
 */
public class A014736 extends A014493 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014771	0	->	1	A014634	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014771 Squares of odd hexagonal numbers.
 * @author Sean A. Irvine
 */
public class A014771 extends A014634 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014772	0	->	1	A014635	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014772 Squares of even hexagonal numbers.
 * @author Sean A. Irvine
 */
public class A014772 extends A014635 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014822	0	->	1	A014824	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014822 Numbers k such that k divides s(k), where s(1)=1, s(j)=10*s(j-1)+j (A014824).
 * @author Sean A. Irvine
 */
public class A014822 extends A014824 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A014850	0	->	1	A000340	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a000.A000340;

/**
 * A014850 Numbers k that divide s(k), where s(1)=1, s(j)=3*s(j-1)+j.
 * @author Sean A. Irvine
 */
public class A014850 extends A000340 {

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A014981	0	->	1	A001608	--------------------------------
package irvine.oeis.a014;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a001.A001608;

/**
 * A014981 a(n) = c(prime(n))/prime(n), where c = Perrin sequence A001608 (starting 0,2,3,...) and prime(n) is the n-th prime.
 * @author Sean A. Irvine
 */
public class A014981 extends A001608 {

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      if (mPrime.isPrime(++mN)) {
        return super.next().divide(mN);
      }
      super.next();
    }
  }
}
#!queue	A015627	1	->	2	A015622	--------------------------------
package irvine.oeis.a015;

/**
 * A015627 Quadruples of different integers from [ 2,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015627 extends A015622 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015628	1	->	2	A015623	--------------------------------
package irvine.oeis.a015;

/**
 * A015628 Quadruples of different integers from [ 2,n ] with no common factors between pairs.
 * @author Sean A. Irvine
 */
public class A015628 extends A015623 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015629	1	->	2	A015625	--------------------------------
package irvine.oeis.a015;

/**
 * A015629 Quadruples of different integers from [ 2,n ] with no common factors between triples.
 * @author Sean A. Irvine
 */
public class A015629 extends A015625 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015638	1	->	2	A015634	--------------------------------
package irvine.oeis.a015;

/**
 * A015638 Number of ordered quadruples of integers from [ 2,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015638 extends A015634 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015639	1	->	2	A015635	--------------------------------
package irvine.oeis.a015;

/**
 * A015639 Number of ordered quadruples of integers from [ 2,n ] with no common factors between triples.
 * @author Sean A. Irvine
 */
public class A015639 extends A015635 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015641	1	->	2	A015640	--------------------------------
package irvine.oeis.a015;

/**
 * A015641 Number of 5-tuples of different integers from [ 2,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015641 extends A015640 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015645	1	->	2	A015644	--------------------------------
package irvine.oeis.a015;

/**
 * A015645 Number of 5-tuples of different integers from [ 2,n ] with no common factors among quadruples.
 * @author Sean A. Irvine
 */
public class A015645 extends A015644 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015649	1	->	2	A015646	--------------------------------
package irvine.oeis.a015;

/**
 * A015649 Number of 5-tuples of different integers from [ 2,n ] with no common factors among triples.
 * @author Sean A. Irvine
 */
public class A015649 extends A015646 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015651	1	->	2	A015650	--------------------------------
package irvine.oeis.a015;

/**
 * A015651 Number of ordered 5-tuples of integers from [ 2,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015651 extends A015650 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015655	1	->	2	A015653	--------------------------------
package irvine.oeis.a015;

/**
 * A015655 Number of ordered 5-tuples of integers from [ 2,n ] with no common factors among quadruples.
 * @author Sean A. Irvine
 */
public class A015655 extends A015653 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015657	1	->	2	A015656	--------------------------------
package irvine.oeis.a015;

/**
 * A015657 Number of ordered 5-tuples of integers from [ 2,n ] with no common factors among triples.
 * @author Sean A. Irvine
 */
public class A015657 extends A015656 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015699	1	->	2	A015698	--------------------------------
package irvine.oeis.a015;

/**
 * A015699 Number of 5-tuples of different integers from [ 2,n ] with no common factors among pairs.
 * @author Sean A. Irvine
 */
public class A015699 extends A015698 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015976	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015976 One iteration of Reverse and Add is needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015976 extends A015977 {

  @Override
  protected int iterations() {
    return 1;
  }
}
#!queue	A015982	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015982 Five iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015982 extends A015977 {

  @Override
  protected int iterations() {
    return 5;
  }
}
#!queue	A015990	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015990 Nine iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015990 extends A015977 {

  @Override
  protected int iterations() {
    return 9;
  }
}
#!queue	A015991	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015991 Numbers such that ten iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015991 extends A015977 {

  @Override
  protected int iterations() {
    return 10;
  }
}
#!queue	A015993	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015993 Twelve iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015993 extends A015977 {

  @Override
  protected int iterations() {
    return 12;
  }
}
#!queue	A016018	1	->	0	A016017	--------------------------------
package irvine.oeis.a016;

/**
 * A016018 Least k such that (tau(k^3)+2)/3=n.
 * @author Sean A. Irvine
 */
public class A016018 extends A016017 {

  @Override
  protected int v() {
    return 3;
  }
}
#!queue	A016020	1	->	0	A016017	--------------------------------
package irvine.oeis.a016;

/**
 * A016020 Least k such that (tau(k^4)+3)/4=n.
 * @author Sean A. Irvine
 */
public class A016020 extends A016017 {

  @Override
  protected int v() {
    return 4;
  }
}
#!queue	A016031	0	->	1	A000295	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;
import irvine.oeis.a000.A000295;

/**
 * A016031 De Bruijn's sequence: 2^(2^(n-1) - n): number of ways of arranging 2^n bits in circle so all 2^n consecutive strings of length n are distinct.
 * @author Sean A. Irvine
 */
public class A016031 extends A000295 {

  @Override
  public Z next() {
    return Z.ONE.shiftLeft(super.next().longValueExact());
  }
}
#!queue	A016048	1	->	2	A016047	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;

/**
 * A016048 Least k such that (2*p_n)*k + 1 | Mersenne(p_n), p_n = n-th prime, n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A016048 extends A016047 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2().divide(mP);
  }
}
#!queue	A016058	1	->	2	A016057	--------------------------------
package irvine.oeis.a016;

import java.util.ArrayList;

import irvine.math.z.Z;

/**
 * A016058 Primitive pseudo-powers to base 3.
 * @author Sean A. Irvine
 */
public class A016058 extends A016057 {

  // Somewhat conjectural ... seems to match entries

  private final ArrayList<Z> mPrimitive = new ArrayList<>();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      boolean ok = true;
      for (final Z p : mPrimitive) {
        final Z[] qr = t.divideAndRemainder(p);
        if (qr[1].isZero()) {
          final Z base = qr[0].isPower();
          if (Z.THREE.equals(qr[0]) || Z.THREE.equals(base)) {
            ok = false;
            break;
          }
        }
      }
      if (ok) {
        mPrimitive.add(t);
        return t;
      }
    }
  }
}
#!queue	A016059	1	->	2	A006521	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;
import irvine.oeis.a006.A006521;

/**
 * A016059 (s(n)+s(n+1))/6, where s()=A006521.
 * @author Sean A. Irvine
 */
public class A016059 extends A006521 {

  private Z mPrev = super.next();

  {
    next();
  }

  @Override
  public Z next() {
    final Z t = mPrev;
    mPrev = super.next();
    return t.add(mPrev).divide(6);
  }
}
#!queue	A016060	1	->	3	A006521	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;
import irvine.oeis.a006.A006521;

/**
 * A016060 (s(n)+s(n+1))/18, where s()=A006521.
 * @author Sean A. Irvine
 */
public class A016060 extends A006521 {

  private Z mPrev = super.next();

  {
    next();
    next();
  }

  @Override
  public Z next() {
    final Z t = mPrev;
    mPrev = super.next();
    return t.add(mPrev).divide(18);
  }
}
#!queue	A018192	0	->	1	A081054	--------------------------------
package irvine.oeis.a018;

import irvine.factor.factor.Jaguar;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Binomial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a081.A081054;

/**
 * A018192 Number of chord diagrams of degree n with an isolated chord.
 * @author Sean A. Irvine
 */
public class A018192 extends A081054 {

  // After Alexander Stoimenow

  protected Z gamma(final int d, final int c) {
    if ((c & 1) == 0) {
      Z sum = Z.ZERO;
      Z zc = Z.ONE;
      for (int i = 0; i <= d / 2; ++i) {
        if (i > 0) {
          zc = zc.multiply(c);
        }
        sum = sum.add(Binomial.binomial(d, 2 * i).multiply(zc).multiply(mF.doubleFactorial(2 * i - 1)));
      }
      return sum;
    } else if ((d & 1) == 0) {
      return Z.valueOf(c).pow(d / 2).multiply(mF.doubleFactorial(d - 1));
    } else {
      return Z.ZERO;
    }
  }

  protected Z lambda(final int e, final int d, final int c) {
    return Binomial.binomial(e + d - 1, e).multiply(gamma(e, c));
  }

  protected Polynomial<Z> lambdaStarSeries(final int c, final int k, final int n) {
    final Z[] series = new Z[n + 1];
    for (int d = 0; d <= n; ++d) {
      series[d] = lambda(d, k, c);
    }
    return Polynomial.create(series);
  }

  private Polynomial<Z> xiSeries(final int c, final int k, final int n) {
    final Z[] t = new Z[n + 1];
    for (int d = 0; d <= n; ++d) {
      t[d] = xi(c, d, k);
    }
    return Polynomial.create(t);
  }

  protected Z xiBar(final int c, final int d, final int k) {
    final int n = d - 2;
    return RING.multiply(RING.diff(psiBarSeries(n).substitutePower(2, n).shift(1)), xiSeries(c, k - 1, n), n).coeff(n);
  }

  protected Z xi(final int c, final int d, final int k) {
    final int n = d - 2 * k;
    if (n < 0 || k < 0) {
      return Z.ZERO;
    }
    return RING.multiply(RING.pow(psiBarSeries(n).substitutePower(2, n), k, n), lambdaStarSeries(c, k + 1, n), n).coeff(n);
  }

  protected Z zeta(final int c, final int d, final int k) {
    return xi(c, d, k).add(xiBar(c, d, k));
  }

  protected Z eta(final int c, final int d) {
    Z sum = Z.ZERO;
    for (int k = 1; k <= d / 2; ++k) {
      sum = sum.signedAdd((k & 1) == 1, zeta(c, d, k));
    }
    return sum;
  }

  protected Z lambda(final int n) {
    return mF.doubleFactorial(2 * n - 1);
  }

  private Z psi(final int n) {
    return lambda(n).subtract(psiBarSeries(n).coeff(n));
  }

  private Z psiBar2(final int n, final int i) {
    return RING.multiply(RING.pow(psiBarSeries(n - 1), i), lambda2Series(i + 1, n), n).coeff(n - i);
  }

  protected Polynomial<Z> lambda2Series(final int i, final int n) {
    final Z[] series = new Z[n + 1];
    for (int d = 0; d <= n; ++d) {
      series[d] = lambda(d, i);
    }
    return Polynomial.create(series);
  }

  private Z psiBar(final int n) {
    Z sum = Z.ZERO;
    for (int i = 0; i <= n; ++i) {
      sum = sum.signedAdd((i & 1) == 0, psiBar2(n, i));
    }
    return sum;
  }

  protected Z gammaTilde(final int d, final int c) {
    if (c == 1) {
      return (d & 1) == 0 ? psi(d / 2) : Z.ZERO;
    }
    if (c == 2) {
      return eta(2, d).add((d & 1) == 1 ? psiBar((d - 1) / 2).multiply(d) : Z.ZERO);
    } else {
      assert c > 2;
      return eta(c, d);
    }
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final int n2 = 2 * mN;
    for (final Z dd : Jaguar.factor(n2).divisors()) {
      final int d = dd.intValue();
      final int c = n2 / d;
      sum = sum.add(gammaTilde(d, c).multiply(Euler.phiAsLong(c)));
    }
    return sum.divide(n2);
  }
}

#!queue	A018886	0	->	1	A002379	--------------------------------
package irvine.oeis.a018;

import irvine.math.z.Z;
import irvine.oeis.a002.A002379;

/**
 * A018886 Waring's problem: least positive integer requiring maximum number of terms when expressed as a sum of positive n-th powers.
 * @author Sean A. Irvine
 */
public class A018886 extends A002379 {

  {
    super.next(); // skip 0th
  }

  @Override
  public Z next() {
    return super.next().shiftLeft(mN).subtract(1);
  }
}
#!queue	A018899	1	->	0	A003586	--------------------------------
package irvine.oeis.a018;

import irvine.math.z.Z;
import irvine.oeis.a003.A003586;
import irvine.util.array.DynamicLongArray;
import irvine.util.array.LongDynamicBooleanArray;
import irvine.util.string.StringUtils;

/**
 * A018899 Smallest positive integer not representable as the sum of at most n distinct numbers of form 2^a*3^b.
 * @author Sean A. Irvine
 */
public class A018899 extends A003586 {

  // After Jack Brennan

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private LongDynamicBooleanArray mA = new LongDynamicBooleanArray();
  private final DynamicLongArray mL = new DynamicLongArray();
  private long mLimit = 1L << 16;
  private int mTerms;
  {
    // Precompute 2^a * 3^b list
    final A003586 mSeq = new A003586();
    final Z lim = Z.valueOf(Long.MAX_VALUE);
    Z t;
    while ((t = mSeq.next()).compareTo(lim) < 0) {
      mL.set(mL.length(), t.longValueExact());
    }
  }

  private long getN() {
    long n = mLimit;
    while (n != 0) {
      if (mA.isSet(--n)) {
        for (int j = 0; j < mL.length() && n + mL.get(j) < mLimit; ++j) {
          mA.set(n + mL.get(j));
        }
      }
    }
    n = 0;
    while (mA.isSet(n) && ++n < mLimit) {
    }
    return n;
  }

  @Override
  public Z next() {
    if (!mA.isSet(0)) {
      mA.set(0);
      return Z.ONE;
    }
    while (true) {
      final long n = getN();
      if (n != mLimit) {
        ++mTerms;
        return Z.valueOf(n);
      }
      mLimit <<= 6; // Expand search region by factor of 64
      if (mLimit <= 0) {
        throw new UnsupportedOperationException();
      }
      mA = new LongDynamicBooleanArray();
      mA.set(0);
      // Run up, skip over already produced terms
      for (int k = 0; k < mTerms; ++k) {
        getN();
      }
      if (mVerbose) {
        StringUtils.message("Limit increased to " + mLimit);
      }
    }
  }
}

#!queue	A019269	0	->	1	A019268	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;

/**
 * A019269 Let Dedekind's psi(m) = product of (p+1)p^(e-1) for primes p, where p^e is a factor of m. Iterating psi(m) eventually results in a number of form 2^a*3^b. a(n) is the number of steps to reach such a number.
 * @author Sean A. Irvine
 */
public class A019269 extends A019268 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(count(++mN));
  }
}
#!queue	A019304	1	->	0	A009475	--------------------------------
package irvine.oeis.a019;

import irvine.oeis.a009.A009475;

/**
 * A019304 "Pascal sweep" for k=3: draw a horizontal line through the 1 at C(k,0) in Pascal's triangle; rotate this line and record the sum of the numbers on it (excluding the initial 1).
 * @author Sean A. Irvine
 */
public class A019304 extends A009475 {

  @Override
  protected long row() {
    return 3;
  }
}
#!queue	A019305	1	->	0	A009475	--------------------------------
package irvine.oeis.a019;

import irvine.oeis.a009.A009475;

/**
 * A019305 "Pascal sweep" for k=4: draw a horizontal line through the 1 at binomial(k,0) in Pascal's triangle; rotate this line and record the sum of the numbers on it (excluding the initial 1).
 * @author Sean A. Irvine
 */
public class A019305 extends A009475 {

  @Override
  protected long row() {
    return 4;
  }
}
#!queue	A019306	1	->	0	A009475	--------------------------------
package irvine.oeis.a019;

import irvine.oeis.a009.A009475;

/**
 * A019306 "Pascal sweep" for k=5: draw a horizontal line through the 1 at C(k,0) in Pascal's triangle; rotate this line and record the sum of the numbers on it (excluding the initial 1).
 * @author Sean A. Irvine
 */
public class A019306 extends A009475 {

  @Override
  protected long row() {
    return 5;
  }
}
#!queue	A019444	0	->	1	A002251	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;
import irvine.oeis.a002.A002251;

/**
 * A019444 a_1, a_2, ..., is a permutation of the positive integers such that the average of each initial segment is an integer, using the greedy algorithm to define a_n.
 * @author Sean A. Irvine
 */
public class A019444 extends A002251 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A019578	1	->	3	A019575	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;

/**
 * A019578 Place n distinguishable balls in n boxes (in n^n ways); let f(n,k) = number of ways that max in any box is k, for 1&lt;=k&lt;=n; sequence gives f(n,3)/n.
 * @author Sean A. Irvine
 */
public class A019578 extends A019575 {

  private int mN = 2;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    mF = mF.multiply(mN++);
    return get(mN, mN, 3).subtract(get(mN, mN, 2)).multiply(mF).toZ();
  }
}
#!queue	A019579	1	->	3	A019575	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;

/**
 * A019579 Place n distinguishable balls in n boxes (in n^n ways); let f(n,k) = number of ways that max in any box is k, for 1 &lt;= k &lt;= n; sequence gives f(n,n-2)/n.
 * @author Sean A. Irvine
 */
public class A019579 extends A019575 {

  private int mN = 2;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    mF = mF.multiply(mN++);
    return get(mN, mN, mN - 2).subtract(get(mN, mN, mN - 3)).multiply(mF).toZ();
  }
}
#!queue	A019580	1	->	4	A019575	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;

/**
 * A019580 Place n distinguishable balls in n boxes (in n^n ways); let f(n,k) = number of ways that max in any box is k, for 1&lt;=k&lt;=n; sequence gives f(n,4)/n.
 * @author Sean A. Irvine
 */
public class A019580 extends A019575 {

  private int mN = 3;
  private Z mF = Z.TWO;

  @Override
  public Z next() {
    mF = mF.multiply(mN++);
    return get(mN, mN, 4).subtract(get(mN, mN, 3)).multiply(mF).toZ();
  }
}
#!queue	A020479	1	->	2	A000252	--------------------------------
package irvine.oeis.a020;

import irvine.math.z.Z;
import irvine.oeis.a000.A000252;

/**
 * A020479 Number of noninvertible 2 X 2 matrices over Z/nZ (determinant is a divisor of 0).
 * @author Sean A. Irvine
 */
public class A020479 extends A000252 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z a = super.next();
    return Z.valueOf(mN).pow(4).subtract(a);
  }
}
#!queue	A022155	0	->	1	A020985	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.a020.A020985;

/**
 * A022155 Values of n at which Golay-Rudin-Shapiro sequence A020985 is negative.
 * @author Sean A. Irvine
 */
public class A022155 extends A020985 {

  @Override
  public Z next() {
    while (true) {
      if (super.next().signum() < 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A022301	1	->	0	A022300	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022301 Index of n-th 1 in A022300.
 * @author Sean A. Irvine
 */
public class A022301 extends A022300 {

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN + 1);
      }
    }
  }
}
#!queue	A022302	1	->	0	A022300	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022302 Least k such that first k terms of A022300 contain n more 1's than 2's.
 * @author Sean A. Irvine
 */
public class A022302 extends A022300 {

  private long mExcess = 0;
  private long mOnes = 0;

  @Override
  public Z next() {
    ++mExcess;
    while (true) {
      if (Z.ONE.equals(super.next())) {
        ++mOnes;
      }
      final long twos = mN + 1 - mOnes;
      if (mOnes >= twos + mExcess) {
        return Z.valueOf(mN + 1);
      }
    }
  }
}
#!queue	A022304	1	->	0	A022303	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022304 Index of n-th 1 in A022303.
 * @author Sean A. Irvine
 */
public class A022304 extends A022303 {

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN + 1);
      }
    }
  }
}
#!queue	A022305	1	->	0	A022303	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022305 Exactly half the first a(n) terms of A022303 are 1's.
 * @author Sean A. Irvine
 */
public class A022305 extends A022303 {

  private long mA = 0; // Counts 2 * the number of 1s

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (mA == mN + 1) {
        return Z.valueOf(mA);
      }
    }
  }
}
#!queue	A022494	1	->	0	A137251	--------------------------------
package irvine.oeis.a022;

import java.util.Arrays;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a137.A137251;

/**
 * A022494 Number of connected regular linearized chord diagrams of degree n.
 * @author Sean A. Irvine
 */
public class A022494 extends A137251 {

  // After Gheorghe Coserea

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final PolynomialRingField<Polynomial<Z>> RING2 = new PolynomialRingField<>("t", RING);
  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    final Polynomial<Polynomial<Z>> r = new Polynomial<>("t", RING.zero(), RING.one());
    r.add(RING.zero());
    r.add(RING.one());
    for (int n = 2; n <= mN; ++n) {
      final Polynomial<Z> c = new Polynomial<>("x", Z.ZERO, Z.ONE);
      c.add(Z.ZERO);
      for (int k = 0; k <= mN; ++k) {
        c.add(RING.create(Arrays.asList(get(k, 0, 0))).shift(2).coeff(n));
      }
      r.add(c);
    }
    return RING2.eval(RING2.series(RING2.x(), RING2.reversion(r, mN), mN), RING.one()).coeff(mN - 1);
  }
}
#!queue	A022818	0	->	1	A022811	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022818 Square array read by antidiagonals: A(n,k) = number of terms in the n-th derivative of a function composed with itself k times (n, k &gt;= 1).
 * @author Sean A. Irvine
 */
public class A022818 extends A022811 {

  private long mD = 1;
  private long mN = 1;

  @Override
  public Z next() {
    if (++mN >= mD) {
      ++mD;
      mN = 1;
    }
    return get(mN, mD - mN);
  }
}
#!queue	A022895	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022895 Number of solutions to c(1)*prime(1) + ... + c(n)*prime(n) = 1, where c(i) = +-1 for i &gt; 1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022895 extends A022894 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(1L, ++mN);
  }
}
#!queue	A022896	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022896 Number of solutions to c(1)*prime(1) + ... + c(n)*prime(n) = 2, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022896 extends A022894 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(0L, ++mN);
  }
}
#!queue	A022897	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022897 Number of solutions to c(1)*prime(2) +...+ c(n)*prime(n+1) = 0, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022897 extends A022894 {

  private long mN = 0;

  @Override
  protected long start() {
    return 2;
  }

  @Override
  public Z next() {
    return get(3L, ++mN);
  }
}
#!queue	A022900	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022900 Number of solutions to c(1)*prime(3) + ... + c(n)*prime(n+2) = 0, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022900 extends A022894 {

  private long mN = 0;

  @Override
  protected long start() {
    return 4;
  }

  @Override
  public Z next() {
    return get(5L, ++mN);
  }
}
#!queue	A022903	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022903 Number of solutions to c(1)*prime(4) + ... + c(n)*prime(n+3) = 0, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022903 extends A022894 {

  private long mN = 0;

  @Override
  protected long start() {
    return 6;
  }

  @Override
  public Z next() {
    return get(7L, ++mN);
  }
}
#!queue	A022907	0	->	1	A000123	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.a000.A000123;

/**
 * A022907 The sequence m(n) in A022905.
 * @author Sean A. Irvine
 */
public class A022907 extends A000123 {

  @Override
  public Z next() {
    return super.next().multiply(3).divide2().subtract(1);
  }
}
#!queue	A023025	4	->	5	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023025 Number of partitions of n into 5 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023025 extends A023024 {

  @Override
  protected int parts() {
    return 5;
  }
}
#!queue	A023026	4	->	6	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023026 Number of partitions of n into 6 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023026 extends A023024 {

  @Override
  protected int parts() {
    return 6;
  }
}
#!queue	A023027	4	->	7	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023027 Number of partitions of n into 7 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023027 extends A023024 {

  @Override
  protected int parts() {
    return 7;
  }
}
#!queue	A023028	4	->	8	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023028 Number of partitions of n into 8 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023028 extends A023024 {

  @Override
  protected int parts() {
    return 8;
  }
}
#!queue	A023029	4	->	9	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023029 Number of partitions of n into 9 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023029 extends A023024 {

  @Override
  protected int parts() {
    return 9;
  }
}
#!queue	A023030	4	->	10	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023030 Number of partitions of n into 10 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023030 extends A023024 {

  @Override
  protected int parts() {
    return 10;
  }
}
#!queue	A023031	1	->	6	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023031 Number of compositions of n into 6 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023031 extends A000741 {

  {
    for (int k = 0; k < 5; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 5);
  }
}
#!queue	A023032	1	->	7	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023032 Number of compositions of n into 7 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023032 extends A000741 {

  {
    for (int k = 0; k < 6; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 6);
  }
}
#!queue	A023033	1	->	8	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023033 Number of compositions of n into 8 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023033 extends A000741 {

  {
    for (int k = 0; k < 7; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 7);
  }
}
#!queue	A023034	1	->	9	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023034 Number of compositions of n into 9 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023034 extends A000741 {

  {
    for (int k = 0; k < 8; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 8);
  }
}
#!queue	A023035	1	->	10	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023035 Number of compositions of n into 10 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023035 extends A000741 {

  {
    for (int k = 0; k < 9; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 9);
  }
}
#!queue	A023095	3	->	4	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023095 a(n) is the least k &gt; 0 such that k and 3k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023095 extends A023094 {

  @Override
  protected int multiple() {
    return 3;
  }
}
#!queue	A023096	3	->	5	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023096 Least k such that k and 4k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023096 extends A023094 {

  @Override
  protected int multiple() {
    return 4;
  }
}
#!queue	A023097	3	->	6	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023097 a(n) is least k such that k and 5k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023097 extends A023094 {

  @Override
  protected int multiple() {
    return 5;
  }
}
#!queue	A023098	3	->	7	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023098 a(n) is least k such that k and 6k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023098 extends A023094 {

  @Override
  protected int multiple() {
    return 6;
  }
}
#!queue	A023099	3	->	8	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023099 a(n) is least k such that k and 7k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023099 extends A023094 {

  @Override
  protected int multiple() {
    return 7;
  }
}
#!queue	A023100	3	->	9	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023100 a(n) is least k such that k and 8k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023100 extends A023094 {

  @Override
  protected int multiple() {
    return 8;
  }
}
#!queue	A023101	3	->	10	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023101 a(n) is least k such that k and 9k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023101 extends A023094 {

  @Override
  protected int multiple() {
    return 9;
  }
}
#!queue	A023102	3	->	11	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023102 a(n) is least k such that k and 10k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023102 extends A023094 {

  @Override
  protected int multiple() {
    return 10;
  }
}
#!queue	A023487	1	->	0	A000204	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000204;
import irvine.oeis.a001.A001690;

/**
 * A023487 a(n) = b(n) + d(n), where b(n) = (n-th Lucas number &gt; 3) and d(n) = (n-th non-Fibonacci number).
 * @author Sean A. Irvine
 */
public class A023487 extends A000204 {

  final Sequence mA = new A001690();
  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().add(mA.next());
  }
}
#!queue	A023495	1	->	0	A000204	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000204;
import irvine.oeis.a090.A090946;

/**
 * A023495 a(n) = b(n) + d(n), where b(n) = (n-th Lucas number &gt; 3) and d(n) = (n-th non-Lucas number).
 * @author Sean A. Irvine
 */
public class A023495 extends A000204 {

  final Sequence mA = new A090946();
  {
    super.next();
    next();
  }

  @Override
  public Z next() {
    return super.next().add(mA.next());
  }
}
#!queue	A023901	0	->	1	A002126	--------------------------------
package irvine.oeis.a023;

import java.util.Collections;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002126;

/**
 * A023901 Derivative of log of A002126.
 * @author Sean A. Irvine
 */
public class A023901 extends A002126 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mG = RING.create(Collections.singletonList(new Q(super.next())));
  private int mN = 0;

  @Override
  public Z next() {
    mG.add(new Q(super.next()));
    return RING.diff(RING.log(mG, ++mN)).coeff(mN - 1).toZ();
  }
}

#!queue	A023986	0	->	1	A023847	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;

/**
 * A023986 Sum of exponents of primes in C(4n,2n)/C(2n,n).
 * @author Sean A. Irvine
 */
public class A023986 extends A023847 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(binomialOmega(4 * ++mN, 2 * mN) - binomialOmega(2 * mN, mN));
  }
}

#!queue	A023987	0	->	1	A023847	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;

/**
 * A023987 Sum of exponents of primes in C(5n,3n)/C(3n,2n).
 * @author Sean A. Irvine
 */
public class A023987 extends A023847 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(binomialOmega(5 * ++mN, 3 * mN) - binomialOmega(3 * mN, 2 * mN));
  }
}

#!queue	A024222	0	->	1	A002326	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a002.A002326;

/**
 * A024222 Number of shuffles (perfect faro shuffles with cut) required to return a deck of size n to original order.
 * @author Sean A. Irvine
 */
public class A024222 extends A002326 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    if (mA == null) {
      mA = super.next();
      if (!Z.ONE.equals(mA)) {
        return mA;
      }
    }
    final Z t = mA;
    mA = null;
    return t;
  }
}

#!queue	A024311	0	->	1	A002212	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a055.A055879;

/**
 * A024311 Catacondensed simply-connected monopentapolyhexes.
 * @author Sean A. Irvine
 */
public class A024311 extends A002212 {

  private Z mU = super.next().subtract(1);
  private final Sequence mVSeq = new A055879();

  @Override
  public Z next() {
    final Z uPrev = mU;
    mU = super.next();
    return mU.subtract(uPrev.multiply2()).subtract(mVSeq.next()).divide2();
  }
}
#!queue	A024482	1	->	2	A051924	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a051.A051924;

/**
 * A024482 a(n) = (1/2)*(binomial(2n, n) - binomial(2n-2, n-1)).
 * @author Sean A. Irvine
 */
public class A024482 extends A051924 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A024512	1	->	2	A004431	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a004.A004431;

/**
 * A024512 Position of 1 + n^2 in A004431 (sums of 2 distinct nonzero squares).
 * @author Sean A. Irvine
 */
public class A024512 extends A004431 {

  private long mN = 0;
  private long mM = 1;

  @Override
  public Z next() {
    final Z t = Z.valueOf(++mM).square().add(1);
    while (true) {
      ++mN;
      if (super.next().equals(t)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A024610	1	->	0	A003136	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a003.A003136;

/**
 * A024610 Position of n^2 in A003136.
 * @author Sean A. Irvine
 */
public class A024610 extends A003136 {

  private long mN = 0;
  private long mM = -1;

  @Override
  public Z next() {
    final Z m2 = Z.valueOf(++mM).square();
    while (true) {
      ++mN;
      if (super.next().equals(m2)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024673	1	->	2	A024670	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;

/**
 * A024673 Position of 1 + n^3 in A024670 (distinct sums of cubes of distinct positive integers).
 * @author Sean A. Irvine
 */
public class A024673 extends A024670 {

  private long mN = 0;
  private long mM = 1;

  @Override
  public Z next() {
    final Z t = Z.valueOf(++mM).pow(3).add(1);
    while (true) {
      ++mN;
      if (t.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024808	1	->	3	A004432	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a004.A004432;

/**
 * A024808 a(n) = position of 5 + n^2 in A004432.
 * @author Sean A. Irvine
 */
public class A024808 extends A004432 {

  private long mN = 0;
  private long mM = 2;

  @Override
  public Z next() {
    final Z t = Z.valueOf(++mM).square().add(5);
    while (true) {
      ++mN;
      if (t.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024818	0	->	1	A024814	--------------------------------
package irvine.oeis.a024;

import irvine.math.cr.CR;
import irvine.math.cr.ComputableReals;
import irvine.math.z.Z;

/**
 * A024818 a(n) = floor(tan m), where m is the least positive integer such that floor(tan m) &gt; floor(tan k) for k = 0,1,...,m-1.
 * @author Sean A. Irvine
 */
public class A024818 extends A024814 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return ComputableReals.SINGLETON.tan(CR.valueOf(super.next())).floor();
  }
}
#!queue	A024943	0	->	1	A024941	--------------------------------
package irvine.oeis.a024;

import irvine.oeis.Sequence;
import irvine.oeis.a002.A002476;

/**
 * A024943 Number of partitions of n into distinct 6k+1 primes.
 * @author Sean A. Irvine
 */
public class A024943 extends A024941 {

  @Override
  protected Sequence seq() {
    return new A002476();
  }

  {
    next();
  }
}
#!queue	A024944	0	->	1	A024941	--------------------------------
package irvine.oeis.a024;

import irvine.oeis.Sequence;
import irvine.oeis.a007.A007528;

/**
 * A024944 Number of partitions of n into distinct 6k-1 primes.
 * @author Sean A. Irvine
 */
public class A024944 extends A024941 {

  @Override
  protected Sequence seq() {
    return new A007528();
  }

  {
    next();
  }
}
#!queue	A024979	1	->	3	A024975	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;

/**
 * A024979 Position of n^3 + 9 in A024975.
 * @author Sean A. Irvine
 */
public class A024979 extends A024975 {

  private long mM = 2;
  private long mN = 0;

  @Override
  public Z next() {
    final Z t = Z.valueOf(++mM).pow(3).add(9);
    while (true) {
      ++mN;
      if (super.next().equals(t)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024997	2	->	3	A025179	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a025.A025179;

/**
 * A024997 a(n) = number of (s(0), s(1), ..., s(n)) such that every s(i) is an integer, s(0) = 0 = s(n), |s(i) - s(i-1)| = 1 for i = 1,2; |s(i) - s(i-1)| &lt;= 1 for i &gt;= 3. Also a(n) = T(n,n), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A024997 extends A025179 {

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A025047	1	->	0	A059882	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a059.A059882;

/**
 * A025047 Alternating compositions, i.e., compositions with alternating increases and decreases, starting with either an increase or a decrease.
 * @author Sean A. Irvine
 */
public class A025047 extends A059882 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.NEG_ONE;
    for (long k = 1; k <= mN; ++k) {
      sum = sum.add(mS.get(mN, k).add(mT.get(mN, k)));
    }
    return sum;
  }
}
#!queue	A025048	1	->	0	A059882	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a059.A059882;

/**
 * A025048 Number of up/down (initially ascending) compositions of n.
 * @author Sean A. Irvine
 */
public class A025048 extends A059882 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= mN; ++k) {
      sum = sum.add(mT.get(mN, k));
    }
    return sum;
  }
}
#!queue	A025049	1	->	0	A059882	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a059.A059882;

/**
 * A025049 Number of down/up (initially descending) compositions of n.
 * @author Sean A. Irvine
 */
public class A025049 extends A059882 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= mN; ++k) {
      sum = sum.add(mS.get(mN, k));
    }
    return sum;
  }
}
#!queue	A025135	0	->	1	A025134	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025135 (n-1)st elementary symmetric function of binomial(n,0), binomial(n,1), ..., binomial(n,n).
 * @author Sean A. Irvine
 */
public class A025135 extends A025134 {

  private long mN = 0;

  @Override
  public Z next() {
    return sym(Z.ONE, 0, ++mN, mN, mN - 1);
  }
}
#!queue	A025141	0	->	2	A025134	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025141 a(n) = (k-1)st elementary symmetric function of C(n,0), C(n,1), ..., C(n,k), where k = floor( n/2 ).
 * @author Sean A. Irvine
 */
public class A025141 extends A025134 {

  private long mN = 1;

  @Override
  public Z next() {
    return sym(Z.ONE, 0, ++mN / 2, mN, mN / 2 - 1);
  }
}
#!queue	A025158	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025158 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 4.
 * @author Sean A. Irvine
 */
public class A025158 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 4);
  }
}
#!queue	A025159	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025159 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 5.
 * @author Sean A. Irvine
 */
public class A025159 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 5);
  }
}
#!queue	A025160	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025160 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 6.
 * @author Sean A. Irvine
 */
public class A025160 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 6);
  }
}
#!queue	A025161	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025161 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 7.
 * @author Sean A. Irvine
 */
public class A025161 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 7);
  }
}
#!queue	A025162	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025162 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 8.
 * @author Sean A. Irvine
 */
public class A025162 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 8);
  }
}
#!queue	A025183	0	->	1	A025177	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025183 a(n) = T(2n-1,n), where T is the array defined in A025177.
 * @author Sean A. Irvine
 */
public class A025183 extends A025177 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN);
  }
}
#!queue	A025187	0	->	1	A025177	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025187 a(n) = T(2n,n-1), where T is the array defined in A025177.
 * @author Sean A. Irvine
 */
public class A025187 extends A025177 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A025188	0	->	1	A025177	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025188 a(n) = T(2n,n+1), where T is the array defined in A025177.
 * @author Sean A. Irvine
 */
public class A025188 extends A025177 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A025200	3	->	2	A025194	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A025200 a(n) = floor(floor(S3)/floor(S1)), where S3 and S1 are, respectively, the 3rd and first elementary symmetric functions of {sqrt(k), k = 1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A025200 extends A025194 {

  private final Sequence mS1 = new A025224().skip(3);

  @Override
  public Z next() {
    return super.next().divide(mS1.next());
  }
}
#!queue	A025480	1	->	0	A000265	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a000.A000265;

/**
 * A025480 a(2n) = n, a(2n+1) = a(n).
 * @author Sean A. Irvine
 */
public class A025480 extends A000265 {

  @Override
  public Z next() {
    return super.next().subtract(1).divide2();
  }
}

#!queue	A025537	1	->	0	A002944	--------------------------------
package irvine.oeis.a025;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002944;
import irvine.oeis.a003.A003418;

/**
 * A025537 a(n) = (1/s(1) + 1/s(2) + ... + 1/s(n+1)) * LCM{1, 2, ..., n}, where s(k) = LCM{1,2,...,k}/k = A002944(k).
 * @author Sean A. Irvine
 */
public class A025537 extends A002944 {

  private Sequence mA = new A003418();
  private Q mSum = Q.ZERO;

  @Override
  public Z next() {
    mSum = mSum.add(new Q(Z.ONE, super.next()));
    return mSum.multiply(mA.next()).toZ();
  }
}
#!queue	A025538	1	->	0	A002944	--------------------------------
package irvine.oeis.a025;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002944;
import irvine.oeis.a003.A003418;

/**
 * A025538 a(n) = (1/s(1) - 1/s(2) + ... + d/s(n+1)) * LCM{1, 2, ..., n}, where d = (-1)^n, s = A002944, i.e., s(k) = LCM of row k of Pascal's triangle.
 * @author Sean A. Irvine
 */
public class A025538 extends A002944 {

  private Sequence mA = new A003418();
  private Q mSum = Q.ZERO;
  private boolean mSign = false;

  @Override
  public Z next() {
    mSign = !mSign;
    mSum = mSum.signedAdd(mSign, new Q(Z.ONE, super.next()));
    return mSum.multiply(mA.next()).toZ();
  }
}
#!queue	A025547	0	->	1	A005408	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a005.A005408;

/**
 * A025547 Least common multiple of {1,3,5,...,2n-1}.
 * @author Sean A. Irvine
 */
public class A025547 extends A005408 {

  private Z mL = Z.ONE;

  @Override
  public Z next() {
    mL = mL.lcm(super.next());
    return mL;
  }
}
#!queue	A025565	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025565 a(n) = T(n,n-1), where T is array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025565 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A025569	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025569 T(2n-1,n), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025569 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(2 * mN, mN + 1);
  }
}
#!queue	A025570	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025570 a(n) = T(2n,n), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025570 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(2 * mN - 1, mN);
  }
}
#!queue	A025571	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025571 a(n) = T(3n,n), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025571 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(3 * mN - 1, mN);
  }
}
#!queue	A025572	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025572 a(n) = T(4n,n), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025572 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(4 * mN - 1, mN);
  }
}
#!queue	A025573	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025573 a(n) = T(2n,n-1), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025573 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(2 * mN + 1, mN);
  }
}
#!queue	A025574	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025574 T(2n,n+1), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025574 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(2 * mN + 1, mN + 2);
  }
}
#!queue	A025575	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025575 a(n) = T(n,[ n/2 ]), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025575 extends A025564 {

  private long mN = -2;

  @Override
  public Z next() {
    if (++mN == -1) {
      return Z.ONE;
    }
    return get(mN, (mN + 1) / 2);
  }
}
#!queue	A025576	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025576 a(n) = T(n,[ n/2 ]+1), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025576 extends A025564 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, (mN + 1) / 2 + 1);
  }
}
#!queue	A025578	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025578 a(n) = Sum{T(n,k-1), k = 1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A025578 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A025692	1	->	0	A025610	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025692 Index of 2^n within sequence of numbers of form 2^i*6^j.
 * @author Sean A. Irvine
 */
public class A025692 extends A025610 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply2();
    return Z.valueOf(mN);
  }
}
#!queue	A025693	1	->	0	A003591	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a003.A003591;

/**
 * A025693 Index of 2^n within sequence of numbers of form 2^i*7^j.
 * @author Sean A. Irvine
 */
public class A025693 extends A003591 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply2();
    return Z.valueOf(mN);
  }
}
#!queue	A025694	1	->	0	A025611	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025694 Index of 2^n within sequence of numbers of form 2^i * 9^j.
 * @author Sean A. Irvine
 */
public class A025694 extends A025611 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply2();
    return Z.valueOf(mN);
  }
}
#!queue	A025702	1	->	0	A025617	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025702 Index of 4^n within sequence of numbers of form 4^i*5^j.
 * @author Sean A. Irvine
 */
public class A025702 extends A025617 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.shiftLeft(2);
    return Z.valueOf(mN);
  }
}
#!queue	A025703	1	->	0	A025618	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025703 Index of 4^n within sequence of numbers of form 4^i*6^j.
 * @author Sean A. Irvine
 */
public class A025703 extends A025618 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.shiftLeft(2);
    return Z.valueOf(mN);
  }
}
#!queue	A025706	1	->	0	A025617	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025706 Index of 5^n within sequence of numbers of form 4^i*5^j.
 * @author Sean A. Irvine
 */
public class A025706 extends A025617 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(5);
    return Z.valueOf(mN);
  }
}
#!queue	A025707	1	->	0	A025622	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025707 Index of 5^n within sequence of numbers of form 5^i*6^j.
 * @author Sean A. Irvine
 */
public class A025707 extends A025622 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(5);
    return Z.valueOf(mN);
  }
}
#!queue	A025708	1	->	0	A003595	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a003.A003595;

/**
 * A025708 Index of 5^n within sequence of numbers of form 5^i*7^j.
 * @author Sean A. Irvine
 */
public class A025708 extends A003595 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(5);
    return Z.valueOf(mN);
  }
}
#!queue	A025715	1	->	0	A025622	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025715 Index of 6^n in A025622 (numbers of form 5^i*6^j).
 * @author Sean A. Irvine
 */
public class A025715 extends A025622 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(6);
    return Z.valueOf(mN);
  }
}
#!queue	A025723	1	->	0	A003595	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a003.A003595;

/**
 * A025723 Index of 7^n within sequence of numbers of form 5^i*7^j.
 * @author Sean A. Irvine
 */
public class A025723 extends A003595 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(7);
    return Z.valueOf(mN);
  }
}
#!queue	A025742	1	->	0	A025621	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025742 a(n) is the index of 10^n within sequence of numbers of form 4^i*10^j.
 * @author Sean A. Irvine
 */
public class A025742 extends A025621 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(10);
    return Z.valueOf(mN);
  }
}
#!queue	A025747	1	->	0	A025635	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025747 Index of 10^n within sequence of numbers of form 9^i*10^j.
 * @author Sean A. Irvine
 */
public class A025747 extends A025635 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(10);
    return Z.valueOf(mN);
  }
}
#!queue	A026002	0	->	1	A008288	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A026002 a(n) = T(n,n+2), where T = Delannoy triangle (A008288).
 * @author Sean A. Irvine
 */
public class A026002 extends A008288 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN + 2);
  }
}
#!queue	A026052	0	->	2	A008778	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.recur.PeriodicSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a008.A008778;

/**
 * A026052 (d(n)-r(n))/2, where d = A008778 and r is the periodic sequence with fundamental period (1,1,0,1).
 * @author Sean A. Irvine
 */
public class A026052 extends A008778 {

  private final Sequence mS = new PeriodicSequence(1, 1, 0, 1);
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mS.next()).divide2();
  }
}

#!queue	A026053	0	->	2	A008778	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.recur.PeriodicSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a008.A008778;

/**
 * A026053 (d(n)-r(n))/5, where d = A008778 and r is the periodic sequence with fundamental period (0,3,1,0,1).
 * @author Sean A. Irvine
 */
public class A026053 extends A008778 {

  private final Sequence mS = new PeriodicSequence(0, 3, 1, 0, 1);
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mS.next()).divide(5);
  }
}

#!queue	A026072	0	->	1	A024996	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a024.A024996;

/**
 * A026072 a(n) = T(2n-1,n), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A026072 extends A024996 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN).max(Z.ONE);
  }
}

#!queue	A026076	0	->	1	A024996	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a024.A024996;

/**
 * A026076 a(n) = T(2n,n-1), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A026076 extends A024996 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}

#!queue	A026077	0	->	1	A024996	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a024.A024996;

/**
 * A026077 a(n) = T(2n,n+1), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A026077 extends A024996 {

  private long mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return get(2 * mN, mN + 1);
  }
}

#!queue	A026079	2	->	1	A025179	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a025.A025179;

/**
 * A026079 a(n) = Sum_{k = 1..n} T(k,k-1), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A026079 extends A025179 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().add(2);
  }
}

#!queue	A026089	1	->	0	A026082	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026089 a(n) = T(2n,n), where T is the array defined in A026082.
 * @author Sean A. Irvine
 */
public class A026089 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}

#!queue	A026090	1	->	0	A026082	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026090 a(n) = T(3n,n), where T is the array defined in A026082.
 * @author Sean A. Irvine
 */
public class A026090 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(3 * ++mN, mN);
  }
}

#!queue	A026091	1	->	0	A026082	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026091 a(n) = T(4n,n), where T is the array defined in A026082.
 * @author Sean A. Irvine
 */
public class A026091 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(4 * ++mN, mN);
  }
}

#!queue	A026094	1	->	0	A026082	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026094 a(n) = T(n,[ n/2 ]), where T is the array defined in A026082.
 * @author Sean A. Irvine
 */
public class A026094 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}

#!queue	A026106	0	->	5	A002212	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a007.A007317;

/**
 * A026106 Number of polyhexes of class PF2 (with one catafusene annealated to pyrene).
 * @author Sean A. Irvine
 */
public class A026106 extends A002212 {

  private final Sequence mB = new A007317();
  private Z mA = null;
  private boolean mEven = false;
  {
    super.next();
  }

  @Override
  public Z next() {
    mEven = !mEven;
    if (mEven) {
      mA = mB.next();
    }
    return super.next().multiply(3).add(mA).divide2();
  }
}
#!queue	A026118	1	->	6	A039658	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a039.A039658;

/**
 * A026118 Number of polyhexes of class PF2 (with two catafusenes annealated to pyrene).
 * @author Sean A. Irvine
 */
public class A026118 extends A039658 {

  private final MemorySequence mA = MemorySequence.cachedSequence(new A002212());
  private int mN = 1;
  {
    super.next(); // skip n == 1 in A039658
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k < mN; ++k) {
      sum = sum.add(mA.a(k).multiply(mA.a(mN - k)));
    }
    sum = sum.multiply(13).add(super.next());
    if ((mN & 1) == 0) {
      sum = sum.add(mA.a(mN / 2).multiply(6));
    }
    return sum.divide(4);
  }
}
#!queue	A026147	0	->	1	A001285	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a001.A001285;

/**
 * A026147 a(n) = position of n-th 1 in A001285 or A010059 (Thue-Morse sequence).
 * @author Sean A. Irvine
 */
public class A026147 extends A001285 {

  private long mN = 0;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!Z.ONE.equals(super.next()));
    return Z.valueOf(mN);
  }
}
#!queue	A026152	1	->	2	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026152 a(n) = T(n,n-1), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026152 extends A026148 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A026153	1	->	2	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026153 T(n,n-2), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026153 extends A026148 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026154	1	->	3	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026154 a(n) = T(n,n-3), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026154 extends A026148 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026155	1	->	4	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026155 T(n,n-4), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026155 extends A026148 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026157	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026157 a(n) = T(2n,n), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026157 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026158	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026158 a(n) = T(3n,n), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026158 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(3 * ++mN, mN);
  }
}
#!queue	A026159	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026159 T(4n,n), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026159 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(4 * ++mN, mN);
  }
}
#!queue	A026162	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026162 a(n) = T(n,[ n/2 ]), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026162 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026164	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026164 a(n) = Sum{T(n,k)}, k = 0,1,...,n, where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026164 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026243	0	->	1	A000522	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a000.A000522;

/**
 * A026243 a(n) = A000522(n) - 2.
 * @author Sean A. Irvine
 */
public class A026243 extends A000522 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(2);
  }
}
#!queue	A026245	0	->	1	A002251	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a002.A002251;

/**
 * A026245 a(n) = (1/2)*(s(n) + 1), where s(n) is the n-th odd number in A002251.
 * @author Sean A. Irvine
 */
public class A026245 extends A002251 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isEven());
    return t.add(1).divide2();
  }
}
#!queue	A026247	0	->	1	A002251	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a002.A002251;

/**
 * A026247 a(n) = (1/2)*s(n), where s(n) is n-th even number in A002251.
 * @author Sean A. Irvine
 */
public class A026247 extends A002251 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isOdd());
    return t.divide2();
  }
}
#!queue	A026291	0	->	2	A026268	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026291 a(n) = T(2n-1,n), where T is the array in A026268.
 * @author Sean A. Irvine
 */
public class A026291 extends A026268 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN);
  }
}
#!queue	A026295	0	->	1	A026268	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026295 a(n) = T(2n,n-1), where T is the array in A026268.
 * @author Sean A. Irvine
 */
public class A026295 extends A026268 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026296	0	->	1	A026268	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026296 a(n) = T(2n,n+1), where T is the array in A026268.
 * @author Sean A. Irvine
 */
public class A026296 extends A026268 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026305	0	->	1	A026300	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026305 a(n) = T(2n,n-1), where T is the array in A026300.
 * @author Sean A. Irvine
 */
public class A026305 extends A026300 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 1);
  }
}
#!queue	A026330	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026330 a(n) = number of (s(0), s(1), ..., s(n)) such that s(i) is a nonnegative integer and |s(i) - s(i-1)| &lt;= 1 for i = 1,2,...,n, s(0) = 2, s(2n) = n+1. Also a(n) = T(2n,n+1), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026330 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026332	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026332 a(n) = T(2n,n), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026332 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026333	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026333 a(n) = T(3n,n), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026333 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(3 * ++mN, mN);
  }
}
#!queue	A026334	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026334 T(4n,n), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026334 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(4 * ++mN, mN);
  }
}
#!queue	A026336	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026336 a(n) = T(n,[ n/2 ]), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026336 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026376	0	->	1	A002212	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a002.A002212;

/**
 * A026376 a(n) is the number of integer strings s(0),...,s(n) counted by array T in A026374 that have s(n)=2; also a(n) = T(2n,n-1).
 * @author Sean A. Irvine
 */
public class A026376 extends A002212 {

  private long mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}
#!queue	A026388	0	->	1	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026388 a(n) is the number of integer strings s(0),...,s(n) counted by array T in A026386 that have s(n)=2; also a(n) = T(2n,n-1).
 * @author Sean A. Irvine
 */
public class A026388 extends A026386 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026389	0	->	2	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026389 a(n) = number of integer strings s(0),...,s(n) counted by array T in A026386 that have s(n)=4; also a(n) = T(2n,n-2).
 * @author Sean A. Irvine
 */
public class A026389 extends A026386 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026392	0	->	1	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026392 T(n,[ n/2 ]), where T is the array in A026386.
 * @author Sean A. Irvine
 */
public class A026392 extends A026386 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026402	1	->	2	A026400	--------------------------------
package irvine.oeis.a026;

import java.util.TreeMap;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A026402 Position of the second n in A026400.
 * @author Sean A. Irvine
 */
public class A026402 extends A026400 {

  private final TreeSet<Long> mSeenFirst = new TreeSet<>();
  private final TreeMap<Long, Long> mMap = new TreeMap<>();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    while (!mMap.containsKey(mN)) {
      final long s = super.next().longValueExact();
      ++mM;
      if (s >= mN && !mMap.containsKey(s) && !mSeenFirst.add(s)) {
        mMap.put(s, mM);
      }
    }
    mSeenFirst.remove(mN);
    return Z.valueOf(mMap.remove(mN));
  }
}
#!queue	A026404	1	->	2	A026400	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicLongArray;

/**
 * A026404 a(n) = greatest number of numbers between consecutive appearances of n in A026400.
 * @author Sean A. Irvine
 */
public class A026404 extends A026400 {

  private final LongDynamicLongArray mPrev = new LongDynamicLongArray();
  private final LongDynamicLongArray mMax = new LongDynamicLongArray();
  private final LongDynamicLongArray mCount = new LongDynamicLongArray();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    while (mCount.get(mN) != mN) {
      ++mM;
      final long s = super.next().longValueExact();
      if (mPrev.get(s) != 0) {
        mMax.set(s, Math.max(mMax.get(s), mM - mPrev.get(s) - 1));
      }
      mPrev.set(s, mM);
      mCount.set(s, mCount.get(s) + 1);
    }
    return Z.valueOf(mMax.get(mN));
  }
}
#!queue	A026411	1	->	2	A026409	--------------------------------
package irvine.oeis.a026;

import java.util.TreeMap;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A026411 Position of the second n in A026409.
 * @author Sean A. Irvine
 */
public class A026411 extends A026409 {

  private final TreeSet<Long> mSeenFirst = new TreeSet<>();
  private final TreeMap<Long, Long> mMap = new TreeMap<>();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    while (!mMap.containsKey(mN)) {
      final long s = super.next().longValueExact();
      ++mM;
      if (s >= mN && !mMap.containsKey(s) && !mSeenFirst.add(s)) {
        mMap.put(s, mM);
      }
    }
    mSeenFirst.remove(mN);
    return Z.valueOf(mMap.remove(mN));
  }
}
#!queue	A026413	1	->	2	A026409	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicLongArray;

/**
 * A026413 a(n) = greatest number of numbers between consecutive appearances of n in A026409.
 * @author Sean A. Irvine
 */
public class A026413 extends A026409 {

  private final LongDynamicLongArray mPrev = new LongDynamicLongArray();
  private final LongDynamicLongArray mMax = new LongDynamicLongArray();
  private final LongDynamicLongArray mCount = new LongDynamicLongArray();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    while (mCount.get(mN) != mN) {
      ++mM;
      final long s = super.next().longValueExact();
      if (mPrev.get(s) != 0) {
        mMax.set(s, Math.max(mMax.get(s), mM - mPrev.get(s) - 1));
      }
      mPrev.set(s, mM);
      mCount.set(s, mCount.get(s) + 1);
    }
    return Z.valueOf(mMax.get(mN));
  }
}
#!queue	A026414	1	->	2	A026409	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicLongArray;

/**
 * A026414 a(n) = greatest integer not found after first n in A026409.
 * @author Sean A. Irvine
 */
public class A026414 extends A026409 {

  private final LongDynamicLongArray mCount = new LongDynamicLongArray();
  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    while (mCount.get(mN) == 0) {
      final long s = super.next().longValueExact();
      mCount.set(s, mCount.get(s) + 1);
    }
    long k = mN;
    while (mCount.get(k) != k) {
      --k;
    }
    return Z.valueOf(k);
  }
}
#!queue	A026521	0	->	1	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026521 a(n) = T(n, n-1), T given by A026519. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 1.
 * @author Sean A. Irvine
 */
public class A026521 extends A026519 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A026522	0	->	2	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026522 a(n) = T(n, n-2), where T is given by A026519. Also number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 2.
 * @author Sean A. Irvine
 */
public class A026522 extends A026519 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026523	0	->	3	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026523 a(n) = T(n, n-3), T given by A026519. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 3.
 * @author Sean A. Irvine
 */
public class A026523 extends A026519 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026524	0	->	4	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026524 a(n) = T(n, n-4), T given by A026519. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 4.
 * @author Sean A. Irvine
 */
public class A026524 extends A026519 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026526	0	->	1	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026526 a(n) = T(2n,n-1), T given by A026519.
 * @author Sean A. Irvine
 */
public class A026526 extends A026519 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026527	0	->	2	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026527 a(n) = T(2*n, n-2), where T is given by A026519.
 * @author Sean A. Irvine
 */
public class A026527 extends A026519 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026528	0	->	1	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026528 a(n) = T(2*n-1, n-1), T given by A026519.
 * @author Sean A. Irvine
 */
public class A026528 extends A026519 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026529	0	->	2	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026529 a(n) = T(2*n-1, n-2), where T is given by A026519.
 * @author Sean A. Irvine
 */
public class A026529 extends A026519 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026538	0	->	1	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026538 a(n) = T(n,n-1), T given by A026536. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 1.
 * @author Sean A. Irvine
 */
public class A026538 extends A026536 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A026539	0	->	2	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026539 a(n) = T(n,n-2), T given by A026536. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 2.
 * @author Sean A. Irvine
 */
public class A026539 extends A026536 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026540	0	->	3	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026540 a(n) = T(n,n-3), T given by A026536. Also number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 3.
 * @author Sean A. Irvine
 */
public class A026540 extends A026536 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026541	0	->	4	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026541 a(n) = T(n,n-4), T given by A026536. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 4.
 * @author Sean A. Irvine
 */
public class A026541 extends A026536 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026545	0	->	1	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026545 a(n) = T(2n-1, n-1), T given by A026536.
 * @author Sean A. Irvine
 */
public class A026545 extends A026536 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026546	0	->	2	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026546 a(n) = T(2n-1,n-2), T given by A026536.
 * @author Sean A. Irvine
 */
public class A026546 extends A026536 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026554	0	->	1	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026554 a(n) = T(n,n-1), T given by A026552. Also a(n) is the number of integer strings s(0),...,s(n) counted by T, such that s(n)=1.
 * @author Sean A. Irvine
 */
public class A026554 extends A026552 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A026555	0	->	2	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026555 a(n) = T(n, n-2), T given by A026552. Also a(n) = number of integer strings s(0), ..., s(n) counted by T, such that s(n) = 2.
 * @author Sean A. Irvine
 */
public class A026555 extends A026552 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026556	0	->	3	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026556 a(n) = T(n, n-3), T given by A026552. Also a(n) = number of integer strings s(0), ..., s(n) counted by T, such that s(n) = 3.
 * @author Sean A. Irvine
 */
public class A026556 extends A026552 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026557	0	->	4	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026557 a(n) = T(n, n-4), T given by A026552. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=4.
 * @author Sean A. Irvine
 */
public class A026557 extends A026552 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026559	0	->	1	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026559 a(n) = T(2*n, n-1), where T is given by A026552.
 * @author Sean A. Irvine
 */
public class A026559 extends A026552 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026560	0	->	2	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026560 a(n) = T(2*n, n-2), where T is given by A026552.
 * @author Sean A. Irvine
 */
public class A026560 extends A026552 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026569	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026569 a(n) = T(n,n), T given by A026568. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=0.
 * @author Sean A. Irvine
 */
public class A026569 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A026571	1	->	2	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026571 a(n)=T(n,n-2), T given by A026568. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=2.
 * @author Sean A. Irvine
 */
public class A026571 extends A026568 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026572	1	->	3	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026572 a(n) = T(n,n-3), T given by A026568. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=3.
 * @author Sean A. Irvine
 */
public class A026572 extends A026568 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026573	1	->	4	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026573 a(n)=T(n,n-4), T given by A026568. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=4.
 * @author Sean A. Irvine
 */
public class A026573 extends A026568 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026574	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026574 T(2n,n), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026574 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026576	1	->	2	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026576 T(2n,n-2), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026576 extends A026568 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026578	1	->	2	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026578 T(2n-1,n-2), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026578 extends A026568 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026579	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026579 T(n,[ n/2 ]), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026579 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026580	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026580 T(n,0) + T(n,1) + ... + T(n,n), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026580 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026583	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026583 a(n) = Sum{T(i,j)}, 0&lt;=j&lt;=i, 0&lt;=i&lt;=2n, T given by A026568.
 * @author Sean A. Irvine
 */
public class A026583 extends A026568 {

  private long mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k <= 2 * mN; ++k) {
      mSum = mSum.add(get(mN, k));
    }
    return mSum;
  }
}
#!queue	A026585	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026585 a(n) = T(n,n), T given by A026584. Also a(n) is the number of integer strings s(0), ..., s(n) counted by T, such that s(n)=0.
 * @author Sean A. Irvine
 */
public class A026585 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A026587	1	->	2	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026587 a(n) = T(n, n-2), T given by A026584. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=2.
 * @author Sean A. Irvine
 */
public class A026587 extends A026584 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026589	1	->	4	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026589 a(n) = T(n,n-4), T given by A026584. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=4.
 * @author Sean A. Irvine
 */
public class A026589 extends A026584 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026590	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026590 a(n) = T(2*n, n), where T is given by A026584.
 * @author Sean A. Irvine
 */
public class A026590 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026592	1	->	2	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026592 a(n) = T(2*n, n-2), where T is given by A026584.
 * @author Sean A. Irvine
 */
public class A026592 extends A026584 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026594	1	->	2	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026594 a(n) = T(2*n-1, n-2), where T is given by A026584.
 * @author Sean A. Irvine
 */
public class A026594 extends A026584 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026595	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026595 a(n) = T(n, floor(n/2)), where T is given by A026584.
 * @author Sean A. Irvine
 */
public class A026595 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026596	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026596 Row sums of A026584.
 * @author Sean A. Irvine
 */
public class A026596 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026599	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026599 a(n) = Sum_{j=0..2*i, i=0..n} A026584(i,j).
 * @author Sean A. Irvine
 */
public class A026599 extends A026584 {

  private long mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k <= 2 * mN; ++k) {
      mSum = mSum.add(get(mN, k));
    }
    return mSum;
  }
}
#!queue	A026616	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026616 T(2n,n), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026616 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026620	1	->	2	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026620 T(2n-1,n-2), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026620 extends A026615 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026621	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026621 T(n,[ n/2 ]), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026621 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026622	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026622 a(n) = T(n,0) + T(n,1) + ... + T(n,n), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026622 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026623	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026623 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026623 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026627	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026627 T(2n,n), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026627 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026629	1	->	2	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026629 T(2n,n-2), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026629 extends A026626 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026631	1	->	2	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026631 T(2n-1,n-2), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026631 extends A026626 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026632	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026632 T(n,[ n/2 ]), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026632 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026634	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026634 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026634 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026639	0	->	1	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026639 T(2n,n-1), T given by A026637.
 * @author Sean A. Irvine
 */
public class A026639 extends A026637 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026640	0	->	2	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026640 T(2n,n-2), T given by A026637.
 * @author Sean A. Irvine
 */
public class A026640 extends A026637 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026642	0	->	2	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026642 a(n) = T(2n-1,n-2), T given by A026637.
 * @author Sean A. Irvine
 */
public class A026642 extends A026637 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026649	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026649 a(n) = T(2n,n), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026649 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026651	1	->	2	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026651 a(n) = T(2n,n-2), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026651 extends A026648 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026653	1	->	2	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026653 a(n) = T(2n-1,n-2), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026653 extends A026648 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026654	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026654 a(n) = T(n,[ n/2 ]), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026654 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026656	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026656 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026656 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026660	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026660 T(2n,n), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026660 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026662	1	->	2	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026662 T(2n,n-2), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026662 extends A026659 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026664	1	->	2	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026664 T(2n-1,n-2), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026664 extends A026659 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026665	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026665 T(n,[ n/2 ]), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026665 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026666	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026666 T(n,0) + T(n,1) + ... + T(n,n), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026666 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026667	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026667 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026667 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026669	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026669 Sum{T(n-k,k)}, 0&lt;=k&lt;=[ n/2 ], T given by A026659.
 * @author Sean A. Irvine
 */
public class A026669 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026672	0	->	2	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026672 a(n) = T(2n,n-1), T given by A026670. Also T(2n,n-1)=T(2n+1,n+2), T given by A026725; and T(2n,n-1), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026672 extends A026670 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026673	0	->	2	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026673 a(n) = T(2n,n-2), T given by A026670.
 * @author Sean A. Irvine
 */
public class A026673 extends A026670 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026674	0	->	1	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026674 a(n) = T(2n-1,n-1) = T(2n,n+1), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026674 extends A026670 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026675	0	->	2	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026675 a(n) = T(2n-1,n-2), T given by A026670. Also T(2n-1,n-2) = T(2n,n+2), T given by A026725 and T(2n,n-2), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026675 extends A026670 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026682	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026682 a(n) = A026681(2n,n).
 * @author Sean A. Irvine
 */
public class A026682 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026684	1	->	2	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026684 T(2n,n-2), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026684 extends A026681 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026686	1	->	2	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026686 T(2n-1,n-2), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026686 extends A026681 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026687	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026687 T(n,[ n/2 ]), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026687 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026688	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026688 T(n,0) + T(n,1) + ... + T(n,n), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026688 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026689	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026689 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026689 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026691	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026691 Sum{T(n-k,k)}, 0&lt;=k&lt;=[ n/2 ], T given by A026681.
 * @author Sean A. Irvine
 */
public class A026691 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026693	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026693 T(2n,n), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026693 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026695	1	->	2	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026695 T(2n,n-2), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026695 extends A026692 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026697	1	->	2	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026697 T(2n-1,n-2), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026697 extends A026692 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026698	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026698 T(n,[ n/2 ]), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026698 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026699	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026699 T(n,0) + T(n,1) + ... + T(n,n), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026699 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026700	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026700 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026700 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026702	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026702 a(n) = Sum_{k=0..floor(n/2)} T(n-k, k), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026702 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026704	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026704 T(2n,n), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026704 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026706	1	->	2	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026706 T(2n,n-2), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026706 extends A026703 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026708	1	->	2	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026708 T(2n-1,n-2), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026708 extends A026703 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026709	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026709 T(n,[ n/2 ]), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026709 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026710	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026710 T(n,0) + T(n,1) + ... + T(n,n), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026710 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026711	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026711 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026711 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026713	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026713 Sum{T(n-k,k)}, 0&lt;=k&lt;=[ n/2 ], T given by A026703.
 * @author Sean A. Irvine
 */
public class A026713 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026715	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026715 T(2n,n), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026715 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026717	1	->	2	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026717 T(2n,n-2), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026717 extends A026714 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026719	1	->	2	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026719 T(2n-1,n-2), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026719 extends A026714 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026720	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026720 T(n,[ n/2 ]), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026720 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026721	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026721 T(n,0) + T(n,1) + ... + T(n,n), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026721 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026722	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026722 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026722 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026724	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026724 Sum{T(n-k,k)}, 0&lt;=k&lt;=[ n/2 ], T given by A026714.
 * @author Sean A. Irvine
 */
public class A026724 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026749	0	->	1	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026749 a(n) = T(2n,n-1), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026749 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026750	0	->	2	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026750 a(n) = T(2n,n-2), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026750 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026751	0	->	1	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026751 a(n) = T(2n-1,n-1), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026751 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026752	0	->	2	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026752 a(n) = T(2n-1,n-2), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026752 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026760	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026760 a(n) = T(2n, n-1), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026760 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026761	0	->	2	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026761 a(n) = T(2n, n-2), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026761 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026762	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026762 a(n) = T(2n-1,n-1), T given by A026758. Also T(2n+1,n+1), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026762 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026763	0	->	2	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026763 a(n) = T(2n-1,n-2), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026763 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026771	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026771 a(n) = T(2n,n-1), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026771 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026772	0	->	2	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026772 a(n) = T(2n, n-2), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026772 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026773	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026773 a(n) = T(2n-1,n-1), T given by A026769. Also T(2n+1,n+1), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026773 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026774	0	->	2	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026774 a(n) = T(2n-1,n-2), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026774 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026782	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026782 a(n) = T(2n,n-1), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026782 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026783	0	->	2	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026783 a(n) = T(2n, n-2), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026783 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026784	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026784 a(n) = T(2n-1, n-1), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026784 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026785	0	->	2	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026785 a(n) = T(2n-1, n-2), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026785 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026840	0	->	1	A079126	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a079.A079126;

/**
 * A026840 Triangular array T read by rows: T(n,k) = number of partitions of n into distinct parts &lt;= k, for k=1,2,...n.
 * @author Sean A. Irvine
 */
public class A026840 extends A079126 {

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}
#!queue	A026841	0	->	4	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026841 a(n) = T(2n,n-4), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026841 extends A026725 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026842	0	->	3	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026842 a(n) = T(2n,n-3), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026842 extends A026725 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026843	0	->	3	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026843 a(n) = T(2n,n+3), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026843 extends A026725 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026844	0	->	4	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026844 a(n) = T(2n,n+4), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026844 extends A026725 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026846	0	->	3	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026846 a(n) = T(2n+1,n+4), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026846 extends A026725 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026848	0	->	4	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026848 a(n) = T(2n,n-4), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026848 extends A026736 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026849	0	->	3	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026849 a(n) = T(2n,n-3), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026849 extends A026736 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026850	0	->	1	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026850 a(n) = T(2n,n+1), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026850 extends A026736 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026851	0	->	2	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026851 a(n) = T(2n,n+2), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026851 extends A026736 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026852	0	->	3	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026852 a(n) = T(2n,n+3), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026852 extends A026736 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026853	0	->	4	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026853 a(n) = T(2n,n+4), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026853 extends A026736 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026855	0	->	1	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026855 a(n) = T(2n+1,n+2), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026855 extends A026736 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026856	0	->	2	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026856 a(n) = T(2n+1,n+3), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026856 extends A026736 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026857	0	->	3	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026857 a(n) = T(2n+1,n+4), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026857 extends A026736 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026859	0	->	4	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026859 T(2n,n-4), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026859 extends A026747 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026860	0	->	3	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026860 T(2n,n-3), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026860 extends A026747 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026861	0	->	1	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026861 T(2n,n+1), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026861 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026862	0	->	2	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026862 T(2n,n+2), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026862 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026863	0	->	3	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026863 T(2n,n+3), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026863 extends A026747 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026864	0	->	4	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026864 T(2n,n+4), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026864 extends A026747 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026866	0	->	1	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026866 T(2n+1,n+2), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026866 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026867	0	->	2	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026867 T(2n+1,n+3), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026867 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026868	0	->	3	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026868 T(2n+1,n+4), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026868 extends A026747 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026870	0	->	4	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026870 T(2n,n-4), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026870 extends A026758 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026871	0	->	3	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026871 T(2n,n-3), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026871 extends A026758 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026872	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026872 T(2n,n+1), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026872 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026873	0	->	2	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026873 T(2n,n+2), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026873 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026874	0	->	3	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026874 T(2n,n+3), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026874 extends A026758 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026875	0	->	4	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026875 T(2n,n+4), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026875 extends A026758 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026877	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026877 T(2n+1,n+2), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026877 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026878	0	->	2	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026878 a(n) = T(2n+1,n+3), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026878 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026879	0	->	3	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026879 T(2n+1,n+4), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026879 extends A026758 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026880	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026880 a(n) = T(n,m) + T(n,m+1) + ... + T(n,n), m=[ (n+1)/2 ], T given by A026758.
 * @author Sean A. Irvine
 */
public class A026880 extends A026758 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = (mN + 1) / 2; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026881	0	->	4	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026881 T(2n,n-4), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026881 extends A026769 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026882	0	->	3	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026882 T(2n,n-3), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026882 extends A026769 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026883	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026883 T(2n,n+1), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026883 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026884	0	->	2	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026884 T(2n,n+2), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026884 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026885	0	->	3	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026885 T(2n,n+3), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026885 extends A026769 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026886	0	->	4	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026886 T(2n,n+4), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026886 extends A026769 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026888	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026888 T(2n+1,n+2), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026888 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026889	0	->	2	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026889 T(2n+1,n+3), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026889 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026890	0	->	3	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026890 T(2n+1,n+4), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026890 extends A026769 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026891	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026891 a(n) = T(n,m) + T(n,m+1) + ... + T(n,n), m=[ (n+1)/2 ], T given by A026769.
 * @author Sean A. Irvine
 */
public class A026891 extends A026769 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = (mN + 1) / 2; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026892	0	->	4	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026892 T(2n,n-4), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026892 extends A026780 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026893	0	->	3	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026893 T(2n,n-3), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026893 extends A026780 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026894	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026894 T(2n,n+1), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026894 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026895	0	->	2	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026895 T(2n,n+2), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026895 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026896	0	->	3	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026896 T(2n,n+3), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026896 extends A026780 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026897	0	->	4	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026897 T(2n,n+4), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026897 extends A026780 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026899	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026899 T(2n+1,n+2), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026899 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026900	0	->	2	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026900 T(2n+1,n+3), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026900 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026901	0	->	3	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026901 T(2n+1,n+4), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026901 extends A026780 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026902	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026902 a(n) = T(n,m) + T(n,m+1) + ... + T(n,n), m=[ (n+1)/2 ], T given by A026780.
 * @author Sean A. Irvine
 */
public class A026902 extends A026780 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = (mN + 1) / 2; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026910	0	->	1	A026907	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026910 T(2n,n-1), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026910 extends A026907 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 1);
  }
}
#!queue	A026911	0	->	2	A026907	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026911 T(2n,n-2), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026911 extends A026907 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 2);
  }
}
#!queue	A026912	0	->	1	A026907	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026912 T(2n-1,n-1), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026912 extends A026907 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026913	0	->	2	A026907	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026913 T(2n-1,n-2), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026913 extends A026907 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026919	0	->	1	A026907	--------------------------------
package irvine.oeis.a026;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A026919 Uniquification of A026907.
 * @author Sean A. Irvine
 */
public class A026919 extends A026907 {

  private long mRow = 0;
  private Z mLeading = t(mRow, 0);
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    if (mSet.isEmpty() || mSet.first().compareTo(mLeading) > 0) {
      // Need to run through another row
      for (long k = 0; k <= mRow; ++k) {
        mSet.add(t(mRow, k));
      }
      mLeading = t(++mRow, 0);
    }
    return mSet.pollFirst();
  }
}
#!queue	A026934	0	->	1	A008288	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A026934 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A008288.
 * @author Sean A. Irvine
 */
public class A026934 extends A008288 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN - k , k).multiply(get(mN - k - 1, k + 1)));
    }
    return sum;
  }
}
#!queue	A026935	0	->	2	A008288	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A026935 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A008288.
 * @author Sean A. Irvine
 */
public class A026935 extends A008288 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN - k , k).multiply(get(mN - k - 2, k + 2)));
    }
    return sum;
  }
}
#!queue	A026936	0	->	3	A008288	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A026936 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A008288.
 * @author Sean A. Irvine
 */
public class A026936 extends A008288 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN - k , k).multiply(get(mN - k - 3, k + 3)));
    }
    return sum;
  }
}
#!queue	A026940	0	->	1	A026300	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026940 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026300.
 * @author Sean A. Irvine
 */
public class A026940 extends A026300 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A026941	0	->	2	A026300	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026941 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026300.
 * @author Sean A. Irvine
 */
public class A026941 extends A026300 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A026942	0	->	3	A026300	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026942 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026300.
 * @author Sean A. Irvine
 */
public class A026942 extends A026300 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A026947	0	->	1	A026374	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026947 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026374.
 * @author Sean A. Irvine
 */
public class A026947 extends A026374 {

  {
    nextRow();
  }

  @Override
  public Z next() {
    nextRow();
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.add(mGfRow.coeff(k).multiply(mGfRow.coeff(mN - k - 1)));
    }
    return sum;
  }
}
#!queue	A026948	0	->	2	A026374	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026948 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026374.
 * @author Sean A. Irvine
 */
public class A026948 extends A026374 {
  
  {
    nextRow();
    nextRow();
  }

  @Override
  public Z next() {
    nextRow();
    Z sum = Z.ZERO;
    for (int k = 0; k < mN - 1; ++k) {
      sum = sum.add(mGfRow.coeff(k).multiply(mGfRow.coeff(mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026949	0	->	3	A026374	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026949 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026374.
 * @author Sean A. Irvine
 */
public class A026949 extends A026374 {
  
  {
    nextRow();
    nextRow();
    nextRow();
  }

  @Override
  public Z next() {
    nextRow();
    Z sum = Z.ZERO;
    for (int k = 0; k < mN - 2; ++k) {
      sum = sum.add(mGfRow.coeff(k).multiply(mGfRow.coeff(mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026952	0	->	1	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026952 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026386.
 * @author Sean A. Irvine
 */
public class A026952 extends A026386 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 1)));
    }
    return sum;
  }
}
#!queue	A026953	0	->	2	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026953 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026386.
 * @author Sean A. Irvine
 */
public class A026953 extends A026386 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026954	0	->	3	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026954 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026386.
 * @author Sean A. Irvine
 */
public class A026954 extends A026386 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026956	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026956 a(n) = self-convolution of array T given by A026615.
 * @author Sean A. Irvine
 */
public class A026956 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026958	1	->	2	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026958 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026615.
 * @author Sean A. Irvine
 */
public class A026958 extends A026615 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026959	1	->	3	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026959 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026615.
 * @author Sean A. Irvine
 */
public class A026959 extends A026615 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026961	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026961 a(n) = self-convolution of array T given by A026626.
 * @author Sean A. Irvine
 */
public class A026961 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026963	1	->	2	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026963 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026626.
 * @author Sean A. Irvine
 */
public class A026963 extends A026626 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026964	1	->	3	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026964 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026626.
 * @author Sean A. Irvine
 */
public class A026964 extends A026626 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026965	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026965 a(n) = Sum_{k=0..n} (k+1) * A026626(n,k).
 * @author Sean A. Irvine
 */
public class A026965 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026967	0	->	1	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026967 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026637.
 * @author Sean A. Irvine
 */
public class A026967 extends A026637 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 1)));
    }
    return sum;
  }
}
#!queue	A026968	0	->	2	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026968 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026637.
 * @author Sean A. Irvine
 */
public class A026968 extends A026637 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026969	0	->	3	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026969 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026637.
 * @author Sean A. Irvine
 */
public class A026969 extends A026637 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026971	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026971 a(n) = self-convolution of array T given by A026648.
 * @author Sean A. Irvine
 */
public class A026971 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026973	1	->	2	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026973 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026648.
 * @author Sean A. Irvine
 */
public class A026973 extends A026648 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026974	1	->	3	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026974 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026648.
 * @author Sean A. Irvine
 */
public class A026974 extends A026648 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026975	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026975 a(n) = Sum_{k=0..n} (k+1) * A026648(n,k).
 * @author Sean A. Irvine
 */
public class A026975 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026976	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026976 Self-convolution of array T given by A026659.
 * @author Sean A. Irvine
 */
public class A026976 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026978	1	->	2	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026978 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026659.
 * @author Sean A. Irvine
 */
public class A026978 extends A026659 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026979	1	->	3	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026979 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026659.
 * @author Sean A. Irvine
 */
public class A026979 extends A026659 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026980	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026980 a(n) = Sum_{k=0..n} (k+1) * A026659(n,k).
 * @author Sean A. Irvine
 */
public class A026980 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026982	0	->	1	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026982 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026670.
 * @author Sean A. Irvine
 */
public class A026982 extends A026670 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 1)));
    }
    return sum;
  }
}
#!queue	A026983	0	->	2	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026983 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026670.
 * @author Sean A. Irvine
 */
public class A026983 extends A026670 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026984	0	->	3	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026984 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026670.
 * @author Sean A. Irvine
 */
public class A026984 extends A026670 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026986	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026986 Self-convolution of array T given by A026681.
 * @author Sean A. Irvine
 */
public class A026986 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026988	1	->	2	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026988 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026681.
 * @author Sean A. Irvine
 */
public class A026988 extends A026681 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026989	1	->	3	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026989 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026681.
 * @author Sean A. Irvine
 */
public class A026989 extends A026681 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026990	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026990 a(n) = Sum_{k=0..n} (k+1) * A026681(n, k).
 * @author Sean A. Irvine
 */
public class A026990 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026991	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026991 Self-convolution of array T given by A026692.
 * @author Sean A. Irvine
 */
public class A026991 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026993	1	->	2	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026993 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026692.
 * @author Sean A. Irvine
 */
public class A026993 extends A026692 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026994	1	->	3	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026994 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026692.
 * @author Sean A. Irvine
 */
public class A026994 extends A026692 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026995	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026995 a(n) = Sum_{k=0..n} (k+1) * A026692(n, k).
 * @author Sean A. Irvine
 */
public class A026995 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026996	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026996 Self-convolution of array T given by A026703.
 * @author Sean A. Irvine
 */
public class A026996 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A027003	0	->	4	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027003 a(n) = A026998(2n, n+4).
 * @author Sean A. Irvine
 */
public class A027003 extends A027960 {

  private long mN = 6;

  @Override
  public Z next() {
    mN += 2;
    return get(mN, mN + 8);
  }
}
#!queue	A027007	0	->	3	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027007 a(n) = A026998(2n+1, n+4).
 * @author Sean A. Irvine
 */
public class A027007 extends A027960 {

  private long mN = 5;

  @Override
  public Z next() {
    mN += 2;
    return get(mN, mN + 7);
  }
}
#!queue	A027008	0	->	1	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027008 a(n) = greatest number in row n of array T given by A026998.
 * @author Sean A. Irvine
 */
public class A027008 extends A027960 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z max = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      max = max.max(get(mN, 2 * k));
    }
    return max;
  }
}
#!queue	A027011	0	->	1	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027011 Triangular array T read by rows: T(n,k) = t(n, 2k+1) for 0 &lt;= k &lt;= floor((2n-1)/2), t given by A027960, n &gt;= 0.
 * @author Sean A. Irvine
 */
public class A027011 extends A027960 {

  private long mN = 0;
  private long mM = 0;

  protected Z t(final long n, final long m) {
    return get(n, 2 * m + 1);
  }

  @Override
  public Z next() {
    if (++mM > (2 * mN - 1) / 2) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A027027	0	->	2	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027027 a(n) = T(n, 2n-3), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027027 extends A027023 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 3);
  }
}
#!queue	A027028	0	->	2	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027028 a(n) = T(n,2n-4), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027028 extends A027023 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 4);
  }
}
#!queue	A027029	0	->	3	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027029 a(n) = T(n,2n-5), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027029 extends A027023 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 5);
  }
}
#!queue	A027030	0	->	3	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027030 a(n) = T(n,2n-6), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027030 extends A027023 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 6);
  }
}
#!queue	A027031	0	->	4	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027031 a(n) = T(n,2n-7), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027031 extends A027023 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 7);
  }
}
#!queue	A027032	0	->	4	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027032 a(n) = T(n,2n-8), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027032 extends A027023 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 8);
  }
}
#!queue	A027033	0	->	5	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027033 a(n) = T(n,2n-9), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027033 extends A027023 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 9);
  }
}
#!queue	A027034	0	->	5	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027034 a(n) = T(n,2n-10), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027034 extends A027023 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 10);
  }
}
#!queue	A027042	0	->	1	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027042 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,2n-k), with T given by A027023.
 * @author Sean A. Irvine
 */
public class A027042 extends A027023 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027045	0	->	1	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027045 a(n) = Sum_{k=n+1..2*n} T(n, k), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027045 extends A027023 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = mN + 1; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027047	0	->	1	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027047 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A027023.
 * @author Sean A. Irvine
 */
public class A027047 extends A027023 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027048	0	->	2	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027048 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A027023.
 * @author Sean A. Irvine
 */
public class A027048 extends A027023 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027049	0	->	3	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027049 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A027023.
 * @author Sean A. Irvine
 */
public class A027049 extends A027023 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027050	0	->	1	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027050 a(n) = T(n,2n-1), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027050 extends A027023 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 1);
  }
}
#!queue	A027051	0	->	2	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027051 a(n) = T(n,2n-2), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027051 extends A027023 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 2);
  }
}
#!queue	A027056	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027056 a(n) = A027052(n, 2n-1).
 * @author Sean A. Irvine
 */
public class A027056 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 1);
  }
}
#!queue	A027058	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027058 a(n) = A027052(n, 2n-2).
 * @author Sean A. Irvine
 */
public class A027058 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 2);
  }
}
#!queue	A027059	0	->	2	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027059 a(n) = A027052(n, 2n-3).
 * @author Sean A. Irvine
 */
public class A027059 extends A027052 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 3);
  }
}
#!queue	A027060	0	->	2	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027060 a(n) = T(n,2n-4), T given by A027052.
 * @author Sean A. Irvine
 */
public class A027060 extends A027052 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 4);
  }
}
#!queue	A027061	0	->	3	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027061 a(n) = A027052(n, 2n-5).
 * @author Sean A. Irvine
 */
public class A027061 extends A027052 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 5);
  }
}
#!queue	A027062	0	->	3	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027062 a(n) = A027052(n, 2n-6).
 * @author Sean A. Irvine
 */
public class A027062 extends A027052 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 6);
  }
}
#!queue	A027063	0	->	4	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027063 a(n) = A027052(n, 2n-7).
 * @author Sean A. Irvine
 */
public class A027063 extends A027052 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 7);
  }
}
#!queue	A027064	0	->	4	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027064 a(n) = A027052(n, 2n-8).
 * @author Sean A. Irvine
 */
public class A027064 extends A027052 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 8);
  }
}
#!queue	A027065	0	->	5	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027065 a(n) = A027052(n, 2n-9).
 * @author Sean A. Irvine
 */
public class A027065 extends A027052 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 9);
  }
}
#!queue	A027066	0	->	5	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027066 a(n) = A027052(n, 2n-10).
 * @author Sean A. Irvine
 */
public class A027066 extends A027052 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 10);
  }
}
#!queue	A027074	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027074 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,2n-k), with T given by A027052.
 * @author Sean A. Irvine
 */
public class A027074 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027077	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027077 a(n) = Sum_{k=n+1..2*n} T(n,k), T given by A027052.
 * @author Sean A. Irvine
 */
public class A027077 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = mN + 1; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027079	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027079 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A027052.
 * @author Sean A. Irvine
 */
public class A027079 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027080	0	->	2	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027080 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A027052.
 * @author Sean A. Irvine
 */
public class A027080 extends A027052 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027081	0	->	3	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027081 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A027052.
 * @author Sean A. Irvine
 */
public class A027081 extends A027052 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027088	0	->	1	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027088 a(n) = A027082(n, 2n-1).
 * @author Sean A. Irvine
 */
public class A027088 extends A027082 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 1);
  }
}
#!queue	A027089	0	->	2	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027089 a(n) = A027082(n, 2n-2).
 * @author Sean A. Irvine
 */
public class A027089 extends A027082 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 2);
  }
}
#!queue	A027090	0	->	2	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027090 a(n) = A027082(n, 2n-3).
 * @author Sean A. Irvine
 */
public class A027090 extends A027082 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 3);
  }
}
#!queue	A027091	0	->	2	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027091 a(n) = A027082(n, 2n-4).
 * @author Sean A. Irvine
 */
public class A027091 extends A027082 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 4);
  }
}
#!queue	A027092	0	->	3	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027092 a(n) = A027082(n, 2n-5).
 * @author Sean A. Irvine
 */
public class A027092 extends A027082 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 5);
  }
}
#!queue	A027093	0	->	3	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027093 a(n) = A027082(n, 2n-6).
 * @author Sean A. Irvine
 */
public class A027093 extends A027082 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 6);
  }
}
#!queue	A027094	0	->	4	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027094 a(n) = A027082(n, 2n-7).
 * @author Sean A. Irvine
 */
public class A027094 extends A027082 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 7);
  }
}
#!queue	A027095	0	->	4	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027095 a(n) = A027082(n, 2n-8).
 * @author Sean A. Irvine
 */
public class A027095 extends A027082 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 8);
  }
}
#!queue	A027096	0	->	5	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027096 a(n) = A027082(n, 2n-9).
 * @author Sean A. Irvine
 */
public class A027096 extends A027082 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 9);
  }
}
#!queue	A027097	0	->	5	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027097 a(n) = A027082(n, 2n-10).
 * @author Sean A. Irvine
 */
public class A027097 extends A027082 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 10);
  }
}
#!queue	A027105	0	->	1	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027105 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,2n-k), with T given by A027082.
 * @author Sean A. Irvine
 */
public class A027105 extends A027082 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027110	0	->	1	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027110 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A027082.
 * @author Sean A. Irvine
 */
public class A027110 extends A027082 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027111	0	->	2	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027111 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A027082.
 * @author Sean A. Irvine
 */
public class A027111 extends A027082 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027112	0	->	3	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027112 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A027082.
 * @author Sean A. Irvine
 */
public class A027112 extends A027082 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027145	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027145 a(n) = A027144(2n, n).
 * @author Sean A. Irvine
 */
public class A027145 extends A027144 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A027147	1	->	2	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027147 a(n) = A027144(2n, n-2).
 * @author Sean A. Irvine
 */
public class A027147 extends A027144 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A027149	1	->	2	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027149 a(n) = A027144(2n-1, n-2).
 * @author Sean A. Irvine
 */
public class A027149 extends A027144 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A027150	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027150 a(n) = A027144(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A027150 extends A027144 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A027152	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027152 T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A027144.
 * @author Sean A. Irvine
 */
public class A027152 extends A027144 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027154	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027154 a(n) = Sum_{k=0..floor(n/2)} A027144(n-k, k).
 * @author Sean A. Irvine
 */
public class A027154 extends A027144 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A027155	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027155 Greatest number in row n of array T given by A027144.
 * @author Sean A. Irvine
 */
public class A027155 extends A027144 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z max = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      max = max.max(get(mN, k));
    }
    return max;
  }
}
#!queue	A027156	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027156 a(n) = self-convolution of array T given by A027144.
 * @author Sean A. Irvine
 */
public class A027156 extends A027144 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A027172	0	->	1	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027172 a(n) = (1/2) * A027170(2n, n).
 * @author Sean A. Irvine
 */
public class A027172 extends A027170 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN, mN).divide2();
  }
}
#!queue	A027173	0	->	1	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027173 a(n) = A027170(2n, n-1).
 * @author Sean A. Irvine
 */
public class A027173 extends A027170 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 1);
  }
}
#!queue	A027174	0	->	2	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027174 a(n) = A027170(2n, n-2).
 * @author Sean A. Irvine
 */
public class A027174 extends A027170 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 2);
  }
}
#!queue	A027175	0	->	1	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027175 a(n) = A027170(2n-1, n-1).
 * @author Sean A. Irvine
 */
public class A027175 extends A027170 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A027176	0	->	2	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027176 a(n) = A027170(2n-1, n-2).
 * @author Sean A. Irvine
 */
public class A027176 extends A027170 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A027183	0	->	1	A027170	--------------------------------
package irvine.oeis.a027;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A027183 a(n) = n-th largest even number in array T given by A027170.
 * @author Sean A. Irvine
 */
public class A027183 extends A027170 {

  private long mRow = 2;
  private Z mLast = Z.ZERO;
  private Z mLeading = t(mRow, 1);
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    while (mSet.isEmpty() || mSet.first().compareTo(mLeading) > 0) {
      for (long k = 0; k <= mRow / 2; ++k) {
        final Z t = t(mRow, k);
        if (t.isEven() && t.compareTo(mLast) > 0) {
          mSet.add(t);
        }
      }
      mLeading = t(++mRow, 1);
    }
    mLast = mSet.pollFirst();
    return mLast;
  }
}
#!queue	A027189	0	->	1	A027188	--------------------------------
package irvine.oeis.a027;

/**
 * A027189 Number of partitions of n into an odd number of parts, the least being 3; also, a(n+3) = number of partitions of n into an even number of parts, each &gt;=3.
 * @author Sean A. Irvine
 */
public class A027189 extends A027188 {

  @Override
  protected int leastPart() {
    return 3;
  }
}
#!queue	A027190	0	->	1	A027188	--------------------------------
package irvine.oeis.a027;

/**
 * A027190 Number of partitions of n into an odd number of parts, the least being 4; also, a(n+4) = number of partitions of n into an even number of parts, each &gt;=4.
 * @author Sean A. Irvine
 */
public class A027190 extends A027188 {

  @Override
  protected int start() {
    return -4;
  }

  @Override
  protected int leastPart() {
    return 4;
  }
}
#!queue	A027191	0	->	1	A027188	--------------------------------
package irvine.oeis.a027;

/**
 * A027191 Number of partitions of n into an odd number of parts, the least being 5; also, a(n+5) = number of partitions of n into an even number of parts, each &gt;=5.
 * @author Sean A. Irvine
 */
public class A027191 extends A027188 {

  @Override
  protected int start() {
    return -5;
  }

  @Override
  protected int leastPart() {
    return 5;
  }
}
#!queue	A027192	0	->	1	A027188	--------------------------------
package irvine.oeis.a027;

/**
 * A027192 Number of partitions of n into an odd number of parts, the least being 6; also, a(n+6) = number of partitions of n into an even number of parts, each &gt;=6.
 * @author Sean A. Irvine
 */
public class A027192 extends A027188 {

  @Override
  protected int start() {
    return -6;
  }

  @Override
  protected int leastPart() {
    return 6;
  }
}
#!queue	A027201	1	->	0	A026714	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026714;

/**
 * A027201 a(n) = self-convolution of row n of array T given by A026714.
 * @author Sean A. Irvine
 */
public class A027201 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A027203	1	->	2	A026714	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026714;

/**
 * A027203 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026714.
 * @author Sean A. Irvine
 */
public class A027203 extends A026714 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A027204	1	->	3	A026714	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026714;

/**
 * A027204 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026714.
 * @author Sean A. Irvine
 */
public class A027204 extends A026714 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A027205	1	->	0	A026714	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026714;

/**
 * A027205 a(n) = Sum_{k=0..n} (k+1) * A026714(n, k).
 * @author Sean A. Irvine
 */
public class A027205 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027208	0	->	1	A026725	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026725;

/**
 * A027208 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026725.
 * @author Sean A. Irvine
 */
public class A027208 extends A026725 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027209	0	->	2	A026725	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026725;

/**
 * A027209 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026725.
 * @author Sean A. Irvine
 */
public class A027209 extends A026725 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027210	0	->	3	A026725	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026725;

/**
 * A027210 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026725.
 * @author Sean A. Irvine
 */
public class A027210 extends A026725 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027216	0	->	1	A026736	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026736;

/**
 * A027216 a(n) = Sum_{k=0..n-1} T(n,k)*T(n,k+1), T given by A026736.
 * @author Sean A. Irvine
 */
public class A027216 extends A026736 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027217	0	->	2	A026736	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026736;

/**
 * A027217 a(n) = Sum_{k=0..n-2} T(n,k)*T(n,k+2), T given by A026736.
 * @author Sean A. Irvine
 */
public class A027217 extends A026736 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027218	0	->	3	A026736	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026736;

/**
 * A027218 a(n) = Sum_{k=0..n-3} T(n,k)*T(n,k+3), T given by A026736.
 * @author Sean A. Irvine
 */
public class A027218 extends A026736 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027224	0	->	1	A026747	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026747;

/**
 * A027224 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026747.
 * @author Sean A. Irvine
 */
public class A027224 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027225	0	->	2	A026747	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026747;

/**
 * A027225 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026747.
 * @author Sean A. Irvine
 */
public class A027225 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027226	0	->	3	A026747	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026747;

/**
 * A027226 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026747.
 * @author Sean A. Irvine
 */
public class A027226 extends A026747 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027232	0	->	1	A026758	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026758;

/**
 * A027232 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026758.
 * @author Sean A. Irvine
 */
public class A027232 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027233	0	->	2	A026758	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026758;

/**
 * A027233 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026758.
 * @author Sean A. Irvine
 */
public class A027233 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027234	0	->	3	A026758	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026758;

/**
 * A027234 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026758.
 * @author Sean A. Irvine
 */
public class A027234 extends A026758 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027240	0	->	1	A026769	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026769;

/**
 * A027240 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026769.
 * @author Sean A. Irvine
 */
public class A027240 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027241	0	->	2	A026769	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026769;

/**
 * A027241 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026769.
 * @author Sean A. Irvine
 */
public class A027241 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027242	0	->	3	A026769	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026769;

/**
 * A027242 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026769.
 * @author Sean A. Irvine
 */
public class A027242 extends A026769 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027248	0	->	1	A026780	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026780;

/**
 * A027248 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026780.
 * @author Sean A. Irvine
 */
public class A027248 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027249	0	->	2	A026780	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026780;

/**
 * A027249 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026780.
 * @author Sean A. Irvine
 */
public class A027249 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027250	0	->	3	A026780	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026780;

/**
 * A027250 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026780.
 * @author Sean A. Irvine
 */
public class A027250 extends A026780 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027254	1	->	2	A026703	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026703;

/**
 * A027254 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026703.
 * @author Sean A. Irvine
 */
public class A027254 extends A026703 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027255	1	->	3	A026703	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026703;

/**
 * A027255 Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026703.
 * @author Sean A. Irvine
 */
public class A027255 extends A026703 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027256	1	->	0	A026703	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026703;

/**
 * A027256 a(n) = Sum_{k=0..n} (k+1) * A026703(n, k).
 * @author Sean A. Irvine
 */
public class A027256 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027258	0	->	1	A025177	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a025.A025177;

/**
 * A027258 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A025177.
 * @author Sean A. Irvine
 */
public class A027258 extends A025177 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027259	0	->	2	A025177	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a025.A025177;

/**
 * A027259 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A025177.
 * @author Sean A. Irvine
 */
public class A027259 extends A025177 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027260	0	->	3	A025177	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a025.A025177;

/**
 * A027260 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A025177.
 * @author Sean A. Irvine
 */
public class A027260 extends A025177 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027263	0	->	1	A026519	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026519;

/**
 * A027263 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A026519.
 * @author Sean A. Irvine
 */
public class A027263 extends A026519 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027264	0	->	2	A026519	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026519;

/**
 * A027264 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A026519.
 * @author Sean A. Irvine
 */
public class A027264 extends A026519 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027265	0	->	3	A026519	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026519;

/**
 * A027265 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A026519.
 * @author Sean A. Irvine
 */
public class A027265 extends A026519 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027268	0	->	1	A026536	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026536;

/**
 * A027268 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A026536.
 * @author Sean A. Irvine
 */
public class A027268 extends A026536 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027269	0	->	1	A026536	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026536;

/**
 * A027269 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A026536.
 * @author Sean A. Irvine
 */
public class A027269 extends A026536 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027270	0	->	2	A026536	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026536;

/**
 * A027270 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A026536.
 * @author Sean A. Irvine
 */
public class A027270 extends A026536 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027273	0	->	1	A026552	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026552;

/**
 * A027273 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A026552.
 * @author Sean A. Irvine
 */
public class A027273 extends A026552 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027274	0	->	2	A026552	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026552;

/**
 * A027274 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A026552.
 * @author Sean A. Irvine
 */
public class A027274 extends A026552 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027275	0	->	3	A026552	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026552;

/**
 * A027275 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A026552.
 * @author Sean A. Irvine
 */
public class A027275 extends A026552 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027277	1	->	0	A026568	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026568;

/**
 * A027277 a(n) = Sum_{k=0..n} binomial(2*k,k)*binomial(2*n-k,k).
 * @author Sean A. Irvine
 */
public class A027277 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027279	1	->	2	A026568	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026568;

/**
 * A027279 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A026568.
 * @author Sean A. Irvine
 */
public class A027279 extends A026568 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027280	1	->	3	A026568	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026568;

/**
 * A027280 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A026568.
 * @author Sean A. Irvine
 */
public class A027280 extends A026568 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027282	1	->	0	A026584	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026584;

/**
 * A027282 a(n) = self-convolution of row n of array T given by A026584.
 * @author Sean A. Irvine
 */
public class A027282 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027284	1	->	2	A026584	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026584;

/**
 * A027284 a(n) = Sum_{k=0..2*n-2} T(n,k) * T(n,k+2), with T given by A026584.
 * @author Sean A. Irvine
 */
public class A027284 extends A026584 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A027285	1	->	3	A026584	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026584;

/**
 * A027285 a(n) = Sum_{k=0..2*n-3} T(n,k) * T(n,k+3), with T given by A026584.
 * @author Sean A. Irvine
 */
public class A027285 extends A026584 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A027286	1	->	0	A026584	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026584;

/**
 * A027286 a(n) = Sum_{k=0..2n} (k+1) * A026584(n, k).
 * @author Sean A. Irvine
 */
public class A027286 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027289	0	->	2	A026009	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026009;

/**
 * A027289 a(n) = Sum_{k=0..floor(n/2)-1} T(n,k) * T(n,k+2), with T given by A026009.
 * @author Sean A. Irvine
 */
public class A027289 extends A026009 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN / 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027290	0	->	4	A026009	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026009;

/**
 * A027290 a(n) = Sum_{k=0..floor(n/2)-2} T(n,k) * T(n,k+3), with T given by A026009.
 * @author Sean A. Irvine
 */
public class A027290 extends A026009 {

  private long mN = 3;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN / 2 - 1; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027294	1	->	0	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027294 Self-convolution of row n of array T given by A026022.
 * @author Sean A. Irvine
 */
public class A027294 extends A026022 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN >= 3 ? (mN + 1) / 2 + 1 : mN;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, lim - k)));
    }
    return sum;
  }
}
#!queue	A027296	1	->	2	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027296 a(n) = Sum_{k=0..floor((n-1)/2)} T(n,k) * T(n,k+2), with T given by A026022.
 * @author Sean A. Irvine
 */
public class A027296 extends A026022 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = (mN - 1) / 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027297	1	->	3	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027297 a(n) = Sum_{k=0..floor((n-3)/2)} T(n,k) * T(n,k+3), with T given by A026022.
 * @author Sean A. Irvine
 */
public class A027297 extends A026022 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = (mN - 3) / 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027298	1	->	0	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027298 a(n) = Sum_{k=0..m} (k+1) * A026022(n, k), where m=n for n=0,1 and m = floor((n+3)/2) for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027298 extends A026022 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN >= 3 ? (mN + 1) / 2 + 1 : mN;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027299	1	->	0	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027299 a(n) = Sum_{k=0..m} (k+1) * A026022(n, m-k), where m=n for n=0,1 and m = floor((n+3)/2) for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027299 extends A026022 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN >= 3 ? (mN + 1) / 2 + 1 : mN;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, lim - k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027302	0	->	1	A008315	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a008.A008315;

/**
 * A027302 a(n) = Sum_{k=0..floor((n-1)/2)} T(n,k) * T(n,k+1), with T given by A008315.
 * @author Sean A. Irvine
 */
public class A027302 extends A008315 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN / 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027303	0	->	3	A008315	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a008.A008315;

/**
 * A027303 a(n) = Sum_{k=0..floor((n-3)/2)} T(n,k) * T(n,k+2)}, with T given by A008315.
 * @author Sean A. Irvine
 */
public class A027303 extends A008315 {

  private long mN = 3;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= (mN - 3) / 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027304	0	->	5	A008315	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a008.A008315;

/**
 * A027304 a(n) = Sum_{k=0..floor((n-5)/2)} T(n,k) * T(n,k+1)}, with T given by A008315.
 * @author Sean A. Irvine
 */
public class A027304 extends A008315 {

  private long mN = 5;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= (mN - 5) / 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027311	1	->	2	A026323	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026323;

/**
 * A027311 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+3), with T given by A026323.
 * @author Sean A. Irvine
 */
public class A027311 extends A026323 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027312	1	->	0	A026323	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026323;

/**
 * A027312 a(n) = Sum_{k=0..n+2} (k+1) * A026323(n, k).
 * @author Sean A. Irvine
 */
public class A027312 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN + 2; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027314	1	->	0	A026323	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026323;

/**
 * A027314 a(n) is the sum of squares of numbers in row n of array T given by A026323.
 * @author Sean A. Irvine
 */
public class A027314 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN + 2; ++k) {
      sum = sum.add(get(mN, k).square());
    }
    return sum;
  }
}
#!queue	A027315	1	->	0	A026082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026082;

/**
 * A027315 Self-convolution of array T given by A026082.
 * @author Sean A. Irvine
 */
public class A027315 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).square());
    }
    return sum;
  }
}
#!queue	A027317	1	->	2	A026082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026082;

/**
 * A027317 a(n) = Sum_{k=0..m-2} T(n,k) * T(n,k+2), where m=n for n=0,1,2,3; m=2n for n &gt;= 4; and T is given by A026082.
 * @author Sean A. Irvine
 */
public class A027317 extends A026082 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027318	1	->	3	A026082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026082;

/**
 * A027318 a(n) = Sum_{k=0..m-3} T(n,k) * T(n,k+2), where m=n for n=0,1,2,3; m=2n for n &gt;= 4; and T is given by A026082.
 * @author Sean A. Irvine
 */
public class A027318 extends A026082 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027319	1	->	0	A026082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026082;

/**
 * A027319 a(n) = Sum_{k=0..m} (k+1) * A026082(n, k), where 0 &lt;= k &lt;= m, m=n for n=0,1,2,3; m=2n for n &gt;= 4.
 * @author Sean A. Irvine
 */
public class A027319 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027329	1	->	0	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027329 a(n) = self-convolution of row n of array T given by A026148.
 * @author Sean A. Irvine
 */
public class A027329 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN < 2 ? mN : mN + 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, lim - k)));
    }
    return sum;
  }
}
#!queue	A027331	1	->	2	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027331 a(n) = Sum_{k=0..m} T(n,k) * T(n,k+2), where m=2 for n=2 and m=n+1 for n &gt;= 3; and T is given by A026148.
 * @author Sean A. Irvine
 */
public class A027331 extends A026148 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027332	1	->	3	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027332 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+3), with T given by A026148.
 * @author Sean A. Irvine
 */
public class A027332 extends A026148 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027333	1	->	0	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027333 a(n) = Sum_{k=0..m} (k+1) * A026148(n, k), where m=0 for n=1; m=n+1 for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027333 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN < 2 ? mN : mN + 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027334	1	->	0	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027334 a(n) = Sum_{k=0..m} (k+1) * A026148(n, m-k), where m=0 for n=1; m=n+1 for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027334 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN < 2 ? mN : mN + 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(get(mN, lim - k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027335	1	->	0	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027335 a(n) is the sum of squares of the numbers in row n of array T given by A026148.
 * @author Sean A. Irvine
 */
public class A027335 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN < 2 ? mN : mN + 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(get(mN, k).square());
    }
    return sum;
  }
}
#!queue	A027419	0	->	1	A027384	--------------------------------
package irvine.oeis.a027;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;

/**
 * A027419 Number of distinct products ij with 0 &lt;= i, j &lt;= n-th prime.
 * @author Sean A. Irvine
 */
public class A027419 extends A027384 {

  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (mPrime.isPrime(mN)) {
        return t;
      }
    }
  }
}
#!queue	A027449	1	->	2	A027446	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027449 Second diagonal of A027446.
 * @author Sean A. Irvine
 */
public class A027449 extends A027446 {

  private long mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027450	1	->	3	A027446	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027450 Third diagonal of A027446.
 * @author Sean A. Irvine
 */
public class A027450 extends A027446 {

  private long mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027458	1	->	3	A027446	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027458 Third column of A027446.
 * @author Sean A. Irvine
 */
public class A027458 extends A027446 {

  private long mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027481	1	->	3	A027477	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027481 Second subdiagonal of triangle A027477, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027481 extends A027477 {

  private int mN = 2;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, mN - 3).multiply(f).toZ();
  }
}
#!queue	A027487	1	->	2	A027477	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027487 Second column of triangle A027477, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027487 extends A027477 {

  private int mN = 1;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, 1).multiply(f).toZ();
  }
}
#!queue	A027488	1	->	3	A027477	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027488 Third column of triangle A027477, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027488 extends A027477 {

  private int mN = 2;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, 2).multiply(f).toZ();
  }
}
#!queue	A027499	1	->	2	A027495	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027499 Second diagonal of A027495.
 * @author Sean A. Irvine
 */
public class A027499 extends A027495 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027500	1	->	3	A027495	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027500 Third diagonal of A027495.
 * @author Sean A. Irvine
 */
public class A027500 extends A027495 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027508	1	->	2	A027495	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027508 Second column of A027495.
 * @author Sean A. Irvine
 */
public class A027508 extends A027495 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027509	1	->	3	A027495	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027509 Third column of A027495.
 * @author Sean A. Irvine
 */
public class A027509 extends A027495 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027593	0	->	1	A027594	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027593 Sequence satisfies T^2(a)=a, where T is defined below.
 * @author Sean A. Irvine
 */
public class A027593 extends A027594 {

  @Override
  protected Z select(final Z a, final Z b) {
    return b;
  }
}
#!queue	A027827	0	->	1	A000041	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A027827 Values of k for which 11 divides A000041(k).
 * @author Sean A. Irvine
 */
public class A027827 extends A000041 {

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(11) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A027840	0	->	1	A060240	--------------------------------
package irvine.oeis.a027;

import irvine.math.MemoryFunction2;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a060.A060240;

/**
 * A027840 Number of subgroups of index n in fundamental group of a certain fiber space.
 * @author Sean A. Irvine
 */
public class A027840 extends A060240 {

  private int mN = 0;

  private final MemoryFunction2<Integer, Z> mBeta = new MemoryFunction2<Integer, Z>() {
    @Override
    protected Z compute(final Integer k, final Integer e) {
      if (k == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      final IntegerPartition partition = new IntegerPartition(k);
      int[] p;
      while ((p = partition.next()) != null) {
        sum = sum.add(mF.factorial(k).divide(degree(k, p)).pow(e));
      }
      return sum;
    }
  };

  private Z bigR(final int n, final int e) {
    Z sum = Z.ZERO;
    final IntegerPartition partition = new IntegerPartition(n);
    int[] p;
    final int[] cnt = new int[n + 1];
    while ((p = partition.next()) != null) {
      IntegerPartition.toCountForm(p, cnt);
      Z b = Z.ONE;
      for (final int i : p) {
        b = b.multiply(mBeta.get(i, e));
      }
      b = b.multiply(n).multiply(Binomial.multinomial(p.length, cnt)).divide(p.length);
      sum = sum.signedAdd((p.length & 1) == 1, b);
    }
    return sum;
  }

  protected int nu() {
    return 2;
  }

  @Override
  public Z next() {
    return bigR(++mN, nu());
  }
}
#!queue	A027857	0	->	1	A027423	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027857 Number of positive divisors of n!, read mod n.
 * @author Sean A. Irvine
 */
public class A027857 extends A027423 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A027917	1	->	3	A001303	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000217;
import irvine.oeis.a001.A001303;

/**
 * A027917 a(n) = least k such that 1+2+...+k &gt;= E{1,2,...,n}, where E is the 3rd elementary symmetric function.
 * @author Sean A. Irvine
 */
public class A027917 extends A001303 {

  private final Sequence mA = new A000217();
  private long mK = -1;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027918	1	->	4	A000915	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000217;
import irvine.oeis.a000.A000915;

/**
 * A027918 Least k such that 1+2+...+k &gt;= E{1,2,...,n}, where E is the 4th elementary symmetric function.
 * @author Sean A. Irvine
 */
public class A027918 extends A000915 {

  private final Sequence mA = new A000217();
  private long mK = -1;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027919	1	->	3	A001303	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000914;
import irvine.oeis.a001.A001303;

/**
 * A027919 a(n) = least k such that 2nd elementary symmetric function of {1,2,...,k+1} &gt;= 3rd elementary symmetric function of {1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A027919 extends A001303 {

  private final Sequence mA = new A000914();
  private long mK = -1;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027920	1	->	4	A000915	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000914;
import irvine.oeis.a000.A000915;

/**
 * A027920 Least k such that 2nd elementary symmetric function of {1,2,...,k} &gt;= 4th elementary symmetric function of {1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A027920 extends A000915 {

  private final Sequence mA = new A000914();
  private long mK = -1;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027921	1	->	4	A000915	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000915;
import irvine.oeis.a001.A001303;

/**
 * A027921 a(n) = least k such that 3rd elementary symmetric function of {1,2,...,k} &gt;= 4th elementary symmetric function of {1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A027921 extends A000915 {

  private final Sequence mA = new A001303();
  private long mK = 0;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027925	0	->	1	A000537	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000537;
import irvine.oeis.a000.A000914;

/**
 * A027925 a(n) = least k such that E{1,2,...,k} &gt;= 1^3 + 2^3 + ... + n^3, where E = 2nd elementary symmetric function.
 * @author Sean A. Irvine
 */
public class A027925 extends A000537 {

  private final Sequence mA = new A000914();
  private Z mT = Z.NEG_ONE;
  private long mK = -1;

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    while (mT.compareTo(t) < 0) {
      mT = mA.next();
      ++mK;
    }
    return Z.valueOf(mK);
  }
}
#!queue	A027936	0	->	1	A027935	--------------------------------
package irvine.oeis.a027;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A027936 Uniquification of array T given by A027935.
 * @author Sean A. Irvine
 */
public class A027936 extends A027935 {

  private long mRow = 1;
  private Z mLast = Z.ZERO;
  private Z mLeading = A027926.t(mRow, 2 * mRow - 2);
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    while (mSet.isEmpty() || mSet.first().compareTo(mLeading) > 0) {
      // Need to run through another row
      for (long k = 0; k <= mRow; ++k) {
        final Z t = A027926.t(mRow, 2 * k);
        if (t.compareTo(mLast) > 0) {
          mSet.add(t);
        }
      }
      mLeading = A027926.t(++mRow, 2 * mRow - 2);
    }
    mLast = mSet.pollFirst();
    return mLast;
  }
}
#!queue	A027985	0	->	1	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027985 a(n) = Sum{T(n,k)*T(n,k+1)}, 0&lt;=k&lt;=2n-1, T given by A027960.
 * @author Sean A. Irvine
 */
public class A027985 extends A027960 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long m = 0; m < 2 * mN; ++m) {
      sum = sum.add(get(mN, m).multiply(get(mN, m + 1)));
    }
    return sum;
  }
}
#!queue	A027986	0	->	2	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027986 Sum{T(n,k)*T(n,k+2)}, 0&lt;=k&lt;=2n-2, T given by A027960.
 * @author Sean A. Irvine
 */
public class A027986 extends A027960 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long m = 0; m < 2 * mN - 1; ++m) {
      sum = sum.add(get(mN, m).multiply(get(mN, m + 2)));
    }
    return sum;
  }
}
#!queue	A027987	0	->	3	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027987 a(n) = Sum{T(n,k)*T(n,k+3)}, 0&lt;=k&lt;=2n-3, T given by A027960.
 * @author Sean A. Irvine
 */
public class A027987 extends A027960 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long m = 0; m < 2 * mN - 2; ++m) {
      sum = sum.add(get(mN, m).multiply(get(mN, m + 3)));
    }
    return sum;
  }
}
#!queue	A028243	0	->	1	A000392	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a000.A000392;

/**
 * A028243 a(n) = 3^(n-1) - 2*2^(n-1) + 1 (essentially Stirling numbers of second kind).
 * @author Sean A. Irvine
 */
public class A028243 extends A000392 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A028305	1	->	0	A007710	--------------------------------
package irvine.oeis.a028;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a007.A007710;
import irvine.util.Permutation;

/**
 * A028305 Triangle of numbers of permutations eliminating just k cards out of n in game of Mousetrap.
 * @author Sean A. Irvine
 */
public class A028305 extends A007710 {

  private int mN = 0;
  private int mM = -1;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    long count = 0;
    final Permutation perm = new Permutation(mN);
    int[] p;
    while ((p = perm.next()) != null) {
      if (isDiscardCount(Arrays.copyOf(p, p.length), mM)) {
        ++count;
      }
    }
    return Z.valueOf(count);
  }

}
#!queue	A028330	1	->	0	A014413	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a014.A014413;

/**
 * A028330 Elements to the right of the central elements of the even-Pascal triangle A028326.
 * @author Sean A. Irvine
 */
public class A028330 extends A014413 {

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A028334	1	->	2	A001223	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a001.A001223;

/**
 * A028334 Differences between consecutive odd primes, divided by 2.
 * @author Sean A. Irvine
 */
public class A028334 extends A001223 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A028339	0	->	2	A028338	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028339 Coefficient of x^2 in expansion of (x+1)*(x+3)*...*(x+2*n-1).
 * @author Sean A. Irvine
 */
public class A028339 extends A028338 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}
#!queue	A028340	0	->	3	A028338	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028340 Coefficient of x^3 in expansion of (x+1)*(x+3)*...*(x+2*n-1).
 * @author Sean A. Irvine
 */
public class A028340 extends A028338 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3);
  }
}
#!queue	A028341	0	->	4	A028338	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028341 Coefficient of x^4 in expansion of (x+1)*(x+3)*...*(x+2*n-1).
 * @author Sean A. Irvine
 */
public class A028341 extends A028338 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, 4);
  }
}
#!queue	A028370	0	->	1	A000722	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a000.A000722;

/**
 * A028370 a(n) = (2^(n-1))!*2^(2^(n-1)-1).
 * @author Sean A. Irvine
 */
public class A028370 extends A000722 {

  private int mN = -1;

  @Override
  public Z next() {
    return super.next().shiftLeft(Z.ONE.shiftLeft(++mN).longValueExact() - 1);
  }
}
#!queue	A028371	0	->	2	A028366	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028371 a(n) = (2^(n-1)-1)!*2^((2^(n-1)-1)-1).
 * @author Sean A. Irvine
 */
public class A028371 extends A028366 {

  private int mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().shiftLeft(Z.ONE.shiftLeft(++mN).longValueExact() - 2);
  }
}
#!queue	A028894	0	->	1	A005614	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a005.A005614;

/**
 * A028894 a(n) = either 4a(n-1)+1 or 4a(n-1)+3 depending on corresponding term of A005614, +1 for 0, +3 for 1.
 * @author Sean A. Irvine
 */
public class A028894 extends A005614 {

  private Z mA = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
      super.next();
    } else {
      mA = mA.shiftLeft(2).add(super.next().multiply2().add(1));
    }
    return mA;
  }
}
#!queue	A028987	0	->	1	A010785	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A028987 Repdigit - 1 is prime.
 * @author Sean A. Irvine
 */
public class A028987 extends A010785 {

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.subtract(1).isProbablePrime()) {
        return p;
      }
    }
  }
}
#!queue	A028988	0	->	1	A010785	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A028988 Repdigit + 1 is prime.
 * @author Sean A. Irvine
 */
public class A028988 extends A010785 {

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.add(1).isProbablePrime()) {
        return p;
      }
    }
  }
}
#!queue	A029637	0	->	1	A029635	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029637 Numbers in the (1,2)-Pascal triangle A029635 that are different from 2.
 * @author Sean A. Irvine
 */
public class A029637 extends A029635 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (Z.TWO.equals(t));
    return t;
  }
}
#!queue	A029638	0	->	1	A029635	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029638 Numbers in the (1,2)-Pascal triangle A029635 that are different from 1.
 * @author Sean A. Irvine
 */
public class A029638 extends A029635 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (Z.ONE.equals(t));
    return t;
  }
}
#!queue	A029640	0	->	1	A029635	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029640 Even numbers in the (1,2)-Pascal triangle A029635.
 * @author Sean A. Irvine
 */
public class A029640 extends A029635 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isOdd());
    return t;
  }
}
#!queue	A029652	0	->	1	A029635	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029652 Odd numbers in the (1,2)-Pascal triangle A029635.
 * @author Sean A. Irvine
 */
public class A029652 extends A029635 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isEven());
    return t;
  }
}
#!queue	A029656	0	->	1	A029653	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029656 Numbers in the (2,1)-Pascal triangle A029653 that are different from 1.
 * @author Sean A. Irvine
 */
public class A029656 extends A029653 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (Z.ONE.equals(t));
    return t;
  }
}
#!queue	A029714	1	->	0	A002034	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a002.A002034;

/**
 * A029714 a(n) = Sum_{k divides 3^n} S(k), where S is the Kempner function A002034.
 * @author Sean A. Irvine
 */
public class A029714 extends A002034 {

  private Z mA = Z.ZERO;
  private Z mN = Z.ONE;

  @Override
  public Z next() {
    mA = mA.add(kempner(mN));
    mN = mN.multiply(3);
    return mA;
  }
}
#!queue	A029715	1	->	0	A002034	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a002.A002034;

/**
 * A029715 a(n) = Sum_{k divides 2^n} S(k), where S is the Kempner function A002034.
 * @author Sean A. Irvine
 */
public class A029715 extends A002034 {

  private Z mA = Z.ZERO;
  private Z mN = Z.ONE;

  @Override
  public Z next() {
    mA = mA.add(kempner(mN));
    mN = mN.multiply2();
    return mA;
  }
}
#!queue	A029777	1	->	0	A029776	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029777 Cubes such that digits of cube root of n appear in n.
 * @author Sean A. Irvine
 */
public class A029777 extends A029776 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A029791	1	->	0	A029790	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029791 Squares such that digits of sqrt(n) are not present in n or n^(3/2).
 * @author Sean A. Irvine
 */
public class A029791 extends A029790 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A029792	1	->	0	A029790	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029792 Cubes such that digits of cube root of n are not present in n^(2/3) or n.
 * @author Sean A. Irvine
 */
public class A029792 extends A029790 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A029796	1	->	0	A029795	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029796 Cubes such that cube root of n and n have same digits.
 * @author Sean A. Irvine
 */
public class A029796 extends A029795 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A029798	1	->	0	A029797	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029798 Squares such that n and n^(3/2) have same digits.
 * @author Sean A. Irvine
 */
public class A029798 extends A029797 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A029799	1	->	0	A029797	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029799 Cubes such that n^(2/3) and n have same digits.
 * @author Sean A. Irvine
 */
public class A029799 extends A029797 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A029828	1	->	0	A013959	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a013.A013959;

/**
 * A029828 Eisenstein series E_12(q) (alternate convention E_6(q)), multiplied by 691.
 * @author Sean A. Irvine
 */
public class A029828 extends A013959 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.valueOf(691);
    }
    return super.next().multiply(65520);
  }
}
#!queue	A029829	1	->	0	A013963	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a013.A013963;

/**
 * A029829 Eisenstein series E_16(q) (alternate convention E_8(q)), multiplied by 3617.
 * @author Sean A. Irvine
 */
public class A029829 extends A013963 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.valueOf(3617);
    }
    return super.next().multiply(16320);
  }
}
#!queue	A029830	1	->	0	A013967	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a013.A013967;

/**
 * A029830 Eisenstein series E_20(q) (alternate convention E_10(q)), multiplied by 174611.
 * @author Sean A. Irvine
 */
public class A029830 extends A013967 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.valueOf(174611);
    }
    return super.next().multiply(13200);
  }
}
#!queue	A029831	1	->	0	A013971	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a013.A013971;

/**
 * A029831 Eisenstein series E_24(q) (alternate convention E_12(q)), multiplied by 236364091.
 * @author Sean A. Irvine
 */
public class A029831 extends A013971 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.valueOf(236364091);
    }
    return super.next().multiply(131040);
  }
}
#!queue	A029855	1	->	5	A033185	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a033.A033185;

/**
 * A029855 Number of rooted trees where root has degree 4.
 * @author Sean A. Irvine
 */
public class A029855 extends A033185 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN, 4);
  }
}
#!queue	A029890	0	->	1	A029889	--------------------------------
package irvine.oeis.a029;

import irvine.math.IntegerUtils;

/**
 * A029890 Number of odd graphical partitions.
 * @author Sean A. Irvine
 */
public class A029890 extends A029889 {

  {
    super.next();
  }

  @Override
  protected boolean accept(final int[] rowSums) {
    return (IntegerUtils.sum(rowSums) & 1) == 1;
  }
}
#!queue	A029891	0	->	1	A029889	--------------------------------
package irvine.oeis.a029;

import irvine.math.IntegerUtils;

/**
 * A029891 Number of even graphical partitions.
 * @author Sean A. Irvine
 */
public class A029891 extends A029889 {

  {
    super.next();
  }

  @Override
  protected boolean accept(final int[] rowSums) {
    return (IntegerUtils.sum(rowSums) & 1) == 0;
  }
}
#!queue	A029892	0	->	1	A029889	--------------------------------
package irvine.oeis.a029;

import java.util.HashSet;
import java.util.List;

import irvine.math.z.Z;

/**
 * A029892 Number of even graphical partitions of order 2n - number of odd partitions.
 * @author Sean A. Irvine
 */
public class A029892 extends A029889 {

  {
    super.next(); // skip 0
  }

  @Override
  protected long count(final HashSet<List<Integer>> seen) {
    long cnt = 0;
    for (final List<Integer> lst : seen) {
      int s = 0;
      for (final int l : lst) {
        s += l;
      }
      cnt += 1 - 2 * (s & 1);
    }
    return cnt;
  }

  @Override
  public Z next() {
    ++mN;
    return super.next();
  }
}
#!queue	A030109	0	->	1	A030101	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030109 Write n in binary, reverse bits, subtract 1, divide by 2.
 * @author Sean A. Irvine
 */
public class A030109 extends A030101 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    return super.next().subtract(1).divide2();
  }
}
#!queue	A030176	0	->	1	A030177	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030176 Squares composed of digits {4,5,6}.
 * @author Sean A. Irvine
 */
public class A030176 extends A030177 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A030196	0	->	1	A000295	--------------------------------
package irvine.oeis.a030;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a000.A000295;
import irvine.oeis.a008.A008292;

/**
 * A030196 Distinct elements occurring in triangle of Eulerian numbers (sorted).
 * @author Sean A. Irvine
 */
public class A030196 extends A000295 {

  private final A008292 mEuler = new A008292();
  private final TreeSet<Z> mS = new TreeSet<>();
  private long mRow = 0;
  private Z mA = super.next();

  {
    next();
    next();
    mS.add(Z.ONE);
  }

  @Override
  public Z next() {
    if (mS.isEmpty() || mS.first().compareTo(mA) <= 0) {
      ++mRow;
      for (long col = 2; col <= (mRow + 1) / 2; ++col) {
        mS.add(mEuler.get(mRow, col));
      }
      mA = super.next();
    }
    return mS.pollFirst();
  }
}
#!queue	A030232	0	->	1	A027423	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a027.A027423;

/**
 * A030232 Numbers k such that the number of divisors of k! divides the number of divisors of (2k)!.
 * @author Sean A. Irvine
 */
public class A030232 extends A027423 {

  private final Sequence mA = new A027423();
  private long mN = 0;
  {
    mA.next();
    super.next();
  }
  
  @Override
  public Z next() {
    while (true) {
      ++mN;
      mA.next();
      if (mA.next().mod(super.next()).isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A030309	0	->	1	A030308	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030309 Position of n-th 0 in A030308.
 * @author Sean A. Irvine
 */
public class A030309 extends A030308 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030310	0	->	1	A030308	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030310 Position of n-th 1 in A030308.
 * @author Sean A. Irvine
 */
public class A030310 extends A030308 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030314	0	->	1	A030308	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030314 (# 1's)-(# 0's) in first n terms of A030308.
 * @author Sean A. Irvine
 */
public class A030314 extends A030308 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    mSum = mSum.signedAdd(Z.ONE.equals(super.next()), Z.ONE);
    return mSum;
  }
}

#!queue	A030342	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030342 Position of n-th 0 in A030341.
 * @author Sean A. Irvine
 */
public class A030342 extends A030341 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030343	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030343 Position of n-th 1 in A030341.
 * @author Sean A. Irvine
 */
public class A030343 extends A030341 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030344	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030344 Position of n-th 2 in A030341.
 * @author Sean A. Irvine
 */
public class A030344 extends A030341 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030346	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030346 Length of n-th run of digit 0 in A030341.
 * @author Sean A. Irvine
 */
public class A030346 extends A030341 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    long cnt = 1;
    if (mFirst) {
      mFirst = false;
      --cnt;
    } else {
      while (!super.next().isZero()) {
        // do nothing
      }
    }
    while (super.next().isZero()) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030347	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030347 Length of n-th run of digit 1 in A030341.
 * @author Sean A. Irvine
 */
public class A030347 extends A030341 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.ONE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030348	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030348 Length of n-th run of digit 2 in A030341.
 * @author Sean A. Irvine
 */
public class A030348 extends A030341 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.TWO.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030349	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030349 (# 1's)-(# 0's) in first n terms of A030341.
 * @author Sean A. Irvine
 */
public class A030349 extends A030341 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 0) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030350	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030350 a(n) = (# 1's)-(# 2's) in first n terms of A030341.
 * @author Sean A. Irvine
 */
public class A030350 extends A030341 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 2) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030387	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030387 Position of n-th 0 in A030386.
 * @author Sean A. Irvine
 */
public class A030387 extends A030386 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030388	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030388 Position of n-th 1 in A030386.
 * @author Sean A. Irvine
 */
public class A030388 extends A030386 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030389	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030389 Position of n-th 2 in A030386.
 * @author Sean A. Irvine
 */
public class A030389 extends A030386 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030390	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030390 Position of n-th 3 in A030386.
 * @author Sean A. Irvine
 */
public class A030390 extends A030386 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030392	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030392 Length of n-th run of digit 0 in A030386.
 * @author Sean A. Irvine
 */
public class A030392 extends A030386 {

  @Override
  public Z next() {
    while (!super.next().isZero()) {
      // do nothing
    }
    long cnt = 1;
    while (super.next().isZero()) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030393	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030393 Length of n-th run of digit 1 in A030386.
 * @author Sean A. Irvine
 */
public class A030393 extends A030386 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.ONE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030394	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030394 Length of n-th run of digit 2 in A030386.
 * @author Sean A. Irvine
 */
public class A030394 extends A030386 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.TWO.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030395	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030395 Length of n-th run of digit 3 in A030386.
 * @author Sean A. Irvine
 */
public class A030395 extends A030386 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.THREE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030396	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030396 a(n)=(# 1's)-(# 0's) in first n terms of A030386.
 * @author Sean A. Irvine
 */
public class A030396 extends A030386 {

  private Z mSum = Z.ZERO;
  {
    super.next(); // skip 0th term that was added later to A030386
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 0) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030397	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030397 a(n)=(# 1's)-(# 2's) in first n terms of A030386.
 * @author Sean A. Irvine
 */
public class A030397 extends A030386 {

  private Z mSum = Z.ZERO;
  {
    super.next(); // skip 0th term that was added later to A030386
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 2) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030398	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030398 a(n)=(# 2's)-(# 3's) in first n terms of A030386.
 * @author Sean A. Irvine
 */
public class A030398 extends A030386 {

  private Z mSum = Z.ZERO;
  {
    super.next(); // skip 0th term that was added later to A030386
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 2) {
      mSum = mSum.add(1);
    } else if (t == 3) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030449	0	->	1	A005345	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a005.A005345;

/**
 * A030449 Number of elements in the free band (idempotent semigroup) on n generators.
 * @author Sean A. Irvine
 */
public class A030449 extends A005345 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A030463	1	->	0	A002385	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a002.A002385;

/**
 * A030463 Previous palindromic prime concatenated with this palindromic prime is prime.
 * @author Sean A. Irvine
 */
public class A030463 extends A002385 {

  private Z mP = super.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mP;
      mP = super.next();
      if (new Z(t.toString() + mP).isProbablePrime()) {
        return mP;
      }
    }
  }
}
#!queue	A030479	1	->	0	A030478	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030479 Cubes with property that all even digits occur together and all odd digits occur together.
 * @author Sean A. Irvine
 */
public class A030479 extends A030478 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A030486	1	->	0	A030484	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030486 When squared gives number composed of digits {2,5,6}.
 * @author Sean A. Irvine
 */
public class A030486 extends A030484 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}
#!queue	A030487	1	->	0	A030485	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030487 When squared gives number composed of digits {2, 5, 7}.
 * @author Sean A. Irvine
 */
public class A030487 extends A030485 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}
#!queue	A030504	3	->	4	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030504 Graham-Sloane-type lower bound on the size of a ternary (n,3,4) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030504 extends A030503 {

  @Override
  protected int w() {
    return 4;
  }
}

#!queue	A030505	3	->	5	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030505 Graham-Sloane-type lower bound on the size of a ternary (n,3,5) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030505 extends A030503 {

  @Override
  protected int w() {
    return 5;
  }
}

#!queue	A030506	3	->	6	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030506 Graham-Sloane-type lower bound on the size of a ternary (n,3,6) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030506 extends A030503 {

  @Override
  protected int w() {
    return 6;
  }
}

#!queue	A030507	3	->	7	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030507 Graham-Sloane-type lower bound on the size of a ternary (n,3,7) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030507 extends A030503 {

  @Override
  protected int w() {
    return 7;
  }
}

#!queue	A030508	3	->	8	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030508 Graham-Sloane-type lower bound on the size of a ternary (n,3,8) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030508 extends A030503 {

  @Override
  protected int w() {
    return 8;
  }
}

#!queue	A030509	3	->	9	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030509 Graham-Sloane-type lower bound on the size of a ternary (n,3,9) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030509 extends A030503 {

  @Override
  protected int w() {
    return 9;
  }
}

#!queue	A030510	3	->	10	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030510 Graham-Sloane-type lower bound on the size of a ternary (n,3,10) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030510 extends A030503 {

  @Override
  protected int w() {
    return 10;
  }
}

#!queue	A030568	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030568 Position of n-th 0 in A030567.
 * @author Sean A. Irvine
 */
public class A030568 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030569	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030569 Position of n-th 1 in A030567.
 * @author Sean A. Irvine
 */
public class A030569 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030570	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030570 Position of n-th 2 in A030567.
 * @author Sean A. Irvine
 */
public class A030570 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030571	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030571 Position of n-th 3 in A030567.
 * @author Sean A. Irvine
 */
public class A030571 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030572	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030572 Position of n-th 4 in A030567.
 * @author Sean A. Irvine
 */
public class A030572 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030573	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030573 Position of n-th 5 in A030567.
 * @author Sean A. Irvine
 */
public class A030573 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030575	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030575 Run length of n-th run of digit 0 in A030567.
 * @author Sean A. Irvine
 */
public class A030575 extends A030567 {

  @Override
  public Z next() {
    while (!super.next().isZero()) {
      // do nothing
    }
    long cnt = 1;
    while (super.next().isZero()) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030576	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030576 Length of n-th run of digit 1 in A030567.
 * @author Sean A. Irvine
 */
public class A030576 extends A030567 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.ONE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030577	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030577 Length of n-th run of digit 2 in A030567.
 * @author Sean A. Irvine
 */
public class A030577 extends A030567 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.TWO.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030578	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030578 Length of n-th run of digit 3 in A030567.
 * @author Sean A. Irvine
 */
public class A030578 extends A030567 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.THREE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030579	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030579 Length of n-th run of digit 4 in A030567.
 * @author Sean A. Irvine
 */
public class A030579 extends A030567 {

  @Override
  public Z next() {
    while (!Z.FOUR.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.FOUR.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030580	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030580 Length of n-th run of digit 5 in A030567.
 * @author Sean A. Irvine
 */
public class A030580 extends A030567 {

  @Override
  public Z next() {
    while (!Z.FIVE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.FIVE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030581	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030581 a(n)=(# 1's)-(# 0's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030581 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 0) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030582	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030582 a(n)=(# 1's)-(# 2's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030582 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 2) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030583	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030583 a(n)=(# 2's)-(# 3's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030583 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 2) {
      mSum = mSum.add(1);
    } else if (t == 3) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030584	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030584 (# 3's)-(# 4's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030584 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 3) {
      mSum = mSum.add(1);
    } else if (t == 4) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030585	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030585 (# 4's)-(# 5's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030585 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 4) {
      mSum = mSum.add(1);
    } else if (t == 5) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030622	0	->	1	A000455	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000455;

/**
 * A030622 Powers of 2 grouped in pairs of two digits (version 1).
 * @author Sean A. Irvine
 */
public class A030622 extends A000455 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(10).add(super.next());
  }
}

#!queue	A030623	0	->	1	A000455	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000455;

/**
 * A030623 Powers of 2 grouped in pairs of 2 digits (version 2).
 * @author Sean A. Irvine
 */
public class A030623 extends A000455 {

  @Override
  public Z next() {
    return super.next().multiply(10).add(super.next());
  }
}

#!queue	A030624	0	->	1	A000455	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000455;

/**
 * A030624 Powers of 2 grouped in pairs of 2 digits (version 3).
 * @author Sean A. Irvine
 */
public class A030624 extends A000455 {

  @Override
  public Z next() {
    Z t = Z.ZERO;
    do {
      t = t.multiply(10).add(super.next());
    } while (t.compareTo(Z.TEN) < 0);
    return t;
  }
}

#!queue	A030692	0	->	1	A000578	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A030692 Smallest nontrivial extension of n-th cube which is a prime.
 * @author Sean A. Irvine
 */
public class A030692 extends A000578 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z t = super.next().multiply(10);
    long lim = 10;
    long v = -1;
    while (true) {
      v += 2;
      if (v >= lim) {
        lim *= 10;
        t = t.multiply(10);
        //v = 1; // to allow for leading 0s in what is appended
      }
      if (v % 5 != 0) {
        final Z u = t.add(v);
        if (u.isProbablePrime()) {
          return u;
        }
      }
    }
  }
}

#!queue	A030693	0	->	1	A000578	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A030693 Smallest nontrivial extension of n-th cube which is a square.
 * @author Sean A. Irvine
 */
public class A030693 extends A000578 {

  private static final long[] STEPS = {1, 1, 3, 1, 1, 3};
  {
    super.next();
  }

  @Override
  public Z next() {
    Z t = super.next().multiply(10);
    long lim = 10;
    long v = -1;
    int s = -1;
    while (true) {
      if (++s == STEPS.length) {
        s = 0;
      }
      v += STEPS[s];
      if (v >= lim) {
        lim *= 10;
        t = t.multiply(10);
        v = 0; // to allow for leading 0s in what is appended
        s = 0;
      }
      final Z u = t.add(v);
      if (u.isSquare()) {
        return u;
      }
    }
  }
}

#!queue	A030695	0	->	1	A000578	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A030695 Smallest nontrivial extension of n-th cube which is a cube.
 * @author Sean A. Irvine
 */
public class A030695 extends A000578 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z t = super.next().multiply(10);
    long lim = 10;
    long v = -1;
    while (true) {
      if (++v >= lim) {
        lim *= 10;
        t = t.multiply(10);
        v = 0; // to allow for leading 0s in what is appended
      }
      final Z u = t.add(v);
      if (ZUtils.isCube(u)) {
        return u;
      }
    }
  }
}

#!queue	A030697	0	->	1	A000578	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A030697 Smallest nontrivial extension of n-th cube which is a cube not ending 000.
 * @author Sean A. Irvine
 */
public class A030697 extends A000578 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z t = super.next().multiply(10);
    long lim = 10;
    long v = 0;
    while (true) {
      if (++v >= lim) {
        lim *= 10;
        t = t.multiply(10);
        v = 1; // to allow for leading 0s in what is appended
      }
      final Z u = t.add(v);
      if (ZUtils.isCube(u)) {
        return u;
      }
    }
  }
}

#!queue	A030979	0	->	1	A000984	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A030979 Numbers k such that binomial(2k,k) is not divisible by 3, 5 or 7.
 * @author Sean A. Irvine
 */
public class A030979 extends A000984 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.mod(3) == 0 || t.mod(5) == 0 || t.mod(7) == 0);
    return Z.valueOf(mN);
  }
}
#!queue	A030999	0	->	1	A030998	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030999 Position of n-th 0 in A030998.
 * @author Sean A. Irvine
 */
public class A030999 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031000	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031000 Position of n-th 1 in A030998.
 * @author Sean A. Irvine
 */
public class A031000 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031001	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031001 Position of n-th 2 in A030998.
 * @author Sean A. Irvine
 */
public class A031001 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031002	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031002 Position of n-th 3 in A030998.
 * @author Sean A. Irvine
 */
public class A031002 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031003	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031003 Position of n-th 4 in A030998.
 * @author Sean A. Irvine
 */
public class A031003 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031004	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031004 Position of n-th 5 in A030998.
 * @author Sean A. Irvine
 */
public class A031004 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031005	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031005 Position of n-th 6 in A030998.
 * @author Sean A. Irvine
 */
public class A031005 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031008	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031008 Position of n-th 0 in A031007.
 * @author Sean A. Irvine
 */
public class A031008 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031009	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031009 Position of n-th 1 in A031007.
 * @author Sean A. Irvine
 */
public class A031009 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031010	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031010 Position of n-th 2 in A031007.
 * @author Sean A. Irvine
 */
public class A031010 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031011	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031011 Position of n-th 3 in A031007.
 * @author Sean A. Irvine
 */
public class A031011 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031012	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031012 Position of n-th 4 in A031007.
 * @author Sean A. Irvine
 */
public class A031012 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031013	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031013 Position of n-th 5 in A031007.
 * @author Sean A. Irvine
 */
public class A031013 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031014	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031014 Position of n-th 6 in A031007.
 * @author Sean A. Irvine
 */
public class A031014 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031046	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031046 Position of n-th 0 in A031045.
 * @author Sean A. Irvine
 */
public class A031046 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031047	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031047 Position of n-th 1 in A031045.
 * @author Sean A. Irvine
 */
public class A031047 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031048	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031048 Position of n-th 2 in A031045.
 * @author Sean A. Irvine
 */
public class A031048 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031049	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031049 Position of n-th 3 in A031045.
 * @author Sean A. Irvine
 */
public class A031049 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031050	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031050 Position of n-th 4 in A031045.
 * @author Sean A. Irvine
 */
public class A031050 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031051	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031051 Position of n-th 5 in A031045.
 * @author Sean A. Irvine
 */
public class A031051 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031052	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031052 Position of n-th 6 in A031045.
 * @author Sean A. Irvine
 */
public class A031052 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031053	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031053 Position of n-th 7 in A031045.
 * @author Sean A. Irvine
 */
public class A031053 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SEVEN.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031088	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031088 Position of n-th 0 in A031087.
 * @author Sean A. Irvine
 */
public class A031088 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031089	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031089 Position of n-th 1 in A031087.
 * @author Sean A. Irvine
 */
public class A031089 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031090	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031090 Position of n-th 2 in A031087.
 * @author Sean A. Irvine
 */
public class A031090 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031091	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031091 Position of n-th 3 in A031087.
 * @author Sean A. Irvine
 */
public class A031091 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031092	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031092 Position of n-th 4 in A031087.
 * @author Sean A. Irvine
 */
public class A031092 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031093	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031093 Position of n-th 5 in A031087.
 * @author Sean A. Irvine
 */
public class A031093 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031094	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031094 Position of n-th 6 in A031087.
 * @author Sean A. Irvine
 */
public class A031094 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031095	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031095 Position of n-th 7 in A031087.
 * @author Sean A. Irvine
 */
public class A031095 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SEVEN.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031096	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031096 Position of n-th 8 in A031087.
 * @author Sean A. Irvine
 */
public class A031096 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.EIGHT.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031179	0	->	1	A031178	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031179 Numbers having period-1 3-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031179 extends A031178 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031180	0	->	1	A031178	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031180 Numbers having period-2 3-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031180 extends A031178 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031181	0	->	1	A031178	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031181 Numbers having period-3 3-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031181 extends A031178 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031183	0	->	1	A031182	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031183 Numbers having period-1 4-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031183 extends A031182 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031184	0	->	1	A031182	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031184 Numbers having period-2 4-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031184 extends A031182 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031185	0	->	1	A031182	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031185 Numbers having period-7 4-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031185 extends A031182 {

  @Override
  public Z next() {
    while (!Z.SEVEN.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031187	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031187 Numbers having period-1 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031187 extends A031186 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031188	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031188 Numbers having period-2 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031188 extends A031186 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031189	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031189 Numbers having period-4 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031189 extends A031186 {

  @Override
  public Z next() {
    while (!Z.FOUR.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031190	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031190 Numbers having period-6 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031190 extends A031186 {

  @Override
  public Z next() {
    while (!Z.SIX.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031191	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031191 Numbers having period-10 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031191 extends A031186 {

  @Override
  public Z next() {
    while (!Z.TEN.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031192	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031192 Numbers having period-12 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031192 extends A031186 {

  private static final Z Z12 = Z.valueOf(12);

  @Override
  public Z next() {
    while (!Z12.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031193	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031193 Numbers having period-22 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031193 extends A031186 {

  private static final Z Z22 = Z.valueOf(22);

  @Override
  public Z next() {
    while (!Z22.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031194	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031194 Numbers having period-28 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031194 extends A031186 {

  private static final Z Z28 = Z.valueOf(28);

  @Override
  public Z next() {
    while (!Z28.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031196	0	->	1	A031195	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031196 Numbers having period-3 6-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031196 extends A031195 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031197	0	->	1	A031195	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031197 Numbers having period-4 6-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031197 extends A031195 {

  @Override
  public Z next() {
    while (!Z.FOUR.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031198	0	->	1	A031195	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031198 Numbers having period-10 6-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031198 extends A031195 {

  @Override
  public Z next() {
    while (!Z.TEN.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031199	0	->	1	A031195	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031199 Numbers having period-30 6-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031199 extends A031195 {

  private static final Z Z30 = Z.valueOf(30);

  @Override
  public Z next() {
    while (!Z30.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031201	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031201 Numbers having period-1 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031201 extends A031200 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031202	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031202 Numbers having period-2 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031202 extends A031200 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031203	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031203 Numbers having period-3 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031203 extends A031200 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031204	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031204 Numbers having period-12 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031204 extends A031200 {

  private static final Z Z12 = Z.valueOf(12);

  @Override
  public Z next() {
    while (!Z12.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031205	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031205 Numbers having period-14 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031205 extends A031200 {

  private static final Z Z14 = Z.valueOf(14);

  @Override
  public Z next() {
    while (!Z14.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031206	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031206 Numbers having period-21 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031206 extends A031200 {

  private static final Z Z21 = Z.valueOf(21);

  @Override
  public Z next() {
    while (!Z21.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031207	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031207 Numbers having period-27 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031207 extends A031200 {

  private static final Z Z27 = Z.valueOf(27);

  @Override
  public Z next() {
    while (!Z27.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031208	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031208 Numbers having period-30 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031208 extends A031200 {

  private static final Z Z30 = Z.valueOf(30);

  @Override
  public Z next() {
    while (!Z30.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031236	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031236 Position of n-th 0 in A031235.
 * @author Sean A. Irvine
 */
public class A031236 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031237	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031237 Position of n-th 1 in A031235.
 * @author Sean A. Irvine
 */
public class A031237 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031238	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031238 Position of n-th 2 in A031235.
 * @author Sean A. Irvine
 */
public class A031238 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031239	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031239 Position of n-th 3 in A031235.
 * @author Sean A. Irvine
 */
public class A031239 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031240	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031240 Position of n-th 4 in A031235.
 * @author Sean A. Irvine
 */
public class A031240 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031242	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031242 Length of n-th run of digit 0 in A031235.
 * @author Sean A. Irvine
 */
public class A031242 extends A031235 {

  @Override
  public Z next() {
    while (!super.next().isZero()) {
      // do nothing
    }
    long cnt = 1;
    while (super.next().isZero()) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031243	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031243 Length of n-th run of digit 1 in A031235.
 * @author Sean A. Irvine
 */
public class A031243 extends A031235 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.ONE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031244	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031244 Length of n-th run of digit 2 in A031235.
 * @author Sean A. Irvine
 */
public class A031244 extends A031235 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.TWO.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031245	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031245 Length of n-th run of digit 3 in A031235.
 * @author Sean A. Irvine
 */
public class A031245 extends A031235 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.THREE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031246	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031246 Length of n-th run of digit 4 in A031235.
 * @author Sean A. Irvine
 */
public class A031246 extends A031235 {

  @Override
  public Z next() {
    while (!Z.FOUR.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.FOUR.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031247	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031247 a(n)=(# 1's)-(# 0's) in first n terms of A031235.
 * @author Sean A. Irvine
 */
public class A031247 extends A031235 {

  {
    super.next();
  }

  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 0) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A031248	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031248 a(n)=(# 1's)-(# 2's) in first n terms of A031235.
 * @author Sean A. Irvine
 */
public class A031248 extends A031235 {

  {
    super.next();
  }

  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 2) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A031249	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031249 a(n)=(# 2's)-(# 3's) in first n terms of A031235.
 * @author Sean A. Irvine
 */
public class A031249 extends A031235 {

  {
    super.next();
  }

  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 2) {
      mSum = mSum.add(1);
    } else if (t == 3) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A031250	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031250 (# 3's)-(# 4's) in first n terms of A031235.
 * @author Sean A. Irvine
 */
public class A031250 extends A031235 {

  {
    super.next();
  }

  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 3) {
      mSum = mSum.add(1);
    } else if (t == 4) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A031287	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031287 Position of n-th 0 in A007376.
 * @author Sean A. Irvine
 */
public class A031287 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031288	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031288 Position of n-th 1 in A007376.
 * @author Sean A. Irvine
 */
public class A031288 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031289	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031289 Position of n-th 2 in A007376.
 * @author Sean A. Irvine
 */
public class A031289 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031290	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031290 Position of n-th 3 in A007376.
 * @author Sean A. Irvine
 */
public class A031290 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031291	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031291 Position of n-th 4 in A007376.
 * @author Sean A. Irvine
 */
public class A031291 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031292	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031292 Position of n-th 5 in A007376.
 * @author Sean A. Irvine
 */
public class A031292 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031293	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031293 Position of n-th 6 in A007376.
 * @author Sean A. Irvine
 */
public class A031293 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031294	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031294 Position of n-th 7 in A007376.
 * @author Sean A. Irvine
 */
public class A031294 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SEVEN.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031295	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031295 Position of n-th 8 in A007376.
 * @author Sean A. Irvine
 */
public class A031295 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.EIGHT.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031296	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031296 Position of n-th 9 in A007376.
 * @author Sean A. Irvine
 */
public class A031296 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.NINE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031299	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031299 Position of n-th 0 in A031298.
 * @author Sean A. Irvine
 */
public class A031299 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031300	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031300 Position of n-th 1 in A031298.
 * @author Sean A. Irvine
 */
public class A031300 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031301	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031301 Position of n-th 2 in A031298.
 * @author Sean A. Irvine
 */
public class A031301 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031302	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031302 Position of n-th 3 in A031298.
 * @author Sean A. Irvine
 */
public class A031302 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031303	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031303 Position of n-th 4 in A031298.
 * @author Sean A. Irvine
 */
public class A031303 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031304	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031304 Position of n-th 5 in A031298.
 * @author Sean A. Irvine
 */
public class A031304 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031305	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031305 Position of n-th 6 in A031298.
 * @author Sean A. Irvine
 */
public class A031305 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031306	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031306 Position of n-th 7 in A031298.
 * @author Sean A. Irvine
 */
public class A031306 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SEVEN.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031307	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031307 Position of n-th 8 in A031298.
 * @author Sean A. Irvine
 */
public class A031307 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.EIGHT.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031308	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031308 Position of n-th 9 in A031298.
 * @author Sean A. Irvine
 */
public class A031308 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.NINE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031502	8	->	10	A030069	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030069;

/**
 * A031502 Size of lexicographic code of length n, Hamming distance 10 and weight 10.
 * @author Sean A. Irvine
 */
public class A031502 extends A030069 {

  private int mN = 9;

  @Override
  public Z next() {
    if (++mN > 63) {
      throw new UnsupportedOperationException();
    }
    return Z.valueOf(buildLexicographicCode(mN, 10, 10).size());
  }
}
#!queue	A031503	8	->	12	A030069	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030069;

/**
 * A031503 Size of lexicographic code of length n, Hamming distance 12 and weight 12.
 * @author Sean A. Irvine
 */
public class A031503 extends A030069 {

  private int mN = 11;

  @Override
  public Z next() {
    if (++mN > 63) {
      throw new UnsupportedOperationException();
    }
    return Z.valueOf(buildLexicographicCode(mN, 12, 12).size());
  }
}
#!queue	A031504	8	->	6	A030069	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030069;

/**
 * A031504 Size of lexicographic code of length n, Hamming distance 6 and weight 6.
 * @author Sean A. Irvine
 */
public class A031504 extends A030069 {

  private int mN = 5;

  @Override
  public Z next() {
    if (++mN > 63) {
      throw new UnsupportedOperationException();
    }
    return Z.valueOf(buildLexicographicCode(mN, 6, 6).size());
  }
}
#!queue	A031877	0	->	1	A004086	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a004.A004086;

/**
 * A031877 Nontrivial reversal numbers (numbers which are integer multiples of their reversals), excluding palindromic numbers and multiples of 10.
 * @author Sean A. Irvine
 */
public class A031877 extends A004086 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (mN % 10 != 0) {
        final Z n = Z.valueOf(mN);
        if (n.compareTo(t) > 0 && n.mod(t).isZero()) {
          return n;
        }
      }
    }
  }
}
#!queue	A032037	0	->	1	A001003	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a001.A001003;

/**
 * A032037 Doubles (index 2+) under "AIJ" (ordered, indistinct, labeled) transform.
 * @author Sean A. Irvine
 */
public class A032037 extends A001003 {

  private int mN = 0;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    return super.next().multiply(mF);
  }
}
#!queue	A032112	0	->	1	A006155	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a006.A006155;

/**
 * A032112 "BIJ" (reversible, indistinct, labeled) transform of 2,1,1,1...
 * @author Sean A. Irvine
 */
public class A032112 extends A006155 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().add(2).divide2();
  }
}
#!queue	A032165	0	->	1	A001692	--------------------------------
package irvine.oeis.a032;

import irvine.oeis.a001.A001692;

/**
 * A032165 Number of aperiodic necklaces of n beads of 10 colors.
 * @author Sean A. Irvine
 */
public class A032165 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 10;
  }
}
#!queue	A032166	0	->	1	A001692	--------------------------------
package irvine.oeis.a032;

import irvine.oeis.a001.A001692;

/**
 * A032166 Number of aperiodic necklaces of n beads of 11 colors.
 * @author Sean A. Irvine
 */
public class A032166 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 11;
  }
}
#!queue	A032167	0	->	1	A001692	--------------------------------
package irvine.oeis.a032;

import irvine.oeis.a001.A001692;

/**
 * A032167 Number of aperiodic necklaces of n beads of 12 colors.
 * @author Sean A. Irvine
 */
public class A032167 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 12;
  }
}
#!queue	A032321	0	->	1	A001037	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a001.A001037;

/**
 * A032321 Number of aperiodic necklaces with n labeled beads of 2 colors.
 * @author Sean A. Irvine
 */
public class A032321 extends A001037 {

  private long mN = 0;
  private Z mF = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return super.next().multiply(mF);
  }
}
#!queue	A032322	0	->	1	A027376	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a027.A027376;

/**
 * A032322 Number of aperiodic necklaces with n labeled beads of 3 colors.
 * @author Sean A. Irvine
 */
public class A032322 extends A027376 {

  private long mN = 0;
  private Z mF = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return super.next().multiply(mF);
  }
}
#!queue	A032323	0	->	1	A027377	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a027.A027377;

/**
 * A032323 Number of aperiodic necklaces with n labeled beads of 4 colors.
 * @author Sean A. Irvine
 */
public class A032323 extends A027377 {

  private long mN = 0;
  private Z mF = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return super.next().multiply(mF);
  }
}
#!queue	A032324	0	->	1	A001692	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a001.A001692;

/**
 * A032324 Number of aperiodic necklaces with n labeled beads of 5 colors.
 * @author Sean A. Irvine
 */
public class A032324 extends A001692 {

  private long mN = 0;
  private Z mF = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return super.next().multiply(mF);
  }
}
#!queue	A032348	5	->	0	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032348 Coefficients of Jacobi function c(3,m).
 * @author Sean A. Irvine
 */
public class A032348 extends A032428 {

  @Override
  protected int j() {
    return 3;
  }
}
#!queue	A032358	1	->	2	A003434	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a003.A003434;

/**
 * A032358 Number of iterations of phi(n) needed to reach 2.
 * @author Sean A. Irvine
 */
public class A032358 extends A003434 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A032427	5	->	0	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032427 Coefficients of Jacobi elliptic function c(4,m).
 * @author Sean A. Irvine
 */
public class A032427 extends A032428 {

  @Override
  protected int j() {
    return 4;
  }
}
#!queue	A032429	5	->	6	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032429 Coefficients of Jacobi elliptic function c(6,m).
 * @author Sean A. Irvine
 */
public class A032429 extends A032428 {

  @Override
  protected int j() {
    return 6;
  }
}
#!queue	A032430	5	->	7	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032430 Coefficients of Jacobi elliptic function c(7,m).
 * @author Sean A. Irvine
 */
public class A032430 extends A032428 {

  @Override
  protected int j() {
    return 7;
  }
}
#!queue	A032431	5	->	8	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032431 Coefficients of Jacobi elliptic function c(8,m).
 * @author Sean A. Irvine
 */
public class A032431 extends A032428 {

  @Override
  protected int j() {
    return 8;
  }
}
#!queue	A032432	5	->	9	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032432 Coefficients of Jacobi elliptic function c(9,m).
 * @author Sean A. Irvine
 */
public class A032432 extends A032428 {

  @Override
  protected int j() {
    return 9;
  }
}
#!queue	A032433	5	->	10	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032433 Coefficients of Jacobi elliptic function c(10,m).
 * @author Sean A. Irvine
 */
public class A032433 extends A032428 {

  @Override
  protected int j() {
    return 10;
  }
}
#!queue	A032522	0	->	1	A000170	--------------------------------
package irvine.oeis.a032;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a000.A000170;

/**
 * A032522 Number of point symmetric solutions to non-attacking queens problem on n X n board.
 * @author Sean A. Irvine
 */
public class A032522 extends A000170 {

  {
    next();
  }

  private int[] rotate180(final int[] q) {
    final int n = q.length;
    final int[] r = new int[n];
    for (int x = 0; x < n; ++x) {
      r[n - x  - 1] = n - q[x] - 1;
    }
    return r;
  }

  @Override
  protected Z count(final int[] q) {
    final int[] q1 = rotate180(q);
    return Arrays.equals(q, q1) ? Z.ONE : Z.ZERO;
  }
}
#!queue	A032599	1	->	0	A000959	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a000.A000959;

/**
 * A032599 Cubes of lucky numbers.
 * @author Sean A. Irvine
 */
public class A032599 extends A000959 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A032736	1	->	0	A032734	--------------------------------
package irvine.oeis.a032;

/**
 * A032736 a(n) cannot be prefixed or followed by any digit to form a prime ('empty' prefixes allowed).
 * @author Sean A. Irvine
 */
public class A032736 extends A032734 {

  private static final String[] PREFIXES = {"", "1", "2", "3", "4", "5", "6", "7", "8", "9"};

  @Override
  protected String[] prefixes() {
    return PREFIXES;
  }
}
#!queue	A032737	1	->	0	A032734	--------------------------------
package irvine.oeis.a032;

/**
 * A032737 a(n) cannot be prefixed or followed by any digit to form a prime ('empty' suffixes are allowed).
 * @author Sean A. Irvine
 */
public class A032737 extends A032734 {

  private static final String[] SUFFIXES = {"", "1", "3", "7", "9"};

  @Override
  protected String[] suffixes() {
    return SUFFIXES;
  }
}
#!queue	A033148	0	->	1	A000170	--------------------------------
package irvine.oeis.a033;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a000.A000170;

/**
 * A033148 Number of rotationally symmetric solutions for queens on n X n board.
 * @author Sean A. Irvine
 */
public class A033148 extends A000170 {

  private int mN = 0;

  private int[] rotate90(final int[] q) {
    final int n = q.length;
    final int[] r = new int[n];
    for (int x = 0; x < n; ++x) {
      r[q[x]] = n - x - 1;
    }
    return r;
  }

  @Override
  protected Z count(final int[] q) {
    final int[] q1 = rotate90(q);
    return Arrays.equals(q, q1) ? Z.ONE : Z.ZERO;
  }

  @Override
  public Z next() {
    final long r = ++mN & 3;
    return r > 1 ? Z.ZERO : count(new int[mN], 0);
  }
}
#!queue	A033264	0	->	1	A005811	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.oeis.a005.A005811;

/**
 * A033264 Number of blocks of {1,0} in the binary expansion of n.
 * @author Sean A. Irvine
 */
public class A033264 extends A005811 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    final Z a = super.next();
    return a.subtract(a.add(1).divide2());
  }
}

#!queue	A033314	1	->	2	A000037	--------------------------------
package irvine.oeis.a033;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a000.A000037;
import irvine.util.array.LongDynamicLongArray;

/**
 * A033314 Least D in the Pellian x^2 - D*y^2 = 1 for which x has least solution n.
 * @author Sean A. Irvine
 */
public class A033314 extends A000037 {

  private static final long LIMIT = 10000000; // Stops very large results from being stored
  private static final Z Z_LIMIT = Z.valueOf(LIMIT);
  private final LongDynamicLongArray mA = new LongDynamicLongArray();
  private long mN = 1;

  @Override
  public Z next() {
    if (++mN >= LIMIT) {
      throw new UnsupportedOperationException();
    }
    while (mA.get(mN) == 0) {
      final Z d = super.next();
      final Q conv = A033313.solvePell(d);
      if (conv.num().compareTo(Z_LIMIT) < 0) {
        final long x = conv.num().longValueExact();
        if (mA.get(x) == 0) {
          mA.set(x, d.longValueExact());
        }
      }
    }
    return Z.valueOf(mA.get(mN));
  }
}

#!queue	A033618	0	->	2	A010785	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A033618 Number of ways n-th repdigit number, A010785(n), can be expressed as a polygonal number.
 * @author Sean A. Irvine
 */
public class A033618 extends A010785 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z r = super.next();
    if (Z.TWO.equals(r)) {
      return Z.TWO; // Not sure why this special case needed
    }
    final Z t = r.multiply2();
    long c = 0;
    for (final Z n : Jaguar.factor(t).divisors()) {
      if (!Z.ONE.equals(n)) {
        final Z q = t.divide(n);
        final Z n1 = n.subtract(1);
        if (q.mod(n1).equals(Z.TWO.mod(n1))) {
          ++c;
        }
      }
    }
    return Z.valueOf(c);
  }
}
#!queue	A033702	0	->	1	A010785	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A033702 Number of polygonal numbers which are n-digit repdigits.
 * @author Sean A. Irvine
 */
public class A033702 extends A010785 {

  {
    super.next();
  }

  @Override
  public Z next() {
    long c = 0;
    for (int k = 1; k < 10; ++k) {
      final Z r = super.next();
      if (!Z.ONE.equals(r)) {
        final Z t = r.multiply2();
        for (final Z n : Jaguar.factor(t).divisors()) {
          if (!Z.ONE.equals(n)) {
            final Z q = t.divide(n);
            final Z n1 = n.subtract(1);
            if (q.mod(n1).equals(Z.TWO.mod(n1))) {
              ++c;
            }
          }
        }
      }
    }
    return Z.valueOf(c);
  }
}
#!queue	A033882	1	->	0	A033880	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;

/**
 * A033882 Abundancy of the abundant or perfect numbers: m = sigma(n)-2n for n such that m &gt;= 0.
 * @author Sean A. Irvine
 */
public class A033882 extends A033880 {

  @Override
  public Z next() {
    while (true) {
      final Z a = super.next();
      if (a.signum() >= 0) {
        return a;
      }
    }
  }
}
#!queue	A033883	1	->	0	A033879	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;

/**
 * A033883 Deficiency of the deficient or perfect numbers: m = 2n - sigma(n) for n such that m &gt;= 0.
 * @author Sean A. Irvine
 */
public class A033883 extends A033879 {

  @Override
  public Z next() {
    while (true) {
      final Z a = super.next();
      if (a.signum() >= 0) {
        return a;
      }
    }
  }
}
#!queue	A033952	0	->	1	A007376	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A033952 Write 1,2,... in a clockwise spiral on a square lattice, writing each digit at a separate lattice point, starting with 1 at the origin and 2 at x=0, y=-1; sequence gives the numbers on the positive x-axis.
 * @author Sean A. Irvine
 */
public class A033952 extends A007376 {

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    final long t = 4 * mN * mN - 5 * mN + 2;
    while (mM < t) {
      super.next();
      ++mM;
    }
    ++mM;
    return super.next();
  }
}
#!queue	A034267	0	->	1	A034261	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;

/**
 * A034267 a(n)=f(n,n) where f is given in A034261.
 * @author Sean A. Irvine
 */
public class A034267 extends A034261 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, mN);
  }
}

#!queue	A034274	0	->	1	A034261	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;

/**
 * A034274 a(n)=f(n,n-1) where f is given in A034261.
 * @author Sean A. Irvine
 */
public class A034274 extends A034261 {

  private long mN = 1;

  @Override
  public Z next() {
    return f(++mN, mN - 1);
  }
}

#!queue	A034275	0	->	1	A034261	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;

/**
 * A034275 a(n)=f(n,n-2) where f is given in A034261.
 * @author Sean A. Irvine
 */
public class A034275 extends A034261 {

  private long mN = 0;

  @Override
  public Z next() {
    return f(++mN, mN - 2);
  }
}

#!queue	A034853	2	->	3	A034781	--------------------------------
package irvine.oeis.a034;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A034853 Triangle giving number of trees with n &gt;= 3 nodes and diameter d &gt;= 2.
 * @author Sean A. Irvine
 */
public class A034853 extends A034781 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = 2;
  private int mD = 2;

  private Polynomial<Z> r(final int diameter, final int n) {
    final Z[] r = new Z[n + 1];
    for (int k = 0; k < r.length; ++k) {
      r[k] = t(k, diameter);
    }
    return Polynomial.create(r);
  }

  private Z s(final int points, final int h) {
    if (points <= 1) {
      return Z.valueOf(points);
    }
    Z s = Z.ZERO;
    for (int k = 0; k <= h; ++k) {
      s = s.add(t(points, k));
    }
    return s;
  }

  private Polynomial<Z> sx(final int diameter, final int n) {
    final Z[] s = new Z[n + 1];
    for (int k = 0; k < s.length; ++k) {
      s[k] = s(k, diameter);
    }
    return Polynomial.create(s);
  }

  private Z d(final int points, final int diameter) {
    final int d = diameter / 2;
    if ((diameter & 1) == 0) {
      return RING.subtract(r(d, points), RING.multiply(r(d - 1, points), sx(d - 1, points), points)).coeff(points);
    } else {
      return RING.add(RING.pow(r(d, points), 2, points), r(d, points / 2).substitutePower(2, points)).coeff(points).divide2();
    }
  }

  @Override
  public Z next() {
    if (++mD >= mN) {
      ++mN;
      mD = 2;
    }
    return d(mN, mD);
  }
}
#!queue	A034854	2	->	0	A034855	--------------------------------
package irvine.oeis.a034;

import java.util.ArrayList;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A034854 Triangle giving number of labeled trees with n &gt;= 3 nodes and diameter d &gt;= 2.
 * @author Sean A. Irvine
 */
public class A034854 extends A034855 {

  private Polynomial<Q> r0(final int d, final int n) {
    if (d < 0) {
      return RING.zero();
    }
    final ArrayList<Q> coeff = new ArrayList<>();
    for (int k = 0; k <= n; ++k) {
      coeff.add(new Q(r(k, d), mF.factorial(k)));
    }
    return RING.create(coeff);
  }

  protected Z t(final int d, final int p) {
    final int dd = d / 2;
    if ((d & 1) == 0) {
      final Polynomial<Q> t0 = RING.subtract(r0(dd, p), RING.multiply(gf(dd - 1, p), r0(dd - 1, p), p));
      return t0.coeff(p).multiply(mF.factorial(p)).toZ();
    } else {
      final Polynomial<Q> t0 = RING.pow(r0(dd, p), 2, p);
      return t0.coeff(p).multiply(mF.factorial(p)).toZ().divide2();
    }
  }

  private int mP = 2;
  private int mD = 2;

  @Override
  public Z next() {
    if (++mD >= mP) {
      ++mP;
      mD = 2;
    }
    return t(mD, mP);
  }
}
#!queue	A034929	0	->	1	A091836	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;
import irvine.oeis.a091.A091836;

/**
 * A034929 A triangle of Motzkin ballot numbers, read by rows.
 * @author Sean A. Irvine
 */
public class A034929 extends A091836 {

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (--mM < 1) {
      mM = ++mN;
    }
    return t(mN, mM);
  }
}

#!queue	A034971	0	->	1	A000364	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A034971 a(n) = floor(E_(n+1)/E_(n)) where E_n is n-th Euler number (see A028296 and A000364).
 * @author Sean A. Irvine
 */
public class A034971 extends A000364 {

  {
    super.next();
  }
  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.divide(t);
  }
}
#!queue	A034973	0	->	1	A001405	--------------------------------
package irvine.oeis.a034;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A034973 Number of distinct prime factors in central binomial coefficients C(n, floor(n/2)), the terms of A001405.
 * @author Sean A. Irvine
 */
public class A034973 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).omega());
  }
}
#!queue	A034974	0	->	1	A001405	--------------------------------
package irvine.oeis.a034;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A034974 Number of divisors of binomial(n, floor(n/2)), the terms of A001405.
 * @author Sean A. Irvine
 */
public class A034974 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).sigma0();
  }
}
#!queue	A035001	1	->	0	A035002	--------------------------------
package irvine.oeis.a035;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A035001 Sorted elements of table (A035002) of a(m,n) = sum(a(m-k,n), k=1..m-1)+sum(a(m,n-k), k=1..n-1).
 * @author Sean A. Irvine
 */
public class A035001 extends A035002 {

  private final TreeSet<Z> mA = new TreeSet<>();
  private int mN = 0;

  @Override
  public Z next() {
    while (mA.isEmpty() || mA.first().compareTo(get(mN, 1)) >= 0) {
      ++mN;
      for (int m = 1; m <= mN; ++m) {
        mA.add(get(mN - m + 1, m));
      }
    }
    return mA.pollFirst();
  }
}
#!queue	A035065	0	->	1	A034886	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a034.A034886;

/**
 * A035065 Numbers k such that k! has a prime number of digits.
 * @author Sean A. Irvine
 */
public class A035065 extends A034886 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isProbablePrime()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A035066	0	->	1	A034886	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a034.A034886;

/**
 * A035066 Prime lengths of factorials: see A035065.
 * @author Sean A. Irvine
 */
public class A035066 extends A034886 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A035067	0	->	1	A034886	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a034.A034886;
import irvine.util.string.StringUtils;

/**
 * A035067 n! has a palindromic prime number of digits.
 * @author Sean A. Irvine
 */
public class A035067 extends A034886 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z t = super.next();
      if (t.isProbablePrime() && StringUtils.isPalindrome(t.toString())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A035088	1	->	0	A035087	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035088 Number of labeled polygonal cacti (Husimi graphs) with n nodes.
 * @author Sean A. Irvine
 */
public class A035088 extends A035087 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().divide(Math.max(1, mN));
  }
}
#!queue	A035112	0	->	1	A000367	--------------------------------
package irvine.oeis.a035;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A035112 Smallest even index 2a such that n-th irregular prime p (A000928(n)) divides Bernoulli_{2a} with 0&lt;=2a&lt;=p-3.
 * @author Sean A. Irvine
 */
public class A035112 extends A000367 {

  private final ArrayList<Z> mB = new ArrayList<>();
  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      final long q = mP / 2;
      while (mB.size() < q) {
        mB.add(super.next());
      }
      for (int k = 1; k <= (mP - 3) / 2; ++k) {
        if (mB.get(k).mod(mP) == 0) {
          return Z.valueOf(2L * k);
        }
      }
    }
  }
}
#!queue	A035130	0	->	1	A000578	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A035130 Cubes when digits rotated right once remain cubic.
 * @author Sean A. Irvine
 */
public class A035130 extends A000578 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    while (true) {
      final Z s = super.next();
      final String t = s.toString();
      if (ZUtils.isCube(new Z(t.charAt(t.length() - 1) + t.substring(0, t.length() - 1)))) {
        return s;
      }
    }
  }
}
#!queue	A035131	0	->	1	A000578	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A035131 Cubes that when digits rotated left once remain cubic.
 * @author Sean A. Irvine
 */
public class A035131 extends A000578 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    while (true) {
      final Z s = super.next();
      final String t = s.toString();
      if ((t.length() == 1 || t.charAt(1) != '0') && ZUtils.isCube(new Z(t.substring(1) + t.charAt(0)))) {
        return s;
      }
    }
  }
}
#!queue	A035163	0	->	1	A000364	--------------------------------
package irvine.oeis.a035;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A035163 Composite numbers k, not a power of 2, such that the E(k) == 1 (mod k), where E(k) is the k-th Euler number (A000364).
 * @author Sean A. Irvine
 */
public class A035163 extends A000364 {

  {
    super.next(); // skip 0
  }
  private long mN = 0;
  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(++mN) == 1 && (mN & (mN - 1)) != 0 && !mPrime.isPrime(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A035314	0	->	-1	A013973	--------------------------------
package irvine.oeis.a035;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a013.A013973;

/**
 * A035314 Fourier coefficients of T_8.
 * @author Sean A. Irvine
 */
public class A035314 extends A013973 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final Polynomial<Z> mE3 = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mE3.add(super.next());
    return RING.coeff(mE3, RING.pow(RING.eta(RING.x(), mN), 24, mN), mN);
  }
}

#!queue	A035315	0	->	-1	A004009	--------------------------------
package irvine.oeis.a035;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a004.A004009;

/**
 * A035315 Fourier coefficients of T_{10}.
 * @author Sean A. Irvine
 */
public class A035315 extends A004009 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final Polynomial<Z> mE4 = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mE4.add(super.next());
    return RING.coeff(mE4, RING.pow(RING.eta(RING.x(), mN), 24, mN), mN);
  }
}

#!queue	A035469	0	->	1	A007559	--------------------------------
package irvine.oeis.a035;

import java.util.ArrayList;
import java.util.List;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a007.A007559;
import irvine.oeis.transform.BellTransform;

/**
 * A035469 Triangle read by rows, the Bell transform of the triple factorial numbers A007559(n+1) without column 0.
 * @author Sean A. Irvine
 */
public class A035469 extends A007559 {

  private final List<Q> mA = new ArrayList<>();
  private BellTransform mBellTransform = null;
  private int mN = 0;
  private int mM = 0;
  {
    super.next();
    mA.add(Q.ZERO);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      mA.add(new Q(super.next()));
      ++mN;
      mM = 1;
      mBellTransform = new BellTransform(mA);
    }
    return mBellTransform.get(mN, mM).toZ();
  }
}

#!queue	A035487	0	->	1	A001966	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a001.A001966;

/**
 * A035487 Second column of Stolarsky array.
 * @author Sean A. Irvine
 */
public class A035487 extends A001966 {

  private long mN = -1;

  @Override
  public Z next() {
    return super.next().subtract(++mN);
  }
}

#!queue	A035491	0	->	1	A035485	--------------------------------
package irvine.oeis.a035;

import java.util.Iterator;

import irvine.math.z.Z;

/**
 * A035491 Relevant part of deck in Guy's shuffling problem (A035485): row n of the table lists the first 2n "cards" (numbers) after the n-th shuffle.
 * @author Sean A. Irvine
 */
public class A035491 extends A035485 {

  private int mN = 1;
  private Iterator<Long> mIterator = null;
  {
    super.next();
  }

  @Override
  public Z next() {
    if (++mN >= mDeck.size()) {
      super.next();
      mIterator = mDeck.iterator();
      mN = 2;
    }
    return Z.valueOf(mIterator.next());
  }
}

#!queue	A035493	0	->	1	A035485	--------------------------------
package irvine.oeis.a035;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A035493 Order in which new cards appear on top of deck in Guy's shuffling problem A035485.
 * @author Sean A. Irvine
 */
public class A035493 extends A035485 {

  private final TreeSet<Z> mSeen = new TreeSet<>();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (mSeen.add(t)) {
        return t;
      }
    }
  }
}

#!queue	A035496	0	->	1	A035485	--------------------------------
package irvine.oeis.a035;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A035496 Numbers of the form x*y^2 + y*z^2 + z*x^2, x,y,z &gt;= 1.
 * @author Sean A. Irvine
 */
public class A035496 extends A035485 {

  private final TreeSet<Z> mA = new TreeSet<>();
  private long mX = 1;

  @Override
  public Z next() {
    if (mA.isEmpty() || mA.first().compareTo(Z.valueOf(mX * mX + mX)) > 0) {
      for (long y = 1; y <= mX; ++y) {
        for (long z = 1; z <= mX; ++z) {
          mA.add(Z.valueOf(mX * y * y + y * z * z + z * mX * mX));
        }
      }
      ++mX;
    }
    return mA.pollFirst();
  }
}

#!queue	A035500	0	->	1	A035485	--------------------------------
package irvine.oeis.a035;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A035500 Shuffles at which new cards appear on top of deck in Guy's shuffling problem A035485.
 * @author Sean A. Irvine
 */
public class A035500 extends A035485 {

  private final TreeSet<Z> mSeen = new TreeSet<>();
  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z t = super.next();
      if (mSeen.add(t)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A035522	1	->	0	A035342	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035522 Reverse and add (in binary) - written in base 10.
 * @author Sean A. Irvine
 */
public class A035522 extends A035342 {

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.add(new Z(new StringBuilder(mN.toString(2)).reverse(), 2));
    return mN;
  }
}

#!queue	A035523	1	->	0	A035342	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035523 Reverse and add (in base 3).
 * @author Sean A. Irvine
 */
public class A035523 extends A035342 {

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.add(new Z(new StringBuilder(mN.toString(3)).reverse(), 3));
    return mN;
  }
}

#!queue	A035524	1	->	0	A035342	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035524 Reverse and add (in base 4).
 * @author Sean A. Irvine
 */
public class A035524 extends A035342 {

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.add(new Z(new StringBuilder(mN.toString(4)).reverse(), 4));
    return mN;
  }
}

#!queue	A035526	1	->	0	A035342	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035526 Reverse and add (in binary).
 * @author Sean A. Irvine
 */
public class A035526 extends A035342 {

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.add(new Z(new StringBuilder(mN.toString(2)).reverse(), 2));
    return new Z(mN.toString(2));
  }
}

#!queue	A035928	0	->	1	A036044	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a036.A036044;

/**
 * A035928 Numbers n such that BCR(n) = n, where BCR = binary-complement-and-reverse = take one's complement then reverse bit order.
 * @author Sean A. Irvine
 */
public class A035928 extends A036044 {

  @Override
  public Z next() {
    while (true) {
      final long v = super.next().longValueExact();
      if (v == mN) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A036047	0	->	1	A036046	--------------------------------
package irvine.oeis.a036;

import java.util.List;

import irvine.math.z.Z;

/**
 * A036047 Product of order of cycles of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036047 extends A036046 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    Z res = Z.ONE;
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        res = res.multiply(c);
      }
    }
    return res;
  }
}
#!queue	A036048	0	->	1	A036046	--------------------------------
package irvine.oeis.a036;

import java.util.List;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A036048 Number of different cycle lengths of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036048 extends A036046 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    return Z.valueOf(set.size());
  }
}
#!queue	A036049	0	->	1	A036046	--------------------------------
package irvine.oeis.a036;

import java.util.List;

import irvine.math.z.Z;

/**
 * A036049 Number of cycles of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036049 extends A036046 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    int cycles = 0;
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        ++cycles;
      }
    }
    return Z.valueOf(cycles);
  }
}
#!queue	A036050	0	->	1	A036046	--------------------------------
package irvine.oeis.a036;

import java.util.List;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A036050 Sum of the lengths of the cycle types of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036050 extends A036046 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    Z sum = Z.ZERO;
    for (final int s : set) {
      sum = sum.add(s);
    }
    return sum;
  }
}
#!queue	A036053	0	->	1	A036052	--------------------------------
package irvine.oeis.a036;

import java.util.List;

import irvine.math.z.Z;

/**
 * A036053 Product of order of cycles of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036053 extends A036052 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    Z res = Z.ONE;
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        res = res.multiply(c);
      }
    }
    return res;
  }
}
#!queue	A036054	0	->	1	A036052	--------------------------------
package irvine.oeis.a036;

import java.util.List;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A036054 Number of different cycle lengths of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036054 extends A036052 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    return Z.valueOf(set.size());
  }
}
#!queue	A036055	0	->	1	A036052	--------------------------------
package irvine.oeis.a036;

import java.util.List;

import irvine.math.z.Z;

/**
 * A036055 Number of cycles of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036055 extends A036052 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    int cycles = 0;
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        ++cycles;
      }
    }
    return Z.valueOf(cycles);
  }
}
#!queue	A036056	0	->	1	A036052	--------------------------------
package irvine.oeis.a036;

import java.util.List;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A036056 Sum of the lengths of the cycle types of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036056 extends A036052 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    Z sum = Z.ZERO;
    for (final int s : set) {
      sum = sum.add(s);
    }
    return sum;
  }
}
#!queue	A036060	1	->	3	A033502	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a033.A033502;

/**
 * A036060 Number of 3-component Carmichael numbers C = (6M + 1)(12M + 1)(18M + 1) &lt; 10^n.
 * @author Sean A. Irvine
 */
public class A036060 extends A033502 {

  private Z mA = super.next();
  private Z mLim = Z.valueOf(1000);
  private long mCnt = 0;

  @Override
  public Z next() {
    while (mA.compareTo(mLim) < 0) {
      ++mCnt;
      mA = super.next();
    }
    mLim = mLim.multiply(10);
    return Z.valueOf(mCnt);
  }
}
#!queue	A036276	1	->	0	A001864	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a001.A001864;

/**
 * A036276 a(n) = A001864(n+1)/2.
 * @author Sean A. Irvine
 */
public class A036276 extends A001864 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}

#!queue	A036360	1	->	0	A001865	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a001.A001865;

/**
 * A036360 Number of labeled connected functional digraphs.
 * @author Sean A. Irvine
 */
public class A036360 extends A001865 {

  @Override
  public Z next() {
    return super.next().multiply(mN * (long) mN);
  }
}
#!queue	A036437	0	->	1	A036370	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036437 Triangle of coefficients of generating function of ternary rooted trees of height exactly n.
 * @author Sean A. Irvine
 */
public class A036437 extends A036370 {

  private int mM = 0;
  private int mN = 0;

  @Override
  public Z next() {
    if (++mM >= max(mN)) {
      ++mN;
      mM = mN;
    }
    return get(mN, mM).subtract(get(mN - 1, mM));
  }
}
#!queue	A036462	0	->	1	A104320	--------------------------------
package irvine.oeis.a036;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a104.A104320;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A036462 Conjecturally, a power of 2 written in base 3 cannot have this many 0's.
 * @author Sean A. Irvine
 */
public class A036462 extends A104320 {

  // A104321 is better sequence for running a search for this!

  private final TreeSet<Long> mReported = new TreeSet<>();
  private final LongDynamicBooleanArray mSeen = new LongDynamicBooleanArray();
  private long mZ = 114; // Number of zeros to consider

  @Override
  public Z next() {
    while (true) {
      ++mZ;
      // Heuristic is to wait until we have seen count 10 times higher than target
      while (mSeen.length() < 10 * mZ) {
        final long zeros = super.next().longValueExact();
        if (mReported.contains(zeros)) {
          throw new RuntimeException("Heuristic failure: " + zeros + " is not in the sequence, found with n=" + mN);
        }
        mSeen.set(zeros);
      }
      if (!mSeen.isSet(mZ)) {
        mReported.add(mZ);
        return Z.valueOf(mZ);
      }
    }
  }
}

#!queue	A036558	1	->	0	A003136	--------------------------------
package irvine.oeis.a036;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a003.A003136;

/**
 * A036558 Squared distances that can arise in any Barlow packing of spheres of diameter sqrt(3) (the scale being the simplest one that makes this an integer sequence).
 * @author Sean A. Irvine
 */
public class A036558 extends A003136 {

  private final TreeSet<Z> mA = new TreeSet<>();
  {
    mA.add(super.next());
  }
  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (mN.compareTo(mA.last()) > 0) {
        mA.add(super.next());
      }
      if (mA.contains(mN) && mN.mod(3) == 0) {
        // i.e. z == 0, n == 3k
        return mN;
      }
      if (mA.contains(mN.subtract(2)) && mN.mod(3) == 0) {
        // i.e. z == 1, n == 3k
        return mN;
      }
      Z u;
      for (long z = 2; (u = mN.subtract(Z.valueOf(z).square().multiply2())).signum() >= 0; ++z) {
        if (mA.contains(u)) {
          return mN;
        }
      }
    }
  }
}
#!queue	A036571	1	->	0	A001614	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a001.A001614;

/**
 * A036571 Binary packing of Connell sequence (shifted once right).
 * @author Sean A. Irvine
 */
public class A036571 extends A001614 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ZERO : Z.ONE.shiftLeft(super.next().longValueExact() - 1).add(mA);
    return mA;
  }
}
#!queue	A036671	0	->	1	A000598	--------------------------------
package irvine.oeis.a036;

import irvine.math.group.DihedralGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000598;

/**
 * A036671 Number of isomers C_n H_{2n} without double bonds.
 * @author Sean A. Irvine
 */
public class A036671 extends A000598 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mG = RING.empty();
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    mG.add(new Q(super.next()));
    final Polynomial<Q> g = RING.divide(RING.add(RING.pow(mG, 2, mN), mG.substitutePower(2, mN)).shift(1), Q.TWO);
    Polynomial<Q> sum = RING.zero();
    for (int k = 3; k <= mN; ++k) {
      sum = RING.add(sum, DihedralGroup.cycleIndex(k).apply(g, mN));
    }
    return sum.coeff(mN).toZ();
  }
}
#!queue	A036761	1	->	0	A033950	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a033.A033950;

/**
 * A036761 Number of refactorable integers (A033950) of binary order (A029837) n.
 * @author Sean A. Irvine
 */
public class A036761 extends A033950 {

  private Z mLim = Z.ONE;
  private Z mA = super.next();

  @Override
  public Z next() {
    long count = 0;
    while (mA.compareTo(mLim) <= 0) {
      ++count;
      mA = super.next();
    }
    mLim = mLim.multiply2();
    return Z.valueOf(count);
  }
}
#!queue	A036789	2	->	0	A022821	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a022.A022821;

/**
 * A036789 a(n) = Sum_{i=0..n} floor((2*i + 2)/(n - i + 1)).
 * @author Sean A. Irvine
 */
public class A036789 extends A022821 {

  @Override
  public Z next() {
    return super.next().subtract(mN - 1);
  }
}
#!queue	A036832	4	->	5	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036832 Schoenheim bound L_1(n,5,4).
 * @author Sean A. Irvine
 */
public class A036832 extends A036831 {

  private long mN = 4;

  @Override
  public Z next() {
    return l(++mN, 5, 4, 1);
  }
}
#!queue	A036833	4	->	6	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036833 Schoenheim bound L_1(n,6,5).
 * @author Sean A. Irvine
 */
public class A036833 extends A036831 {

  private long mN = 5;

  @Override
  public Z next() {
    return l(++mN, 6, 5, 1);
  }
}
#!queue	A036834	4	->	7	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036834 Schoenheim bound L_1(n,7,6).
 * @author Sean A. Irvine
 */
public class A036834 extends A036831 {

  private long mN = 6;

  @Override
  public Z next() {
    return l(++mN, 7, 6, 1);
  }
}
#!queue	A036835	4	->	8	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036835 Schoenheim bound L_1(n,8,7).
 * @author Sean A. Irvine
 */
public class A036835 extends A036831 {

  private long mN = 7;

  @Override
  public Z next() {
    return l(++mN, 8, 7, 1);
  }
}
#!queue	A036836	4	->	9	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036836 Schoenheim bound L_1(n,9,8).
 * @author Sean A. Irvine
 */
public class A036836 extends A036831 {

  private long mN = 8;

  @Override
  public Z next() {
    return l(++mN, 9, 8, 1);
  }
}
#!queue	A036837	4	->	7	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036837 Schoenheim bound L_1(n,n-5,n-6).
 * @author Sean A. Irvine
 */
public class A036837 extends A036831 {

  private long mN = 6;

  @Override
  public Z next() {
    return l(++mN, mN - 5, mN - 6, 1);
  }
}
#!queue	A036838	4	->	0	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036838 Triangle read by rows: T(n,k) = value of Schoenheim bound L_1(n+2,k+2,k+1) on covering numbers (0 &lt;= k &lt;= n).
 * @author Sean A. Irvine
 */
public class A036838 extends A036831 {

  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return l(mN + 2, mM + 2, mM + 1, 1);
  }
}
#!queue	A036919	1	->	0	A036918	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036919 A036918/2.
 * @author Sean A. Irvine
 */
public class A036919 extends A036918 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A037031	1	->	0	A000720	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A037031 Number of combinations of n objects taken pi(n) at a time.
 * @author Sean A. Irvine
 */
public class A037031 extends A000720 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    final Z pi = super.next();
    return Binomial.binomial(mN, pi);
  }
}

#!queue	A037203	1	->	0	A001223	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;
import irvine.oeis.a001.A001223;

/**
 * A037203 Number of terms by which A001223 lags behind A037201.
 * @author Sean A. Irvine
 */
public class A037203 extends A001223 {

  private Z mPrev = Z.ZERO;
  private long mLag = 0;

  @Override
  public Z next() {
    final Z t = mPrev;
    mPrev = super.next();
    if (t.equals(mPrev)) {
      ++mLag;
    }
    return Z.valueOf(mLag);
  }
}
#!queue	A037834	0	->	1	A005811	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;
import irvine.oeis.a005.A005811;

/**
 * A037834 a(n) = Sum_{i=1..m} |d(i) - d(i-1)|, where Sum_{i=0..m} d(i)*2^i is the base-2 representation of n.
 * @author Sean A. Irvine
 */
public class A037834 extends A005811 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A037862	0	->	1	A037861	--------------------------------
package irvine.oeis.a037;

/**
 * A037862 a(n)=(number of digits &lt;=1)-(number of digits &gt;1) in base 3 representation of n.
 * @author Sean A. Irvine
 */
public class A037862 extends A037861 {

  {
    super.next(); // skip 0
  }

  @Override
  protected long base() {
    return 3;
  }
}
#!queue	A037992	1	->	0	A050376	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;
import irvine.oeis.a050.A050376;

/**
 * A037992 Smallest number with 2^n divisors.
 * @author Sean A. Irvine
 */
public class A037992 extends A050376 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply(super.next());
    return mA;
  }
}
#!queue	A038005	2	->	0	A033178	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a033.A033178;

/**
 * A038005 Odd k such that b(k) is less than b(k-1) and b(k+1). b(k): A033178.
 * @author Sean A. Irvine
 */
public class A038005 extends A033178 {

  private Z mA = super.next();
  private Z mB = super.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mA;
      mA = mB;
      mB = super.next();
      if ((mN & 1) == 0 && mA.compareTo(t) < 0 && mA.compareTo(mB) < 0) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A038007	2	->	1	A033178	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a033.A033178;

/**
 * A038007 Even numbers k such that b(k) is greater than b(k-1) and b(k+1); b(k) = A033178(k).
 * @author Sean A. Irvine
 */
public class A038007 extends A033178 {

  private Z mA = null;
  private Z mB = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = super.next();
      mB = super.next();
    }
    while (true) {
      final Z t = mA;
      mA = mB;
      mB = super.next();
      if ((mN & 1) == 1 && mA.compareTo(t) > 0 && mA.compareTo(mB) > 0) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A038033	1	->	3	A000313	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000313;

/**
 * A038033 a(n) = A000166(n-1)*n*(n-1).
 * @author Sean A. Irvine
 */
public class A038033 extends A000313 {

  {
    next();
    next();
    next();
  }

  @Override
  public Z next() {
    return super.next().multiply(6);
  }
}
#!queue	A038054	1	->	0	A038049	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038054 Number of labeled trees with 2-colored leaves.
 * @author Sean A. Irvine
 */
public class A038054 extends A038049 {

  private boolean mFirst = true;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    final Z t = mA;
    mA = super.next();
    return t.multiply(mN).add(mA).divide(mN);
  }
}
#!queue	A038058	1	->	0	A038057	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038058 Number of labeled trees with 2-colored nodes.
 * @author Sean A. Irvine
 */
public class A038058 extends A038057 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().divide(mN);
  }
}
#!queue	A038062	1	->	0	A038061	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038062 Number of labeled trees with 3-colored nodes.
 * @author Sean A. Irvine
 */
public class A038062 extends A038061 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().divide(mN);
  }
}
#!queue	A038107	1	->	0	A000720	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A038107 Number of primes &lt; n^2.
 * @author Sean A. Irvine
 */
public class A038107 extends A000720 {

  private long mN = 0;
  private long mLim = 0;
  private long mSquareM1 = 0;

  @Override
  public Z next() {
    if (mLim == 0) {
      ++mLim;
      return Z.ZERO;
    }
    while (mN < mSquareM1) {
      ++mN;
      super.next();
    }
    ++mN;
    mSquareM1 = ++mLim * mLim - 1;
    return super.next();
  }
}
#!queue	A038108	1	->	2	A001358	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a001.A001358;

/**
 * A038108 Number of prime pairs {p,q}, such that pq &lt; n^2.
 * @author Sean A. Irvine
 */
public class A038108 extends A001358 {

  private long mCount = 0;
  private long mN = 1;
  private Z mS = super.next();

  @Override
  public Z next() {
    final Z square = Z.valueOf(++mN).square();
    while (mS.compareTo(square) < 0) {
      mS = super.next();
      ++mCount;
    }
    return Z.valueOf(mCount);
  }
}
#!queue	A038190	0	->	-2	A038189	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038190 Pagoda sequence: a(0) = b(n)-b(n-2) mod 3, where b(n) = A038189(n).
 * @author Sean A. Irvine
 */
public class A038190 extends A038189 {

  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    final Z t = mA;
    mA = mB;
    mB = super.next();
    return mB.subtract(t).mod(Z.THREE);
  }
}
#!queue	A038360	0	->	3	A000079	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000079;
import irvine.oeis.a000.A000931;

/**
 * A038360 Ranks of certain relations among Euler sums of weight n.
 * @author Sean A. Irvine
 */
public class A038360 extends A000079 {

  private final Sequence mA = new A000931().skip(6);

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A038377	0	->	1	A037040	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a037.A037040;

/**
 * A038377 Number of odd nonprimes &lt;= (2n+1)^2.
 * @author Sean A. Irvine
 */
public class A038377 extends A037040 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A038398	0	->	1	A000578	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A038398 Concatenate first n cubes in reverse order.
 * @author Sean A. Irvine
 */
public class A038398 extends A000578 {

  private final StringBuilder mS = new StringBuilder();
  {
    super.next();
  }

  @Override
  public Z next() {
    mS.insert(0, super.next());
    return new Z(mS);
  }
}
#!queue	A038494	0	->	1	A000384	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A038494 Images of hexamorphic numbers: suppose k-th hexagonal number H(k) (A000384) ends in k; sequence gives positive values of H(k).
 * @author Sean A. Irvine
 */
public class A038494 extends A000384 {

  private long mN = 0;
  private long mLim = 10;
  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (++mN == mLim) {
        mLim *= 10;
      }
      if (t.mod(mLim) == mN) {
        return t;
      }
    }
  }
}
#!queue	A038736	1	->	0	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038736 T(3*n + 1, n + 1), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038736 extends A038792 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(3 * ++mN + 1, mN + 1);
  }
}
#!queue	A038746	0	->	1	A173380	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a173.A173380;

/**
 * A038746 Coefficients arising in the enumeration of configurations of linear chains.
 * @author Sean A. Irvine
 */
public class A038746 extends A173380 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(4).divide(8);
  }
}
#!queue	A038753	0	->	1	A000041	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A038753 Nonprime partition numbers.
 * @author Sean A. Irvine
 */
public class A038753 extends A000041 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    while (true) {
      final Z partitions = super.next();
      if (!partitions.isProbablePrime()) {
        return partitions;
      }
    }
  }
}
#!queue	A038776	0	->	1	A014486	--------------------------------
package irvine.oeis.a038;

import java.util.LinkedList;
import java.util.TreeMap;

import irvine.math.z.Z;
import irvine.oeis.a014.A014486;

/**
 * A038776 The sequence a[1] to a[ cat[n] ] is the permutation that converts forest[n] of depth-first planar planted binary trees into breadth-first representation.
 * @author Sean A. Irvine
 */
public class A038776 extends A014486 {

  {
    super.next(); // skip 0
  }

  private final TreeMap<Z, Long> mOrdering = new TreeMap<>();
  private final LinkedList<Z> mA = new LinkedList<>();
  private int mBitCount = 1;
  private long mM = 0;
  private long mN = -1;

  private void step() {
    Z t = super.next();
    if (t.bitCount() == mBitCount) {
      mOrdering.put(t, ++mN);
      mA.add(t);
    } else {
      mOrdering.clear();
      mA.clear();
      mN = mM - 1;
      for (int k = 0; k <= mN; ++k) {
        t = super.next();
      }
      mOrdering.put(t, ++mN);
      mA.add(t);
      mBitCount = t.bitCount();
    }
  }

  private long getIndex(final Z n) {
    while (!mOrdering.containsKey(n)) {
      step();
    }
    // We can remove because this is a permutation
    return mOrdering.remove(n);
  }

  private static class Node {
    private Node mLeft = null;
    private Node mRight = null;
  }

  private void dfs(final Node node, final StringBuilder sb) {
    if (node == null) {
      sb.append('0');
    } else {
      sb.append(1);
      dfs(node.mLeft, sb);
      dfs(node.mRight, sb);
    }
  }

  private Z bfsTodfs(final Z n) {
    if (n.isZero()) {
      return Z.ZERO;
    }
    final String s = n.toString(2);
    // Build dfs tree
    final Node root = new Node();
    final LinkedList<Node> bfs = new LinkedList<>();
    bfs.add(root);
    for (int k = 1; k + 1 < s.length(); k += 2) { // k == 0 is root
      final Node node = bfs.pollFirst();
      if (s.charAt(k) == '1') {
        final Node t = new Node();
        node.mLeft = t;
        bfs.add(t);
      }
      if (s.charAt(k + 1) == '1') {
        final Node t = new Node();
        node.mRight = t;
        bfs.add(t);
      }
    }
    final StringBuilder sb = new StringBuilder();
    dfs(root, sb);
    //System.out.println(s + " -> " + sb);
    return new Z(sb, 2).divide2(); // Ignore last implicit 0
  }

  @Override
  public Z next() {
    if (mA.isEmpty()) {
      step();
    }
    ++mM;
    return Z.valueOf(getIndex(bfsTodfs(mA.pollFirst())) + 1);
  }
}
#!queue	A038793	1	->	3	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038793 T(n,n-3), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038793 extends A038792 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 4L);
  }
}
#!queue	A038794	1	->	4	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038794 T(n,n-4), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038794 extends A038792 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 5L);
  }
}
#!queue	A038795	1	->	5	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038795 T(n,n-5), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038795 extends A038792 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 6L);
  }
}
#!queue	A038796	1	->	6	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038796 T(n,n-6), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038796 extends A038792 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 7L);
  }
}
#!queue	A039593	0	->	1	A001405	--------------------------------
package irvine.oeis.a039;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A039593 Number of unitary divisors of central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A039593 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).unitarySigma0();
  }
}
#!queue	A039594	0	->	1	A000384	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A039594 Hexamorphic numbers: k such that the k-th hexagonal number ends with k.
 * @author Sean A. Irvine
 */
public class A039594 extends A000384 {

  private long mN = 0;
  private long mLim = 10;
  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z h = super.next();
      if (++mN == mLim) {
        mLim *= 10;
      }
      if (h.mod(mLim) == mN) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A039653	1	->	0	A000203	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A039653 a(0) = 0; for n &gt; 0, a(n) = sigma(n)-1.
 * @author Sean A. Irvine
 */
public class A039653 extends A000203 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().subtract(1);
  }
}
#!queue	A039732	2	->	1	A039731	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;

/**
 * A039732 a(n) = s(n+1)/2, s=A039731.
 * @author Sean A. Irvine
 */
public class A039732 extends A039731 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A039919	0	->	1	A002212	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a002.A002212;

/**
 * A039919 Related to enumeration of edge-rooted catafusenes.
 * @author Sean A. Irvine
 */
public class A039919 extends A002212 {

  private Z mSum = super.next();

  @Override
  public Z next() {
    final Z t = super.next();
    final Z u = mSum;
    mSum = mSum.add(t);
    return t.subtract(u);
  }
}
#!queue	A039953	2	->	1	A003022	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a003.A003022;

/**
 * A039953 Triangle of "canonical" optimal Golomb rulers.
 * @author Sean A. Irvine
 */
public class A039953 extends A003022 {

  {
    super.next();
  }

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN >= mPositions.length) {
      super.next();
      mN = 1;
    }
    return Z.valueOf(mPositions[mN] - mPositions[mN - 1]);
  }
}
#!queue	A039963	1	->	0	A035263	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a035.A035263;

/**
 * A039963 The period-doubling sequence A035263 repeated.
 * @author Sean A. Irvine
 */
public class A039963 extends A035263 {

  private Z mA = null;

  @Override
  public Z next() {
    if (mA != null) {
      final Z t = mA;
      mA = null;
      return t;
    }
    mA = super.next();
    return mA;
  }
}

#!queue	A039974	0	->	1	A006318	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a006.A006318;

/**
 * A039974 An example of a d-perfect sequence.
 * @author Sean A. Irvine
 */
public class A039974 extends A006318 {

  private long mMult = -1;

  @Override
  public Z next() {
    final long r = super.next().mod(3);
    mMult = -mMult;
    return Z.valueOf((3 + r * mMult) % 3);
  }
}

#!queue	A039975	0	->	1	A006318	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a006.A006318;

/**
 * A039975 An example of a d-perfect sequence: a(n) = A006318(n-1) mod 3.
 * @author Sean A. Irvine
 */
public class A039975 extends A006318 {

  @Override
  public Z next() {
    return super.next().mod(Z.THREE);
  }
}

#!queue	A039990	0	->	1	A039987	--------------------------------
package irvine.oeis.a039;

/**
 * A039990 k th digit of a(n) is the number of different digits within 4 of k (not including k).
 * @author Sean A. Irvine
 */
public class A039990 extends A039987 {

  @Override
  protected int shift() {
    return 4;
  }
}

#!queue	A040016	0	->	1	A000149	--------------------------------
package irvine.oeis.a040;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000149;

/**
 * A040016 Largest prime &lt; e^n.
 * @author Sean A. Irvine
 */
public class A040016 extends A000149 {

  {
    super.next();
  }
  private final Fast mPrime = new Fast();
  private Z mP = Z.NEG_ONE;

  @Override
  public Z next() {
    final Z t = super.next();
    Z a = mP;
    while (mP.compareTo(t) <= 0) {
      a = mP;
      mP = mPrime.nextPrime(mP);
    }
    return a;
  }
}
#!queue	A043294	0	->	1	A000984	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000984;

/**
 * A043294 Sum of digits of binomial(2n,n).
 * @author Sean A. Irvine
 */
public class A043294 extends A000984 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()));
  }
}

#!queue	A043295	0	->	1	A000367	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000367;

/**
 * A043295 Sum of digits of numerator of Bernoulli number B(2n).
 * @author Sean A. Irvine
 */
public class A043295 extends A000367 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next().abs()));
  }
}

#!queue	A043296	0	->	1	A002445	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002445;

/**
 * A043296 Sum of digits of denominator of Bernoulli number B(2n).
 * @author Sean A. Irvine
 */
public class A043296 extends A002445 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next().abs()));
  }
}

#!queue	A043303	1	->	0	A001067	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.oeis.a001.A001067;

/**
 * A043303 Numerator of B(4n+2)/(2n+1) where B(m) are the Bernoulli numbers.
 * @author Sean A. Irvine
 */
public class A043303 extends A001067 {

  @Override
  public Z next() {
    final Z t = super.next();
    super.next();
    return t;
  }
}

#!queue	A043544	2	->	1	A043306	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;

/**
 * A043544 Numbers k such that s(k)&lt;s(k-1), where s(k)=sum of all digits in all base b representations of k, for 2&lt;=b&lt;=k.
 * @author Sean A. Irvine
 */
public class A043544 extends A043306 {

  private Z mA = super.next();
  private long mN = 2;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z t = mA;
      mA = super.next();
      if (mA.compareTo(t) < 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A045645	0	->	1	A011545	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a011.A011545;

/**
 * A045645 Concatenate first n terms of A011545.
 * @author Sean A. Irvine
 */
public class A045645 extends A011545 {

  private final StringBuilder mA = new StringBuilder();

  @Override
  public Z next() {
    mA.append(super.next());
    return new Z(mA);
  }
}
#!queue	A045739	1	->	2	A094040	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a094.A094040;

/**
 * A045739 Number of edges in all noncrossing forests on n nodes on a circle.
 * @author Sean A. Irvine
 */
public class A045739 extends A094040 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 1; k < mN; ++k) {
      sum = sum.add(t(mN, k).multiply(k));
    }
    return sum;
  }
}
#!queue	A045747	0	->	1	A007662	--------------------------------
package irvine.oeis.a045;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a007.A007662;

/**
 * A045747 Number of prime factors of n!!!! (A007662), with multiplicity.
 * @author Sean A. Irvine
 */
public class A045747 extends A007662 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).bigOmega());
  }
}
#!queue	A045766	0	->	1	A006882	--------------------------------
package irvine.oeis.a045;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A045766 Number of prime factors of double factorials n!! (A006882), with multiplicity.
 * @author Sean A. Irvine
 */
public class A045766 extends A006882 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).bigOmega());
  }
}
#!queue	A045767	0	->	1	A007661	--------------------------------
package irvine.oeis.a045;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a007.A007661;

/**
 * A045767 Number of prime factors of triple factorials n!!! (A007661), with multiplicity.
 * @author Sean A. Irvine
 */
public class A045767 extends A007661 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).bigOmega());
  }
}
#!queue	A045814	0	->	1	A045812	--------------------------------
package irvine.oeis.a045;

/**
 * A045814 Number of times the digits are repeated in A045813.
 * @author Sean A. Irvine
 */
public class A045814 extends A045812 {

  @Override
  protected int base() {
    return 4;
  }
}

#!queue	A045816	0	->	1	A045812	--------------------------------
package irvine.oeis.a045;

/**
 * A045816 Number of times the digits are repeated in A045815.
 * @author Sean A. Irvine
 */
public class A045816 extends A045812 {

  @Override
  protected int base() {
    return 6;
  }
}

#!queue	A045881	0	->	1	A000230	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A045881 Smallest of first string of exactly 2n-1 consecutive composite integers.
 * @author Sean A. Irvine
 */
public class A045881 extends A000230 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A045978	1	->	0	A002385	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a002.A002385;

/**
 * A045978 Palindromic primes that are "near miss circular primes" (all cyclic shifts except one are primes).
 * @author Sean A. Irvine
 */
public class A045978 extends A002385 {

  private boolean isNearCircular(final Z p) {
    final String s = p.toString();
    boolean sawNonPrime = false;
    for (int k = 1; k < s.length(); ++k) {
      if (!new Z(s.substring(k) + s.substring(0, k)).isProbablePrime()) {
        if (sawNonPrime) {
          return false;
        }
        sawNonPrime = true;
      }
    }
    return sawNonPrime;
  }

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (isNearCircular(p)) {
        return p;
      }
    }
  }
}
#!queue	A045979	0	->	1	A002445	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a002.A002445;

/**
 * A045979 Bernoulli number B_{2n} has denominator 6.
 * @author Sean A. Irvine
 */
public class A045979 extends A002445 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A046053	0	->	1	A002275	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A046053 Total number of prime factors of the repunit R(n)=(10^n-1)/9.
 * @author Sean A. Irvine
 */
public class A046053 extends A002275 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A046109	1	->	0	A046080	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046109 Number of lattice points (x,y) on the circumference of a circle of radius n with center at (0,0).
 * @author Sean A. Irvine
 */
public class A046109 extends A046080 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().multiply(8).add(4);
  }
}
#!queue	A046110	1	->	0	A046080	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046110 Number of lattice points on circumference of a circle of radius (2n+1)/2 with center at (1/2,0).
 * @author Sean A. Irvine
 */
public class A046110 extends A046080 {

  @Override
  public Z next() {
    final Z t = super.next();
    super.next();
    return t.multiply(4).add(2);
  }
}
#!queue	A046111	1	->	0	A046080	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046111 Number of lattice points on circumference of a circle of radius 1/3,2/3,4/3,5/3,... with center at (1/3,0).
 * @author Sean A. Irvine
 */
public class A046111 extends A046080 {

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 2) {
      super.next();
      mN = 0;
    }
    return super.next().multiply2().add(1);
  }
}
#!queue	A046112	0	->	1	A006339	--------------------------------
package irvine.oeis.a046;

import irvine.oeis.a006.A006339;

/**
 * A046112 a(n) is smallest integral radius of circle centered at (0,0) having 8n-4 lattice points on its circumference; a(n)/2 is smallest half-integral radius circle centered at (1/2,0) having 4n-2 lattice points; a(n)/3 is smallest third-integral radius circle centered at (1/3,0) having 2n-1 lattice points.
 * @author Sean A. Irvine
 */
public class A046112 extends A006339 {
  // Differs only in offset
}
#!queue	A046164	0	->	14	A343146	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a343.A343146;

/**
 * A046164 Number of distinct solutions to reverse the 8 puzzle (3 X 3 analog of the 4 X 4 15 puzzle) in 28, 30, 32, ... moves.
 * @author Sean A. Irvine
 */
public class A046164 extends A343146 {

  private static final long TARGET_STATE = 0b1000_0111_0110_0101_0100_0011_0010_0001_0000L;
  private boolean[] mUsed = null;
  private int mN = 26;
  private long mCount = 0;
  private long mSum = 0; // Work around historical over counting

  @Override
  protected long targetState() {
    return TARGET_STATE;
  }

  private void search(final int id, final int stepsRemaining) {
    if (stepsRemaining == 0) {
      if (id == mTargetId) {
        ++mCount;
      }
      return;
    }
    for (final int newId : mTransitions[id]) {
      if (!mUsed[newId]) {
        mUsed[newId] = true;
        search(newId, stepsRemaining - 1);
        mUsed[newId] = false;
      }
    }
  }

  @Override
  protected void init() {
    super.init();
    if (mUsed == null) {
      mUsed = new boolean[mTransitions.length];
    }
  }

  @Override
  public Z next() {
    init();
    mCount = 0;
    mN += 2;
    search(mStateToId.get(START_STATE), mN);
    mSum = mCount - mSum; // Work around historical inaccuracy?
    return Z.valueOf(mSum);
  }
}
#!queue	A046171	0	->	1	A001411	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a001.A001411;

/**
 * A046171 Number of inequivalent self-avoiding walks of length n on a 2-D lattice which start at origin, take first step in {+1,0} direction and if any steps are vertical, a step up is taken before a step down.
 * @author Sean A. Irvine
 */
public class A046171 extends A001411 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    return super.next().add(4).divide(8);
  }
}
#!queue	A046212	0	->	1	A002457	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a002.A002457;

/**
 * A046212 First numerator and then denominator of central elements of Leibniz's Harmonic Triangle.
 * @author Sean A. Irvine
 */
public class A046212 extends A002457 {

  private boolean mNumerator = false;

  @Override
  public Z next() {
    mNumerator = !mNumerator;
    return mNumerator ? Z.ONE : super.next();
  }
}
#!queue	A046234	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046234 Cubes which are palindromes in base 5.
 * @author Sean A. Irvine
 */
public class A046234 extends A046232 {

  @Override
  protected int base() {
    return 5;
  }
}
#!queue	A046236	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046236 Cubes which are palindromes in base 6.
 * @author Sean A. Irvine
 */
public class A046236 extends A046232 {

  @Override
  protected int base() {
    return 6;
  }
}
#!queue	A046238	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046238 Cubes which are palindromes in base 7.
 * @author Sean A. Irvine
 */
public class A046238 extends A046232 {

  @Override
  protected int base() {
    return 7;
  }
}
#!queue	A046240	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046240 Cubes which are palindromes in base 8.
 * @author Sean A. Irvine
 */
public class A046240 extends A046232 {

  @Override
  protected int base() {
    return 8;
  }
}
#!queue	A046242	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046242 Cubes which are palindromes in base 9.
 * @author Sean A. Irvine
 */
public class A046242 extends A046232 {

  @Override
  protected int base() {
    return 9;
  }
}
#!queue	A046244	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046244 Cubes which are palindromes in base 11.
 * @author Sean A. Irvine
 */
public class A046244 extends A046232 {

  @Override
  protected int base() {
    return 11;
  }
}
#!queue	A046246	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046246 Cubes which are palindromes in base 12.
 * @author Sean A. Irvine
 */
public class A046246 extends A046232 {

  @Override
  protected int base() {
    return 12;
  }
}
#!queue	A046248	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046248 Cubes which are palindromes in base 13.
 * @author Sean A. Irvine
 */
public class A046248 extends A046232 {

  @Override
  protected int base() {
    return 13;
  }
}
#!queue	A046250	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046250 Cubes which are palindromes in base 14.
 * @author Sean A. Irvine
 */
public class A046250 extends A046232 {

  @Override
  protected int base() {
    return 14;
  }
}
#!queue	A046252	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046252 Cubes which are palindromes in base 15.
 * @author Sean A. Irvine
 */
public class A046252 extends A046232 {

  @Override
  protected int base() {
    return 15;
  }
}
#!queue	A046278	1	->	0	A000959	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a000.A000959;

/**
 * A046278 Concatenate lucky numbers.
 * @author Sean A. Irvine
 */
public class A046278 extends A000959 {

  private final StringBuilder mA = new StringBuilder();

  @Override
  public Z next() {
    mA.append(super.next());
    return new Z(mA);
  }
}
#!queue	A046439	1	->	0	A046432	--------------------------------
package irvine.oeis.a046;

/**
 * A046439 9 steps needed to reach a prime under "Sum of digits raised to its digits' powers" procedure.
 * @author Sean A. Irvine
 */
public class A046439 extends A046432 {

  @Override
  protected int steps() {
    return 9;
  }
}
#!queue	A046471	0	->	1	A046019	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046471 Number of numbers k&gt;1 such that k equals the sum of digits in k^n.
 * @author Sean A. Irvine
 */
public class A046471 extends A046019 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A046646	0	->	1	A001764	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a001.A001764;

/**
 * A046646 Number of certain rooted planar maps.
 * @author Sean A. Irvine
 */
public class A046646 extends A001764 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return super.next();
    }
    return super.next().multiply2();
  }
}
#!queue	A046651	1	->	0	A091599	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a091.A091599;

/**
 * A046651 Triangle of rooted planar maps.
 * @author Sean A. Irvine
 */
public class A046651 extends A091599 {

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (--mM <= 0) {
      mM = ++mN;
    }
    return t(mN, mM);
  }
}
#!queue	A046652	1	->	0	A091665	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a091.A091665;

/**
 * A046652 Triangle of rooted planar maps, read by rows.
 * @author Sean A. Irvine
 */
public class A046652 extends A091665 {

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (--mM <= 0) {
      mM = ++mN;
    }
    return t(mN, mM);
  }
}
#!queue	A046728	0	->	1	A000230	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A046728 Let p1, p2 be first pair of consecutive primes with difference 2n; let p3, p4 be 2nd such pair; sequence gives "wadi" value p3-p1.
 * @author Sean A. Irvine
 */
public class A046728 extends A000230 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z p1 = super.next();
    // Search for second gap of required size
    Z p3 = mPrime.nextPrime(p1);
    while (true) {
      final Z p4 = mPrime.nextPrime(p3);
      if (p4.subtract(p3).intValueExact() == mGapSize) {
        return p3.subtract(p1);
      }
      p3 = p4;
    }
  }
}
#!queue	A046753	0	->	1	A000367	--------------------------------
package irvine.oeis.a046;

import java.util.TreeSet;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A046753 Prime factors of |numerator(B(2n))| which are &gt;= 2n+3.
 * @author Sean A. Irvine
 */
public class A046753 extends A000367 {

  private final TreeSet<Z> mA = new TreeSet<>();
  private Z mT = Z.THREE;

  @Override
  public Z next() {
    while (mA.isEmpty()) {
      mT = mT.add(2);
      for (final Z p : Jaguar.factor(super.next().abs()).toZArray()) {
        if (p.compareTo(mT) >= 0) {
          mA.add(p);
        }
      }
    }
    return mA.pollFirst();
  }
}
#!queue	A046789	0	->	1	A000230	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A046789 Lower prime of the second gap of 2n between primes.
 * @author Sean A. Irvine
 */
public class A046789 extends A000230 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z p1 = super.next();
    // Search for second gap of required size
    Z p3 = mPrime.nextPrime(p1);
    while (true) {
      final Z p4 = mPrime.nextPrime(p3);
      if (p4.subtract(p3).intValueExact() == mGapSize) {
        return p3;
      }
      p3 = p4;
    }
  }
}
#!queue	A046801	0	->	1	A000225	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A046801 Number of divisors of 2^n-1.
 * @author Sean A. Irvine
 */
public class A046801 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z a = super.next();
    return a.compareTo(Z.TWO) < 0 ? Z.ONE : Jaguar.factor(a).sigma0();
  }
}

#!queue	A046815	0	->	1	A000119	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000045;
import irvine.oeis.a000.A000119;
import irvine.util.array.DynamicLongArray;

/**
 * A046815 Smallest number which can be written as the sum of distinct Fibonacci numbers in n ways and such that the Zeckendorf representation of the number uses only even-subscripted Fibonacci numbers.
 * @author Sean A. Irvine
 */
public class A046815 extends A000119 {

  private final Sequence mFibo = new A000045();
  private long mM = -1;
  private int mN = 0;
  private final DynamicLongArray mFirst = new DynamicLongArray();
  private final DynamicLongArray mFiboCache = new DynamicLongArray();

  private long fibo(final int k) {
    while (k >= mFiboCache.length()) {
      mFiboCache.set(mFiboCache.length(), mFibo.next().longValueExact());
    }
    return mFiboCache.get(k);
  }

  private boolean isEvenIndexZeckendorf(final long n) {
    int k = 1;
    while (fibo(k) <= n) {
      ++k;
    }
    long m = n;
    while (m != 0) {
      final long f = fibo(k);
      if (f > m) {
        --k;
      } else {
        if ((k & 1) == 1) {
          return false;
        }
        m -= f;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    ++mN;
    while (mFirst.get(mN) == 0) {
      ++mM;
      final int v = super.next().intValueExact();
      if (mFirst.get(v) == 0 && isEvenIndexZeckendorf(mM)) {
        mFirst.set(v, mM);
      }
    }
    return Z.valueOf(mFirst.get(mN));
  }
}
#!queue	A046932	2	->	1	A055061	--------------------------------
package irvine.oeis.a046;

import java.util.List;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a055.A055061;

/**
 * A046932 a(n) = period of x^n + x + 1 over GF(2), i.e., the smallest integer m&gt;0 such that x^n + x + 1 divides x^m + 1 over GF(2).
 * @author Sean A. Irvine
 */
public class A046932 extends A055061 {

  private int mN = 0;

  @Override
  public Z next() {
    final long[] c = new long[++mN + 1];
    c[0] = 1;
    c[1] = 1;
    c[mN] = 1;
    final Polynomial<Z> f = Polynomial.create(c);
    final List<Polynomial<Z>> factors = factor(f);
    Z per = Z.ONE;
    for (final Polynomial<Z> p : factors) {
      per = per.lcm(periodIrreducible(p));
    }
    return per;
  }
}
#!queue	A047003	0	->	1	A047000	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047003 T(n,n-1), array T given by A047000.
 * @author Sean A. Irvine
 */
public class A047003 extends A047000 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047004	0	->	2	A047000	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047004 T(n,n-2), array T given by A047000.
 * @author Sean A. Irvine
 */
public class A047004 extends A047000 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047005	0	->	3	A047000	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047005 T(n,n-3), array T given by A047000.
 * @author Sean A. Irvine
 */
public class A047005 extends A047000 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047013	0	->	1	A047010	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047013 T(n,n-1), array T given by A047010.
 * @author Sean A. Irvine
 */
public class A047013 extends A047010 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047014	0	->	2	A047010	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047014 T(n,n-2), array T given by A047010.
 * @author Sean A. Irvine
 */
public class A047014 extends A047010 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047015	0	->	3	A047010	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047015 T(n,n-3), array T given by A047010.
 * @author Sean A. Irvine
 */
public class A047015 extends A047010 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047023	0	->	1	A047020	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047023 T(n,n-1), array T given by A047020.
 * @author Sean A. Irvine
 */
public class A047023 extends A047020 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047024	0	->	2	A047020	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047024 T(n,n-2), array T given by A047020.
 * @author Sean A. Irvine
 */
public class A047024 extends A047020 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047025	0	->	3	A047020	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047025 T(n,n-3), array T given by A047020.
 * @author Sean A. Irvine
 */
public class A047025 extends A047020 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047029	0	->	1	A047020	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047029 T(2n,n), array T given by A047020.
 * @author Sean A. Irvine
 */
public class A047029 extends A047020 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A047033	0	->	1	A047030	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047033 T(n,n-1), array T as in A047030.
 * @author Sean A. Irvine
 */
public class A047033 extends A047030 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047034	0	->	2	A047030	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047034 T(n,n-2), array T as in A047030.
 * @author Sean A. Irvine
 */
public class A047034 extends A047030 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047035	0	->	3	A047030	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047035 T(n,n-3), array T as in A047030.
 * @author Sean A. Irvine
 */
public class A047035 extends A047030 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047043	0	->	1	A047040	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047043 T(n,n-1), array T as in A047040; T(n-1,n), array T given by A047050.
 * @author Sean A. Irvine
 */
public class A047043 extends A047040 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047044	0	->	2	A047040	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047044 T(n,n-2), array T as in A047040; T(n-2,n), array T given by A047050.
 * @author Sean A. Irvine
 */
public class A047044 extends A047040 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047045	0	->	3	A047040	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047045 T(n,n-3), array T as in A047040; T(n-3,n), array T given by A047050.
 * @author Sean A. Irvine
 */
public class A047045 extends A047040 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047063	0	->	1	A047060	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047063 T(n,n-1), array T as in A047060.
 * @author Sean A. Irvine
 */
public class A047063 extends A047060 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047064	0	->	2	A047060	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047064 T(n,n-2), array T as in A047060.
 * @author Sean A. Irvine
 */
public class A047064 extends A047060 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047065	0	->	3	A047060	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047065 T(n,n-3), array T as in A047060.
 * @author Sean A. Irvine
 */
public class A047065 extends A047060 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047087	0	->	1	A047080	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047087 a(n) = A047080(2*n, n+1).
 * @author Sean A. Irvine
 */
public class A047087 extends A047080 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A047088	0	->	1	A047080	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047088 a(n) = A047080(2*n+1, n+2).
 * @author Sean A. Irvine
 */
public class A047088 extends A047080 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A047092	0	->	1	A047089	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047092 T(n,n-1), array T as in A047089.
 * @author Sean A. Irvine
 */
public class A047092 extends A047089 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN);
  }
}
#!queue	A047093	0	->	2	A047089	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047093 T(n,n-2), array T as in A047089.
 * @author Sean A. Irvine
 */
public class A047093 extends A047089 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 2, mN);
  }
}
#!queue	A047094	0	->	3	A047089	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047094 T(n,n-3), array T as in A047089.
 * @author Sean A. Irvine
 */
public class A047094 extends A047089 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN - 3, mN);
  }
}
#!queue	A047099	0	->	1	A047098	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047099 a(n) = A047098(n)/2.
 * @author Sean A. Irvine
 */
public class A047099 extends A047098 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A047103	0	->	1	A047100	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047103 T(n,n-1), array T as in A047100.
 * @author Sean A. Irvine
 */
public class A047103 extends A047100 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047104	0	->	2	A047100	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047104 T(n,n-2), array T as in A047100.
 * @author Sean A. Irvine
 */
public class A047104 extends A047100 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047105	0	->	3	A047100	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047105 T(n,n-3), array T as in A047100.
 * @author Sean A. Irvine
 */
public class A047105 extends A047100 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047113	0	->	1	A047110	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047113 T(n,n-1), array T as in A047110.
 * @author Sean A. Irvine
 */
public class A047113 extends A047110 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047114	0	->	2	A047110	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047114 T(n,n-2), array T as in A047110.
 * @author Sean A. Irvine
 */
public class A047114 extends A047110 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047115	0	->	3	A047110	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047115 T(n,n-3), array T as in A047110.
 * @author Sean A. Irvine
 */
public class A047115 extends A047110 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047123	0	->	1	A047120	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047123 T(n,n-1), array T as in A047120.
 * @author Sean A. Irvine
 */
public class A047123 extends A047120 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047124	0	->	2	A047120	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047124 T(n,n-2), array T as in A047120.
 * @author Sean A. Irvine
 */
public class A047124 extends A047120 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047125	0	->	3	A047120	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047125 T(n,n-3), array T as in A047120.
 * @author Sean A. Irvine
 */
public class A047125 extends A047120 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047133	0	->	1	A047130	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047133 T(n,n-1), array T as in A047130.
 * @author Sean A. Irvine
 */
public class A047133 extends A047130 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047134	0	->	2	A047130	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047134 T(n,n-2), array T as in A047130.
 * @author Sean A. Irvine
 */
public class A047134 extends A047130 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047135	0	->	3	A047130	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047135 a(n) = T(n,n-3), array T as in A047130.
 * @author Sean A. Irvine
 */
public class A047135 extends A047130 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047143	0	->	1	A047140	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047143 T(n,n-1), array T as in A047140.
 * @author Sean A. Irvine
 */
public class A047143 extends A047140 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047144	0	->	2	A047140	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047144 T(n,n-2), array T as in A047140.
 * @author Sean A. Irvine
 */
public class A047144 extends A047140 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047145	0	->	3	A047140	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047145 T(n,n-3), array T as in A047140.
 * @author Sean A. Irvine
 */
public class A047145 extends A047140 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047153	0	->	1	A047150	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047153 T(n,n-1), array T as in A047150.
 * @author Sean A. Irvine
 */
public class A047153 extends A047150 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047154	0	->	2	A047150	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047154 T(n,n-2), array T as in A047150.
 * @author Sean A. Irvine
 */
public class A047154 extends A047150 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047155	0	->	3	A047150	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047155 T(n,n-3), array T as in A047150.
 * @author Sean A. Irvine
 */
public class A047155 extends A047150 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047662	0	->	1	A008288	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A047662 Square array a(n,k) read by antidiagonals: a(n,1)=n, a(1,k)=k, a(n,k)=a(n-1,k-1)+a(n-1,k)+a(n,k-1)+1.
 * @author Sean A. Irvine
 */
public class A047662 extends A008288 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next().divide2();
      if (t.signum() > 0) {
        return t;
      }
    }
  }
}
#!queue	A047676	1	->	0	A047675	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047676 Main diagonal of square array defined in A047675.
 * @author Sean A. Irvine
 */
public class A047676 extends A047675 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A047758	0	->	1	A001764	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047758 Number of dissectable polyhedra with symmetry of type G.
 * @author Sean A. Irvine
 */
public class A047758 extends A001764 {

  private final Sequence mA = new A047751();
  private final Sequence mB = new A047752();
  private final Sequence mC = new A047753();
  private long mN = 0;

  @Override
  public Z next() {
    final Z t = mA.next().add(mB.next().multiply2()).add(mC.next().multiply(3));
    if ((++mN & 3) != 1) {
      return Z.ZERO;
    } else {
      return super.next().subtract(t).divide(6);
    }
  }
}

#!queue	A047766	0	->	1	A001764	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047766 Number of dissectable polyhedra with symmetry of type O.
 * @author Sean A. Irvine
 */
public class A047766 extends A001764 {

  private final Sequence mA = new A047764();
  private long mN = 0;

  @Override
  public Z next() {
    final Z a = mA.next();
    return (++mN % 6) != 2 ? Z.ZERO : super.next().subtract(a).divide2();
  }
}

#!queue	A047769	0	->	1	A001764	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047769 Number of dissectable polyhedra with symmetry of type M.
 * @author Sean A. Irvine
 */
public class A047769 extends A001764 {

  {
    super.next();
  }
  private final Sequence mA = new A047764();
  private final Sequence mB = new A047765();
  private final Sequence mC = new A047766();
  private boolean mOdd = false;

  @Override
  public Z next() {
    final Z t = mA.next().add(mB.next()).add(mC.next().multiply2());
    mOdd = !mOdd;
    return mOdd ? Z.ZERO : super.next().subtract(t).divide2();
  }
}
#!queue	A047771	0	->	1	A001764	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047771 Number of dissectable polyhedra with symmetry of type L.
 * @author Sean A. Irvine
 */
public class A047771 extends A001764 {

  {
    super.next();
  }
  private final Sequence mA = new A047764();
  private final Sequence mB = new A047765();
  private final Sequence mC = new A047766();
  private boolean mOdd = false;

  @Override
  public Z next() {
    final Z t = mA.next().add(mB.next().multiply(3)).add(mC.next().multiply2());
    mOdd = !mOdd;
    return mOdd ? Z.ZERO : super.next().subtract(t).divide(6);
  }
}

#!queue	A047809	1	->	0	A000378	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.a000.A000378;

/**
 * A047809 a(n) counts different values of i^2+j^2+k^2 &lt;= n^2 or number of distances from the origin to all integer points inside a sphere of radius n.
 * @author Sean A. Irvine
 */
public class A047809 extends A000378 {

  private Z mA = super.next();
  private long mC = 0;
  private long mN = -1;

  @Override
  public Z next() {
    final Z n2 = Z.valueOf(++mN).square();
    while (mA.compareTo(n2) <= 0) {
      ++mC;
      mA = super.next();
    }
    return Z.valueOf(mC);
  }
}
#!queue	A047893	0	->	1	A000364	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A047893 Number of decimal digits of Euler (Zig) numbers A000364: a(n) = ceiling(log_10(|E(2n)|)), where E is Euler's E function.
 * @author Sean A. Irvine
 */
public class A047893 extends A000364 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return Z.ONE.equals(t) ? Z.ZERO : Z.valueOf(t.toString().length());
  }
}
#!queue	A048057	0	->	-2	A058550	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a010.A010839;
import irvine.oeis.a058.A058550;

/**
 * A048057 Fourier coefficients of T_{12}.
 * @author Sean A. Irvine
 */
public class A048057 extends A058550 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048100	0	->	-2	A013974	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a010.A010839;
import irvine.oeis.a013.A013974;

/**
 * A048100 Fourier coefficients of T_{16}.
 * @author Sean A. Irvine
 */
public class A048100 extends A013974 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048101	0	->	-2	A008410	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a008.A008410;
import irvine.oeis.a010.A010839;

/**
 * A048101 Fourier coefficients of T_{18}.
 * @author Sean A. Irvine
 */
public class A048101 extends A008410 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048110	0	->	-2	A013973	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a010.A010839;
import irvine.oeis.a013.A013973;

/**
 * A048110 Fourier coefficients of T_{20}.
 * @author Sean A. Irvine
 */
public class A048110 extends A013973 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048116	0	->	1	A048113	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048116 a(n) = T(2n,n), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048116 extends A048113 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A048120	0	->	1	A048113	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048120 a(n)=T(2n,n+1), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048120 extends A048113 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A048138	1	->	2	A001065	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001065;
import irvine.util.array.LongDynamicIntArray;

/**
 * A048138 a(n) = number of m such that sum of proper divisors of m (A001065(m)) is n.
 * @author Sean A. Irvine
 */
public class A048138 extends A001065 {

  private final LongDynamicIntArray mA = new LongDynamicIntArray();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    final long lim = ++mN * mN;
    while (mM <= lim) {
      final long v = super.next().longValueExact();
      mA.set(v, mA.get(v) + 1);
      ++mM;
    }
    return Z.valueOf(mA.get(mN));
  }
}
#!queue	A048145	0	->	-2	A004009	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a004.A004009;
import irvine.oeis.a010.A010839;

/**
 * A048145 Fourier coefficients of T_{22}.
 * @author Sean A. Irvine
 */
public class A048145 extends A004009 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048179	1	->	4	A001430	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001430;

/**
 * A048179 Number of graphs with n nodes and n+1 edges.
 * @author Sean A. Irvine
 */
public class A048179 extends A001430 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return numberLinearGraphs(++mN, mN + 1);
  }
}
#!queue	A048180	1	->	4	A001430	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001430;

/**
 * A048180 Number of graphs with n nodes and n+2 edges.
 * @author Sean A. Irvine
 */
public class A048180 extends A001430 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return numberLinearGraphs(++mN, mN + 2);
  }
}
#!queue	A048292	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048292 1-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048292 extends A001203 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(Z.TEN) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048293	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048293 Positions of 1-digit terms in the continued fraction for Pi (3 is at position 0).
 * @author Sean A. Irvine
 */
public class A048293 extends A001203 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z t = super.next();
      if (t.compareTo(Z.TEN) < 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A048294	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048294 2-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048294 extends A001203 {

  private static final Z UPPER = Z.valueOf(100);

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(Z.TEN) >= 0 && t.compareTo(UPPER) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048384	0	->	1	A048380	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048384 Squares resulting from procedure described in A048383.
 * @author Sean A. Irvine
 */
public class A048384 extends A048380 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isSquare()) {
        return t;
      }
    }
  }
}
#!queue	A048387	0	->	1	A048385	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048387 Squares resulting from procedure described in A048386.
 * @author Sean A. Irvine
 */
public class A048387 extends A048385 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isSquare()) {
        return t;
      }
    }
  }
}
#!queue	A048392	0	->	1	A048390	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048392 Squares resulting from procedure described in A048391.
 * @author Sean A. Irvine
 */
public class A048392 extends A048390 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isSquare()) {
        return t;
      }
    }
  }
}
#!queue	A048394	0	->	1	A048390	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048394 Primes resulting from procedure described in A048393.
 * @author Sean A. Irvine
 */
public class A048394 extends A048390 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A048406	1	->	0	A033068	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.a033.A033068;

/**
 * A048406 Numbers whose consecutive digits differ by 4.
 * @author Sean A. Irvine
 */
public class A048406 extends A033068 {

  @Override
  protected int base() {
    return 10;
  }

  @Override
  protected long diff() {
    return 4;
  }

  @Override
  protected long start() {
    return 0;
  }
}
#!queue	A048456	1	->	0	A047844	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;

/**
 * A048456 First terms from generation 1 onwards.
 * @author Sean A. Irvine
 */
public class A048456 extends A047844 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(1L, ++mN);
  }
}
#!queue	A048461	1	->	0	A047844	--------------------------------
package irvine.oeis.a048;

import java.util.Comparator;
import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;
import irvine.util.Pair;

/**
 * A048461 Numbers in sorted order taken from all generations.
 * @author Sean A. Irvine
 */
public class A048461 extends A047844 {

  private final TreeSet<Pair<Long, Long>> mA = new TreeSet<>(Comparator.comparing((Pair<Long, Long> o) -> get(o.left(), o.right())).thenComparingLong(Pair::left));
  {
    mA.add(new Pair<>(1L, 1L));
  }
  private Z mPrev = Z.ZERO;

  @Override
  public Z next() {
    while (true) {
      final Pair<Long, Long> a = mA.pollFirst();
      mA.add(new Pair<>(a.left() + 1, a.right()));
      mA.add(new Pair<>(a.left(), a.right() + 1));
      final Z t = get(a.left(), a.right());
      if (!t.equals(mPrev)) {
        mPrev = t;
        return t;
      }
    }
  }
}
#!queue	A048462	1	->	0	A047844	--------------------------------
package irvine.oeis.a048;

import java.util.Comparator;
import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;
import irvine.util.Pair;

/**
 * A048462 Odd numbers in sorted order from generation 2 onwards.
 * @author Sean A. Irvine
 */
public class A048462 extends A047844 {

  private final TreeSet<Pair<Long, Long>> mA = new TreeSet<>(Comparator.comparing((Pair<Long, Long> o) -> get(o.left(), o.right())).thenComparingLong(Pair::left));
  {
    mA.add(new Pair<>(1L, 2L));
  }
  private Z mPrev = Z.ZERO;

  @Override
  public Z next() {
    while (true) {
      final Pair<Long, Long> a = mA.pollFirst();
      mA.add(new Pair<>(a.left() + 1, a.right()));
      mA.add(new Pair<>(a.left(), a.right() + 1));
      final Z t = get(a.left(), a.right());
      if (t.isOdd() && !t.equals(mPrev)) {
        mPrev = t;
        return t;
      }
    }
  }
}
#!queue	A048463	1	->	0	A047844	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;

/**
 * A048463 Smallest prime occurring in generation n (0 if none).
 * @author Sean A. Irvine
 */
public class A048463 extends A047844 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z t;
    long m = 0;
    while (m <= mN) {
      t = get(++m, mN);
      if (t.isProbablePrime()) {
        return t;
      }
    }
//    while ((t = get(++m, mN)).isOdd()) {
//      if (t.isProbablePrime()) {
//        return t;
//      }
//    }
    return Z.ZERO;
  }
}
#!queue	A048466	1	->	2	A047844	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;

/**
 * A048466 Total number of primes in "generation" n.
 * @author Sean A. Irvine
 */
public class A048466 extends A047844 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    long c = 0;
    long m = 0;
    while (++m <= mN) {
      if (get(m, mN).isProbablePrime()) {
        ++c;
      }
    }
//    while (get(++m, mN).isOdd()) {
//      if (get(m, mN).isProbablePrime()) {
//        ++c;
//      }
//    }
    return Z.valueOf(c);
  }
}
#!queue	A048529	0	->	1	A002378	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002378;
import irvine.util.array.DynamicLongArray;

/**
 * A048529 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 0's.
 * @author Sean A. Irvine
 */
public class A048529 extends A002378 {

  private final DynamicLongArray mFirst = new DynamicLongArray();
  private int mN = 0;
  private long mM = 0; // offset by 1 since we use 0 as sentinel

  protected int digit() {
    return 0;
  }

  @Override
  public Z next() {
    ++mN;
    while (mFirst.get(mN) == 0) {
      ++mM;
      final int zeros = ZUtils.digitCounts(super.next())[digit()];
      if (mFirst.get(zeros) == 0) {
        mFirst.set(zeros, mM);
      }
    }
    return Z.valueOf(mFirst.get(mN) - 1);
  }
}
#!queue	A048530	0	->	1	A002378	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002378;
import irvine.util.array.DynamicArray;

/**
 * A048530 Smallest oblong (promic) number containing exactly n 0's.
 * @author Sean A. Irvine
 */
public class A048530 extends A002378 {

  private final DynamicArray<Z> mFirst = new DynamicArray<>();
  private int mN = 0;

  protected int digit() {
    return 0;
  }

  @Override
  public Z next() {
    ++mN;
    while (mFirst.get(mN) == null) {
      final Z pronic = super.next();
      final int zeros = ZUtils.digitCounts(pronic)[digit()];
      if (mFirst.get(zeros) == null) {
        mFirst.set(zeros, pronic);
      }
    }
    return mFirst.get(mN);
  }
}
#!queue	A048619	1	->	0	A002944	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001405;
import irvine.oeis.a002.A002944;

/**
 * A048619 a(n) = LCM(binomial(n,0), ..., binomial(n,n)) / binomial(n,floor(n/2)).
 * @author Sean A. Irvine
 */
public class A048619 extends A002944 {

  private final Sequence mA = new A001405();

  @Override
  public Z next() {
    return super.next().divide(mA.next());
  }
}

#!queue	A048633	0	->	1	A001405	--------------------------------
package irvine.oeis.a048;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A048633 Largest squarefree number dividing n-th central binomial coefficient C(n,[ n/2 ]).
 * @author Sean A. Irvine
 */
public class A048633 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).squareFreeKernel();
  }
}
#!queue	A048664	0	->	1	A001168	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001168;

/**
 * A048664 Number of rooted 2-dimensional polyominoes with n square cells, with no symmetries removed.
 * @author Sean A. Irvine
 */
public class A048664 extends A001168 {

  private long mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}
#!queue	A048830	-1	->	0	A014221	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a014.A014221;

/**
 * A048830 Number of rooted identity game trees of height &lt;=n, first player to reach to reach top wins. First player wins.
 * @author Sean A. Irvine
 */
public class A048830 extends A014221 {

  private final MemorySequence mC = MemorySequence.cachedSequence(new A014221());
  private int mN = 0;

  @Override
  public Z next() {
    if (++mN <= 2) {
      return mN == 1 ? Z.ZERO : Z.ONE;
    }
    return mC.a(mN).subtract(Z.ONE.shiftLeft(mC.a(mN - 1).longValueExact() - mC.a(mN - 2).longValueExact()));
  }
}
#!queue	A048859	0	->	1	A001044	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001044;

/**
 * A048859 A sieve: keep the first 2 numbers, delete the next 3 numbers; keep the next 3 numbers, delete the next 4 numbers; keep the next 4 numbers, delete the next 5 numbers; and so on. In other words, keep the next k numbers and delete the next k+1 numbers, for k = 2, 3, ...
 * @author Sean A. Irvine
 */
public class A048859 extends A001044 {

  private long mN = 2;
  private long mM = 0;
  private long mK = 3;

  @Override
  public Z next() {
    if (--mK == 0) {
      mM += ++mN;
      mK = mN;
    }
    return Z.valueOf(++mM);
  }
}

#!queue	A048882	1	->	0	A035529	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.a035.A035529;

/**
 * A048882 A convolution triangle of numbers obtained from A034255.
 * @author Sean A. Irvine
 */
public class A048882 extends A035529 {

  @Override
  protected long degree() {
    return 4;
  }
}

#!queue	A048888	1	->	0	A048887	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048888 a(n) = Sum{T(m,n+1-m): m=1,2,...,n}, array T as in A048887.
 * @author Sean A. Irvine
 */
public class A048888 extends A048887 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long m = 1; m <= mN; ++m) {
      sum = sum.add(get(mN + 1 - m, m));
    }
    return sum;
  }
}

#!queue	A048955	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048955 Positions of 2-digit terms in the continued fraction for Pi (3 is at position 0).
 * @author Sean A. Irvine
 */
public class A048955 extends A001203 {

  private static final Z UPPER = Z.valueOf(100);
  private long mM = -1;

  @Override
  public Z next() {
    while (true) {
      ++mM;
      final Z t = super.next();
      if (t.compareTo(Z.TEN) >= 0 && t.compareTo(UPPER) < 0) {
        return Z.valueOf(mM);
      }
    }
  }
}
#!queue	A048956	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048956 3-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048956 extends A001203 {

  private static final Z LOWER = Z.valueOf(100);
  private static final Z UPPER = Z.valueOf(1000);

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048957	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048957 Positions of 3-digit terms in the continued fraction for Pi (3 is at position 0).
 * @author Sean A. Irvine
 */
public class A048957 extends A001203 {

  private static final Z LOWER = Z.valueOf(100);
  private static final Z UPPER = Z.valueOf(1000);
  private long mM = -1;

  @Override
  public Z next() {
    while (true) {
      ++mM;
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return Z.valueOf(mM);
      }
    }
  }
}
#!queue	A048958	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048958 4-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048958 extends A001203 {

  private static final Z LOWER = Z.valueOf(1000);
  private static final Z UPPER = Z.valueOf(10000);

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048959	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048959 Positions of 4-digit terms in the continued fraction for Pi (3 is at position 0).
 * @author Sean A. Irvine
 */
public class A048959 extends A001203 {

  private static final Z LOWER = Z.valueOf(1000);
  private static final Z UPPER = Z.valueOf(10000);
  private long mM = -1;

  @Override
  public Z next() {
    while (true) {
      ++mM;
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return Z.valueOf(mM);
      }
    }
  }
}
#!queue	A048960	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048960 5-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048960 extends A001203 {

  private static final Z LOWER = Z.valueOf(10000);
  private static final Z UPPER = Z.valueOf(100000);

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048961	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048961 Positions of 5-digit terms in the continued fraction for Pi (3 is position 0).
 * @author Sean A. Irvine
 */
public class A048961 extends A001203 {

  private static final Z LOWER = Z.valueOf(10000);
  private static final Z UPPER = Z.valueOf(100000);
  private long mM = -1;

  @Override
  public Z next() {
    while (true) {
      ++mM;
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return Z.valueOf(mM);
      }
    }
  }
}
#!queue	A049019	0	->	1	A048996	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a036.A036038;
import irvine.oeis.a048.A048996;

/**
 * A049019 Number of preferential arrangements (onto functions) associated with each numeric partition, partitions in Abramowitz and Stegun order, irregular triangle read by rows.
 * @author Sean A. Irvine
 */
public class A049019 extends A048996 {

  private final Sequence mA = new A036038();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(mA.next());
  }
}
#!queue	A049240	0	->	1	A010052	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a010.A010052;

/**
 * A049240 Smallest nonnegative value taken on by x^2 - n*y^2 for an infinite number of integer pairs (x, y).
 * @author Sean A. Irvine
 */
public class A049240 extends A010052 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.ONE.subtract(super.next());
  }
}
#!queue	A049355	1	->	0	A049354	--------------------------------
package irvine.oeis.a049;

/**
 * A049355 Digitally balanced numbers in base 4: equal numbers of 0's, 1's, ... 3's.
 * @author Sean A. Irvine
 */
public class A049355 extends A049354 {

  @Override
  protected int base() {
    return 4;
  }
}
#!queue	A049454	1	->	0	A000010	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a000.A000010;

/**
 * A049454 a(n) = 1 + Sum_{i=1..n} phi(i)^2.
 * @author Sean A. Irvine
 */
public class A049454 extends A000010 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.add(super.next().square());
    return mA;
  }
}
#!queue	A049461	1	->	2	A000214	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000214;
import irvine.oeis.a053.A053037;

/**
 * A049461 Number of equivalence classes of self-dual Boolean functions of n variables under action of LSD(n,2).
 * @author Sean A. Irvine
 */
public class A049461 extends A000214 {

  private final Sequence mA = new A053037();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A049575	0	->	1	A000041	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A049575 Prime partition numbers.
 * @author Sean A. Irvine
 */
public class A049575 extends A000041 {

  @Override
  public Z next() {
    while (true) {
      final Z part = super.next();
      if (part.isProbablePrime()) {
        return part;
      }
    }
  }
}

#!queue	A049716	3	->	1	A049711	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049716 a(n) = 2*n + 1 - prevprime(2*n + 1).
 * @author Sean A. Irvine
 */
public class A049716 extends A049711 {

  @Override
  public Z next() {
    final Z res = super.next();
    super.next();
    return res;
  }
}
#!queue	A049801	1	->	3	A049765	--------------------------------
package irvine.oeis.a049;

/**
 * A049801 Triangular array T, read by rows: T(n,k) = n mod floor(k/3), k = 3..n and n &gt;= 3.
 * @author Sean A. Irvine
 */
public class A049801 extends A049765 {

  @Override
  protected long t(final long n, final long m) {
    return (n + 2) % ((m + 2) / 3);
  }
}
#!queue	A049843	1	->	2	A049816	--------------------------------
package irvine.oeis.a049;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;

/**
 * A049843 Triangular array T read by rows: T(n,k)=number of nonzero remainders when Euclidean algorithm acts on primes p(n) and p(k), k=1,2,...,n-1; n=2,3,4,...
 * @author Sean A. Irvine
 */
public class A049843 extends A049816 {

  private final Fast mPrime = new Fast();
  private long mN = 2;
  private long mM = 0;

  @Override
  public Z next() {
    mM = mPrime.nextPrime(mM);
    if (mM >= mN) {
      mN = mPrime.nextPrime(mN);
      mM = 2;
    }
    return Z.valueOf(t(mN, mM));
  }
}
#!queue	A049881	2	->	3	A049880	--------------------------------
package irvine.oeis.a049;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A049881 a(n) is the number of distinct sums of 3 different primes chosen from the first n primes.
 * @author Sean A. Irvine
 */
public class A049881 extends A049880 {

  protected final TreeSet<Long> mSeen2 = new TreeSet<>();
  private long mP = 3;

  @Override
  public Z next() {
    super.next();
    mP = mPrime.nextPrime(mP);
    for (final long q : mSeen) {
      mSeen2.add(mP + q);
    }
    return Z.valueOf(mSeen2.size());
  }
}
#!queue	A050148	1	->	2	A050143	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050148 a(n) = T(n,n-2), array T as in A050143.
 * @author Sean A. Irvine
 */
public class A050148 extends A050143 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A050149	1	->	3	A050143	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050149 a(n) = T(n,n-3), array T as in A050143.
 * @author Sean A. Irvine
 */
public class A050149 extends A050143 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A050188	0	->	3	A001840	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a001.A001840;

/**
 * A050188 T(n,3), array T as in A050186; a count of aperiodic binary words.
 * @author Sean A. Irvine
 */
public class A050188 extends A001840 {

  @Override
  public Z next() {
    return super.next().multiply(mN + 3);
  }
}
#!queue	A050189	0	->	4	A006918	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a006.A006918;

/**
 * A050189 T(n,4), array T as in A050186; a count of aperiodic binary words.
 * @author Sean A. Irvine
 */
public class A050189 extends A006918 {

  @Override
  public Z next() {
    return super.next().multiply(mN + 4);
  }
}
#!queue	A050640	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050640 a(n+1) is next smallest nontrivial cube containing a(n) as a substring, initial term is 1.
 * @author Sean A. Irvine
 */
public class A050640 extends A000578 {

  {
    super.next(); // skip 0
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.contains(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050642	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050642 a(n+1) is next smallest nontrivial cube containing a(n) as a substring, initial term is 8.
 * @author Sean A. Irvine
 */
public class A050642 extends A000578 {

  {
    super.next(); // skip 0
    super.next(); // skip 1
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.contains(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050644	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050644 a(n+1) is next smallest nontrivial cube containing a(n) as a substring, initial term is 27.
 * @author Sean A. Irvine
 */
public class A050644 extends A000578 {

  {
    super.next(); // skip 0
    super.next(); // skip 1
    super.next(); // skip 8
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.contains(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050646	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050646 a(n+1) is next smallest cube ending with a(n), initial term is 1.
 * @author Sean A. Irvine
 */
public class A050646 extends A000578 {

  {
    super.next(); // skip 0
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.endsWith(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050648	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050648 a(n+1) is next smallest cube ending with a(n), initial term is 8.
 * @author Sean A. Irvine
 */
public class A050648 extends A000578 {

  {
    super.next(); // skip 0
    super.next(); // skip 1
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.endsWith(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050650	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050650 a(n+1) is next smallest cube ending with a(n), initial term is 27.
 * @author Sean A. Irvine
 */
public class A050650 extends A000578 {

  {
    super.next(); // skip 0
    super.next(); // skip 1
    super.next(); // skip 8
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.endsWith(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050726	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050726 Decimal expansion of 5^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050726 extends A050724 {

  @Override
  protected long multiplier() {
    return 5;
  }
}

#!queue	A050728	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050728 Decimal expansion of 7^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050728 extends A050724 {

  @Override
  protected long multiplier() {
    return 7;
  }
}

#!queue	A050729	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050729 Decimal expansion of 8^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050729 extends A050724 {

  @Override
  protected long multiplier() {
    return 8;
  }
}

#!queue	A050730	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050730 Decimal expansion of 9^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050730 extends A050724 {

  @Override
  protected long multiplier() {
    return 9;
  }
}

#!queue	A050731	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050731 Decimal expansion of 11^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050731 extends A050724 {

  @Override
  protected long multiplier() {
    return 11;
  }
}

#!queue	A050734	0	->	1	A050733	--------------------------------
package irvine.oeis.a050;

/**
 * A050734 Numbers of form 4^k (values of k see A050725) containing no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050734 extends A050733 {

  @Override
  protected long multiplier() {
    return 4;
  }
}

#!queue	A050767	1	->	0	A050703	--------------------------------
package irvine.oeis.a050;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A050767 Let f(m) = smallest composite number that takes m steps of "add prime factors to number" to reach a prime and g(m) be the prime that is reached. Sequence gives values of g(m), sorted and duplicates removed.
 * @author Sean A. Irvine
 */
public class A050767 extends A050703 {

  private final LongDynamicBooleanArray mSteps = new LongDynamicBooleanArray();
  private final TreeSet<Z> mA = new TreeSet<>();
  private Z mPrev = Z.ZERO;
  private Z mN = Z.ONE;

  @Override
  public Z next() {
    while (mA.isEmpty() || mA.first().compareTo(mN) >= 0) {
      mN = mN.add(1);
      if (!mN.isProbablePrime()) {
        long cnt = 0;
        Z t = mN;
        while (true) {
          ++cnt;
          t = f(t);
          if (t.isProbablePrime()) {
            if (!mSteps.isSet(cnt)) {
              if (t.compareTo(mPrev) > 0) {
                mA.add(t);
              }
              mSteps.set(cnt);
            }
            break;
          }
        }
      }
    }
    mPrev = mA.pollFirst();
    return mPrev;
  }
}
#!queue	A050768	1	->	0	A050703	--------------------------------
package irvine.oeis.a050;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;

/**
 * A050768 Iterated procedure 'composite k added to sum of its prime factors reaches a prime' yields 1 skipped prime.
 * @author Sean A. Irvine
 */
public class A050768 extends A050703 {

  private final Fast mPrime = new Fast();
  private long mN = 1;

  @Override
  public Z next() {
    while (true) {
      final Z n = Z.valueOf(++mN);
      if (!n.isProbablePrime()) {
        Z t = f(n);
        while (!t.isProbablePrime()) {
          t = f(t);
        }
        Z p = n;
        for (int k = 0; k <= iterations() && p.compareTo(t) <= 0; ++k) {
          p = mPrime.nextPrime(p);
        }
        if (t.equals(p)) {
          return n;
        }
      }
    }
  }
}
#!queue	A050777	1	->	0	A050703	--------------------------------
package irvine.oeis.a050;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.util.array.DynamicLongArray;

/**
 * A050777 First occurrence from iterated procedure 'composite k added to sum of its prime factors reaches a prime' yielding n skipped primes.
 * @author Sean A. Irvine
 */
public class A050777 extends A050703 {

  private final DynamicLongArray mFirsts = new DynamicLongArray();
  private final Fast mPrime = new Fast();
  private int mM = 0;
  private long mN = 1;

  @Override
  public Z next() {
    ++mM;
    while (mFirsts.get(mM) == 0) {
      final Z n = Z.valueOf(++mN);
      if (!n.isProbablePrime()) {
        Z t = f(n);
        while (!t.isProbablePrime()) {
          t = f(t);
        }
        Z p = n;
        int cnt = 0;
        while (p.compareTo(t) < 0) {
          p = mPrime.nextPrime(p);
          ++cnt;
        }
        if (mFirsts.get(cnt) == 0) {
          mFirsts.set(cnt, mN);
        }
      }
    }
    return Z.valueOf(mFirsts.get(mM));
  }
}
#!queue	A051009	0	->	1	A001601	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a001.A001601;

/**
 * A051009 Reduced denominators of Newton's iteration for sqrt(2).
 * @author Sean A. Irvine
 */
public class A051009 extends A001601 {

  @Override
  public Z next() {
    return super.next().square().subtract(1).divide2().sqrt().max(Z.ONE);
  }
}
#!queue	A051059	1	->	0	A048141	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a048.A048141;

/**
 * A051059 a(n) = A048141(3*n+1).
 * @author Sean A. Irvine
 */
public class A051059 extends A048141 {

  @Override
  public Z next() {
    final Z t = super.next();
    super.next();
    super.next();
    return t;
  }
}
#!queue	A051060	1	->	0	A048141	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a048.A048141;

/**
 * A051060 a(n) = A048141(3*n+2).
 * @author Sean A. Irvine
 */
public class A051060 extends A048141 {

  @Override
  public Z next() {
    super.next();
    final Z t = super.next();
    super.next();
    return t;
  }
}
#!queue	A051106	1	->	2	A048601	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a048.A048601;

/**
 * A051106 Second diagonal of triangle A048601.
 * @author Sean A. Irvine
 */
public class A051106 extends A048601 {

  private int mN = 1;

  @Override
  public Z next() {
    return t(++mN, 2);
  }
}
#!queue	A051177	0	->	1	A000041	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A051177 Perfectly partitioned numbers: numbers k that divide the number of partitions p(k).
 * @author Sean A. Irvine
 */
public class A051177 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A051178	0	->	1	A027423	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a027.A027423;

/**
 * A051178 Numbers k such that k divides the number of divisors of k!.
 * @author Sean A. Irvine
 */
public class A051178 extends A027423 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A051192	0	->	7	A050186	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a050.A050186;

/**
 * A051192 T(n,7), array T as in A050186; a count of aperiodic binary words.
 * @author Sean A. Irvine
 */
public class A051192 extends A050186 {

  private long mN = 6;

  @Override
  public Z next() {
    return t(++mN, 7);
  }
}
#!queue	A051201	0	->	1	A050186	--------------------------------
package irvine.oeis.a051;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a050.A050186;

/**
 * A051201 Sum of elements of the set { [ n/k ] : 1 &lt;= k &lt;= n }.
 * @author Sean A. Irvine
 */
public class A051201 extends A050186 {

  private long mN = 0;

  @Override
  public Z next() {
    final Z m = CR.valueOf(4 * ++mN + 1).sqrt().subtract(CR.ONE).divide(CR.TWO).floor();
    Z sum = m.multiply(m.add(1)).divide2();
    for (long k = 1; k <= mN / (m.longValueExact() + 1); ++k) {
      sum = sum.add(mN / k);
    }
    return sum;
  }
}
#!queue	A051223	0	->	1	A000170	--------------------------------
package irvine.oeis.a051;

import irvine.oeis.a000.A000170;

/**
 * A051223 Number of ways of placing n nonattacking superqueens on an n X n board.
 * @author Sean A. Irvine
 */
public class A051223 extends A000170 {

  // Not really competitive ...

  private static final int[] DELTA_X = {-2, -2, -1, -1, 1, 1, 2, 2};
  private static final int[] DELTA_Y = {1, -1, 2, -2, 2, -2, 1, -1};
  {
    next(); // skip 0
  }

  static boolean isKnightConsistent(final int[] q, final int n) {
    for (int k = 0; k < n; ++k) {
      final int col = q[n];
      for (int d = 0; d < DELTA_X.length; ++d) {
        final int x = col + DELTA_X[d];
        final int y = n + DELTA_Y[d];
        if (x >= 0 && x < q.length && y >= 0 && y < n && q[y] == x) {
          return false;
        }
      }
    }
    return true;
  }

  @Override
  protected boolean isConsistent(final int[] q, final int n) {
    // Check queen-style moves
    if (!super.isConsistent(q, n)) {
      return false;
    }
    // Check knight-style moves
    return isKnightConsistent(q, n);
  }
}
#!queue	A051241	0	->	1	A000595	--------------------------------
package irvine.oeis.a051;

import irvine.math.IntegerUtils;
import irvine.oeis.a000.A000595;

/**
 * A051241 Number of relations with 5 arguments on n nodes.
 * @author Sean A. Irvine
 */
public class A051241 extends A000595 {

  {
    super.next();
  }

  @Override
  protected int t(final int[] s) {
    int sum = 0;
    for (int i = 1; i < s.length; ++i) {
      for (int j = 1; j < s.length; ++j) {
        final int ij = i * j;
        final int lij = IntegerUtils.lcm(i, j);
        for (int k = 1; k < s.length; ++k) {
          final int ijk = ij * k;
          final int lijk = IntegerUtils.lcm(lij, k);
          for (int l = 1; l < s.length; ++l) {
            final int ijkl = ijk * l;
            final int lijkl = IntegerUtils.lcm(lijk, l);
            for (int m = 1; m < s.length; ++m) {
              final int lcm = IntegerUtils.lcm(lijkl, m);
              sum += (ijkl * m / lcm) * s[i] * s[j] * s[k] * s[l] * s[m];
            }
          }
        }
      }
    }
    return sum;
  }
}
#!queue	A051259	0	->	1	A051258	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051259 Every 25th Fibocyclotomic number.
 * @author Sean A. Irvine
 */
public class A051259 extends A051258 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    for (int k = 0; k < 24; ++k) {
      super.next();
    }
    return super.next();
  }
}
#!queue	A051548	1	->	0	A000005	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a000.A000005;

/**
 * A051548 a(n) = LCM { tau(1), ..., tau(n) }, a(0) = 1.
 * @author Sean A. Irvine
 */
public class A051548 extends A000005 {

  private Z mLcm = null;

  @Override
  public Z next() {
    mLcm = mLcm == null ? Z.ONE : mLcm.lcm(super.next());
    return mLcm;
  }
}
#!queue	A051549	1	->	0	A000203	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A051549 a(n) = LCM { sigma(1), ..., sigma(n) }.
 * @author Sean A. Irvine
 */
public class A051549 extends A000203 {

  private Z mLcm = Z.ONE;

  @Override
  public Z next() {
    mLcm = mLcm.lcm(super.next());
    return mLcm;
  }
}
#!queue	A051640	0	->	2	A000244	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a000.A000244;

/**
 * A051640 a(n) contains the digit b-1 in all bases b from 2 to n.
 * @author Sean A. Irvine
 */
public class A051640 extends A000244 {

  private long mN = 1;
  private long mM = 1;

  private boolean isOk(final long n, final long b) {
    long m = n;
    while (m != 0) {
      if (m % b == b - 1) {
        return true;
      }
      m /= b;
    }
    return false;
  }

  private boolean is(final long n, final long b) {
    for (long k = b; k >= 2; --k) {
      if (!isOk(n, k)) {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    ++mN;
    while (!is(mM, mN)) {
      ++mM;
    }
    return Z.valueOf(mM);
  }
}
#!queue	A051642	1	->	0	A001097	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a001.A001097;

/**
 * A051642 Values of A (the short leg) of a Pythagorean triangle with A and C (the hypotenuse) both prime and part of a twin prime.
 * @author Sean A. Irvine
 */
public class A051642 extends A001097 {

  @Override
  public Z next() {
    while (true) {
      final Z a = super.next();
      final Z u = a.add(1).divide2();
      final Z c = u.square().multiply(2).subtract(u.multiply(2)).add(1);
      if (c.isProbablePrime() && (c.add(2).isProbablePrime() || c.subtract(2).isProbablePrime())) {
        final Z b = u.multiply(2).multiply(u.subtract(1));
        if (a.square().add(b.square()).equals(c.square())) {
          return a;
        }
      }
    }
  }
}
#!queue	A051643	1	->	0	A047812	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a047.A047812;

/**
 * A051643 Central elements in Parker's partition triangle.
 * @author Sean A. Irvine
 */
public class A051643 extends A047812 {

  private int mN = -1;

  @Override
  public Z next() {
    mN += 2;
    return get(mN).coeff(mN * mN / 2);
  }
}
#!queue	A051677	0	->	1	A000332	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000292;
import irvine.oeis.a000.A000332;

/**
 * A051677 Tetrahedron-tree numbers: a(n)=sum(b(m),m=1..n), b(m)=1, 1,3, 1,3,6, 1,3,6,10,..., 1,2,...,i*(i+1)2.
 * @author Sean A. Irvine
 */
public class A051677 extends A000332 {

  private final MemorySequence mA = MemorySequence.cachedSequence(new A000292());
  {
    super.next();
    super.next();
    super.next();
  }
  private Z mT = super.next();
  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      mT = super.next();
      mM = 0;
      ++mN;
    }
    return mT.add(mA.a(mM));
  }
}
#!queue	A051678	0	->	1	A002415	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000330;
import irvine.oeis.a002.A002415;

/**
 * A051678 Square-pyramid-tree numbers: a(n) = sum(b(m),m=1..n), b(m) = 1^2, 1^2,2^2, 1^2,2^2,3^2,.. = (A002260)^2.
 * @author Sean A. Irvine
 */
public class A051678 extends A002415 {

  private final MemorySequence mA = MemorySequence.cachedSequence(new A000330());
  {
    super.next();
  }
  private Z mT = super.next();
  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      mT = super.next();
      mM = 0;
      ++mN;
    }
    return mT.add(mA.a(mM));
  }
}
#!queue	A051684	0	->	1	A001464	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a001.A001464;

/**
 * A051684 Auxiliary sequence for calculation of number of even permutations of degree n and order exactly 2.
 * @author Sean A. Irvine
 */
public class A051684 extends A001464 {

  {
    super.next();
  }
  private boolean mSign = true;

  @Override
  public Z next() {
    mSign = !mSign;
    return Z.NEG_ONE.signedAdd(mSign, super.next());
  }
}
#!queue	A051754	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051754 Consider problem of placing N queens on an n X n board so that each queen attacks precisely 1 other. Sequence gives maximal number of queens.
 * @author Sean A. Irvine
 */
public class A051754 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    solve(++mN, 1);
    return Z.valueOf(mMaximalQueens);
  }
}
#!queue	A051756	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051756 Consider the problem of placing N queens on an n X n board so that each queen attacks precisely 3 others. Sequence gives maximal number of queens.
 * @author Sean A. Irvine
 */
public class A051756 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    solve(++mN, 3);
    return Z.valueOf(mMaximalQueens);
  }
}
#!queue	A051757	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051757 Consider problem of placing A051754(n) queens on an n X n board so that each queen attacks precisely 1 other. Sequence gives number of solutions up to square symmetry.
 * @author Sean A. Irvine
 */
public class A051757 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    return Z.valueOf(solve(++mN, 1));
  }
}
#!queue	A051758	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051758 Consider problem of placing A051755(n) queens on an n X n board so that each queen attacks precisely 2 others. Sequence gives number of solutions up to square symmetry.
 * @author Sean A. Irvine
 */
public class A051758 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    return Z.valueOf(solve(++mN, 2));
  }
}
#!queue	A051759	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051759 Consider the problem of placing A051756(n) queens on an n X n board so that each queen attacks precisely 3 others. Sequence gives number of solutions up to square symmetry.
 * @author Sean A. Irvine
 */
public class A051759 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    return Z.valueOf(solve(++mN, 3));
  }
}
#!queue	A051776	0	->	1	A051775	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051776 Table T(n,m) = Nim-product of n and m, read by antidiagonals, for n &gt;= 1, m &gt;= 1.
 * @author Sean A. Irvine
 */
public class A051776 extends A051775 {

  private Z mN = Z.ONE;
  private Z mM = Z.ZERO;

  @Override
  public Z next() {
    mM = mM.subtract(1);
    if (mM.signum() <= 0) {
      mM = mN;
      mN = mN.add(1);
    }
    return get(mN.subtract(mM), mM);
  }
}
#!queue	A051841	0	->	1	A001037	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000048;
import irvine.oeis.a001.A001037;

/**
 * A051841 Number of binary Lyndon words with an even number of 1's.
 * @author Sean A. Irvine
 */
public class A051841 extends A001037 {

  private final Sequence mA = new A000048();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A051906	0	->	1	A007705	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a007.A007705;

/**
 * A051906 Number of ways of placing n nonattacking queens on an n X n toroidal chessboard.
 * @author Sean A. Irvine
 */
public class A051906 extends A007705 {

  private boolean mEven = false;

  @Override
  public Z next() {
    mEven = !mEven;
    return mEven ? super.next() : Z.ZERO;
  }
}
#!queue	A051911	0	->	1	A051775	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051911 Triangle T(n,m) = Nim-product of n and m, read by rows, 1&lt;=n&lt;=m.
 * @author Sean A. Irvine
 */
public class A051911 extends A051775 {

  private Z mN = Z.ZERO;
  private Z mM = Z.ZERO;

  @Override
  public Z next() {
    mM = mM.add(1);
    if (mM.compareTo(mN) > 0) {
      mN = mN.add(1);
      mM = Z.ONE;
    }
    return get(mN, mM);
  }
}
#!queue	A051917	0	->	1	A051775	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051917 Inverse of n under Nim (or Conway) multiplication.
 * @author Sean A. Irvine
 */
public class A051917 extends A051775 {

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    Z m = Z.ZERO;
    while (true) {
      m = m.add(1);
      if (Z.ONE.equals(get(mN, m))) {
        return m;
      }
    }
  }
}
#!queue	A052001	0	->	1	A000041	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A052001 Even partition numbers.
 * @author Sean A. Irvine
 */
public class A052001 extends A000041 {

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.isEven()) {
        return p;
      }
    }
  }
}
#!queue	A052002	0	->	1	A000041	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A052002 Numbers with an odd number of partitions.
 * @author Sean A. Irvine
 */
public class A052002 extends A000041 {

  @Override
  public Z next() {
    while (super.next().isEven()) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A052003	0	->	1	A000041	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A052003 Odd partition numbers.
 * @author Sean A. Irvine
 */
public class A052003 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.isOdd()) {
        return p;
      }
    }
  }
}
#!queue	A052048	1	->	0	A052047	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;

/**
 * A052048 Cubes whose digits occur with the same frequency.
 * @author Sean A. Irvine
 */
public class A052048 extends A052047 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}

#!queue	A052062	1	->	0	A052061	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;

/**
 * A052062 Squares containing no palindromic substring except single digits.
 * @author Sean A. Irvine
 */
public class A052062 extends A052061 {

  @Override
  public Z next() {
    return super.next().square();
  }
}

#!queue	A052186	1	->	0	A006932	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a006.A006932;

/**
 * A052186 Number of permutations of [n] with no strong fixed points.
 * @author Sean A. Irvine
 */
public class A052186 extends A006932 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    final Z t = super.next();
    return mF.subtract(t);
  }
}

#!queue	A052246	1	->	0	A000422	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a000.A000422;

/**
 * A052246 Concatenation of integers from n down to 0.
 * @author Sean A. Irvine
 */
public class A052246 extends A000422 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().multiply(10);
  }
}

#!queue	A052265	1	->	0	A052107	--------------------------------
package irvine.oeis.a052;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.IntegerUtils;
import irvine.math.Mobius;
import irvine.math.group.PolynomialRing;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A052265 Triangle giving T(n,r) = number of equivalence classes of Boolean functions of n variables and range r=0..2^n under action of symmetric group.
 * @author Sean A. Irvine
 */
public class A052265 extends A052107 {

  // After Andrew Howroyd

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = 0;
  private int mM = -1;
  private Z mF = Z.ONE;
  private Polynomial<Z> mRow = RING.onePlusXToTheN(1);

  private Polynomial<Z> fix(final int[] q) {
    final Z lcm = IntegerUtils.lcm(q);
    final ArrayList<Z> u = new ArrayList<>();
    final Z[] v = Jaguar.factor(lcm).divisors();
    for (final Z d : v) {
      int w = 0;
      for (final int j : q) {
        final int g = IntegerUtils.gcd(d.intValueExact(), j);
        w += g;
      }
      u.add(Z.ONE.shiftLeft(w));
    }
    Polynomial<Z> prod = RING.one();
    for (int i = 0; i < v.length; ++i) {
      final int t = v[i].intValue();
      int sum = 0;
      for (int j = 0; j <= i; ++j) {
        if (v[i].mod(v[j]).isZero()) {
          final int d = v[i].divide(v[j]).intValueExact();
          final int mu = Mobius.mobius(d);
          sum += mu * u.get(j).intValueExact();
        }
      }
      prod = RING.multiply(prod, RING.pow(RING.onePlusXToTheN(t), sum / t));
    }
    return prod;
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      if (++mN > 1) {
        mF = mF.multiply(mN);
      }
      mM = 0;
      mRow = RING.zero();
      final IntegerPartition part = new IntegerPartition(mN);
      int[] p;
      while ((p = part.next()) != null) {
        mRow = RING.add(mRow, RING.multiply(fix(p), IntegerPartition.permCount(p, 1)));
      }
    }
    return mRow.coeff(mM).divide(mF);
  }
}
#!queue	A052283	1	->	0	A052107	--------------------------------
package irvine.oeis.a052;

import irvine.math.IntegerUtils;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A052283 Triangle read by rows: T(n,k) is the number of unlabeled directed graphs on n nodes with k arcs, k=0..n*(n-1).
 * @author Sean A. Irvine
 */
public class A052283 extends A052107 {

  // After Andrew Howroyd

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private Polynomial<Z> mRow = RING.zero();
  protected int mK = -1;
  protected int mM = 0;

  private Polynomial<Z> edgesPoly(final int[] v) {
    Polynomial<Z> prod = RING.one();
    for (int i = 1; i < v.length; ++i) {
      for (int j = 0; j < i; ++j) {
        final int g = IntegerUtils.gcd(v[i], v[j]);
        prod = RING.multiply(prod, RING.pow(RING.onePlusXToTheN(v[i] * v[j] / g), 2L * g));
      }
    }
    for (final int j : v) {
      prod = RING.multiply(prod, RING.pow(RING.onePlusXToTheN(j), j - 1));
    }
    return prod;
  }

  protected Polynomial<Z> g(final int n) {
    Polynomial<Z> row = RING.zero();
    final IntegerPartition part = new IntegerPartition(n);
    int[] p;
    while ((p = part.next()) != null) {
      row = RING.add(row, RING.multiply(edgesPoly(p), IntegerPartition.permCount(p, 1)));
    }
    return RING.divide(row, mF.factorial(n));
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      if (++mK <= 1) {
        return Z.ONE;
      }
      mRow = g(mK);
      mM = 0;
    }
    return mRow.coeff(mM);
  }
}
#!queue	A052317	1	->	0	A052316	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A052317 Number of labeled trees with n nodes and 2-colored internal (non-leaf) nodes.
 * @author Sean A. Irvine
 */
public class A052317 extends A052316 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mB = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Q.ZERO);
      return Z.ONE;
    }
    mF = mF.multiply(mN);
    mB.add(new Q(super.next(), mF));
    final Q t = mB.get(mN).subtract(mB.get(mN - 1)).subtract(RING.pow(mB, 2, mN).coeff(mN).divide(2));
    return t.multiply(mF).toZ();
  }
}

#!queue	A052319	0	->	1	A006882	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A052319 Number of increasing rooted trimmed trees with n nodes.
 * @author Sean A. Irvine
 */
public class A052319 extends A006882 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> NEG_X = RING.negate(RING.x());
  private final Polynomial<Q> mBPrime = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN > 0) {
      mBPrime.add(new Q(super.next(), mF));
      mF = mF.multiply(mN);
    }
    final Polynomial<Q> b = RING.add(RING.one(), RING.integrate(mBPrime));
    return RING.coeff(RING.one(), RING.substitute(b, NEG_X, mN), mN).multiply(mF).toZ();
  }
}
#!queue	A052371	1	->	0	A052107	--------------------------------
package irvine.oeis.a052;

import irvine.math.IntegerUtils;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A052371 Triangle T(n,k) of n X n binary matrices with k=0...n^2 ones up to row and column permutations.
 * @author Sean A. Irvine
 */
public class A052371 extends A052107 {

  // After Andrew Howroyd

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private Polynomial<Q> mRow = RING.zero();
  private int mN = -1;
  private int mM = 0;

  private Polynomial<Q> c(final int[] p, final int[] q) {
    Polynomial<Q> prod = RING.one();
    for (final int j : q) {
      for (final int i : p) {
        final Polynomial<Q> f = RING.pow(RING.onePlusXToTheN(IntegerUtils.lcm(i, j)), IntegerUtils.gcd(i, j));
        prod = RING.multiply(prod, f);
      }
    }
    return prod;
  }

  /*
  c(p, q)={prod(i=1, #p, prod(j=1, #q, (1 + x^lcm(p[i], q[j]))^gcd(p[i], q[j])))}

row(n)={my(s=0); forpart(p=n, forpart(q=n, s+=permcount(p) * permcount(q) * c(p, q))); Vec(s/(n!^2))}

for(n=1, 5, print(row(n)))
   */

  protected Polynomial<Q> row(final int n) {
    Polynomial<Q> sum = RING.zero();
    final IntegerPartition part = new IntegerPartition(n);
    int[] q;
    while ((q = part.next()) != null) {
      final Z pcq = IntegerPartition.permCount(q, 1);
      final IntegerPartition part2 = new IntegerPartition(n);
      int[] p;
      while ((p = part2.next()) != null) {
        sum = RING.add(sum, RING.multiply(c(p, q), new Q(IntegerPartition.permCount(p, 1).multiply(pcq))));
      }
    }
    return RING.multiply(sum, new Q(Z.ONE, mF.factorial(n).square()));
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      if (++mN == 0) {
        return Z.ONE;
      }
      mRow = row(mN);
      mM = 0;
    }
    return mRow.coeff(mM).toZ();
  }
}
#!queue	A052434	1	->	2	A000720	--------------------------------
package irvine.oeis.a052;

import irvine.math.Mobius;
import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A052434 Nearest integer to R(n) - pi(n), where R(x) is the Riemann prime counting function.
 * @author Sean A. Irvine
 */
public class A052434 extends A000720 {

  // This is slow ... and heuristic ...

  private static final long HEURISTIC_TERMS = 10000;

  private long mN = 1;
  {
    super.next();
  }

  protected CR riemann(final long n) {
    return new CR() {
      @Override
      protected Z approximate(final int precision) {
        final CR ncr = CR.valueOf(n);
        Z sum = Z.ZERO;
        long k = 0;
        while (true) {
          final CR kcr = CR.valueOf(++k);
          final Z t = ncr.pow(kcr.inverse()).li().divide(kcr).getApprox(precision);
          if (t.isZero() || k > HEURISTIC_TERMS) {
            break;
          }
          final int mobius = Mobius.mobius(k);
          if (mobius != 0) {
            sum = sum.signedAdd(mobius == 1, t);
          }
        }
        return sum;
      }
    };
  }

  @Override
  public Z next() {
    final CR r = riemann(++mN);
    //System.out.println(mN + " R=" + r);
    return r.subtract(CR.valueOf(super.next())).round();
  }
}
#!queue	A052435	1	->	2	A000720	--------------------------------
package irvine.oeis.a052;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A052435 a(n) = round(li(n) - pi(n)), where li is the logarithmic integral and pi(x) is the number of primes &lt;= x.
 * @author Sean A. Irvine
 */
public class A052435 extends A000720 {

  private long mN = 1;
  {
    super.next();
  }

  @Override
  public Z next() {
    return CR.valueOf(++mN).li().subtract(CR.valueOf(super.next())).round();
  }
}
#!queue	A052480	1	->	0	A002385	--------------------------------
package irvine.oeis.a052;

import java.util.ArrayList;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002385;
import irvine.util.Permutation;

/**
 * A052480 Primes associated with A052507.
 * @author Sean A. Irvine
 */
public class A052480 extends A002385 {

  private final ArrayList<Z> mA = new ArrayList<>();
  private int mM = 0;

  private Permutation permuter(final Z prime) {
    final int[] cnts = ZUtils.digitCounts(prime);
    final int sum = (int) IntegerUtils.sum(cnts);
    final int[] digits = new int[sum];
    for (int k = 0, i = 0; k < cnts.length; ++k) {
      for (int j = 0; j < cnts[k]; ++j) {
        digits[i++] = k;
      }
    }
    return new Permutation(digits);
  }

  private Z permToZ(final int[] p) {
    Z t = Z.ZERO;
    for (int v : p) {
      t = t.multiply(10).add(v);
    }
    return t;
  }

  @Override
  public Z next() {
    if (++mM >= mA.size()) {
      mA.clear();
      mM = 0;
      final Z palin = super.next();
      final Permutation perm = permuter(palin);
      int[] p;
      while ((p = perm.next()) != null) {
        if (p[0] != 0) {
          final Z t = permToZ(p);
          if (t.isProbablePrime()) {
            mA.add(t);
          }
        }
      }
    }
    return mA.get(mM);
  }
}
#!queue	A052779	6	->	0	A001233	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a001.A001233;

/**
 * A052779 Expansion of e.g.f.: (log(1-x))^6.
 * @author Sean A. Irvine
 */
public class A052779 extends A001233 {

  private long mN = -1;

  @Override
  public Z next() {
    return ++mN < 6 ? Z.ZERO : super.next().multiply(720);
  }
}
#!queue	A052853	1	->	0	A050383	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a050.A050383;

/**
 * A052853 A simple grammar.
 * @author Sean A. Irvine
 */
public class A052853 extends A050383 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mC = RING.empty();
  {
    mC.add(Q.ZERO);
  }

  @Override
  public Z next() {
    mC.add(new Q(super.next().negate()));
    Q sum = Q.ZERO;
    for (int j = 1; j <= mN; ++j) {
      sum = sum.add(RING.log1p(mC.substitutePower(j, mN), mN).coeff(mN).multiply(new Q(Euler.phiAsLong(j), j)));
    }
    return sum.negate().toZ();
  }
}
#!queue	A052894	1	->	0	A053492	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a053.A053492;

/**
 * A052894 a(n) is the number of Schr\u00f6der trees on n vertices with a prescribed root.
 * @author Sean A. Irvine
 */
public class A052894 extends A053492 {

  @Override
  public Z next() {
    return super.next().divide(mN);
  }
}
#!queue	A053015	1	->	0	A089210	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a089.A089210;

/**
 * A053015 A089210 prefixed by an initial zero.
 * @author Georg Fischer
 */
public class A053015 extends A089210 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return mN == 0 ? Z.ZERO : super.next();
  }
}
#!queue	A053021	0	->	1	A027423	--------------------------------
package irvine.oeis.a053;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a027.A027423;

/**
 * A053021 Number of divisors function applied twice to n!.
 * @author Sean A. Irvine
 */
public class A053021 extends A027423 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A053058	0	->	1	A000578	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A053058 Cubes whose digit sum is also a cube.
 * @author Sean A. Irvine
 */
public class A053058 extends A000578 {

  @Override
  public Z next() {
    while (true) {
      final Z cube = super.next();
      final long d = ZUtils.digitSum(cube);
      if (ZUtils.isCube(Z.valueOf(d))) {
        return cube;
      }
    }
  }
}
#!queue	A053286	0	->	1	A000051	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000051;

/**
 * A053286 Cototient of 2^n +1.
 * @author Sean A. Irvine
 */
public class A053286 extends A000051 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return n.subtract(Euler.phi(n));
  }
}

#!queue	A053287	0	->	1	A000225	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A053287 Euler totient function (A000010) of 2^n - 1.
 * @author Sean A. Irvine
 */
public class A053287 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}

#!queue	A053288	0	->	1	A000225	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A053288 Cototient of 2^n - 1.
 * @author Sean A. Irvine
 */
public class A053288 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return n.subtract(Euler.phi(n));
  }
}

#!queue	A053299	0	->	1	A000230	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A053299 First n-digit prime to begin a gap.
 * @author Sean A. Irvine
 */
public class A053299 extends A000230 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply(10);
    while (true) {
      final Z p = super.next();
      if (p.compareTo(mA) > 0) {
        return p;
      }
    }
  }
}

#!queue	A053371	1	->	0	A039956	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039956;

/**
 * A053371 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of x for n == 2 mod 4.
 * @author Sean A. Irvine
 */
public class A053371 extends A039956 {

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[0].divide2();
  }
}
#!queue	A053372	1	->	0	A039957	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039957;

/**
 * A053372 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of x for n == 3 mod 4.
 * @author Sean A. Irvine
 */
public class A053372 extends A039957 {

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[0].divide2();
  }
}
#!queue	A053374	1	->	0	A039956	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039956;

/**
 * A053374 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of y for n == 2 mod 4.
 * @author Sean A. Irvine
 */
public class A053374 extends A039956 {

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[1].divide2();
  }
}
#!queue	A053375	1	->	0	A039957	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039957;

/**
 * A053375 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of y for n == 3 mod 4.
 * @author Sean A. Irvine
 */
public class A053375 extends A039957 {

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[1].divide2();
  }
}
#!queue	A053512	1	->	2	A007764	--------------------------------
package irvine.oeis.a053;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a007.A007764;

/**
 * A053512 Half the number of non-self-intersecting paths from one corner of an n X n grid to the opposite corner.
 * @author Georg Fischer
 */
public class A053512 extends A007764 {

  protected int mN;
  
  /** Construct the sequence. */
  public A053512() {
    mN = 1;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A053551	0	->	1	A053549	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A053551 REVEGF transform of [1,2,12,152,3640,...] (A053549).
 * @author Sean A. Irvine
 */
public class A053551 extends A053549 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mA = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;
  private boolean mSign = true;
  {
    mA.add(new Q(super.next()));
    next();
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mA.add(new Q(super.next(), mF));
    final Z t = RING.reversion(mA, mN).coeff(mN).multiply(mF).toZ();
    mSign = !mSign;
    return mSign ? t : t.negate();
  }
}
#!queue	A053552	0	->	1	A053549	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A053552 E.g.f. is obtained by reversion of e.g.f. for A053549.
 * @author Sean A. Irvine
 */
public class A053552 extends A053549 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mA = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;
  {
    next();
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mA.add(new Q(super.next(), mF));
    return RING.reversion(mA, mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A053615	1	->	0	A004738	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a004.A004738;

/**
 * A053615 Pyramidal sequence: distance to nearest product of two consecutive integers (promic or heteromecic numbers).
 * @author Sean A. Irvine
 */
public class A053615 extends A004738 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A053622	1	->	2	A000720	--------------------------------
package irvine.oeis.a053;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A053622 a(n) = round( n/log(n) - pi(n) ).
 * @author Sean A. Irvine
 */
public class A053622 extends A000720 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z pi = super.next();
    final CR n = CR.valueOf(mN);
    return n.divide(n.log()).round().subtract(pi);
  }
}
#!queue	A053630	0	->	1	A000058	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a000.A000058;

/**
 * A053630 Pythagorean spiral: a(n-1), a(n)-1 and a(n) are sides of a right triangle.
 * @author Sean A. Irvine
 */
public class A053630 extends A000058 {

  @Override
  public Z next() {
    return super.next().multiply2().subtract(1);
  }
}
#!queue	A053634	0	->	3	A000031	--------------------------------
package irvine.oeis.a053;
// Generated by gen_seq4.pl seqop a000 A000031 divide2() 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000031;

/**
 * A053634 a(n) = Sum_{ d divides n } phi(d)*2^(n/d)/(2n).
 * @author Georg Fischer
 */
public class A053634 extends A000031 {
  private int mN = 3 - 1;
  
  /** Construct the sequence. */
  public A053634() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A053656	0	->	1	A000031	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a000.A000031;

/**
 * A053656 Number of cyclic graphs with oriented edges on n nodes (up to symmetry of dihedral group).
 * @author Sean A. Irvine
 */
public class A053656 extends A000031 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return ((mN & 1) == 0 ? t.add(Z.ONE.shiftLeft(mN / 2 - 1)) : t).divide2();
  }
}
#!queue	A053657	0	->	1	A001898	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a001.A001898;

/**
 * A053657 a(n) = Product_{p prime} p^{ Sum_{k&gt;=0} floor[(n-1)/((p-1)p^k)]}.
 * @author Sean A. Irvine
 */
public class A053657 extends A001898 {

  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (mN > 0) {
      mF = mF.multiply(mN + 1);
    }
    return super.next().multiply(mF);
  }
}
#!queue	A053701	0	->	1	A005900	--------------------------------
package irvine.oeis.a053;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a005.A005900;

/**
 * A053701 Vertically symmetric numbers.
 * @author Sean A. Irvine
 */
public class A053701 extends A005900 {

  private static final char[] DIGITS = {'0', '1', '2', '5', '8'};
  private final TreeSet<Z> mA = new TreeSet<>();
  private int mLength = -1; // Length of half the number!
  private long mLimit = 1;

  private StringBuilder reverseSpecial(final CharSequence s) {
    final StringBuilder sb = new StringBuilder();
    for (int k = s.length() - 1; k >= 0; --k) {
      final char c = s.charAt(k);
      switch (c) {
        case '2':
          sb.append('5');
          break;
        case '5':
          sb.append('2');
          break;
        default:
          sb.append(c);
          break;
      }
    }
    return sb;
  }

  @Override
  public Z next() {
    if (mA.isEmpty()) {
      if (++mLength == 0) {
        mA.add(Z.ONE);
        mA.add(Z.EIGHT);
        return Z.ZERO;
      }
      final long start = mLimit;
      mLimit *= DIGITS.length;
      for (long k = start; k < mLimit; ++k) {
        final StringBuilder sb = new StringBuilder();
        long m = k;
        for (int j = 0; j < mLength; ++j) {
          sb.append(DIGITS[(int) m % DIGITS.length]);
          m /= DIGITS.length;
        }
        final String rev = reverseSpecial(sb).toString();
        mA.add(new Z(rev + sb)); // even length
        mA.add(new Z(rev + '0' + sb)); // odd length
        mA.add(new Z(rev + '1' + sb)); // odd length
        mA.add(new Z(rev + '8' + sb)); // odd length
      }
    }
    return mA.pollFirst();
  }
}
#!queue	A053734	0	->	1	A000016	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000016;
import irvine.oeis.a000.A000048;

/**
 * A053734 A000016-A000048 (when they are lined up so that the two 16's match).
 * @author Sean A. Irvine
 */
public class A053734 extends A000016 {

  private final Sequence mA = new A000048();
  {
    next(); // skip 0th
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A053785	0	->	1	A000583	--------------------------------
package irvine.oeis.a053;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000583;

/**
 * A053785 Nextprime(n^4) - n^4.
 * @author Sean A. Irvine
 */
public class A053785 extends A000583 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n4 = super.next();
    return mPrime.nextPrime(n4).subtract(n4);
  }
}
#!queue	A053786	0	->	1	A000583	--------------------------------
package irvine.oeis.a053;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000583;

/**
 * A053786 a(n) = next prime after n^4.
 * @author Sean A. Irvine
 */
public class A053786 extends A000583 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mPrime.nextPrime(super.next());
  }
}
#!queue	A053787	0	->	1	A000584	--------------------------------
package irvine.oeis.a053;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000584;

/**
 * A053787 Nextprime(n^5) - n^5.
 * @author Sean A. Irvine
 */
public class A053787 extends A000584 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n5 = super.next();
    return mPrime.nextPrime(n5).subtract(n5);
  }
}
#!queue	A053788	0	->	1	A000584	--------------------------------
package irvine.oeis.a053;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000584;

/**
 * A053788 Next prime after n^5.
 * @author Sean A. Irvine
 */
public class A053788 extends A000584 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mPrime.nextPrime(super.next());
  }
}
#!queue	A054012	2	->	1	A054009	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;

/**
 * A054012 Nonzero values of n read modulo (number of proper divisors of n).
 * @author Sean A. Irvine
 */
public class A054012 extends A054009 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (!t.isZero()) {
        return t;
      }
    }
  }
}
#!queue	A054112	0	->	3	A054110	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;

/**
 * A054112 T(n,n-3), array T as in A054110.
 * @author Sean A. Irvine
 */
public class A054112 extends A054110 {

  private long mN = 2;

  @Override
  public Z next() {
    return t(++mN, mN - 3);
  }
}
#!queue	A054348	1	->	0	A042942	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a042.A042942;

/**
 * A054348 Triangular array whose rows are successive generations of the variant of the Kolakoski sequence described in A042942.
 * @author Sean A. Irvine
 */
public class A054348 extends A042942 {

  private long mM = 0;

  @Override
  public Z next() {
    if (++mM == mLimit) {
      super.next();
      mM = 0;
    }
    return ((mSeq.get(mM >>> 5) >>> (mM & 0x1F)) & 1) == 0 ? Z.ONE : Z.TWO;
  }
}
#!queue	A054349	1	->	0	A042942	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a042.A042942;

/**
 * A054349 Successive generations of the variant of the Kolakoski sequence described in A042942.
 * @author Sean A. Irvine
 */
public class A054349 extends A042942 {

  @Override
  public Z next() {
    super.next();
    final StringBuilder sb = new StringBuilder();
    for (long k = 0; k < mLimit; ++k) {
      sb.append(((mSeq.get(k >>> 5) >>> (k & 0x1F)) & 1) == 0 ? '1' : '2');
    }
    return new Z(sb);
  }
}
#!queue	A054503	1	->	0	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054503 Table T(n,k) giving log_b(k), 1&lt;=k&lt;=p, where p = n-th prime and b = smallest primitive root of p (A001918).
 * @author Sean A. Irvine
 */
public class A054503 extends A001918 {

  private Z mB = null;
  private Z mM = Z.ZERO;

  @Override
  public Z next() {
    mM = mM.add(1);
    if (mM.compareTo(mP) >= 0) {
      mB = super.next();
      mM = Z.ONE;
    }
    long lg = 0;
    Z t = Z.ONE;
    while (!t.equals(mM)) {
      t = t.modMultiply(mB, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054505	1	->	2	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054505 Log_b 2 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054505 extends A001918 {

  {
    super.next(); // skip 2
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.TWO.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054506	1	->	3	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054506 Log_b 3 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054506 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.THREE.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054507	1	->	3	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054507 Log_b 4 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054507 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.FOUR.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054508	1	->	4	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054508 Log_b 5 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054508 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.FIVE.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054509	1	->	4	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054509 Log_b 6 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054509 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.SIX.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054510	1	->	5	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054510 Log_b 7 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054510 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
    super.next(); // skip 7
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.SEVEN.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054511	1	->	5	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054511 Log_b 8 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054511 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
    super.next(); // skip 7
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.EIGHT.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054512	1	->	5	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054512 Log_b 9 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054512 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
    super.next(); // skip 7
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.NINE.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054513	1	->	5	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054513 Log_b 10 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054513 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
    super.next(); // skip 7
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.TEN.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054538	0	->	1	A000013	--------------------------------
package irvine.oeis.a054;
// manually dersimpln at 2021-09-27 18:28

import irvine.math.z.Z;
import irvine.oeis.a000.A000013;

/**
 * A054538 A000013 / 2.
 * @author Georg Fischer
 */
public class A054538 extends A000013 {

  protected int mN;
  
  /** Construct the sequence */
  public A054538() {
    mN = 0;
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A054539	0	->	3	A000016	--------------------------------
package irvine.oeis.a054;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a000.A000016;

/**
 * A054539 A000016 / 2.
 * @author Georg Fischer
 */
public class A054539 extends A000016 {

  /** Construct the sequence. */
  public A054539() {
    super.next();
    super.next();
    super.next();
  }
  
  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A054565	0	->	1	A000244	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a000.A000244;

/**
 * A054565 Numbers n such that 3 is the first digit of 3^n.
 * @author Sean A. Irvine
 */
public class A054565 extends A000244 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().toString().startsWith("3")) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A054590	0	->	1	A000273	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000273;
import irvine.oeis.a003.A003085;

/**
 * A054590 Number of disconnected digraphs with n unlabeled nodes.
 * @author Sean A. Irvine
 */
public class A054590 extends A000273 {

  {
    super.next(); // skip 0th
  }
  private final Sequence mA = new A003085();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A054660	0	->	1	A000048	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a000.A000048;

/**
 * A054660 Number of monic irreducible polynomials over GF(4) of degree n with fixed nonzero trace.
 * @author Sean A. Irvine
 */
public class A054660 extends A000048 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A054738	1	->	0	A054737	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;

/**
 * A054738 Squares which can be split into two nonzero squares (perhaps with leading zeros) in exactly two different ways.
 * @author Sean A. Irvine
 */
public class A054738 extends A054737 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A054760	1	->	0	A198300	--------------------------------
package irvine.oeis.a054;

import irvine.math.graph.Graph;
import irvine.math.nauty.GenerateGraphs;
import irvine.math.nauty.GraphProcessor;
import irvine.math.z.Z;
import irvine.oeis.a198.A198300;
import irvine.util.string.StringUtils;

/**
 * A054760 Table T(n,k) = order of (n,k)-cage (smallest n-regular graph of girth k), n &gt;= 2, k &gt;= 3, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A054760 extends A198300 implements GraphProcessor {

  private static class FoundItException extends RuntimeException { }
  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));

  @Override
  public void process(final Graph graph) {
    if (graph.girth() >= mM + 3) {
      throw new FoundItException(); // Abort any further computation we found the solution
    }
  }

  @Override
  public Z next() {
    int n = super.next().intValueExact();
    while (true) {
      final int degree = mN + 1 - mM;
      if (mVerbose) {
        StringUtils.message("Trying " + n + " vertices with degree " + degree + " and target girth " + (mM + 3));
      }
      final GenerateGraphs gg = new GenerateGraphs(0);
      gg.setProcessor(this);
      gg.setVertices(n);
      gg.setMinDeg(degree);
      gg.setMaxDeg(degree);
      gg.setMinEdges(0);
      gg.setMaxEdges(Integer.MAX_VALUE);
      gg.setConnectionLevel(1);
      gg.sanitizeParams();
      try {
        gg.run(false, mM > 2, mM > 1, 0, 0);
      } catch (final FoundItException e) {
        return Z.valueOf(n);
      }
      ++n;
    }
  }

}
#!queue	A054935	0	->	1	A006384	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a006.A006384;
import irvine.oeis.a006.A006849;

/**
 * A054935 Number of planar maps with n edges up to orientation-preserving duality.
 * @author Sean A. Irvine
 */
public class A054935 extends A006384 {

  private final A006849 mSeq = new A006849();
  private boolean mAlt = true;

  {
    super.next();
  }

  @Override
  public Z next() {
    mAlt = !mAlt;
    return super.next().add(mAlt ? mSeq.next() : Z.ZERO).divide2();
  }
}
#!queue	A054936	0	->	1	A006385	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006384;
import irvine.oeis.a006.A006385;

/**
 * A054936 Number of achiral planar maps on n nodes up to orientation-preserving isomorphisms.
 * @author Sean A. Irvine
 */
public class A054936 extends A006385 {

  private final Sequence mA = new A006384();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().multiply2().subtract(mA.next());
  }
}
#!queue	A054937	0	->	1	A006385	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006385;

/**
 * A054937 Number of chiral planar maps on n nodes up to orientation-preserving isomorphisms.
 * @author Sean A. Irvine
 */
public class A054937 extends A006385 {

  private final Sequence mA = new A054936();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A054948	1	->	0	A003030	--------------------------------
package irvine.oeis.a054;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a003.A003030;

/**
 * A054948 Number of labeled semi-strong digraphs on n nodes.
 * @author Sean A. Irvine
 */
public class A054948 extends A003030 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private Z mF = Z.ONE;
  private final Polynomial<Q> mA = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mA.add(mN == 0 ? Q.ZERO : new Q(super.next(), mF));
    return RING.exp(mA, mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A054970	0	->	1	A000384	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a000.A000384;
import irvine.util.string.StringUtils;

/**
 * A054970 Index numbers for palindromic hexagonal numbers.
 * @author Sean A. Irvine
 */
public class A054970 extends A000384 {

  @Override
  public Z next() {
    while (true) {
      final Z hex = super.next();
      if (StringUtils.isPalindrome(hex.toString())) {
        return mN;
      }
    }
  }
}
#!queue	A054971	0	->	1	A000566	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a000.A000566;
import irvine.util.string.StringUtils;

/**
 * A054971 n(5n-3)/2 is a palindromic heptagonal number.
 * @author Sean A. Irvine
 */
public class A054971 extends A000566 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z hex = super.next();
      if (StringUtils.isPalindrome(hex.toString())) {
        return mN;
      }
    }
  }
}
#!queue	A054976	0	->	1	A002724	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002724;
import irvine.oeis.a002.A002725;

/**
 * A054976 Number of binary n X n matrices with no zero rows or columns, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A054976 extends A002724 {

  private final Sequence mA2725 = new A002725();
  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.add(t).subtract(mA2725.next().multiply2());
  }
}

#!queue	A054992	0	->	1	A000051	--------------------------------
package irvine.oeis.a054;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000051;

/**
 * A054992 Number of prime factors of 2^n + 1 (counted with multiplicity).
 * @author Sean A. Irvine
 */
public class A054992 extends A000051 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A055027	0	->	1	A055029	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055027 Number of inequivalent Gaussian primes of successive norms (indexed by A055025).
 * @author Sean A. Irvine
 */
public class A055027 extends A055029 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (!t.isZero()) {
        return t;
      }
    }
  }
}
#!queue	A055036	0	->	1	A000400	--------------------------------
package irvine.oeis.a055;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000400;

/**
 * A055036 Min[x] composite zero site for sigma(x+6^n) - sigma(x) - 6^n.
 * @author Sean A. Irvine
 */
public class A055036 extends A000400 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z f = super.next();
    Z k = Z.THREE;
    while (true) {
      k = k.add(1);
      if (!k.isProbablePrime() && Jaguar.factor(f.add(k)).sigma().equals(Jaguar.factor(k).sigma().add(f))) {
        return k;
      }
    }
  }
}
#!queue	A055097	2	->	1	A055096	--------------------------------
package irvine.oeis.a055;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A055097 Number of divisors for each term in the triangle A055096. It is 2 for primes (all of the form 4k+1).
 * @author Georg Fischer
 */
public class A055097 extends A055096 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A055106	1	->	2	A055105	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055106 Triangle T(n,k) giving number of symmetric polynomials of degree n in k noncommuting variables, n &gt;=2, 2 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A055106 extends A055105 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return t.isZero() ? super.next() : t;
  }
}
#!queue	A055132	2	->	1	A055096	--------------------------------
package irvine.oeis.a055;

import irvine.math.Mobius;
import irvine.math.z.Z;

/**
 * A055132 Moebius function (A008683) applied to each term in the triangle A055096.
 * @author Sean A. Irvine
 */
public class A055132 extends A055096 {

  @Override
  public Z next() {
    return Z.valueOf(Mobius.mobius(super.next().longValueExact()));
  }
}
#!queue	A055165	1	->	0	A000410	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000410;

/**
 * A055165 Number of invertible n X n matrices with entries equal to 0 or 1.
 * @author Sean A. Irvine
 */
public class A055165 extends A000410 {

  private Z mF = Z.ONE;
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    final Z t = super.next();
    mF = mF.multiply(mN);
    return Binomial.binomial((1L << mN) - 1, mN).subtract(t).multiply(mF);
  }
}
#!queue	A055166	1	->	0	A000043	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a000.A000043;

/**
 * A055166 Number of Mersenne prime exponents between 10^n and 10^(n+1).
 * @author Sean A. Irvine
 */
public class A055166 extends A000043 {

  private long mLimit = 1;

  @Override
  public Z next() {
    long cnt = mLimit == 1 ? 0 : 1;
    mLimit *= 10;
    while (super.next().longValueExact() < mLimit) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A055197	0	->	1	A005728	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a005.A005728;

/**
 * A055197 Numbers k such that A005728(k) is not prime.
 * @author Georg Fischer
 */
public class A055197 extends A005728 {

  private int mK = 0;

  /** Construct the sequence. */
  public A055197() {
    super.next();
  }

  @Override
  public Z next() {
    ++mK;
    while (super.next().isProbablePrime()) {
      ++mK;
    }
    return Z.valueOf(mK);
  }
}
#!queue	A055223	0	->	2	A000866	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000866;

/**
 * A055223 One-fourth the digital sum of base 5 representations of 2^n.
 * @author Sean A. Irvine
 */
public class A055223 extends A000866 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()) / 4);
  }
}
#!queue	A055290	1	->	2	A055277	--------------------------------
package irvine.oeis.a055;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A055290 Triangle of trees with n nodes and k leaves, 2 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A055290 extends A055277 {

  private static final Polynomial<Polynomial<Q>> CONS = RING_X.add(RING_X.subtract(RING_X.one(), RING_X.x()), XY);

  private Polynomial<Polynomial<Q>> mGF = super.gf(1);
  private int mDeg = 1;

  @Override
  protected Polynomial<Polynomial<Q>> gf(final int n) {
    if (n > mDeg) {
      final Polynomial<Polynomial<Q>> b = super.gf(n);
      final Polynomial<Polynomial<Q>> bSubs = doubleSubstitute(b, 2);
      final Polynomial<Polynomial<Q>> bSquare = RING_X.multiply(b, b, n);
      mGF = RING_X.add(RING_X.multiply(CONS, b),
        RING_X.multiply(RING_X.subtract(bSubs, bSquare), constant(Q.HALF)));
      mDeg = n;
    }
    return mGF;
  }

  private int mN = 1;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM > mN) {
      mM = 2;
      ++mN;
    }
    return gf(mN).coeff(mN).coeff(mM).toZ();
  }
}
#!queue	A055452	0	->	2	A055450	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055452 T(n,n-2), array T as in A055450.
 * @author Sean A. Irvine
 */
public class A055452 extends A055450 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN + 2, mN);
  }
}
#!queue	A055453	0	->	3	A055450	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055453 T(n,n-3), array T as in A055450.
 * @author Sean A. Irvine
 */
public class A055453 extends A055450 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN + 3, mN);
  }
}
#!queue	A055454	0	->	4	A055450	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055454 T(n,n-4), array T as in A055450.
 * @author Sean A. Irvine
 */
public class A055454 extends A055450 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN + 4, mN);
  }
}
#!queue	A055455	0	->	5	A055450	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055455 T(n,n-5), array T as in A055450.
 * @author Sean A. Irvine
 */
public class A055455 extends A055450 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN + 5, mN);
  }
}
#!queue	A055459	2	->	1	A007712	--------------------------------
package irvine.oeis.a055;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a007.A007712;
import irvine.util.Permutation;

/**
 * A055459 a(n) = number of permutations of {1,...,n} which are twice but not 3-times reformable.
 * @author Sean A. Irvine
 */
public class A055459 extends A007712 {

  private int mN = 3;
  private Z mF = Z.SIX;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    long count = 0;
    final Permutation perm = new Permutation(mN);
    int[] p;
    while ((p = perm.next()) != null) {
      final int[] reform = reform(Arrays.copyOf(p, p.length));
      if (reform != null) {
        final int[] reform2 = reform(reform);
        if (reform2 != null && reform(reform2) == null) {
          ++count;
        }
      }
    }
    return Z.valueOf(count);
  }
}
#!queue	A055531	0	->	2	A001831	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a001.A001831;

/**
 * A055531 Number of labeled order relations on n nodes in which longest chain has 2 nodes.
 * @author Sean A. Irvine
 */
public class A055531 extends A001831 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A055540	0	->	1	A327371	--------------------------------
package irvine.oeis.a055;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a327.A327371;

/**
 * A055540 Total number of leaves (nodes of vertex degree 1) in all graphs of n nodes.
 * @author Sean A. Irvine
 */
public class A055540 extends A327371 {

  private int mN = 0;

  @Override
  public Z next() {
    final Polynomial<Z> t = g(++mN).coeff(mN);
    Z sum = Z.ZERO;
    for (int k = 1; k <= t.degree(); ++k) {
      sum = sum.add(t.get(k).multiply(k));
    }
    return sum;
  }
}
#!queue	A055543	0	->	1	A000055	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a000.A000055;

/**
 * A055543 Total number of nodes in all trees with n nodes.
 * @author Sean A. Irvine
 */
public class A055543 extends A000055 {

  private long mN = 0;

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}
#!queue	A055560	0	->	1	A001106	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a001.A001106;
import irvine.util.string.StringUtils;

/**
 * A055560 Base numbers of 9-gonal palindromic numbers.
 * @author Sean A. Irvine
 */
public class A055560 extends A001106 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (!StringUtils.isPalindrome(super.next().toString())) {
      // do nothing
    }
    return mN;
  }
}
#!queue	A055597	0	->	1	A048855	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a048.A048855;

/**
 * A055597 Powers of 2 in phi(n!).
 * @author Sean A. Irvine
 */
public class A055597 extends A048855 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(super.next().makeOdd().auxiliary());
  }
}
#!queue	A055600	1	->	0	A003586	--------------------------------
package irvine.oeis.a055;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a003.A003586;

/**
 * A055600 Numbers of form 2^i*3^j+1 with i, j &gt;= 0.
 * @author Georg Fischer
 */
public class A055600 extends A003586 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A055656	0	->	1	A048855	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000142;
import irvine.oeis.a048.A048855;

/**
 * A055656 Excess in exponents of powers of 2 in EulerPhi of n! compared to that of n!.
 * @author Sean A. Irvine
 */
public class A055656 extends A048855 {

  private final Sequence mF = new A000142().skip(1);

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(super.next().makeOdd().auxiliary() - mF.next().makeOdd().auxiliary());
  }
}

#!queue	A055679	0	->	1	A048855	--------------------------------
package irvine.oeis.a055;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a048.A048855;

/**
 * A055679 Number of distinct prime factors of phi(n!).
 * @author Sean A. Irvine
 */
public class A055679 extends A048855 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).omega());
  }
}
#!queue	A055723	1	->	0	A000959	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a000.A000959;

/**
 * A055723 Number of lucky numbers (A000959) &lt;= 10^n.
 * @author Sean A. Irvine
 */
public class A055723 extends A000959 {

  private long mLimit = 0;
  private long mCount = 0;

  @Override
  public Z next() {
    mLimit = mLimit == 0 ? 1 : mLimit * 10;
    while (super.next().longValueExact() <= mLimit) {
      ++mCount;
    }
    return Z.valueOf(mCount++);
  }
}
#!queue	A055866	0	->	2	A055818	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055866 Largest number that has the same number of digits in base 10 and base n, or 0 if no such number exists.
 * @author Sean A. Irvine
 */
public class A055866 extends A055818 {

  private static final Z[] SMALL = {
    null,
    null,
    Z.ONE,
    Z.TWO,
    Z.valueOf(15),
    Z.valueOf(124),
    Z.valueOf(1295),
    Z.valueOf(117648),
    Z.valueOf(1073741823),
    new Z("109418989131512359208"),
    Z.ZERO,
    new Z("9999999999999999999999999"),
    Z.valueOf(9999999999999L),
    Z.valueOf(999999999),
    Z.valueOf(9999999),
    Z.valueOf(999999),
    Z.valueOf(99999),
    Z.valueOf(99999),
    Z.valueOf(9999),
    Z.valueOf(9999),
    Z.valueOf(9999),
    Z.valueOf(9999),
  };
  private static final Z Z99 = Z.valueOf(99);
  private static final Z Z999 = Z.valueOf(999);
  private int mN = 1;

  @Override
  public Z next() {
    if (++mN < SMALL.length) {
      return SMALL[mN];
    }
    if (mN <= 31) {
      return Z999;
    }
    if (mN <= 99) {
      return Z99;
    }
    return Z.NINE;
  }
}
#!queue	A055969	0	->	1	A000273	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000273;
import irvine.oeis.a003.A003086;

/**
 * A055969 Number of unlabeled digraphs with n nodes and an odd number of arcs.
 * @author Sean A. Irvine
 */
public class A055969 extends A000273 {

  private final Sequence mA = new A003086();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next()).divide2();
  }
}
#!queue	A056054	0	->	1	A002387	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002387;

/**
 * A056054 a(n) = smallest even number 2m such that value of odd harmonic series Sum_{j=0..m} 1/(2j) is &gt; n.
 * @author Sean A. Irvine
 */
public class A056054 extends A002387 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next().multiply2();
  }
}
#!queue	A056057	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056057 The largest square which divides n-th central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056057 extends A001405 {

  protected final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return n.divide(mFactor.factorize(n).core());
  }
}
#!queue	A056058	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056058 Squarefree part of the n-th central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056058 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return mFactor.factorize(n).core();
  }
}
#!queue	A056059	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056059 GCD of largest square and squarefree part of central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A056059 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    final Z core = mFactor.factorize(n).core();
    return core.gcd(n.divide(core));
  }
}
#!queue	A056060	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056060 The powerfree part of the central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A056060 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = mFactor.factorize(super.next());
    Z prod = Z.ONE;
    for (final Z p : fs.toZArray()) {
      if (fs.getExponent(p) == 1) {
        prod = prod.multiply(p);
      }
    }
    return prod;
  }
}
#!queue	A056077	0	->	1	A001142	--------------------------------
package irvine.oeis.a056;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a001.A001142;

/**
 * A056077 Indices n of terms of sequence A001142, Product_{k=0..n} binomial(n,k), that are divisible by all primes &lt;= n.
 * @author Sean A. Irvine
 */
public class A056077 extends A001142 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  private boolean is(final Z t) {
    for (long p = 2; p <= mN; p = mPrime.nextPrime(p)) {
      if (t.mod(p) != 0) {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      if (is(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A056139	0	->	2	A030664	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a030.A030664;

/**
 * A056139 a(n) = n^2 - primefloor(n)*primeceiling(n).
 * @author Sean A. Irvine
 */
public class A056139 extends A030664 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mN + 1).square().subtract(super.next());
  }
}
#!queue	A056152	0	->	2	A028657	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a028.A028657;

/**
 * A056152 Triangular array giving number of bipartite graphs with n vertices, no isolated vertices and a distinguished bipartite block with k=1..n-1 vertices, up to isomorphism.
 * @author Sean A. Irvine
 */
public class A056152 extends A028657 {

  @Override
  protected Z a(final int n, final int k) {
    return super.a(n, k).subtract(super.a(n - 1, k)).subtract(super.a(n, k - 1)).add(super.a(n - 1, k - 1));
  }

  private int mN = 1;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    return a(mM, mN - mM);
  }
}

#!queue	A056173	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056173 Number of unitary prime divisors of central binomial coefficient C(n, floor(n/2)) (A001405).
 * @author Sean A. Irvine
 */
public class A056173 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = mFactor.factorize(super.next());
    long cnt = 0;
    for (final Z p : fs.toZArray()) {
      if (fs.getExponent(p) == 1) {
        ++cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A056187	1	->	0	A056788	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.LeastPrimeFactorizer;
import irvine.math.z.Z;

/**
 * A056187 Least prime factor of n^n + (n+1)^(n+1).
 * @author Sean A. Irvine
 */
public class A056187 extends A056788 {

  @Override
  public Z next() {
    return LeastPrimeFactorizer.lpf(super.next());
  }
}
#!queue	A056201	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056201 Characteristic cube divisor (A056191) of central binomial coefficient (A001405).
 * @author Sean A. Irvine
 */
public class A056201 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = mFactor.factorize(super.next());
    Z prod = Z.ONE;
    for (final Z p : fs.toZArray()) {
      final int e = fs.getExponent(p);
      if (e > 1 && (e & 1) == 1) {
        prod = prod.multiply(p.pow(3));
      }
    }
    return prod;
  }
}
#!queue	A056202	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056202 Central binomial coefficient A001405(n) divided by its characteristic cube divisor A056201(n).
 * @author Sean A. Irvine
 */
public class A056202 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    final FactorSequence fs = mFactor.factorize(n);
    Z prod = Z.ONE;
    for (final Z p : fs.toZArray()) {
      final int e = fs.getExponent(p);
      if (e > 1 && (e & 1) == 1) {
        prod = prod.multiply(p.pow(3));
      }
    }
    return n.divide(prod);
  }
}
#!queue	A056207	0	->	1	A003095	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a003.A003095;

/**
 * A056207 Number of binary trees of height &lt;= n.
 * @author Sean A. Irvine
 */
public class A056207 extends A003095 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(2);
  }
}
#!queue	A056304	0	->	1	A000048	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000048;
import irvine.oeis.a002.A002075;

/**
 * A056304 Number of primitive (period n) n-bead necklace structures using exactly three different colored beads.
 * A002075(n)-A000048(n)
 * @author Georg Fischer
 */
public class A056304 extends A000048 {

  private Sequence mSeq = new A002075();

  /** Construct the sequence. */
  public A056304() {
    super.next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056353	1	->	0	A152176	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a152.A152176;

/**
 * A056353 Number of bracelet structures using a maximum of three different colored beads.
 * @author Sean A. Irvine
 */
public class A056353 extends A152176 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(mN, 1).add(t(mN, 2)).add(t(mN, 3));
  }
}
#!queue	A056354	1	->	0	A152176	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a152.A152176;

/**
 * A056354 Number of bracelet structures using a maximum of four different colored beads.
 * @author Sean A. Irvine
 */
public class A056354 extends A152176 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(mN, 1).add(t(mN, 2)).add(t(mN, 3)).add(t(mN, 4));
  }
}
#!queue	A056355	1	->	0	A152176	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a152.A152176;

/**
 * A056355 Number of bracelet structures using a maximum of five different colored beads.
 * @author Sean A. Irvine
 */
public class A056355 extends A152176 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(mN, 1).add(t(mN, 2)).add(t(mN, 3)).add(t(mN, 4)).add(t(mN, 5));
  }
}
#!queue	A056356	1	->	0	A152176	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a152.A152176;

/**
 * A056356 Number of bracelet structures using a maximum of six different colored beads.
 * @author Sean A. Irvine
 */
public class A056356 extends A152176 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(mN, 1).add(t(mN, 2)).add(t(mN, 3)).add(t(mN, 4)).add(t(mN, 5)).add(t(mN, 6));
  }
}
#!queue	A056357	0	->	1	A000011	--------------------------------
package irvine.oeis.a056;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a000.A000011;

/**
 * A056357 Number of bracelet structures using exactly two different colored beads.
 * @author Georg Fischer
 */
public class A056357 extends A000011 {

  protected int mN;
  
  /** Construct the sequence. */
  public A056357() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(1);
  }
}
#!queue	A056366	0	->	1	A000046	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000007;
import irvine.oeis.a000.A000046;

/**
 * A056366 Number of primitive (period n) bracelet structures using exactly two different colored beads.
 * @author Sean A. Irvine
 */
public class A056366 extends A000046 {

  private final Sequence mA = new A000007();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A056415	0	->	1	A002729	--------------------------------
package irvine.oeis.a056;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a002.A002729;

/**
 * A056415 Number of step cyclic shifted sequences using exactly two different symbols.
 * @author Georg Fischer
 */
public class A056415 extends A002729 {

  protected int mN;
  
  /** Construct the sequence. */
  public A056415() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(2);
  }
}
#!queue	A056482	0	->	1	A056476	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056482 Number of primitive (aperiodic) palindromic structures using exactly three different symbols.
 * @author Georg Fischer
 */
public class A056482 extends A056476 {

  private final Sequence mSeq = new A056477();

  {
    next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056483	0	->	1	A056477	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056483 Number of primitive (aperiodic) palindromic structures using exactly four different symbols.
 * @author Georg Fischer
 */
public class A056483 extends A056477 {

  private final Sequence mSeq = new A056478();

  {
    next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056484	0	->	1	A056478	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056484 Number of primitive (aperiodic) palindromic structures using exactly five different symbols.
 * @author Georg Fischer
 */
public class A056484 extends A056478 {

  private final Sequence mSeq = new A056479();

  {
    next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056513	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056513 Number of primitive (period n) periodic palindromic structures using a maximum of two different symbols.
 * @author Sean A. Irvine
 */
public class A056513 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 2).add(get(mN, 1));
  }
}
#!queue	A056514	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056514 Number of primitive (period n) periodic palindromic structures using a maximum of three different symbols.
 * @author Sean A. Irvine
 */
public class A056514 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 3).add(get(mN, 2)).add(get(mN, 1));
  }
}
#!queue	A056515	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056515 Number of primitive (period n) periodic palindromic structures using a maximum of four different symbols.
 * @author Sean A. Irvine
 */
public class A056515 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 4).add(get(mN, 3)).add(get(mN, 2)).add(get(mN, 1));
  }
}
#!queue	A056516	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056516 Number of primitive (period n) periodic palindromic structures using a maximum of five different symbols.
 * @author Sean A. Irvine
 */
public class A056516 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 5).add(get(mN, 4)).add(get(mN, 3)).add(get(mN, 2)).add(get(mN, 1));
  }
}
#!queue	A056517	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056517 Number of primitive (period n) periodic palindromic structures using a maximum of six different symbols.
 * @author Sean A. Irvine
 */
public class A056517 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 6).add(get(mN, 5)).add(get(mN, 4)).add(get(mN, 3)).add(get(mN, 2)).add(get(mN, 1));
  }
}
#!queue	A056536	0	->	1	A091018	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a091.A091018;

/**
 * A056536 Mapping from half-antidiagonal reading of the triangle (as used in A028297) to the column-by-column reading of the triangular tables.
 * @author Sean A. Irvine
 */
public class A056536 extends A091018 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A056596	0	->	1	A027423	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a027.A027423;
import irvine.oeis.a055.A055993;

/**
 * A056596 Number of nonsquare divisors of n!.
 * @author Sean A. Irvine
 */
public class A056596 extends A027423 {

  private final Sequence mA = new A055993();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}

#!queue	A056609	0	->	1	A034386	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a034.A034386;

/**
 * A056609 a(n) = rad(n!)/rad(A001142(n)) where rad(n) is the squarefree kernel of n, A007947(n).
 * @author Sean A. Irvine
 */
public class A056609 extends A034386 {

  private final Sequence mA = new A056606();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().divide(mA.next());
  }
}

#!queue	A056610	0	->	1	A034386	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a034.A034386;
import irvine.oeis.a048.A048633;

/**
 * A056610 Quotient: squarefree kernel of lcm(1,..,n) (or of n!) divided by kernel of central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056610 extends A034386 {

  private final Sequence mA = new A048633();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(mA.next());
  }
}

#!queue	A056621	1	->	2	A002931	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A056621 a(n) is the total radius of gyration of all self-avoiding polygons of length 2n on the square lattice.
 * @author Sean A. Irvine
 */
public class A056621 extends A002931 {

  {
    super.next();
  }

  @Override
  protected Z postFilter() {
    Z total = Z.ZERO;
    for (final Polygon polygon : mPolygons) {
      // Radius of gyration
      long r2 = 0;
      for (final Point pt1 : polygon) {
        final int x1 = pt1.left();
        final int y1 = pt1.right();
        for (final Point pt2 : polygon) {
          if (pt2 == pt1) {
            break;
          }
          final int x2 = pt2.left();
          final int y2 = pt2.right();
          final long dx = x1 - x2;
          final long dy = y1 - y2;
          r2 += dx * dx + dy * dy;
        }
      }
      total = total.add(r2);
    }
    return total;
  }
}
#!queue	A056625	1	->	2	A002931	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A056625 a(n) is the total area of all self-avoiding polygons of length 2n on the square lattice.
 * @author Sean A. Irvine
 */
public class A056625 extends A002931 {

  {
    super.next();
  }

  @Override
  protected Z postFilter() {
    Z total = Z.ZERO;
    for (final Polygon polygon : mPolygons) {
      // Area
      int area = 0;
      Point pt0 = null;
      for (final Point pt1 : polygon) {
        if (pt0 != null) {
          area += pt0.left() * pt1.right() - pt1.left() * pt0.right();
        }
        pt0 = pt1;
      }
      // Wrap around to get the last point closing the polygon
      for (final Point pt1 : polygon) {
        area += pt0.left() * pt1.right() - pt1.left() * pt0.right();
        break;
      }
      total = total.add(area / 2);
    }
    return total;
  }
}
#!queue	A056631	1	->	2	A002931	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A056631 a(n) is the total second area moment of all self-avoiding polygons of length 2n on the square lattice.
 * @author Sean A. Irvine
 */
public class A056631 extends A002931 {

  {
    super.next();
  }

  @Override
  protected Z postFilter() {
    Z total = Z.ZERO;
    for (final Polygon polygon : mPolygons) {
      // Area
      int area = 0;
      Point pt0 = null;
      for (final Point pt1 : polygon) {
        if (pt0 != null) {
          area += pt0.left() * pt1.right() - pt1.left() * pt0.right();
        }
        pt0 = pt1;
      }
      // Wrap around to get the last point closing the polygon
      for (final Point pt1 : polygon) {
        area += pt0.left() * pt1.right() - pt1.left() * pt0.right();
        break;
      }
      area /= 2;
      // Second moment
      total = total.add((long) area * area);
    }
    return total;
  }
}
#!queue	A056634	1	->	8	A002931	--------------------------------
package irvine.oeis.a056;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A056634 Number of polygons of length 2n with one hole on square lattice (not allowing rotations).
 * @author Sean A. Irvine
 */
public class A056634 extends A002931 {

  // WARNING: This is insanely slow

  private static final Point ORIGIN = new Point(0, 0);
  private final List<List<Polygon>> mSmall = new ArrayList<>();
  private final List<List<int[]>> mSmallBounds = new ArrayList<>();
  {
    mSmall.add(Collections.emptyList()); // 0
  }
  private final A002931 mSmallGenerator = new A002931() {
    @Override
    protected Z postFilter() {
      final ArrayList<Polygon> polys = new ArrayList<>();
      for (final Polygon p : mPolygons) {
        if (p.contains(ORIGIN)) {
          polys.add(p);
        } else {
          // To an evil back translation to ensure (0,0) is a point
          final Polygon trans = new Polygon(null, null);
          boolean first = true;
          int dx = 0;
          int dy = 0;
          for (final Point pt : p) {
            if (first) {
              dx = pt.left();
              dy = pt.right();
              first = false;
            }
            trans.add(new Point(pt.left() - dx, pt.right() - dy));
          }
          polys.add(trans);
        }
      }
      mSmall.add(polys);
      return Z.ZERO;
    }
  };
  private final long[] mCnt = new long[100];
  {
    super.next(); // 2
    super.next(); // 4
    super.next(); // 6
    super.next(); // 8
    super.next(); // 10
  }

  private int[] getBounds(final Polygon polygon) {
    int maxX = 0;
    int maxY = 0;
    for (final Point pt : polygon) {
      final int x = pt.left();
      if (x > maxX) {
        maxX = x;
      }
      final int y = pt.right();
      if (y > maxY) {
        maxY = y;
      }
    }
    return new int[] {maxX, maxY};
  }

  private List<Polygon> polys(final int n) {
    while (n >= mSmall.size()) {
      mSmallGenerator.next();
      final ArrayList<int[]> bounds = new ArrayList<>();
      for (final Polygon p : mSmall.get(mSmall.size() - 1)) {
        bounds.add(getBounds(p));
      }
      mSmallBounds.add(bounds);
    }
    return mSmall.get(n);
  }

  private boolean isInside(final Polygon polygon, final int x, final int y) {
    if (polygon.contains(new Point(x, y))) {
      return false; // Quick exit if this point hits the polygon
    }
    boolean inside = false;
    final int[] vertx = new int[polygon.size()];
    final int[] verty = new int[polygon.size()];
    int k = 0;
    for (final Point pt : polygon) {
      vertx[k] = pt.left();
      verty[k] = pt.right();
      ++k;
    }
    int p1x = vertx[0];
    int p1y = verty[0];
    for (int i = 1; i <= vertx.length; i++) {
      final int p2x = vertx[i % vertx.length];
      final int p2y = verty[i % vertx.length];
      if (y > Math.min(p1y, p2y) && y <= Math.max(p1y, p2y) && x <= Math.max(p1x, p2x) /*&& p1y != p2y*/) {
        final int c = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
        if (p1x == p2x || x <= c) {
          inside = !inside;
        }
      }
      p1x = p2x;
      p1y = p2y;
    }

    return inside;
  }

  private boolean isOk(final Polygon p, final Polygon q, final int x, final int y) {
    for (final Point pt : q) {
      if (p.contains(new Point(pt.left() + x, pt.right() + y))) {
        return false;
      }
    }
    return true;
  }

  @Override
  protected Z postFilter() {
    for (final Polygon polygon : mPolygons) {
      // Compute bounds
      final int[] bounds = getBounds(polygon);
      final int maxX = bounds[0];
      final int maxY = bounds[1];
      // Test each point potentially inside the bounding rectangle
      for (int y = 1; y < maxY; ++y) {
        for (int x = 1; x < maxX; ++x) {
          if (isInside(polygon, x, y)) {
            // See if we can play a smaller polygon inside
            for (int j = 1; j < mN / 2 - 4; ++j) {
              final List<Polygon> qp = polys(j);
              final List<int[]> qbounds = mSmallBounds.get(j);
              for (int k = 0; k < qp.size(); ++k) {
                final Polygon q = qp.get(k);
                final int[] qxy = qbounds.get(k);
                if (qxy[0] + x < maxX && qxy[1] + y < maxY && isOk(polygon, q, x, y)) {
                  ++mCnt[polygon.size() + q.size()];
                }
              }
            }
          }
        }
      }
    }
//    for (int j = 0; j < mCnt.length; ++j) {
//      if (mCnt[j] > 0) {
//        System.out.println(j + " " + mCnt[j]);
//      }
//    }
    return Z.valueOf(mCnt[mN + 4]);
  }
}
#!queue	A056670	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056670 Largest prime factor of which the exponent exceeds 1 among prime factors of central binomial coefficient, C(n, floor(n/2)); largest non-unitary prime factor of A001405(n); or the maximal prime divisor of the largest square divisor(A056057(n)) of C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A056670 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = mFactor.factorize(super.next());
    final Z[] f = fs.toZArray();
    for (int k = f.length - 1; k >= 0; --k) {
      if (fs.getExponent(f[k]) > 1) {
        return f[k];
      }
    }
    return Z.ONE;
  }
}
#!queue	A056672	0	->	1	A055773	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a055.A055773;

/**
 * A056672 Number of unitary and squarefree divisors of n! Also, number of divisors of the special squarefree part of n!, A055773(n).
 * @author Sean A. Irvine
 */
public class A056672 extends A055773 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).sigma0();
  }
}
#!queue	A056790	1	->	0	A056788	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A056790 Greatest prime factor of n^n + (n+1)^(n+1).
 * @author Sean A. Irvine
 */
public class A056790 extends A056788 {

  @Override
  public Z next() {
    final Z[] p = Jaguar.factor(super.next()).toZArray();
    return p[p.length - 1];
  }
}
#!queue	A056794	0	->	1	A002378	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002378;
import irvine.util.string.StringUtils;

/**
 * A056794 Numbers n such that n*(n-1) is an oblong (promic, A002378) palindrome.
 * @author Sean A. Irvine
 */
public class A056794 extends A002378 {

  @Override
  public Z next() {
    while (true) {
      if (StringUtils.isPalindrome(super.next().toString())) {
        return mN;
      }
    }
  }
}
#!queue	A056851	0	->	1	A034886	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a034.A034886;

/**
 * A056851 Integers n such that the number of digits in n! is a cube.
 * @author Sean A. Irvine
 */
public class A056851 extends A034886 {

  @Override
  public Z next() {
    while (true) {
      if (ZUtils.isCube(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A056872	0	->	1	A000041	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000009;
import irvine.oeis.a000.A000041;

/**
 * A056872 Numbers n such that n | p(n) + q(n) where p(n) = partition numbers (A000041) and q(n) = partition numbers into distinct parts (A000009).
 * @author Sean A. Irvine
 */
public class A056872 extends A000041 {

  private final Sequence mA = new A000009();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next().add(mA.next());
      if (mN > 0 && t.mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A056873	0	->	1	A000041	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000009;
import irvine.oeis.a000.A000041;

/**
 * A056873 Numbers n such that n | p(n) - q(n) where p(n) = partition numbers (A000041) and q(n) = partition numbers into distinct parts (A000009).
 * @author Sean A. Irvine
 */
public class A056873 extends A000041 {

  private final Sequence mA = new A000009();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next().subtract(mA.next());
      if (mN > 0 && t.mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A056897	1	->	0	A056896	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;

/**
 * A056897 Smallest square where a(n)+n is prime.
 * @author Sean A. Irvine
 */
public class A056897 extends A056896 {

  @Override
  public Z next() {
    return super.next().subtract(mN);
  }
}
#!queue	A056904	1	->	0	A005473	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a005.A005473;

/**
 * A056904 Floor[p/24] where p is a prime which is 4 more than a square.
 * @author Sean A. Irvine
 */
public class A056904 extends A005473 {

  @Override
  public Z next() {
    return super.next().divide(24);
  }
}
#!queue	A056973	0	->	1	A023416	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a023.A023416;
import irvine.oeis.a033.A033264;

/**
 * A056973 Number of blocks of {0,0} in the binary expansion of n.
 * @author Sean A. Irvine
 */
public class A056973 extends A023416 {

  {
    super.next();
  }
  private final Sequence mA = new A033264();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A057004	0	->	1	A160449	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.FiniteSequence;
import irvine.oeis.a160.A160449;
import irvine.oeis.transform.InverseEulerTransform;

/**
 * A057004 Array T(n,k) = number of conjugacy classes of subgroups of index k in free group of rank n, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A057004 extends A160449 {

  private int mN = 2;
  private int mM = 1;

  @Override
  protected Z t(final int n, final int k) {
    final FiniteSequence seq = new FiniteSequence();
    for (int j = 1; j < n; ++j) {
      seq.add(super.t(j, k));
    }
    final InverseEulerTransform iet = new InverseEulerTransform(seq);
    for (int j = 2; j < n; ++j) {
      iet.next();
    }
    return iet.next();
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 2;
    }
    return t(mM, mN - mM);
  }
}
#!queue	A057019	0	->	1	A006882	--------------------------------
package irvine.oeis.a057;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A057019 Difference between n!! and the first prime after n!! + 1.
 * @author Sean A. Irvine
 */
public class A057019 extends A006882 {

  private final Fast mPrime = new Fast();
  {
    super.next(); // skip 0!!
  }

  @Override
  public Z next() {
    final Z df = super.next();
    return mPrime.nextPrime(df.add(1)).subtract(df);
  }
}
#!queue	A057034	0	->	4	A006882	--------------------------------
package irvine.oeis.a057;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A057034 Difference between n!! and the first prime before n!! - 1.
 * @author Sean A. Irvine
 */
public class A057034 extends A006882 {

  private final Fast mPrime = new Fast();
  {
    super.next(); // skip 0!!
    super.next(); // skip 1!!
    super.next(); // skip 2!!
    super.next(); // skip 3!!
  }

  @Override
  public Z next() {
    final Z df = super.next();
    return df.subtract(mPrime.prevPrime(df.subtract(1)));
  }
}
#!queue	A057106	0	->	1	A000567	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a000.A000567;
import irvine.util.string.StringUtils;

/**
 * A057106 Numbers k such that k(3k-2) is an octagonal palindrome.
 * @author Sean A. Irvine
 */
public class A057106 extends A000567 {

  @Override
  public Z next() {
    while (!StringUtils.isPalindrome(super.next().toString())) {
      // do nothing
    }
    return mN;
  }
}
#!queue	A057152	1	->	0	A057149	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057152 Limiting number of m X m binary matrices with m+n ones, with no zero rows or columns, up to row and column permutations, as m tends to infinity.
 * @author Sean A. Irvine
 */
public class A057152 extends A057149 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(3 * mN, 4 * mN);
  }
}
#!queue	A057332	1	->	0	A056525	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a056.A056525;

/**
 * A057332 a(n) is the number of (2n+1)-digit palindromic primes that undulate.
 * @author Sean A. Irvine
 */
public class A057332 extends A056525 {

  private Z mPalin = super.next();
  private Z mLimit = Z.ONE;

  @Override
  public Z next() {
    mLimit = mLimit.multiply(100);
    long cnt = 0;
    while (mPalin.compareTo(mLimit) < 0) {
      if (mPalin.isProbablePrime() && ZUtils.isUndulate(mPalin)) {
        ++cnt;
      }
      mPalin = super.next();
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A057517	0	->	1	A014486	--------------------------------
package irvine.oeis.a057;

import irvine.lisp.SExpression;
import irvine.math.z.Z;
import irvine.oeis.a014.A014486;

/**
 * A057517 Binary encodings of the Catalan mountain ranges with exactly one sea-level valley, i.e., the rooted plane trees with root degree = 2.
 * @author Sean A. Irvine
 */
public class A057517 extends A014486 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final SExpression s = SExpression.binexp2pars(super.next());
    final SExpression t = new SExpression();
    t.add(s.car());
    t.add(s.cdr());
    return t.toZ();
  }
}
#!queue	A057650	1	->	2	A056004	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a056.A056004;

/**
 * A057650 Second step in Goodstein sequences, i.e., g(4) if g(2)=n: (first step) write g(2)=n in hereditary representation base 2, bump to base 3, then subtract 1 to produce g(3)=A056004(n), then (second step) write g(3) in hereditary representation base 3, bump to base 4, then subtract 1 to produce g(4).
 * @author Sean A. Irvine
 */
public class A057650 extends A056004 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return code(super.next(), 3);
  }
}
#!queue	A057718	0	->	1	A036917	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a036.A036917;

/**
 * A057718 A036917/8 (omitting leading term of A036917).
 * @author Sean A. Irvine
 */
public class A057718 extends A036917 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(8);
  }
}
#!queue	A057752	0	->	1	A006880	--------------------------------
package irvine.oeis.a057;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a006.A006880;

/**
 * A057752 Difference between nearest integer to Li(10^n) and pi(10^n), where Li(x) = integral of log(x) and pi(10^n) = number of primes &lt;= 10^n (A006880).
 * @author Sean A. Irvine
 */
public class A057752 extends A006880 {

  private Z mA = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mA = mA.multiply(10);
    return CR.valueOf(mA).li().subtract(CR.valueOf(super.next())).round();
  }
}
#!queue	A057766	0	->	1	A000105	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a000.A000105;

/**
 * A057766 Total area of all n-celled polyominoes.
 * @author Sean A. Irvine
 */
public class A057766 extends A000105 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(mN);
  }
}

#!queue	A057835	0	->	1	A006880	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006880;

/**
 * A057835 Difference between pi(10^n) and the integer nearest to 10^n / log(10^n).
 * @author Sean A. Irvine
 */
public class A057835 extends A006880 {

  private final Sequence mA = new A057834();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A057970	0	->	1	A057968	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057970 5 x n binary matrices with 1 unit column up to row and column permutations.
 * @author Sean A. Irvine
 */
public class A057970 extends A057968 {

  private int mN = 0;

  @Override
  public Z next() {
    return b(++mN, 1);
  }
}
#!queue	A057971	0	->	2	A057968	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057971 Number of 5 x n binary matrices with 2 unit columns up to row and column permutations.
 * @author Sean A. Irvine
 */
public class A057971 extends A057968 {

  private int mN = 1;

  @Override
  public Z next() {
    return b(++mN, 2);
  }
}
#!queue	A057972	0	->	3	A057968	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057972 Number of 5 X n binary matrices with 3 unit columns up to row and column permutations.
 * @author Sean A. Irvine
 */
public class A057972 extends A057968 {

  private int mN = 2;

  @Override
  public Z next() {
    return b(++mN, 3);
  }
}
#!queue	A057999	1	->	0	A036012	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a036.A036012;

/**
 * A057999 a(n) is smallest prime such that a(n)-1 is a proper multiple of a(n-1)-1, with a(0) = 2.
 * @author Sean A. Irvine
 */
public class A057999 extends A036012 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply(super.next());
    return mA.add(1);
  }
}
#!queue	A058085	0	->	5	A058057	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058085 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058085 extends A058057 {

  private int mN = 4;

  @Override
  public Z next() {
    return t(++mN, mN - 5);
  }
}

#!queue	A058086	0	->	6	A058057	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058086 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058086 extends A058057 {

  private int mN = 5;

  @Override
  public Z next() {
    return t(++mN, mN - 6);
  }
}

#!queue	A058089	0	->	6	A058087	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058089 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058089 extends A058087 {

  private int mN = 5;

  @Override
  public Z next() {
    return t(++mN, mN - 6);
  }
}

#!queue	A058090	0	->	7	A058087	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058090 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058090 extends A058087 {

  private int mN = 6;

  @Override
  public Z next() {
    return t(++mN, mN - 7);
  }
}

#!queue	A058193	0	->	1	A000230	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A058193 Smallest prime p such that there is a gap of 6n between p and the next prime.
 * @author Sean A. Irvine
 */
public class A058193 extends A000230 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    super.next();
    return super.next();
  }
}
#!queue	A058194	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058194 Number of n-rowed matrices with entries {0,1,2,3} and all row sums 3, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058194 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(++mN, 3 * mN, 3);
  }
}
#!queue	A058204	-1	->	0	A007253	--------------------------------
package irvine.oeis.a058;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a007.A007253;

/**
 * A058204 McKay-Thompson series of class 10c for Monster.
 * @author Sean A. Irvine
 */
public class A058204 extends A007253 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mA = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    final Q t = new Q(super.next());
    mA.add(++mN == 1 ? t.subtract(Q.FOUR) : t);
    return RING.sqrt(mA, mN).coeff(mN).toZ();
  }
}

#!queue	A058209	1	->	2	A000203	--------------------------------
package irvine.oeis.a058;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A058209 a(n) = floor( exp(gamma) n log log n ) - sigma(n), where gamma is Euler's constant (A001620) and sigma(n) is sum of divisors of n (A000203).
 * @author Sean A. Irvine
 */
public class A058209 extends A000203 {

  private static final CR EXP_GAMMA = CR.GAMMA.exp();
  private long mN = 1;
  {
    super.next();
  }

  @Override
  public Z next() {
    return EXP_GAMMA.multiply(++mN).multiply(CR.valueOf(mN).log().log()).floor().subtract(super.next());
  }
}

#!queue	A058261	1	->	0	A006577	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a006.A006577;

/**
 * A058261 a(n) = n times the Collatz number of n (as given in A006577).
 * @author Sean A. Irvine
 */
public class A058261 extends A006577 {

  @Override
  public Z next() {
    return super.next().multiply(mN);
  }
}
#!queue	A058314	0	->	1	A006882	--------------------------------
package irvine.oeis.a058;

import irvine.math.ContinuedFractionUtils;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A058314 Sum of terms in simple continued fraction for n!!/(n-1)!!, where n!! is a double factorial, n(n-2)(n-4)....
 * @author Sean A. Irvine
 */
public class A058314 extends A006882 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return ContinuedFractionUtils.continuedFractionSum(new Q(mA, t));
  }
}
#!queue	A058389	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058389 Number of 3 X 3 matrices with nonnegative integer entries and all row sums equal to n, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058389 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(3, 3, ++mN);
  }
}

#!queue	A058390	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058390 Number of 4 X 4 matrices with nonnegative integer entries and all row sums equal to n, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058390 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(4, 4, ++mN);
  }
}

#!queue	A058391	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058391 Number of 5 X 5 matrices with nonnegative integer entries and all row sums equal to n, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058391 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(5, 5, ++mN);
  }
}

#!queue	A058392	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058392 Number of 6 X 6 matrices with nonnegative integer entries and all row sums equal to n, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058392 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(6, 6, ++mN);
  }
}

#!queue	A058552	1	->	0	A013963	--------------------------------
package irvine.oeis.a058;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a013.A013963;

/**
 * A058552 Numerators of q-expansion of Eisenstein series E_16(q).
 * @author Sean A. Irvine
 */
public class A058552 extends A013963 {

  private static final Q C = new Q(16320, 3617);
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return C.multiply(super.next()).num();
  }
}
#!queue	A058723	0	->	-1	A003114	--------------------------------
package irvine.oeis.a058;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a003.A003106;
import irvine.oeis.a003.A003114;

/**
 * A058723 McKay-Thompson series of class 58a for the Monster group.
 * @author Sean A. Irvine
 */
public class A058723 extends A003114 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final Sequence mHSeq = new A003106();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mH = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mG.add(super.next());
    mH.add(mHSeq.next());
    return RING.multiply(mG, mG.substitutePower(29, mN), mN).coeff(mN)
      .add(mN < 6 ? Z.ZERO : RING.multiply(mH, mH.substitutePower(29, mN - 6), mN - 6).coeff(mN - 6));
  }
}
#!queue	A058737	1	->	2	A000669	--------------------------------
package irvine.oeis.a058;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000669;

/**
 * A058737 Main diagonal of A058735.
 * @author Sean A. Irvine
 */
public class A058737 extends A000669 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final Polynomial<Z> mB = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mB.add(super.next());
    return RING.pow(mB, 2, mN).coeff(mN).add(mB.substitutePower(2, mN).coeff(mN)).divide2();
  }
}
#!queue	A058786	1	->	5	A342053	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a342.A342053;

/**
 * A058786 Number of n-hedra with 2n-5 vertices or 3n-7 edges (the vertices of these are all of degree 3, except one which is of degree 4). Alternatively, the number of polyhedra with n vertices whose faces are all triangular, except one which is tetragonal.
 * @author Sean A. Irvine
 */
public class A058786 extends A342053 {

  private int mN = 0;

  @Override
  public Z next() {
    return a342053ColSeq(++mN, 4).coeff(mN);
  }
}
#!queue	A058802	0	->	3	A006966	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006966;

/**
 * A058802 Vertically decomposable lattices on n unlabeled nodes.
 * @author Sean A. Irvine
 */
public class A058802 extends A006966 {

  private final Sequence mA = new A058800();
  {
    super.next();
    super.next();
    super.next();
    mA.next();
    mA.next();
    mA.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A058814	0	->	1	A034886	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a034.A034886;

/**
 * A058814 Numbers k such that k divides the number of digits of k!.
 * @author Sean A. Irvine
 */
public class A058814 extends A034886 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A058851	0	->	1	A005843	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a005.A005843;
import irvine.util.string.StringUtils;

/**
 * A058851 Sum of even composites up to n is palindromic.
 * @author Sean A. Irvine
 */
public class A058851 extends A005843 {

  private Z mN = Z.ZERO;
  {
    super.next(); // skip 0
    super.next(); // skip 2
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      mN = mN.add(t);
      if (StringUtils.isPalindrome(mN.toString())) {
        return t;
      }
    }
  }
}
#!queue	A058868	1	->	0	A006562	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a006.A006562;

/**
 * A058868 Maximal distances of equidistant lonely primes shown in A058867.
 * @author Sean A. Irvine
 */
public class A058868 extends A006562 {

  private int mDelta = -1;

  @Override
  public Z next() {
    if (mDelta == -1) {
      super.next(); // handle 5
      mDelta = 0;
      return Z.TWO;
    }
    while (true) {
      final Z p = super.next();
      final Z q = mPrime.nextPrime(p);
      final int delta = q.subtract(p).intValueExact();
      if (delta % 6 == 0) {
        final int d = delta / 6;
        if (d > mDelta) {
          mDelta = d;
          return Z.valueOf(delta);
        }
      }
    }
  }
}
#!queue	A058886	0	->	2	A000700	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a000.A000700;

/**
 * A058886 Sum of the row of the character table of S_n corresponding to the partition 2,1^{n-2}.
 * @author Sean A. Irvine
 */
public class A058886 extends A000700 {

  private Z mSum = super.next().add(super.next());
  private Z mPrev = Z.ZERO;

  @Override
  public Z next() {
    mSum = mSum.add(mPrev.multiply2());
    mPrev = super.next();
    mSum = mSum.subtract(mPrev);
    return mSum;
  }
}
#!queue	A058894	1	->	0	A006881	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006881;
import irvine.oeis.a007.A007304;

/**
 * A058894 |A006881(m)-A007304(m)| = 1, sequence gives A006881(m).
 * @author Sean A. Irvine
 */
public class A058894 extends A006881 {

  private final Sequence mA = new A007304();

  @Override
  public Z next() {
    while (true) {
      final Z s = super.next();
      final Z t = mA.next();
      if (s.subtract(t).abs().equals(Z.ONE)) {
        return s;
      }
    }
  }
}
#!queue	A058909	0	->	1	A058760	--------------------------------
package irvine.oeis.a058;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A058909 Integers whose set of prime factors (taken with multiplicity) uses each digit exactly once (i.e., is pandigital) in base 10.
 * @author Sean A. Irvine
 */
public class A058909 extends A058760 {

  private long mN = 15618089;

  private boolean is(final long n) {
    final FactorSequence fs = Jaguar.factor(n);
    if (!fs.isSquareFree()) {
      return false;
    }
    final long[] p = ZUtils.toLong(fs.toZArray());
    return is(p, 10);
  }

  @Override
  public Z next() {
    if (mN == 8439563243L) {
      return null;
    }
    while (true) {
      if (is(++mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A059146	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059146 A hierarchical sequence (W'2{2} - see A059126).
 * @author Sean A. Irvine
 */
public class A059146 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 3)) {
      case 0:
        mA = super.next().square();
        return mA;
      case 1:
        return mA.multiply2();
      case 2:
      default:
        return mA;
    }
  }
}

#!queue	A059147	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059147 A hierarchical sequence (W'2{3} - see A059126).
 * @author Sean A. Irvine
 */
public class A059147 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 7)) {
      case 0:
        mA = super.next().pow(3);
        return mA;
      case 2:
      case 4:
      case 6:
        return mA;
      case 3:
        return mA.multiply(4);
      case 1:
      case 5:
      default:
        return mA.multiply2();
    }
  }
}

#!queue	A059149	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059149 A hierarchical sequence (W'2{2}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059149 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 3)) {
      case 0:
        do {
          mA = super.next();
        } while (Z.ONE.equals(mA));
        return mA.divide2();
      case 1:
        return mA;
      case 2:
      default:
        return mA.divide2();
    }
  }
}

#!queue	A059150	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059150 A hierarchical sequence (W'2{3}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059150 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 7)) {
      case 0:
        do {
          mA = super.next();
        } while (mA.compareTo(Z.TWO) <= 0);
        return mA.shiftRight(2);
      case 3:
        return mA;
      case 2:
      case 4:
      case 6:
        return mA.shiftRight(2);
      case 1:
      case 5:
      default:
        return mA.divide2();
    }
  }
}

#!queue	A059151	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059151 A hierarchical sequence (W'3{2,2}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059151 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 9)) {
      case 0:
        mA = super.next();
        return mA;
      case 4:
        return mA.multiply(4);
      case 2:
      case 6:
      case 8:
        return mA;
      case 1:
      case 3:
      case 5:
      case 7:
      default:
        return mA.multiply2();
    }
  }
}

#!queue	A059220	0	->	1	A059219	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059220 The array in A059219 read by antidiagonals in 'up' direction.
 * @author Sean A. Irvine
 */
public class A059220 extends A059219 {

  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A059229	0	->	1	A059226	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059229 A diagonal of triangle defined in A059226.
 * @author Sean A. Irvine
 */
public class A059229 extends A059226 {

  private int mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A059235	0	->	1	A059219	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059235 The array in A059219 read by antidiagonals in the direction in which it was constructed.
 * @author Sean A. Irvine
 */
public class A059235 extends A059219 {

  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, (mN & 1) == 1 ? mM : mN - mM);
  }
}
#!queue	A059249	0	->	1	A004489	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a004.A004489;

/**
 * A059249 Tersum n + (n-1); write n and n-1 in base 3 and add mod 3 with no carries.
 * @author Sean A. Irvine
 */
public class A059249 extends A004489 {

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    final Z m = mN;
    mN = mN.add(1);
    return tersum(mN, m);
  }
}

#!queue	A059251	7	->	1	A000580	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000027;
import irvine.oeis.a000.A000292;
import irvine.oeis.a000.A000580;

/**
 * A059251 A sequence related to numeric partitions and Fermat Coefficients.
 * @author Sean A. Irvine
 */
public class A059251 extends A000580 {

  private final Sequence mM2 = new A000292(); // C(n,3)
  private final Sequence mM4 = new A000027(); // C(n,1)
  private int mN = -1;
  {
    mM2.next();
  }

  @Override
  public Z next() {
    Z t = super.next();
    if ((++mN & 1) == 0) {
      t = t.add(mM2.next());
    }
    if ((mN & 3) == 0) {
      t = t.add(mM4.next().multiply(6));
    }
    return t.divide(8);
  }
}

#!queue	A059355	2	->	3	A008826	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a008.A008826;

/**
 * A059355 Number of chains of n-3 partitions in the reduced partition lattice on n elements.
 * @author Sean A. Irvine
 */
public class A059355 extends A008826 {

  private int mN = 0;

  @Override
  public Z next() {
    return get(++mN + 2).get(mN);
  }
}
#!queue	A059356	1	->	2	A008298	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a008.A008298;

/**
 * A059356 A diagonal of triangle in A008298.
 * @author Sean A. Irvine
 */
public class A059356 extends A008298 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN).get(2);
  }
}
#!queue	A059357	1	->	3	A008298	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a008.A008298;

/**
 * A059357 A diagonal of triangle in A008298.
 * @author Sean A. Irvine
 */
public class A059357 extends A008298 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN).get(3);
  }
}
#!queue	A059360	1	->	0	A059333	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059360 a(n) = A059333(2^n).
 * @author Sean A. Irvine
 */
public class A059360 extends A059333 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply2();
    return f(mA);
  }
}
#!queue	A059439	1	->	0	A059438	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059439 A diagonal of A059438.
 * @author Sean A. Irvine
 */
public class A059439 extends A059438 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}
#!queue	A059440	1	->	3	A059438	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059440 A diagonal of A059438.
 * @author Sean A. Irvine
 */
public class A059440 extends A059438 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3);
  }
}
#!queue	A059451	0	->	1	A059010	--------------------------------
package irvine.oeis.a059;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A059451 Number of ways n can be written as the sum of two numbers whose binary expansions have even numbers of zeros; also number of ways n can be written as the sum of two numbers whose binary expansions have odd numbers of zeros.
 * @author Sean A. Irvine
 */
public class A059451 extends A059010 {

  private final TreeSet<Long> mA = new TreeSet<>();
  private long mN = 0;
  {
    mA.add(super.next().longValueExact()); // Avoid need for isEmpty check later
  }

  @Override
  public Z next() {
    ++mN;
    while (mN > mA.last()) {
      mA.add(super.next().longValueExact());
    }
    long cnt = 0;
    for (final long v : mA) {
      if (2 * v > mN) {
        break;
      }
      if (mA.contains(mN - v)) {
        ++cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A059510	0	->	1	A059219	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059510 Main diagonal of the array A059220.
 * @author Sean A. Irvine
 */
public class A059510 extends A059219 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A059529	1	->	0	A058377	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a058.A058377;

/**
 * A059529 For 1 &lt; x, each c(i) is "multiply" (*) or "divide" (/); a(n) is number of choices for c(0),...,c(n-1) so that 1 c(0) x^1 c(1) x^2,.., c(n-1) x^n is an integer.
 * @author Sean A. Irvine
 */
public class A059529 extends A058377 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().add(Z.ONE.shiftLeft(mN - 1));
  }
}
#!queue	A059730	0	->	3	A059922	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059730 Third diagonal of A059922.
 * @author Sean A. Irvine
 */
public class A059730 extends A059922 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN + 3);
  }
}

#!queue	A059793	1	->	0	A005574	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a005.A005574;

/**
 * A059793 Stationary value of quotient in the continued fraction expansion of sqrt(prime) when the quotient-cycle-length = 1.
 * @author Sean A. Irvine
 */
public class A059793 extends A005574 {

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A059878	1	->	0	A059876	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a014.A014437;

/**
 * A059878 a(n) = bin_prime_sum(fibonacci(A001651[n])), where fibonacci(A001651[n]) is A014437[n].
 * @author Sean A. Irvine
 */
public class A059878 extends A059876 {

  private final Sequence mA = new A014437();
  {
    mA.next();
  }

  @Override
  public Z next() {
    return binPrimeSum(mA.next());
  }
}
#!queue	A059902	1	->	0	A059884	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A059902 Partitions encoded by interleaving bits in parts. The partition [P1+P2+P3+...] with P1&gt;=P2&gt;=P3&gt;=... is encoded in binary by recursively interleaving the bits of P1 with the (recursively interleaved bits of P2 with the (recursively...)).
 * @author Sean A. Irvine
 */
public class A059902 extends A059884 {

  private final Sequence mA = new A059901();

  @Override
  public Z next() {
    return encode(mA.next());
  }
}
#!queue	A059954	0	->	1	A051775	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a051.A051775;

/**
 * A059954 Number of 2 X 2 matrices with elements from {0,1,2,...,n} and with Nim-Determinant 1. (The Nim-Determinant of the 2 X 2 matrix [a,b; c,d] is defined to be a*d xor b*c, where * denotes Nim-Multiplication.).
 * @author Sean A. Irvine
 */
public class A059954 extends A051775 {

  // This could me made incremental (i.e., avoid recomputing < mN cases)

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    long cnt = 0;
    for (long h = 0; h <= mN; ++h) {
      for (long i = 0; i <= mN; ++i) {
        final Z a = nimMultiply(h, i);
        for (long j = 0; j <= mN; ++j) {
          for (long k = 0; k <= mN; ++k) {
            final Z b = nimMultiply(j, k);
            final Z det = nimSum(a, b);
            if (Z.ONE.equals(det)) {
              ++cnt;
            }
          }
        }
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A059970	0	->	1	A051775	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a051.A051775;

/**
 * A059970 Nim-factorials: a(1)=1 and, for n&gt;1, a(n)=n*a(n-1), where * denotes Nim multiplication.
 * @author Sean A. Irvine
 */
public class A059970 extends A051775 {

  private Z mF = Z.ONE;
  private long mN = 0;

  @Override
  public Z next() {
    mF = get(mF, Z.valueOf(++mN));
    return mF;
  }
}
#!queue	A060056	1	->	0	A059419	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a059.A059419;

/**
 * A060056 Nonzero numbers in expansion of ((tan(x))^4)/4! in (x^n)/n!.
 * @author Sean A. Irvine
 */
public class A060056 extends A059419 {

  private long mN = 2;

  @Override
  public Z next() {
    mN += 2;
    return get(mN, 4L);
  }
}
#!queue	A060057	1	->	0	A059419	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a059.A059419;

/**
 * A060057 Nonzero numbers in expansion of ((tan(x))^5)/5! in (x^n)/n!.
 * @author Sean A. Irvine
 */
public class A060057 extends A059419 {

  private long mN = 3;

  @Override
  public Z next() {
    mN += 2;
    return get(mN, 5L);
  }
}
#!queue	A060216	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060216 Number of orbits of length n under the full 13-shift (whose periodic points are counted by A001022).
 * @author Georg Fischer
 */
public class A060216 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 13;
  }
}
#!queue	A060217	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060217 Number of orbits of length n under the full 14-shift (whose periodic points are counted by A001023).
 * @author Georg Fischer
 */
public class A060217 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 14;
  }
}
#!queue	A060218	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060218 Number of orbits of length n under the full 15-shift (whose periodic points are counted by A001024).
 * @author Georg Fischer
 */
public class A060218 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 15;
  }
}
#!queue	A060219	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060219 Number of orbits of length n under the full 16-shift (whose periodic points are counted by A001025).
 * @author Georg Fischer
 */
public class A060219 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 16;
  }
}
#!queue	A060220	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060220 Number of orbits of length n under the full 17-shift (whose periodic points are counted by A001026).
 * @author Georg Fischer
 */
public class A060220 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 17;
  }
}
#!queue	A060221	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060221 Number of orbits of length n under the full 18-shift (whose periodic points are counted by A001027).
 * @author Georg Fischer
 */
public class A060221 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 18;
  }
}
#!queue	A060222	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060222 Number of orbits of length n under the full 19-shift (whose periodic points are counted by A001029).
 * @author Georg Fischer
 */
public class A060222 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 19;
  }
}
#!queue	A060335	1	->	3	A058876	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a058.A058876;

/**
 * A060335 Number of n-node labeled acyclic digraphs with 3 out-points.
 * @author Sean A. Irvine
 */
public class A060335 extends A058876 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3);
  }
}
#!queue	A060369	0	->	1	A060240	--------------------------------
package irvine.oeis.a060;

import java.util.HashMap;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;

/**
 * A060369 a(n) is the maximum number of occurrences of a degree in the sequence of the degrees of the irreducible representations of the symmetric group S_n.
 * @author Sean A. Irvine
 */
public class A060369 extends A060240 {

  private int mN = 0;

  @Override
  public Z next() {
    final IntegerPartition partitions = new IntegerPartition(++mN);
    final HashMap<Z, Long> counts = new HashMap<>();
    int[] p;
    while ((p = partitions.next()) != null) {
      final Z deg = degree(mN, p);
      counts.merge(deg, 1L, Long::sum);
    }
    long max = 0;
    for (final Long v : counts.values()) {
      if (v > max) {
        max = v;
      }
    }
    return Z.valueOf(max);
  }
}
#!queue	A060379	1	->	2	A002931	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A060379 Number of self-avoiding polygons on the 2-dimensional square lattice with perimeter 2n with at most 4 horizontal edges in each vertical cross-section.
 * @author Sean A. Irvine
 */
public class A060379 extends A002931 {

  {
    super.next();
  }

  private boolean isAcceptable(final Polygon polygon) {
    final int[] cnts = new int[100];
    Point prev = null;
    for (final Point pt : polygon) {
      if (prev == null) {
        prev = pt;
      } else {
        if (pt.right().equals(prev.right())) {
          // Horizontal line
          final int x = Math.min(pt.left(), prev.left());
          if (++cnts[x] > 4) {
            return false;
          }
        }
        prev = pt;
      }
    }
    return true;
  }

  protected Z postFilter() {
    long count = 0;
    for (final Polygon p : mPolygons) {
      if (isAcceptable(p)) {
        ++count;
      }
    }
    return Z.valueOf(count);
  }
}

#!queue	A060426	0	->	1	A060240	--------------------------------
package irvine.oeis.a060;

import java.util.HashMap;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;

/**
 * A060426 a(n) is the number of degrees in the sequence of the degrees of the irreducible representations of the symmetric group S_n that appear only once.
 * @author Sean A. Irvine
 */
public class A060426 extends A060240 {

  private int mN = 0;

  @Override
  public Z next() {
    final IntegerPartition partitions = new IntegerPartition(++mN);
    final HashMap<Z, Long> counts = new HashMap<>();
    int[] p;
    while ((p = partitions.next()) != null) {
      final Z deg = degree(mN, p);
      counts.merge(deg, 1L, Long::sum);
    }
    long uniqueCount = 0;
    for (final Long v : counts.values()) {
      if (v == 1) {
        ++uniqueCount;
      }
    }
    return Z.valueOf(uniqueCount);
  }
}
#!queue	A060437	0	->	1	A060240	--------------------------------
package irvine.oeis.a060;

import java.util.HashSet;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;

/**
 * A060437 a(n) is the number of different degrees in the sequence of the degrees of the irreducible representations of the symmetric group S_n, i.e., count each degree only once.
 * @author Sean A. Irvine
 */
public class A060437 extends A060240 {

  private int mN = 0;

  @Override
  public Z next() {
    final IntegerPartition partitions = new IntegerPartition(++mN);
    final HashSet<Z> seen = new HashSet<>();
    int[] p;
    while ((p = partitions.next()) != null) {
      final Z deg = degree(mN, p);
      seen.add(deg);
    }
    return Z.valueOf(seen.size());
  }
}
#!queue	A060688	0	->	1	A006156	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a006.A006156;

/**
 * A060688 Number of dissimilar ternary squarefree words of length n+1.
 * @author Georg Fischer
 */
public class A060688 extends A006156 {

  protected int mN;
  
  /** Construct the sequence. */
  public A060688() {
    mN = 0;
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(6);
  }
}
#!queue	A060701	1	->	0	A008302	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a008.A008302;

/**
 * A060701 Table by antidiagonals of Mahonian numbers T(n,k): permutations of n letters with k inversions.
 * @author Sean A. Irvine
 */
public class A060701 extends A008302 {

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mM, mN + 1 - mM);
  }
}
#!queue	A060974	0	->	1	A000367	--------------------------------
package irvine.oeis.a060;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A060974 Irregular primes with irregularity &gt; 1.
 * @author Sean A. Irvine
 */
public class A060974 extends A000367 {

  private final ArrayList<Z> mB = new ArrayList<>();
  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      int c = 0;
      final long q = mP / 2;
      while (mB.size() < q) {
        mB.add(super.next());
      }
      for (int k = 1; k <= (mP - 3) / 2; ++k) {
        if (mB.get(k).mod(mP) == 0 && ++c > 1) {
          return Z.valueOf(mP);
        }
      }
    }
  }
}
#!queue	A060975	0	->	1	A000367	--------------------------------
package irvine.oeis.a060;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A060975 Irregular primes with irregularity index three.
 * @author Sean A. Irvine
 */
public class A060975 extends A000367 {

  private final ArrayList<Z> mB = new ArrayList<>();
  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      int c = 0;
      final long q = mP / 2;
      while (mB.size() < q) {
        mB.add(super.next());
      }
      for (int k = 1; k <= (mP - 3) / 2; ++k) {
        if (mB.get(k).mod(mP) == 0 && ++c > 3) {
          break;
        }
      }
      if (c == 3) {
        return Z.valueOf(mP);
      }
    }
  }
}
#!queue	A060976	0	->	1	A000367	--------------------------------
package irvine.oeis.a060;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A060976 Odd nonprimes c which divide Bernoulli(2*c).
 * @author Sean A. Irvine
 */
public class A060976 extends A000367 {

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      mN += 2;
      super.next();
      if (super.next().mod(mN) == 0 && !mPrime.isPrime(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A060982	1	->	0	A061870	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a061.A061870;

/**
 * A060982 a(n) = Smallest nontrivial number k &gt; 9 such that |first (leftmost) decimal digit of k - second digit + third digit - fourth digit ...| = n.
 * @author Georg Fischer
 */
public class A060982 extends A061870 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    long k = 9;
    while (true) {
      ++k;
      if (Math.abs(alternatingDigitSum(String.valueOf(k))) == mN) {
        return Z.valueOf(k);
      }
    }
  }
}
#!queue	A061460	0	->	1	A000578	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A061460 Cubes which produce cubes when the leading digit is moved to the end.
 * @author Sean A. Irvine
 */
public class A061460 extends A000578 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      final String s = t.toString();
      if (ZUtils.isCube(new Z(s.substring(1) + s.charAt(0)))) {
        return t;
      }
    }
  }
}

#!queue	A061479	1	->	0	A061870	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;

/**
 * A061479 Smallest number m such that first digit - second digit + third digit - fourth digit ... (of m) = n.
 * @author Georg Fischer
 */
public class A061479 extends A061870 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    long k = -1;
    while (true) {
      ++k;
      if (alternatingDigitSum(String.valueOf(k)) == mN) {
        return Z.valueOf(k);
      }
    }
  }
}
#!queue	A061882	1	->	0	A061870	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;

/**
 * A061882 a(n) = Smallest nontrivial number k &gt; 9 such that first (leftmost) digit - second digit + third digit - fourth digit ... of k = n.
 * @author Georg Fischer
 */
public class A061882 extends A061870 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    long k = 9;
    while (true) {
      ++k;
      if (alternatingDigitSum(String.valueOf(k)) == mN) {
        return Z.valueOf(k);
      }
    }
  }
}
#!queue	A061885	1	->	0	A004201	--------------------------------
package irvine.oeis.a061;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a004.A004201;

/**
 * A061885 n + largest triangular number less than or equal to n.
 * @author Georg Fischer
 */
public class A061885 extends A004201 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A062556	0	->	1	A000578	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A062556 Cubes that are the concatenation of three numbers, one of which is the sum of the other two.
 * @author Sean A. Irvine
 */
public class A062556 extends A000578 {

  @Override
  public Z next() {
    while (true) {
      final Z sq = super.next();
      final String s = sq.toString();
      for (int k = 1; k < s.length() - 1; ++k) {
        final Z a = new Z(s.substring(0, k));
        if (s.charAt(k) != '0') {
          for (int j = k + 1; j < s.length(); ++j) {
            if (s.charAt(j) != '0') {
              final Z b = new Z(s.substring(k, j));
              final Z c = new Z(s.substring(j));
              if (a.equals(b.add(c)) || b.equals(a.add(c)) || c.equals(a.add(b))) {
                return sq;
              }
            }
          }
        }
      }
    }
  }
}
#!queue	A062686	0	->	1	A000578	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;
import irvine.util.array.LongDynamicArray;

/**
 * A062686 Smallest cube with digit sum n (or 0 if no such cube exists).
 * @author Sean A. Irvine
 */
public class A062686 extends A000578 {

  private final LongDynamicArray<Z> mFirsts = new LongDynamicArray<>();
  private long mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    final long r = ++mN % 9;
    if (r >= 2 && r <= 7) {
      return Z.ZERO;
    }
    while (mFirsts.get(mN) == null) {
      final Z cube = super.next();
      final long d = ZUtils.digitSum(cube);
      if (mFirsts.get(d) == null) {
        mFirsts.set(d, cube);
      }
    }
    return mFirsts.get(mN);
  }
}
#!queue	A063079	0	->	1	A001790	--------------------------------
package irvine.oeis.a063;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001790;


/**
 * A063079 Bisection of A001790.
 * @author Georg Fischer
 */
public class A063079 extends A001790 {

  /** Construct the sequence. */
  public A063079() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A063603	0	->	1	A063115	--------------------------------
package irvine.oeis.a063;
// Generated by gen_seq4.pl parm3 at 2021-05-31 07:18
// DO NOT EDIT here!

/**
 * A063603 Smallest k such that 6^k has exactly n 7's in its decimal representation.
 * @author Georg Fischer
 */
public class A063603 extends A063115 {

  /** Construct the sequence. */
  public A063603() {
    super(6, 7);
  }
}
#!queue	A063686	1	->	0	A048887	--------------------------------
package irvine.oeis.a063;

import irvine.math.api.Matrix;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.z.Euler;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a048.A048887;

/**
 * A063686 Triangular array: a(n,k) is the number of binary necklaces (no turning over) of length n whose longest run of 1's has length k. Table begins at n=0, k=0.
 * @author Sean A. Irvine
 */
public class A063686 extends A048887 {

  // After Andrew Howroyd

  private int mN = -1;
  private int mM = 0;
  private Matrix<Z> mT;

  private Matrix<Z> r(final int n) {
    final Matrix<Z> mat = new DefaultMatrix<>(n, n, Z.ZERO);
    for (long r = 0; r < mat.rows(); ++r) {
      for (long k = 0; k < mat.cols(); ++k) {
        mat.set(r, k, get(r + 1, k + 1));
      }
    }
    return mat;
  }

  private Z sum(final Matrix<Z> m, final long n, final int k) {
    return Integers.SINGLETON.sum(1, k, j -> m.get(n - j - 1, k).subtract(m.get(n - j - 1, k - 1L)).multiply(j));
  }

  private Matrix<Z> s(final Matrix<Z> m) {
    final Matrix<Z> mat = new DefaultMatrix<>(m.rows() - 1, m.cols() - 1, Z.ZERO);
    for (int n = 1; n <= mat.rows(); ++n) {
      for (int k = 1; k <= mat.cols(); ++k) {
        if (k < n - 1) {
          mat.set(n - 1, k - 1, m.get(n - k - 2, k).multiply(k + 1).add(sum(m, n, k)));
        } else if (k < n) {
          mat.set(n - 1, k - 1, Z.valueOf(n));
        }
      }
    }
    return mat;
  }

  private Matrix<Z> t(final int n) {
    final Matrix<Z> m = s(r(n + 1));
    final Matrix<Z> mat = new DefaultMatrix<>(n, n, Z.ZERO);
    for (int row = 1; row <= n; ++row) {
      final int r = row;
      for (int col = 1; col <= n; ++col) {
        final int c = col;
        final Z s = Integers.SINGLETON.sumdiv(r, d -> c < d ? m.get(d - 1, c - 1).multiply(Euler.phi((long) r / d)) : Z.ZERO).divide(r);
        mat.set(row - 1, col - 1, row == col ? s.add(1) : s);
      }
    }
    return mat;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
      mT = t(mN);
    }
    return mM == 0 ? Z.ONE : mT.get(mN - 1, mM - 1);
  }
}
#!queue	A063884	0	->	1	MemorySequence	--------------------------------
package irvine.oeis.a063;

import java.util.HashSet;
import java.util.TreeSet;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;

/**
 * A063884 a(1) = 2, a(2) = 3 and a(k+1) is the least prime not already chosen that divides some a(i)*a(j)+1, where 1&lt;=i&lt;=j&lt;=k.
 * @author Sean A. Irvine
 */
public class A063884 extends MemorySequence {

  protected final TreeSet<Z> mA = new TreeSet<>();
  protected final HashSet<Z> mUsed = new HashSet<>();
  {
    mA.add(Z.TWO);
    mA.add(Z.THREE);
  }

  protected void update(final Z n) {
    for (final Z p : Jaguar.factor(n).toZArray()) {
      if (!mUsed.contains(p)) {
        mA.add(p);
      }
    }
  }

  @Override
  protected Z computeNext() {
    final Z t = mA.pollFirst();
    mUsed.add(t);
    update(t.square().add(1)); // needed because we did not yet add to the sequence
    for (final Z v : this) {
      update(v.multiply(t).add(1));
    }
    return t;
  }
}
#!queue	A063904	0	->	1	A063884	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;

/**
 * A063904 a(1) = 2, a(2) = 3 and a(k+1) is the least prime not already chosen that divides some a(i)*a(j)+1, where 1&lt;=i&lt;j&lt;=k.
 * @author Sean A. Irvine
 */
public class A063904 extends A063884 {

  @Override
  protected Z computeNext() {
    final Z t = mA.pollFirst();
    mUsed.add(t);
    for (final Z v : this) {
      update(v.multiply(t).add(1));
    }
    return t;
  }
}
#!queue	A063993	1	->	0	A319797	--------------------------------
package irvine.oeis.a063;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319797;

/**
 * A063993 Number of ways of writing n as an unordered sum of exactly 3 nonzero triangular numbers.
 * @author Georg Fischer
 */
public class A063993 extends A319797 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A064032	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064032 Product of unitary divisors of central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A064032 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z f = super.next();
    return f.pow(Jaguar.factor(f).unitarySigma0().divide2());
  }
}
#!queue	A064033	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064033 Product of non-unitary divisors of central binomial coefficients or a(n)=1 if all divisors are unitary. See A046098.
 * @author Sean A. Irvine
 */
public class A064033 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z f = super.next();
    final FactorSequence fs = Jaguar.factor(f);
    return f.pow(fs.sigma0().subtract(fs.unitarySigma0()).divide2());
  }
}
#!queue	A064068	1	->	0	A000233	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000233;

/**
 * A064068 Generalized Euler number c(7,n).
 * @author Sean A. Irvine
 */
public class A064068 extends A000233 {

  @Override
  protected int getA() {
    return 7;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A064069	1	->	0	A000233	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000233;

/**
 * A064069 Generalized Euler number c(8,n).
 * @author Sean A. Irvine
 */
public class A064069 extends A000233 {

  @Override
  protected int getA() {
    return 8;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A064070	1	->	0	A000233	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000233;

/**
 * A064070 Generalized Euler number c(9,n).
 * @author Sean A. Irvine
 */
public class A064070 extends A000233 {

  @Override
  protected int getA() {
    return 9;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A064071	1	->	0	A000233	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000233;

/**
 * A064071 Generalized Euler number c(10,n).
 * @author Sean A. Irvine
 */
public class A064071 extends A000233 {

  @Override
  protected int getA() {
    return 10;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A064139	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064139 Sum of divisors of central binomial coefficient C(n, floor(n/2)).
 * @author Georg Fischer
 */
public class A064139 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A064140	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064140 Sum of unitary divisors of central binomial coefficient C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A064140 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).unitarySigma();
  }
}
#!queue	A064141	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064141 Sum of non-unitary divisors of central binomial coefficient C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A064141 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = Jaguar.factor(super.next());
    return fs.sigma().subtract(fs.unitarySigma());
  }
}
#!queue	A064142	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064142 Sum of all distinct primes dividing central binomial coefficient C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A064142 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sopf();
  }
}
#!queue	A064143	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064143 Sum of unitary prime divisors (A056169, A034444) of central binomial coefficient C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A064143 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z sum = Z.ZERO;
    final FactorSequence fs = Jaguar.factor(super.next());
    for (final Z p : fs.toZArray()) {
      if (fs.getExponent(p) == 1) {
        sum = sum.add(p);
      }
    }
    return sum;
  }
}
#!queue	A064146	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064146 Sum of non-unitary prime divisors (A034444, A056169) of central binomial coefficient C(n,floor(n/2)) (A001405). If A001405(n) is squarefree (A046098) then a(n)=0.
 * @author Sean A. Irvine
 */
public class A064146 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z sum = Z.ZERO;
    final FactorSequence fs = Jaguar.factor(super.next());
    for (final Z p : fs.toZArray()) {
      if (fs.getExponent(p) != 1) {
        sum = sum.add(p);
      }
    }
    return sum;
  }
}
#!queue	A065205	0	->	1	A033630	--------------------------------
package irvine.oeis.a065;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a033.A033630;

/**
 * A065205 Number of subsets of proper divisors of n that sum to n.
 * @author Georg Fischer
 */
public class A065205 extends A033630 {

  protected int mN;
  
  /** Construct the sequence. */
  public A065205() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(1);
  }
}
#!queue	A065451	1	->	0	A000010	--------------------------------
package irvine.oeis.a065;
// manually knest at 2023-03-02 11:48

import irvine.math.z.Fibonacci;
import irvine.math.z.Z;
import irvine.oeis.a000.A000010;

/**
 * A065451 a(n) = Fibonacci(phi(n)), a(0) = 0.
 * @author Georg Fischer
 */
public class A065451 extends A000010 {

  private int mN = -1;

  @Override
  public Z next() {
    return (++mN == 0) ? Z.ZERO : Fibonacci.fibonacci(super.next().intValue());
  }
}

#!queue	A066221	1	->	0	A001189	--------------------------------
package irvine.oeis.a066;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001189;


/**
 * A066221 Bisection of A001189.
 * @author Georg Fischer
 */
public class A066221 extends A001189 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A066222	1	->	0	A001189	--------------------------------
package irvine.oeis.a066;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001189;


/**
 * A066222 Bisection of A001189.
 * @author Georg Fischer
 */
public class A066222 extends A001189 {

  /** Construct the sequence. */
  public A066222() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A066973	0	->	1	A000984	--------------------------------
package irvine.oeis.a066;
// Generated by gen_seq4.pl knest/eulphi at 2023-03-01 20:54

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A066973 a(n) = phi(binomial(2n, n)).
 * @author Georg Fischer
 */
public class A066973 extends A000984 {

  {
    super.next();
  }


  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A067063	0	->	2	A002275	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A067063 Smallest prime factor of repunit(n) = (10^n-1)/9 (A002275).
 * @author Georg Fischer
 */
public class A067063 extends A002275 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A067434	0	->	1	A000984	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A067434 Number of distinct prime factors in binomial(2*n,n).
 * @author Georg Fischer
 */
public class A067434 extends A000984 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A067480	0	->	1	A008952	--------------------------------
package irvine.oeis.a067;

import irvine.math.z.Z;
import irvine.oeis.a008.A008952;

/**
 * A067480 Powers of 2 with initial digit 2.
 * @author Georg Fischer
 */
public class A067480 extends A008952 {

  protected int mN;
  protected Z mDigit;

  /** Construct the sequence. */
  public A067480() {
    this(0, 2);
  }

  /**
   * Generic constructor with parameters
   * @param digit leading digit
   */
  public A067480(final int digit) {
    this(0, digit);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param digit leading digit
   */
  public A067480(final int offset, final int digit) {
    super(offset);
    mN = -1;
    mDigit = Z.valueOf(digit);
  }

  @Override
  public Z next() {
    ++mN;
    while (!super.next().equals(mDigit)) {
      ++mN;
    }
    return Z.ONE.shiftLeft(mN);
  }
}
#!queue	A067570	0	->	1	A067553	--------------------------------
package irvine.oeis.a067;

import irvine.math.z.Z;
import irvine.oeis.a000.A000009;

/**
 * A067570 Numbers n such that A000009(n) divides A067553(n).
 * @author Sean A. Irvine
 */
public class A067570 extends A067553 {

  private final A000009 mS = new A000009();
  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().mod(mS.next()).isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A067689	0	->	1	A005249	--------------------------------
package irvine.oeis.a067;
// manually n2/n2add1

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000984;
import irvine.oeis.a005.A005249;

/**
 * A067689 Inverse of determinant of n X n matrix whose (i,j)-th element is 1/(i+j).
 * Equals A005249 * A000984.
 * @author Georg Fischer
 */
public class A067689 extends A005249 {

  private final Sequence mSeq = new A000984();

  {
    next();
  }

  @Override
  public Z next() {
    return super.next().multiply(mSeq.next());
  }
}
#!queue	A067819	0	->	1	A000984	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A067819 Sum of the divisors of binomial(2n,n).
 * @author Georg Fischer
 */
public class A067819 extends A000984 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A068945	1	->	0	A068943	--------------------------------
package irvine.oeis.a068;

import irvine.math.z.Z;

/**
 * A068945 Number of ones in the binary expansion of A068943(n).
 * @author Sean A. Irvine
 */
public class A068945 extends A068943 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return Z.valueOf(super.next().bitCount());
  }
}

#!queue	A069060	0	->	1	A000051	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl knest at 2023-03-02 20:46

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000051;

/**
 * A069060 Product of divisors of 2^n + 1.
 * @author Georg Fischer
 */
public class A069060 extends A000051 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).pod();
  }
}
#!queue	A069061	0	->	1	A000051	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000051;

/**
 * A069061 Sum of divisors of 2^n+1.
 * @author Georg Fischer
 */
public class A069061 extends A000051 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A069112	0	->	1	A000225	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl knest at 2023-03-02 20:46

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A069112 Squarefree part of 2^n-1 : the smallest number such that a(n)*(2^n-1) is a square.
 * @author Georg Fischer
 */
public class A069112 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).core();
  }
}
#!queue	A070834	0	->	1	A004086	--------------------------------
package irvine.oeis.a070;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a004.A004086;

/**
 * A070834 Reverse(n)^n.
 * @author Georg Fischer
 */
public class A070834 extends A004086 {

  protected int mN;
  
  /** Construct the sequence. */
  public A070834() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().pow(mN);
  }
}
#!queue	A073331	1	->	2	A002034	--------------------------------
package irvine.oeis.a073;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002034;

/**
 * A073331 Smallest k such that S(n) = d(n+k), where S(n) is the Kempner function (A002034) and d(n) is the number of divisors of n (A000005).
 * @author Sean A. Irvine
 */
public class A073331 extends A002034 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final long v = super.next().longValue();
    long k = 0;
    while (true) {
      ++k;
      if (v == Jaguar.factor(mN + k).sigma0AsLong()) {
        return Z.valueOf(k);
      }
    }
  }
}

#!queue	A075708	0	->	1	A000225	--------------------------------
package irvine.oeis.a075;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A075708 Sum of the divisors of 2^n - 1.
 * @author Georg Fischer
 */
public class A075708 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A075754	0	->	5	A008300	--------------------------------
package irvine.oeis.a075;

import irvine.math.z.Z;
import irvine.oeis.a008.A008300;

/**
 * A075754 Number of n X n (0,1) matrices containing exactly five 1's in each row and in each column.
 * @author Sean A. Irvine
 */
public class A075754 extends A008300 {

  private int mN = 4;

  @Override
  public Z next() {
    return t(++mN, 5);
  }
}
#!queue	A077805	0	->	1	A007088	--------------------------------
package irvine.oeis.a077;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A077805 Smallest prime factor of numbers containing in their decimal representation only the digits 0 and 1.
 * @author Georg Fischer
 */
public class A077805 extends A007088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A077807	0	->	1	A007088	--------------------------------
package irvine.oeis.a077;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A077807 Number of distinct prime factors of numbers containing in their decimal representation only the digits 0 and 1.
 * @author Georg Fischer
 */
public class A077807 extends A007088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A077808	0	->	1	A007088	--------------------------------
package irvine.oeis.a077;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A077808 Number of prime factors of numbers containing in their decimal representation only the digits 0 and 1 (counted with multiplicity).
 * @author Georg Fischer
 */
public class A077808 extends A007088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A077811	0	->	1	A007088	--------------------------------
package irvine.oeis.a077;
// manually knest/eulphi at 2023-03-01 16:41

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A077811 Euler's totient of numbers containing in their decimal representation only the digits 0 and 1.
 * @author Georg Fischer
 */
public class A077811 extends A007088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A079313	0	->	1	A080032	--------------------------------
package irvine.oeis.a079;

import irvine.math.z.Z;
import irvine.oeis.a080.A080032;

/**
 * A079313 a(n) is taken to be the smallest positive integer not already present which is consistent with the condition "n is a member of the sequence if and only if a(n) is odd".
 * @author Georg Fischer
 */
public class A079313 extends A080032 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A080036	2	->	0	A003057	--------------------------------
package irvine.oeis.a080;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a003.A003057;

/**
 * A080036 a(n) = n + round(sqrt(2*n)) + 1.
 * @author Georg Fischer
 */
public class A080036 extends A003057 {

  protected int mN;
  
  /** Construct the sequence. */
  public A080036() {
    mN = -1;
  }

  @Override
  public Z next() {
    ++mN;
    return mN == 0 ? Z.ONE : super.next().add(mN);
  }
}
#!queue	A080757	1	->	0	A007538	--------------------------------
package irvine.oeis.a080;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a007.A007538;

/**
 * A080757 First differences of Beatty sequence A022838(n) = floor(n sqrt(3)).
 * @author Georg Fischer
 */
public class A080757 extends A007538 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A081256	-1	->	1	A001093	--------------------------------
package irvine.oeis.a081;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001093;

/**
 * A081256 Greatest prime factor of n^3 + 1.
 * @author Georg Fischer
 */
public class A081256 extends A001093 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A081689	1	->	0	A005228	--------------------------------
package irvine.oeis.a081;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a005.A005228;

/**
 * A081689 A005228 - 1.
 * @author Georg Fischer
 */
public class A081689 extends A005228 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A085588	1	->	3	A085587	--------------------------------
package irvine.oeis.a085;

import irvine.math.z.Z;

/**
 * A085588 Maximal cycle lengths in a certain class of one-dimensional cellular automata.
 * @author Sean A. Irvine
 */
public class A085588 extends A085587 {

  {
    super.next();
    super.next();
  }

  @Override
  protected Z step(final Z state) {
    final Z a = state.divide2().or(state.and(Z.ONE).shiftLeft(mN - 1));
    final Z b = state.clearBit(mN - 1).multiply2().add(state.testBit(mN - 1) ? 1 : 0);
    return a.xor(b).xor(state);
  }
}
#!queue	A085719	1	->	0	A085244	--------------------------------
package irvine.oeis.a085;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Z;

/**
 * A085719 Permanent of n X n matrix whose rows are cyclic permutations of 1..n.
 * @author Georg Fischer
 */
public class A085719 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Z.valueOf(1 + (j + i) % n));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A086325	0	->	1	A000166	--------------------------------
package irvine.oeis.a086;
// manually 2021-09-25

import irvine.math.z.Z;
import irvine.oeis.a000.A000166;

/**
 * A086325 Let u(1)=0, u(2)=1, u(k)=u(k-1)+u(k-2)/(k-2); then a(n)=n!*u(n). 
 * @author Georg Fischer
 */
public class A086325 extends A000166 {

  /** Construct the sequence. */
  public A086325() {
    super.next(); // skip A000166(0)
  }

  @Override
  public Z next() {
    return super.next().multiply(mN);
  }
}
#!queue	A087173	0	->	1	A000041	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A087173 Smallest prime factor of n-th partition number.
 * @author Georg Fischer
 */
public class A087173 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A087175	0	->	1	A000041	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A087175 Number of distinct primes dividing the n-th partition number.
 * @author Georg Fischer
 */
public class A087175 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A089626	0	->	1	A057863	--------------------------------
package irvine.oeis.a089;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a057.A057863;

/**
 * A089626 a(n) = 1/h(n) where {h(n)} is the Hankel transform of {t(n)}; t(n) is defined by the expansion of tan(x)= Sum_n&gt;0, t(n)*x^(2*n-1); |x|&lt;Pi/2.
 * @author Georg Fischer
 */
public class A089626 extends A057863 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A091696	0	->	1	A000029	--------------------------------
package irvine.oeis.a091;

import irvine.math.z.Z;
import irvine.oeis.a000.A000029;

/**
 * A091696 Number of classes of compositions of n equivalent under reflection or cycling.
 * @author Sean A. Irvine
 */
public class A091696 extends A000029 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}

#!queue	A091711	0	->	1	A088020	--------------------------------
package irvine.oeis.a091;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a088.A088020;

/**
 * A091711 Exponent of 2 in (n^2)!.
 * @author Georg Fischer
 */
public class A091711 extends A088020 {

  /** Construct the sequence. */
  public A091711() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.TWO));
  }
}
#!queue	A091828	0	->	1	A000254	--------------------------------
package irvine.oeis.a091;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000254;

/**
 * A091828 a(n)=n-2*valuation(A000254(n),3).
 * @author Georg Fischer
 */
public class A091828 extends A000254 {

  private int mN;

  /** Construct the sequence. */
  public A091828() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(mN - 2 * ZUtils.valuation(super.next(), Z.THREE));
  }
}
#!queue	A093952	0	->	1	A000041	--------------------------------
package irvine.oeis.a093;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A093952 Partition number A000041(n) mod n.
 * @author Georg Fischer
 */
public class A093952 extends A000041 {

  private Z mN = Z.ZERO;

  {
    super.next();
  }

  @Override
  public Z next() {
    mN = mN.add(1);
    return super.next().mod(mN);
  }
}
#!queue	A094155	1	->	2	A000939	--------------------------------
package irvine.oeis.a094;
// Generated by gen_seq4.pl bisect at 2021-07-05 13:13
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000939;


/**
 * A094155 Bisection of A000939.
 * @author Georg Fischer
 */
public class A094155 extends A000939 {

  /** Construct the sequence. */
  public A094155() {
    super.next();
    super.next();
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A094156	3	->	1	A000940	--------------------------------
package irvine.oeis.a094;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000940;


/**
 * A094156 Bisection of A000940.
 * @author Georg Fischer
 */
public class A094156 extends A000940 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A094157	3	->	2	A000940	--------------------------------
package irvine.oeis.a094;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000940;


/**
 * A094157 Bisection of A000940.
 * @author Georg Fischer
 */
public class A094157 extends A000940 {

  /** Construct the sequence. */
  public A094157() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A095250	0	->	1	A002275	--------------------------------
package irvine.oeis.a095;
// Generated by gen_seq4.pl seqop a002 A002275 mod(Z.valueOf(mN)) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A095250 a(n) = 11111111... (n times) = (10^n-1)/9 reduced mod n.
 * @author Georg Fischer
 */
public class A095250 extends A002275 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A095250() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A095370	0	->	1	A002275	--------------------------------
package irvine.oeis.a095;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A095370 Number of distinct prime factors of the repunit (-1 + 10^n)/9.
 * @author Georg Fischer
 */
public class A095370 extends A002275 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A096010	0	->	1	A000016	--------------------------------
package irvine.oeis.a096;
// Generated by gen_seq4.pl seqop a000 A000016 add(1) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000016;

/**
 * A096010 Number of different cycles computed with the generalized 3x+1 problem using C=2, B=Cn+m, A=C^m.
 * @author Georg Fischer
 */
public class A096010 extends A000016 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A096010() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().add(1);
  }
}
#!queue	A099061	1	->	0	A000960	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000960;


/**
 * A099061 A bisection of A000960.
 * @author Georg Fischer
 */
public class A099061 extends A000960 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099062	1	->	0	A000960	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000960;


/**
 * A099062 A bisection of A000960.
 * @author Georg Fischer
 */
public class A099062 extends A000960 {

  /** Construct the sequence. */
  public A099062() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099076	1	->	0	A000960	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl seqop a000 A000960 mod(Z.THREE) 1 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000960;

/**
 * A099076 a(n) = A000960(n) mod 3.
 * @author Georg Fischer
 */
public class A099076 extends A000960 {
  private int mN = -1;
  
  /** Construct the sequence. */
  public A099076() {
    super();
    int bOffset = 0;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.THREE);
  }
}
#!queue	A099198	0	->	1	A002807	--------------------------------
package irvine.oeis.a099;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a002.A002807;

/**
 * A099198 A bisection of A002807.
 * @author Georg Fischer
 */
public class A099198 extends A002807 {

  /** Construct the sequence. */
  public A099198() {
    super.next();
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099774	0	->	1	A005408	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl sigman0/sigma0 at 2023-02-28 21:57

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a005.A005408;

/**
 * A099774 Number of divisors of 2*n-1.
 * @author Georg Fischer
 */
public class A099774 extends A005408 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A099821	0	->	1	A007088	--------------------------------
package irvine.oeis.a099;
// manually (bisect) 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A099821 Odd positive integers in base 2 (bisection of A007088).
 * @author Georg Fischer
 */
public class A099821 extends A007088 {

  /** Construct the sequence. */
  public A099821() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099980	1	->	0	A001358	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001358;


/**
 * A099980 Bisection of A001358.
 * @author Georg Fischer
 */
public class A099980 extends A001358 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099981	1	->	0	A001358	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001358;


/**
 * A099981 Bisection of A001358.
 * @author Georg Fischer
 */
public class A099981 extends A001358 {

  /** Construct the sequence. */
  public A099981() {
    super.next();
  }

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099982	1	->	0	A000043	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000043;


/**
 * A099982 Bisection of A000043.
 * @author Georg Fischer
 */
public class A099982 extends A000043 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099983	1	->	0	A000043	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000043;


/**
 * A099983 Bisection of A000043.
 * @author Georg Fischer
 */
public class A099983 extends A000043 {
  
  /** Construct the sequence. */
  public A099983() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A100031	1	->	0	A005384	--------------------------------
package irvine.oeis.a100;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a005.A005384;


/**
 * A100031 Bisection of A005384.
 * @author Georg Fischer
 */
public class A100031 extends A005384 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A100032	1	->	0	A005384	--------------------------------
package irvine.oeis.a100;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a005.A005384;


/**
 * A100032 Bisection of A005384.
 * @author Georg Fischer
 */
public class A100032 extends A005384 {

  /** Construct the sequence. */
  public A100032() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A100430	1	->	0	A002417	--------------------------------
package irvine.oeis.a100;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a002.A002417;


/**
 * A100430 Bisection of A002417.
 * @author Georg Fischer
 */
public class A100430 extends A002417 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A100637	1	->	0	A000720	--------------------------------
package irvine.oeis.a100;
// manually at 2021-07-04

import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A100637 Trisection of A000720.
 * @author Georg Fischer
 */
public class A100637 extends A000720 {

  /** Construct the sequence. */
  public A100637() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A100868	0	->	1	A050946	--------------------------------
package irvine.oeis.a100;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a050.A050946;

/**
 * A100868 a(n) = Sum_{k&gt;0} k^(2n-1)/phi^(2k) where phi = (1+sqrt(5))/2 = A001622.
 * @author Georg Fischer
 */
public class A100868 extends A050946 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A102445	0	->	1	A002426	--------------------------------
package irvine.oeis.a102;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002426;

/**
 * A102445 Number of prime divisors (counted with multiplicity) of the central trinomial coefficients (A002426).
 * @author Georg Fischer
 */
public class A102445 extends A002426 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A103759	0	->	1	A002275	--------------------------------
package irvine.oeis.a103;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A103759 a(n) = sigma((10^n - 1)/9), where sigma(n) is the sum of positive divisors of n.
 * @author Georg Fischer
 */
public class A103759 extends A002275 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A104742	0	->	6	A269920	--------------------------------
package irvine.oeis.a104;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A104742 Number of rooted maps of (orientable) genus 3 containing n edges.
 * @author Sean A. Irvine
 */
public class A104742 extends A269920 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 3, k));
    }
    return sum;
  }
}
#!queue	A106737	1	->	0	A005940	--------------------------------
package irvine.oeis.a106;
// Generated by gen_seq4.pl sigman0/sigma0 at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a005.A005940;

/**
 * A106737 a(n) = Sum_{k=0..n} ({binomial(n+k,n-k)*binomial(n,k)} mod 2).
 * @author Georg Fischer
 */
public class A106737 extends A005940 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A108235	1	->	0	A002849	--------------------------------
package irvine.oeis.a108;
// manually n2 at 2023-05-02 19:56

import irvine.math.z.Z;
import irvine.oeis.a002.A002849;

/**
 * A108235 Number of partitions of {1,2,...,3n} into n triples (X,Y,Z) each satisfying X+Y=Z.
 * <code>a(n) = 0 unless n == 0 or 1 (mod 4). For n == 0 or 1 (mod 4), a(n) = A002849(3n).</code>
 * @author Georg Fischer
 */
public class A108235 extends A002849 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    if (mN == 0) {
      return Z.ONE;
    }
    if (mN % 4 <= 1) {
      super.next();
      super.next();
      return super.next();
    } else {
      super.next();
      super.next();
      super.next();
      return Z.ZERO;
    }
  }
}
#!queue	A110369	0	->	1	A002275	--------------------------------
package irvine.oeis.a110;
// Generated by gen_seq4.pl seqop a002 A002275 add(mN) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A110369 (Digit 1 repeated n times) + n.
 * @author Georg Fischer
 */
public class A110369 extends A002275 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A110369() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().add(mN);
  }
}
#!queue	A113773	0	->	1	A008352	--------------------------------
package irvine.oeis.a113;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a008.A008352;

/**
 * A113773 Number of distinct prime factors of A008352.
 * @author Sean A. Irvine
 */
public class A113773 extends A008352 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));

  {
    super.next(); // skip 0th term
  }

  @Override
  public Z next() {
    final Z n = super.next();
    if (mVerbose) {
      System.err.println("[" + n + "]");
    }
    return Z.valueOf(Jaguar.factor(n).omega());
  }
}


#!queue	A115000	1	->	5	A007434	--------------------------------
package irvine.oeis.a115;

import irvine.math.z.Z;
import irvine.oeis.a007.A007434;

/**
 * A115000 a(n) = J_2(n) / 24.
 * @author Sean A. Irvine
 */
public class A115000 extends A007434 {

  {
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(24);
  }
}
#!queue	A115322	0	->	1	A053117	--------------------------------
package irvine.oeis.a115;
// manually deris/essent at 2022-04-27 19:28

import irvine.math.z.Z;
import irvine.oeis.a053.A053117;

/**
 * A115322 Triangle of coefficients of Pell polynomials.
 * @author Georg Fischer
 */
public class A115322 extends A053117 {

  @Override
  public Z next() {
    return super.next().abs();
  }
}
#!queue	A116941	1	->	0	A074147	--------------------------------
package irvine.oeis.a116;
// Generated by gen_seq4.pl dersimple at 2022-12-15 23:30

import irvine.math.z.Z;
import irvine.oeis.a074.A074147;

/**
 * A116941 Permutation of the natural numbers in conjunction with A116939 and A003056.
 * @author Georg Fischer
 */
public class A116941 extends A074147 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A117601	0	->	1	A000931	--------------------------------
package irvine.oeis.a117;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000931;

/**
 * A117601 Padovan numbers which are divisible by the sum of their digits.
 * @author Georg Fischer
 */
public class A117601 extends A000931 {
    
  protected int mN;
  
  /** Construct the sequence. */
  public A117601() {
    mN = 0;
    for (int n = 0; n <= 12; ++n) { // skip leading terms with duplicates
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    if (mN <= 5) {
      return Z.valueOf(mN); // fixed terms
    }
    Z result = super.next();
    while (! result.remainder(Z.valueOf(ZUtils.digitSum(result))).equals(Z.ZERO)) {
      result = super.next();
    }
    return result;
  }
}
#!queue	A121355	0	->	1	A121357	--------------------------------
package irvine.oeis.a121;

import java.util.ArrayList;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A121355 Number of transitive PSL_2(ZZ) actions on a finite labeled set of size n.
 * @author Sean A. Irvine
 */
public class A121355 extends A121357 {

  private final ArrayList<Q> mA = new ArrayList<>();

  {
    super.next();
    mA.add(Q.ZERO);
  }

  @Override
  public Z next() {
    mA.add(super.nextQ());
    return RING.log1p(RING.create(mA), mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A121358	0	->	1	A000292	--------------------------------
package irvine.oeis.a121;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000292;

/**
 * A121358 Least prime factor of pyramidal number A000292(n), a(1) = 1.
 * @author Georg Fischer
 */
public class A121358 extends A000292 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A123467	0	->	1	A000081	--------------------------------
package irvine.oeis.a123;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a000.A000081;

/**
 * A123467 Number of trivially-perfect graphs on n nodes.
 * @author Georg Fischer
 */
public class A123467 extends A000081 {

  /** Construct the sequence. */
  public A123467() {
    skip(2);
  }
}
#!queue	A126772	0	->	1	A000931	--------------------------------
package irvine.oeis.a126;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A126772 Padovan factorials: a(n) is the product of the first n terms of the Padovan sequence. Similar to the Fibonacci factorial.
 * @author Georg Fischer
 */
public class A126772 extends A000931 {

  protected Z mFact;

  /** Construct the sequence. */
  public A126772() {
    for (int i = 0; i <= 4; ++i) {
      super.next();
    }
    mFact = Z.ONE;
  }

  @Override
  public Z next() {
    mFact = mFact.multiply(super.next());
    return mFact;
  }
}
#!queue	A129184	0	->	1	A010054	--------------------------------
package irvine.oeis.a129;
// manually transpose at 2021-11-10

import irvine.oeis.a010.A010054;

/**
 * A129184 Shift operator, right.
 * @author Georg Fischer
 */
public class A129184 extends A010054 {

  /** Construct the sequence. */
  public A129184() {
    super.next();
    super.next();
  }
}
#!queue	A129335	0	->	1	A006882	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl knest/eulphi at 2023-03-01 20:54

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A129335 a(n) = phi(n!!) where phi is the Euler totient function. In other words, a(n) = A000010(A006882(n)).
 * @author Georg Fischer
 */
public class A129335 extends A006882 {

  {
    super.next();
  }


  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A129527	1	->	0	A000265	--------------------------------
package irvine.oeis.a129;

import irvine.math.z.Z;
import irvine.oeis.a000.A000265;

/**
 * A129527 a(2n) = a(n) + 2n, a(2n+1) = 2n + 1.
 * @author Georg Fischer
 */
public class A129527 extends A000265 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return mN == 0 ? Z.ZERO : Z.TWO.multiply(mN).subtract(super.next());
  }
}
#!queue	A129759	0	->	1	A000793	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000793;

/**
 * A129759 For the Landau function L(n), A000793, this sequence gives the largest prime which is a factor of L(n).
 * @author Georg Fischer
 */
public class A129759 extends A000793 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A131535	1	->	0	A131541	--------------------------------
package irvine.oeis.a131;

/**
 * A131535 Least power of 2 having exactly n consecutive 1's in its decimal representation.
 * @author Sean A. Irvine
 */
public class A131535 extends A131541 {

  @Override
  protected long start() {
    return -1;
  }

  @Override
  protected int getSpecialDigit() {
    return 1;
  }
}

#!queue	A131536	1	->	0	A131541	--------------------------------
package irvine.oeis.a131;

/**
 * A131536 Least power of 2 having exactly n consecutive 2's in its decimal representation.
 * @author Sean A. Irvine
 */
public class A131536 extends A131541 {

  @Override
  protected long start() {
    return -1;
  }

  @Override
  protected int getSpecialDigit() {
    return 2;
  }
}

#!queue	A133457	0	->	1	A048793	--------------------------------
package irvine.oeis.a133;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a048.A048793;

/**
 * A133457 Irregular triangle read by rows: row n gives exponents in expression for n as a sum of powers of 2.
 * @author Georg Fischer
 */
public class A133457 extends A048793 {

  protected int mN;
  
  /** Construct the sequence. */
  public A133457() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(1);
  }
}
#!queue	A133687	1	->	0	A227061	--------------------------------
package irvine.oeis.a133;

import irvine.math.z.Z;
import irvine.oeis.a227.A227061;
import irvine.util.Permutation;

/**
 * A133687 Triangle with number of equivalence classes of n X n matrices over {0,1} with rows and columns summing to k (0&lt;=k&lt;=n), where equivalence is defined by row and column permutations.
 * @author Sean A. Irvine
 */
public class A133687 extends A227061 {

  private int mN = -1;
  private int mM = -1;

  private static int[] transpose(final int[] m) {
    final int[] r = new int[m.length];
    for (int v : m) {
      for (int j = m.length - 1; j >= 0; --j) {
        r[j] <<= 1;
        r[j] += v & 1;
        v >>= 1;
      }
    }
    return r;
  }

  private static int findMin(final int[] m, final int j) {
    int r = 0;
    for (int k = 1; k < j; ++k) {
      if (m[k] < m[r]) {
        r = k;
      }
    }
    return r;
  }

  @Override
  protected boolean accept(final int[] matrix, final int[] transpose) {
    // Note both matrices are already sorted
    final int[] pm = new int[transpose.length];
    // Generate all row permutations of the transpose
    final Permutation perm = new Permutation(transpose.length);
    int[] p;
    while ((p = perm.next()) != null) {
      for (int k = 0; k < pm.length; ++k) {
        pm[k] = transpose[p[k]];
      }
      final int[] t = transpose(pm);

      // Notionally now want to sort t by rows and compare to matrix.
      // If they are the same, then matrix was canonical.  But doing
      // the whole sort is slow, so we do it as we go.

      // Simultaneous sort and compare
      for (int k = 0, j = matrix.length; k < matrix.length; ++k) {
        final int h = findMin(t, j);
        final int u = t[h];
        final int c = matrix[k];
        if (u < c) {
          return false;
        } else if (u > c) {
          break;
        }
        t[h] = t[--j]; // ignore already processed entry
      }
    }
    return true;
  }

  @Override
  public Long get(final Integer n, final Integer m) {
    if (m > n) {
      return 0L;
    }
    return m <= n / 2 ? super.get(n, m) : super.get(n, n - m);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return Z.valueOf(get(mN, mM));
  }
}

#!queue	A133689	1	->	2	A048671	--------------------------------
package irvine.oeis.a133;
// Generated by gen_seq4.pl seqop a048 A048671 add(mN) 1 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a048.A048671;

/**
 * A133689 a(n) = smallest integer that is &gt; n and is a multiple of every proper divisor of n.
 *
 * @author Georg Fischer
 */
public class A133689 extends A048671 {
  private int mN = 1;

  /** Construct the sequence. */
  public A133689() {
    super();
    int bOffset = 0;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().add(mN);
  }
}
#!queue	A133798	0	->	1	A002467	--------------------------------
package irvine.oeis.a133;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a002.A002467;

/**
 * A133798 a(n) = A002467(n) - 1.
 * @author Georg Fischer
 */
public class A133798 extends A002467 {

  /** Construct the sequence. */
  public A133798() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A134719	0	->	1	A000931	--------------------------------
package irvine.oeis.a134;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A134719 Odd Padovan numbers.
 * @author Georg Fischer
 */
public class A134719 extends A000931 {

  @Override
  public Z next() {
    Z result = super.next();
    while (result.isEven()) {
      result = super.next();
    }
    return result;
  }
}
#!queue	A134720	0	->	1	A000931	--------------------------------
package irvine.oeis.a134;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A134720 Even Padovan numbers.
 * @author Georg Fischer
 */
public class A134720 extends A000931 {

  @Override
  public Z next() {
    Z result = super.next();
    while (! result.isEven()) {
      result = super.next();
    }
    return result;
  }
}
#!queue	A134727	0	->	1	A000931	--------------------------------
package irvine.oeis.a134;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A134727 Successive digits of members of the Padovan sequence A000931(n).
 * @author Georg Fischer
 */
public class A134727 extends A000931 {

  protected String mPadov = ""; // current Padovan number
  protected int mPos = 1; // position in mPadov
  
  @Override
  public Z next() {
    if (mPos >= mPadov.length()) {
      mPadov = super.next().toString();
      mPos = 0;
    }
    return Z.valueOf(Character.digit(mPadov.charAt(mPos++), 10));
  }
}
#!queue	A134732	0	->	1	A000931	--------------------------------
package irvine.oeis.a134;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A134732 Concatenation of first n members of the Padovan sequence A000931, starting at (1, 1, 1, 2,).
 * @author Georg Fischer
 */
public class A134732 extends A000931 {

  protected final StringBuilder mConc = new StringBuilder();

  /** Construct the sequence. */
  public A134732() {
    for (int i = 0; i <= 4; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    mConc.append(super.next());
    return new Z(mConc);
  }

}
#!queue	A137327	0	->	1	A000215	--------------------------------
package irvine.oeis.a137;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a000.A000215;

/**
 * A137327 Fermat(n) modulo n.
 * @author Georg Fischer
 */
public class A137327 extends A000215 {

  protected int mN;
  
  /** Construct the sequence. */
  public A137327() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A137345	0	->	1	A014068	--------------------------------
package irvine.oeis.a137;
// Generated by gen_seq4.pl seqop a014 A014068 mod(Z.valueOf(mN)) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a014.A014068;

/**
 * A137345 a(n) = binomial( n(n+1)/2, n) mod n.
 * @author Georg Fischer
 */
public class A137345 extends A014068 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A137345() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A139041	0	->	1	A000041	--------------------------------
package irvine.oeis.a139;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A139041 Sum of divisors of the number of partitions of n.
 * @author Georg Fischer
 */
public class A139041 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A139421	0	->	1	A006882	--------------------------------
package irvine.oeis.a139;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A139421 a(1)=1; for n&gt;1, a(n) = largest prime divisor of n!!.
 * @author Georg Fischer
 */
public class A139421 extends A006882 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A139480	1	->	2	A000043	--------------------------------
package irvine.oeis.a139;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a000.A000043;

/**
 * A139480 a(n) = A000043(n) - 3.
 * @author Georg Fischer
 */
public class A139480 extends A000043 {

  /** Construct the sequence. */
  public A139480() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(3);
  }
}
#!queue	A144527	0	->	4	A000055	--------------------------------
package irvine.oeis.a144;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a000.A000055;

/**
 * A144527 a(n) = A000055(n) - 2.
 * @author Georg Fischer
 */
public class A144527 extends A000055 {

  protected int mN;
  
  /** Construct the sequence. */
  public A144527() {
    mN = 4 - 1;
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(2);
  }
}
#!queue	A145341	0	->	1	A030101	--------------------------------
package irvine.oeis.a145;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a030.A030101;

/**
 * A145341 Convert 2n-1 to binary. Reverse its digits. Convert back to decimal to get a(n).
 * @author Georg Fischer
 */
public class A145341 extends A030101 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A145830	0	->	1	A145768	--------------------------------
package irvine.oeis.a145;

import irvine.math.z.Z;

/**
 * A145830 Indices for which A145768 (XOR of squares of the numbers 1...n) is a power of 2.
 * @author Sean A. Irvine
 */
public class A145830 extends A145768 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));

  @Override
  public Z next() {
    while (super.next().bitCount() != 1) {
      if (mVerbose && (mN & 0xFFFFFF) == 0) {
        System.err.println("[" + mN + "]");
      }
    }
    return Z.valueOf(mN);
  }

}

#!queue	A152024	0	->	3	A000166	--------------------------------
package irvine.oeis.a152;
// manually knest/jaguar at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000166;

/**
 * A152024 Largest prime factor in the subfactorial of n.
 * @author Georg Fischer
 */
public class A152024 extends A000166 {

  {
    for (int i = 0; i < 3; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A152179	1	->	0	A008865	--------------------------------
package irvine.oeis.a152;
// Generated by gen_seq4.pl moderiv at 2020-07-25 14:53
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a008.A008865;


/**
 * A152179 (n^2-2=A008865) mod 9. Period 9:repeat 8,2,7,5,5,7,2,8,7.
 * @author Georg Fischer
 */
public class A152179 extends A008865 {

  /** Construct the sequence. */
  public A152179() {
    super();
  }

  @Override
  public Z next() {
    return super.next().mod(Z.NINE);
  }
}
#!queue	A152612	0	->	1	A160449	--------------------------------
package irvine.oeis.a152;

import irvine.math.z.Z;
import irvine.oeis.a160.A160449;

/**
 * A152612 Number of isomorphism classes of n-fold coverings of a connected graph with Betti number 3.
 * @author Sean A. Irvine
 */
public class A152612 extends A160449 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 3);
  }
}
#!queue	A153002	0	->	1	A153000	--------------------------------
package irvine.oeis.a153;

import irvine.math.z.Z;

/**
 * A153002 Primes in toothpick sequence A153000.
 * @author Sean A. Irvine
 */
public class A153002 extends A153000 {

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.isPrime()) {
        return p;
      }
    }
  }
}

#!queue	A153733	1	->	0	A000265	--------------------------------
package irvine.oeis.a153;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a000.A000265;

/**
 * A153733 Remove all trailing 1's in the binary representation of n.
 * @author Georg Fischer
 */
public class A153733 extends A000265 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A156625	1	->	2	A050504	--------------------------------
package irvine.oeis.a156;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a050.A050504;

/**
 * A156625 Floor(integral of log(x) from 1 to n).
 * @author Georg Fischer
 */
public class A156625 extends A050504 {

  protected int mN;
  
  /** Construct the sequence. */
  public A156625() {
    mN = 1;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(mN).add(1);
  }
}
#!queue	A156769	0	->	1	A049606	--------------------------------
package irvine.oeis.a156;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a049.A049606;

/**
 * A156769 a(n) = denominator(2^(2*n-2)/factorial(2*n-1)).
 * @author Georg Fischer
 */
public class A156769 extends A049606 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A160446	0	->	1	A160449	--------------------------------
package irvine.oeis.a160;

import irvine.math.z.Z;

/**
 * A160446 Number of isomorphism classes of n-fold coverings of a connected graph with Betti number 4.
 * @author Sean A. Irvine
 */
public class A160446 extends A160449 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 4);
  }
}
#!queue	A160503	0	->	1	A006880	--------------------------------
package irvine.oeis.a160;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a006.A006880;

/**
 * A160503 Least prime divisor of pi(10^n).
 * @author Georg Fischer
 */
public class A160503 extends A006880 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A160793	0	->	1	A160792	--------------------------------
package irvine.oeis.a160;

import irvine.math.z.Z;

/**
 * A160793 Natural numbers and the sum of first n primes interleaved.
 * @author Sean A. Irvine
 */
public class A160793 extends A160792 {

  private Z mPrev = super.next();

  @Override
  public Z next() {
    final Z t = super.next();
    final Z r = t.subtract(mPrev);
    mPrev = t;
    return r;
  }
}

#!queue	A161736	0	->	2	A001902	--------------------------------
package irvine.oeis.a161;
// Generated by gen_seq4.pl n2/n2add1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a001.A001902;

/**
 * A161736 Denominators of the column sums of the BG2 matrix.
 * @author Georg Fischer
 */
public class A161736 extends A001902 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A161981	0	->	1	A006128	--------------------------------
package irvine.oeis.a161;
// manually 2021-06-23

import irvine.math.z.Z;
import irvine.oeis.a006.A006128;

/**
 * A161981 A006128(n) mod n.
 * @author Georg Fischer
 */
public class A161981 extends A006128 {
    
  protected int mN;

  /** Construct the sequence. */
  public A161981() {
    mN = 0;
    super.next();
  }
  
  @Override
  public Z next() {
    return super.next().mod(Z.valueOf(++mN));
  }
}
#!queue	A163176	0	->	1	A001898	--------------------------------
package irvine.oeis.a163;
// manually 2021-06-23

import irvine.math.z.Z;
import irvine.oeis.a001.A001898;

/**
 * A163176 The n-th Minkowski number divided by the n-th factorial: a(n) = A053657(n)/n!.
 * a(n) = A001898(n-1)/n.
 * @author Georg Fischer
 */
public class A163176 extends A001898 {
    
  @Override
  public Z next() {
    return super.next().divide(mN + 1);
  }
}
#!queue	A164314	1	->	2	A008865	--------------------------------
package irvine.oeis.a164;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a008.A008865;

/**
 * A164314 Largest prime factor of n^2 - 2.
 * @author Georg Fischer
 */
public class A164314 extends A008865 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A166280	1	->	0	A008277	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl moderiv at 2020-07-25 14:53
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a008.A008277;


/**
 * A166280 Stirling2 triangle mod 2, T(n,k) = A008277(n,k) mod 2.
 * @author Georg Fischer
 */
public class A166280 extends A008277 {

  /** Construct the sequence. */
  public A166280() {
    super();
  }

  @Override
  public Z next() {
    return super.next().mod(Z.TWO);
  }
}
#!queue	A166375	1	->	2	A014817	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a014.A014817;

/**
 * A166375 a(n) = sum (floor (j^2/n)) taken over 1 &lt;= j &lt;= n-1.
 * @author Georg Fischer
 */
public class A166375 extends A014817 {

  protected int mN;
  
  /** Construct the sequence. */
  public A166375() {
    mN = 1;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(mN);
  }
}
#!queue	A166472	0	->	1	A166470	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;

/**
 * A166472 2^F(n+2)*3^F(n+1)/12, where F(n) is the n-th Fibonacci number (A000045(n)).
 * @author Georg Fischer
 */
public class A166472 extends A166470 {

  protected int mN;
  
  /** Construct the sequence. */
  public A166472() {
    mN = 0;
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(12);
  }
}
#!queue	A167028	0	->	1	A002370	--------------------------------
package irvine.oeis.a167;
// manually deris2/essent at 2021-11-04

import irvine.math.z.Z;
import irvine.oeis.a002.A002370;

/**
 * A167028 Number of terms in the expansion of the determinant of a skew-symmetric matrix of order n.
 * Essentially a duplicate of A002370.
 * @author Georg Fischer
 */
public class A167028 extends A002370 {

  private int mN = 0;

  /** Construct the sequence. */
  public A167028() {
    super.next();
  }

  @Override
  public Z next() {
    return (++mN & 1) == 1 ? Z.ZERO : super.next();
  }
}
#!queue	A169964	0	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a169;
// manually 2021-06-24

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a007.A007088;

/**
 * A169964 Numbers whose decimal expansion contains only 0's and 5's.
 * @author Georg Fischer
 */
public class A169964 extends AbstractSequence {

  protected Z mDigit;
  private final A007088 mSeq = new A007088();

  /** Construct the sequence. */
  public A169964() {
    this(0, 5);
  }

  /**
   * Generic constructor with parameter
   * @param offset offset of the sequence
   * @param parm digit to multiply on A007088
   */
  public A169964(final int offset, final int parm) {
    super(offset);
    mDigit = Z.valueOf(parm);
  }

  @Override
  public Z next() {
    return mSeq.next().multiply(mDigit);
  }
}
#!queue	A172541	0	->	1	A008300	--------------------------------
package irvine.oeis.a172;

import irvine.math.z.Z;
import irvine.oeis.a008.A008300;

/**
 * A172541 Number of n X n 0..1 arrays with row sums 7 and column sums 7.
 * @author Sean A. Irvine
 */
public class A172541 extends A008300 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 7);
  }
}
#!queue	A172544	0	->	1	A008300	--------------------------------
package irvine.oeis.a172;

import irvine.math.z.Z;
import irvine.oeis.a008.A008300;

/**
 * A172544 Number of n X n 0..1 arrays with row sums 6 and column sums 6.
 * @author Sean A. Irvine
 */
public class A172544 extends A008300 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 6);
  }
}
#!queue	A176271	0	->	1	A005408	--------------------------------
package irvine.oeis.a176;
// manually 2021-10-19

import irvine.oeis.a005.A005408;

/**
 * A176271 The odd numbers as a triangle read by rows. 
 * @author Georg Fischer
 */
public class A176271 extends A005408 {
}
#!queue	A176767	1	->	0	A176772	--------------------------------
package irvine.oeis.a176;

import irvine.math.z.Z;

/**
 * A176767 Smallest power of 7 whose decimal expansion contains n.
 * @author Sean A. Irvine
 */
public class A176767 extends A176772 {

  /** Default constructor. */
  public A176767() {
    super(-1);
  }

  @Override
  protected Z base() {
    return Z.SEVEN;
  }
}

#!queue	A176768	1	->	0	A176772	--------------------------------
package irvine.oeis.a176;

import irvine.math.z.Z;

/**
 * A176768 Smallest power of 8 whose decimal expansion contains n.
 * @author Sean A. Irvine
 */
public class A176768 extends A176772 {

  /** Construct the sequence. */
  public A176768() {
    super(-1);
  }

  @Override
  protected Z base() {
    return Z.EIGHT;
  }
}

#!queue	A190297	2	->	1	A013697	--------------------------------
package irvine.oeis.a190;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a013.A013697;


/**
 * A190297 Bisection of A013697.
 * @author Georg Fischer
 */
public class A190297 extends A013697 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A190584	2	->	1	A013697	--------------------------------
package irvine.oeis.a190;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a013.A013697;


/**
 * A190584 Bisection of A013697.
 * @author Georg Fischer
 */
public class A190584 extends A013697 {

  /** Construct the sequence. */
  public A190584() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A190815	0	->	1	A049690	--------------------------------
package irvine.oeis.a190;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a049.A049690;


/**
 * A190815 A bisection of A049690.
 * @author Georg Fischer
 */
public class A190815 extends A049690 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A191101	1	->	5	A007678	--------------------------------
package irvine.oeis.a191;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a007.A007678;

/**
 * A191101 Number of regions in a complete but borderless regular polygon.
 * @author Georg Fischer
 */
public class A191101 extends A007678 {

  protected int mN;
  
  /** Construct the sequence. */
  public A191101() {
    mN = 5 - 1;
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(mN);
  }
}
#!queue	A191871	1	->	0	A000265	--------------------------------
package irvine.oeis.a191;
// manually knestm/knest at 2023-03-02 15:17

import irvine.math.z.Z;
import irvine.oeis.a000.A000265;

/**
 * A191871 a(n) = numerator(n^2 / 2^n).
 * @author Georg Fischer
 */
public class A191871 extends A000265 {

  private int mN = -1;

  @Override
  public Z next() {
    return (++mN == 0) ? Z.ZERO : super.next().square();
  }
}
#!queue	A202708	0	->	6	A004152	--------------------------------
package irvine.oeis.a202;
// Generated by gen_seq4.pl seqop a004 A004152 divide(9) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a004.A004152;

/**
 * A202708 Sum of digits of n! divided by 9.
 * @author Georg Fischer
 */
public class A202708 extends A004152 {
  private int mN = 6 - 1;
  
  /** Construct the sequence. */
  public A202708() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(9);
  }
}
#!queue	A203463	0	->	1	A020985	--------------------------------
package irvine.oeis.a203;

import irvine.math.z.Z;
import irvine.oeis.a020.A020985;

/**
 * A203463 Where Golay-Rudin-Shapiro sequence A020985 is positive.
 * @author Sean A. Irvine
 */
public class A203463 extends A020985 {

  @Override
  public Z next() {
    while (true) {
      if (super.next().signum() > 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A204248	1	->	0	A085244	--------------------------------
package irvine.oeis.a204;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Z;
import irvine.oeis.a085.A085244;

/**
 * A204248 Permanent of the n-th principal submatrix of A002024.
 * @author Georg Fischer
 */
public class A204248 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Z.valueOf(i + j + 1));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A204249	1	->	0	A085244	--------------------------------
package irvine.oeis.a204;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Z;
import irvine.oeis.a085.A085244;

/**
 * A204249 Permanent of the n-th principal submatrix of A003057.
 * @author Georg Fischer
 */
public class A204249 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Z.valueOf(i + j + 2));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A204262	1	->	0	A085244	--------------------------------
package irvine.oeis.a204;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Z;
import irvine.oeis.a085.A085244;

/**
 * A204262 Permanent of the n-th principal submatrix of A003983.
 * @author Georg Fischer
 */
public class A204262 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Z.valueOf(i < j ? i + 1 : j + 1));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A206295	0	->	1	A007188	--------------------------------
package irvine.oeis.a206;

import irvine.math.z.Z;
import irvine.oeis.a007.A007188;

/**
 * A206295 (1/6)*A007188(n).
 * @author Georg Fischer
 */
public class A206295 extends A007188 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(6);
  }
}
#!queue	A207982	0	->	1	A000984	--------------------------------
package irvine.oeis.a207;

import java.util.ArrayList;
import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A207982 Least m&gt;1 such that all central binomial coefficients C(2k,k), k&lt;=n, are pairwise not congruent mod m.
 * @author Sean A. Irvine
 */
public class A207982 extends A000984 {

  private final ArrayList<Z> mCentral = new ArrayList<>();
  private int mN = -1;
  private int mLast = 1;

  @Override
  public Z next() {
    mCentral.add(super.next());
    if (++mN == 0) {
      mCentral.add(super.next());
      return Z.TWO;
    }
    int k = mLast;
    final HashSet<Long> seen = new HashSet<>();
    while (true) {
      boolean ok = true;
      seen.clear();
      for (int j = 1; j < mCentral.size(); ++j) {
        if (!seen.add(mCentral.get(j).mod(k))) {
          ok = false;
          break;
        }
      }
      if (ok) {
        mLast = k;
        return Z.valueOf(k);
      }
      ++k;
    }
  }
}

#!queue	A208649	0	->	1	A073617	--------------------------------
package irvine.oeis.a208;

import irvine.math.z.Z;
import irvine.oeis.a073.A073617;

/**
 * A208649 (1/n)*A073617(n+1).
 * @author Georg Fischer
 */
public class A208649 extends A073617 {

  private int mN = 0;

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(++mN);
  }
}
#!queue	A209190	0	->	1	A004086	--------------------------------
package irvine.oeis.a209;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a004.A004086;

/**
 * A209190 Least prime factor of reversal of digits of n.
 * @author Georg Fischer
 */
public class A209190 extends A004086 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A210026	0	->	1	A210025	--------------------------------
package irvine.oeis.a210;

import irvine.math.z.Z;

/**
 * A210026 List of successive digits in A210025.
 * @author Sean A. Irvine
 */
public class A210026 extends A210025 {

  private final StringBuilder mDigits = new StringBuilder();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN >= mDigits.length()) {
      mDigits.append(super.next().toString());
    }
    return Z.valueOf(mDigits.charAt(mN) - '0');
  }
}
#!queue	A210437	0	->	1	A004086	--------------------------------
package irvine.oeis.a210;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a004.A004086;

/**
 * A210437 Greatest prime factor of reversal of digits of n.
 * @author Georg Fischer
 */
public class A210437 extends A004086 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A210986	0	->	1	A001168	--------------------------------
package irvine.oeis.a210;
// manually n2/n2add1 at 2022-04-08 11:54

import irvine.math.z.Z;
import irvine.oeis.a001.A001168;

/**
 * A210986 Number of fixed polyominoes with 2n cells.
 * @author Georg Fischer
 */
public class A210986 extends A001168 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A210987	0	->	1	A001168	--------------------------------
package irvine.oeis.a210;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a001.A001168;

/**
 * A210987 Number of fixed polyominoes with 2n-1 cells.
 * @author Georg Fischer
 */
public class A210987 extends A001168 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A211004	0	->	1	A001840	--------------------------------
package irvine.oeis.a211;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a001.A001840;

/**
 * A211004 Number of distinct regions in the set of partitions of n.
 * @author Georg Fischer
 */
public class A211004 extends A001840 {

  /** Construct the sequence. */
  public A211004() {
    skip(1);
  }
}
#!queue	A213439	1	->	2	A000136	--------------------------------
package irvine.oeis.a213;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a000.A000136;

/**
 * A213439 A000136(n)/2.
 * @author Georg Fischer
 */
public class A213439 extends A000136 {

  /** Construct the sequence. */
  public A213439() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A215339	0	->	1	A001608	--------------------------------
package irvine.oeis.a215;

import irvine.math.z.Z;
import irvine.oeis.a001.A001608;

/**
 * A215339 a(n) = A001608(n) mod n.
 * @author Sean A. Irvine
 */
public class A215339 extends A001608 {

  protected Z mN = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    mN = mN.add(1);
    return super.next().mod(mN);
  }
}
#!queue	A215402	0	->	8	A269920	--------------------------------
package irvine.oeis.a215;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A215402 Number of rooted maps of (orientable) genus 4 containing n edges.
 * @author Sean A. Irvine
 */
public class A215402 extends A269920 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 4, k));
    }
    return sum;
  }
}
#!queue	A215861	1	->	0	Triangle	--------------------------------
package irvine.oeis.a215;

import irvine.math.MemoryFunctionInt2;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A215861 Number T(n,k) of simple labeled graphs on n nodes with exactly k connected components that are trees or cycles; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A215861 extends Triangle {

  /** Construct the sequence. */
  public A215861() {
    super(1, 1, -1);
    hasRAM(true);
  }

  /* Maple:
    T:= proc(n, k) option remember; `if`(k<0 or k>n, 0,
          `if`(n=0, 1, add(binomial(n-1, i)*T(n-1-i, k-1)*
          `if`(i<2, 1, i!/2 +(i+1)^(i-1)), i=0..n-k)))
        end:
    seq(seq(T(n, k), k=0..n), n=0..12);
  */
  private final MemoryFunctionInt2<Z> mB = new MemoryFunctionInt2<Z>() {
    @Override
    protected Z compute(final int n, final int k) {
      if (k < 0 || k > n) {
        return Z.ZERO;
      }
      if (n == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      final int imax = n - k;
      for (int i = 0; i <= imax; ++i) {
        Z term = get(n - 1 - i, k - 1).multiply(Binomial.binomial(n - 1, i));
        if (i >= 2) {
          term = term.multiply(MemoryFactorial.SINGLETON.factorial(i).divide2().add(Z.valueOf(i + 1).pow(i - 1)));
        }
        sum = sum.add(term);
      }
      return sum;
    }
  };

  @Override
  protected Z compute(final int n, final int k) {
    return mB.get(n, k);
  }
}
#!queue	A224652	3	->	1	A006219	--------------------------------
package irvine.oeis.a224;

import irvine.math.z.Z;
import irvine.oeis.a006.A006219;

/**
 * A224652 Triangle read by rows: T(n,k) is the number of permutations of n elements with k the (smallest) header (first element) of the longest descending subsequence.
 * @author Sean A. Irvine
 */
public class A224652 extends A006219 {

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      mM = 1;
      ++mN;
    }
    return f(mN, mM);
  }
}
#!queue	A225764	1	->	0	A085244	--------------------------------
package irvine.oeis.a225;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.a085.A085244;

/**
 * A225764 Permanent of the n X n matrix M_n = [m_n(i,j)] with m_n(i,j) = Stirling2(n+i,j) for 1&lt;=i,j&lt;=n.
 * @author Georg Fischer
 */
public class A225764 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Stirling.secondKind(n + i + 1, j + 1));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A227127	1	->	0	A001223	--------------------------------
package irvine.oeis.a227;
// manually deris/essent at 2022-04-28 15:40

import irvine.math.z.Z;
import irvine.oeis.a001.A001223;

/**
 * A227127 The Akiyama-Tanigawa algorithm applied to 1/(1,2,3,5,... old prime numbers). Reduced numerators of the second row.
 * @author Georg Fischer
 */
public class A227127 extends A001223 {

  private int mN = -1;

  /** Construct the sequence. */
  public A227127() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    if (mN <= 1) {
      return Z.ONE;
    } else if (mN == 2) {
      return Z.TWO;
    }
    return super.next().multiply(mN + 1);
  }
}
#!queue	A227590	2	->	1	A003022	--------------------------------
package irvine.oeis.a227;
// manually knestm/knest at 2023-03-02 16:06

import irvine.math.z.Z;
import irvine.oeis.a003.A003022;

/**
 * A227590 a(n) = A003022(n)+1 with a(1)=1.
 * @author Georg Fischer
 */
public class A227590 extends A003022 {

  private int mN = 0;

  @Override
  public Z next() {
    return (++mN == 1) ? Z.ONE : super.next().add(1);
  }
}
#!queue	A228037	1	->	0	A046094	--------------------------------
package irvine.oeis.a228;
// Generated by gen_seq4.pl n2 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a046.A046094;

/**
 * A228037 Odd-indexed terms of Agoh's congruence A046094: a(n) is conjectured to be 1 iff 2n+1 is prime.
 * @author Georg Fischer
 */
public class A228037 extends A046094 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A230200	0	->	1	A208575	--------------------------------
package irvine.oeis.a230;
// Generated by gen_seq4.pl A067067/parm3 at 2022-02-28 21:02

import irvine.oeis.a002.A002385;
import irvine.oeis.a208.A208575;

/**
 * A230200 Product of digits of n-th palindromic prime.
 * @author Georg Fischer
 */
public class A230200 extends A208575 {

  /** Construct the sequence. */
  public A230200() {
    super(new A002385(), 10);
  }
}
#!queue	A234645	-1	->	0	A001093	--------------------------------
package irvine.oeis.a234;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001093;

/**
 * A234645 Sum of the divisors of n^3+1.
 * @author Georg Fischer
 */
public class A234645 extends A001093 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A238355	0	->	10	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238355 Number of rooted maps of genus 5 containing n edges.
 * @author Sean A. Irvine
 */
public class A238355 extends A269920 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 5, k));
    }
    return sum;
  }
}
#!queue	A238356	0	->	12	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238356 Number of rooted maps of genus 6 containing n edges.
 * @author Sean A. Irvine
 */
public class A238356 extends A269920 {

  private int mN = 11;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 6, k));
    }
    return sum;
  }
}
#!queue	A238357	0	->	14	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238357 Number of genus-7 rooted maps with n edges.
 * @author Sean A. Irvine
 */
public class A238357 extends A269920 {

  private int mN = 13;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 7, k));
    }
    return sum;
  }
}
#!queue	A238358	0	->	16	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238358 Number of genus-8 rooted maps with n edges.
 * @author Sean A. Irvine
 */
public class A238358 extends A269920 {

  private int mN = 15;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 8, k));
    }
    return sum;
  }
}
#!queue	A238359	0	->	18	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238359 Number of rooted maps with n edges of genus 9.
 * @author Sean A. Irvine
 */
public class A238359 extends A269920 {

  private int mN = 17;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 9, k));
    }
    return sum;
  }
}
#!queue	A238360	0	->	20	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238360 Number of genus-10 rooted maps with n edges.
 * @author Sean A. Irvine
 */
public class A238360 extends A269920 {

  private int mN = 19;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 10, k));
    }
    return sum;
  }
}
#!queue	A242538	0	->	1	A004152	--------------------------------
package irvine.oeis.a242;

import irvine.math.z.Z;
import irvine.oeis.a004.A004152;

/**
 * A242538 Squares that are sum of digits of factorials.
 * @author Georg Fischer
 */
public class A242538 extends A004152 {

  private Z mS = Z.ZERO;

  @Override
  public Z next() {
    Z result = super.next();
    while (!result.isSquare() || result.equals(mS)) {
      result = super.next();
    }
    mS = result;
    return result;
  }
}
#!queue	A244410	1	->	0	A244372	--------------------------------
package irvine.oeis.a244;
// manually A244372/trionk

import irvine.math.z.Z;

/**
 * A244410 Number of unlabeled rooted trees with 2n+1 nodes and maximal outdegree (branching factor) n.
 * @author Georg Fischer
 */
public class A244410 extends A244372 {

  private int mN = - 1;
  
  @Override
  public Z next() {
    ++mN;
    // a:= n-> `if`(n=0, 1, b(2*n$2, n$2)-b(2*n$2, n-1$2)):
    return mN == 0 ? Z.ONE : mSeq.b(2 * mN, 2 * mN, mN, mN).subtract(mSeq.b(2 * mN, 2 * mN, mN - 1, mN - 1));
  }
}
#!queue	A244415	0	->	1	A005843	--------------------------------
package irvine.oeis.a244;
// manually valuation/valuat at 2022-03-16 18:05

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a005.A005843;

/**
 * A244415 Exponent of 4 appearing in the 4-adic value of 1/n, n &gt;= 1, given in A240226(n).
 * @author Georg Fischer
 */
public class A244415 extends A005843 {

  /** Construct the sequence. */
  public A244415() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.FOUR));
  }
}
#!queue	A248928	1	->	0	A027434	--------------------------------
package irvine.oeis.a248;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a027.A027434;

/**
 * A248928 Interleave (2*n+2)^2 with (2*n+3)^2, both listed n+1 times.
 * @author Georg Fischer
 */
public class A248928 extends A027434 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A249784	-1	->	1	A002488	--------------------------------
package irvine.oeis.a249;
// manually sigman0/sigma0 at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002488;

/**
 * A249784 Number of divisors of n^(n^n).
 * @author Georg Fischer
 */
public class A249784 extends A002488 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A253103	0	->	2	A001045	--------------------------------
package irvine.oeis.a253;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a001.A001045;

/**
 * A253103 A001045(n)^3.
 * @author Georg Fischer
 */
public class A253103 extends A001045 {

  /** Construct the sequence. */
  public A253103() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A253885	1	->	0	A003961	--------------------------------
package irvine.oeis.a253;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a003.A003961;

/**
 * A253885 Permutation of even numbers: a(n) = A003961(n+1) - 1.
 * @author Georg Fischer
 */
public class A253885 extends A003961 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A255165	2	->	1	A043000	--------------------------------
package irvine.oeis.a255;
// manually dersimpln at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a043.A043000;

/**
 * A255165 a(n) = Sum_{k=2..n} floor(log(n)/log(k)), n &gt;= 1.
 * @author Georg Fischer
 */
public class A255165 extends A043000 {

  protected int mN;
  
  /** Construct the sequence. */
  public A255165() {
    mN = 0;
  }

  @Override
  public Z next() {
    ++mN;
    return mN == 1 ? Z.ZERO : super.next().subtract(mN).add(1);
  }
}
#!queue	A257888	5	->	3	A002055	--------------------------------
package irvine.oeis.a257;
// manually; 2021-05-10

import irvine.math.z.Z;
import irvine.oeis.a002.A002055;

/**
 * A257888 Number of nonintersecting (or self-avoiding) rook paths of length 2n+2 joining opposite corners of an n X n grid.
 * @author Georg Fischer
 */
public class A257888 extends A002055 {

  @Override
  public Z next() {
    return super.next().multiply(4);
  }
}
#!queue	A260233	0	->	2	A000384	--------------------------------
package irvine.oeis.a260;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A260233 Smallest prime factor of the n-th hexagonal number (A000384).
 * @author Georg Fischer
 */
public class A260233 extends A000384 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A260344	0	->	1	A006779	--------------------------------
package irvine.oeis.a260;

import irvine.oeis.a006.A006779;

/**
 * A260344 Sum of squared distances from origin to ends of all n-step spiral self-avoiding walks on simple cubic lattice.
 * @author Sean A. Irvine
 */
public class A260344 extends A006779 {

  {
    super.next();
  }

  @Override
  protected long count(final int point) {
    final int x = x(point);
    final int y = y(point);
    final int z = z(point);
    return 6L * (x * x + y * y + z * z);
  }
}
#!queue	A260345	0	->	1	A006780	--------------------------------
package irvine.oeis.a260;

import irvine.oeis.a006.A006780;

/**
 * A260345 Sum of squared distances from origin to ends of all n-step anisotropic self-avoiding walks on simple cubic lattice.
 * @author Sean A. Irvine
 */
public class A260345 extends A006780 {

  {
    super.next();
  }

  @Override
  protected long count(final int point) {
    final int x = x(point);
    final int y = y(point);
    final int z = z(point);
    return 2L * (x * x + y * y + z * z);
  }
}
#!queue	A262543	0	->	1	A002420	--------------------------------
package irvine.oeis.a262;

import irvine.math.z.Z;
import irvine.oeis.a002.A002420;

/**
 * A262543 Number of rooted asymmetrical polyenoids of type U_n* having n edges.
 * @author Sean A. Irvine
 */
public class A262543 extends A002420 {

  {
    super.next();
    super.next();
  }

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().abs();
  }
}

#!queue	A262568	-1	->	3	A178666	--------------------------------
package irvine.oeis.a262;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a178.A178666;

/**
 * A262568 a(n) = A002703(n) + 2.
 * @author Sean A. Irvine
 */
public class A262568 extends A178666 {

  // After R. J. Mathar

  private int kStart(final int n, final int m) {
    return (n * (n + 1) / 2 + m - 1) / m;
  }

  private int kEnd(final int n, final int m) {
    return (3 * n + 1) * (3 * n) / (6 * m);
  }

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    final int s = 2 * mN - 1;
    final Polynomial<Z> row = a178666((s - 1) / 2);
    final int m = 2 * mN + 1;
    Z q = Z.ZERO;
    for (int k = kStart(mN, m); k <= kEnd(mN, m); ++k) {
      final int vi = m * k - (mN + 1) * mN / 2;
      if (vi >= 0 && vi <= row.degree()) {
        q = q.add(row.coeff(vi));
      }
    }
    return q;
  }
}
#!queue	A263112	0	->	1	A007570	--------------------------------
package irvine.oeis.a263;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a007.A007570;

/**
 * A263112 a(n) = F(F(n)) mod n, where F = Fibonacci = A000045.
 * @author Georg Fischer
 */
public class A263112 extends A007570 {

  protected int mN;
  
  /** Construct the sequence. */
  public A263112() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A269921	0	->	2	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269921 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 1.
 * @author Sean A. Irvine
 */
public class A269921 extends A269920 {

  private int mN = 1;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, 1, mM);
  }

}
#!queue	A269922	0	->	4	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269922 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 2.
 * @author Sean A. Irvine
 */
public class A269922 extends A269920 {

  private int mN = 3;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN - 2) {
      ++mN;
      mM = 1;
    }
    return get(mN, 2, mM);
  }

}
#!queue	A269923	0	->	6	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269923 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 3.
 * @author Sean A. Irvine
 */
public class A269923 extends A269920 {

  private int mN = 5;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN - 4) {
      ++mN;
      mM = 1;
    }
    return get(mN, 3, mM);
  }

}
#!queue	A269924	0	->	8	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269924 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 4.
 * @author Sean A. Irvine
 */
public class A269924 extends A269920 {

  private int mN = 7;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN - 6) {
      ++mN;
      mM = 1;
    }
    return get(mN, 4, mM);
  }

}
#!queue	A269925	0	->	10	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269925 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 5.
 * @author Sean A. Irvine
 */
public class A269925 extends A269920 {

  private int mN = 9;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN - 8) {
      ++mN;
      mM = 1;
    }
    return get(mN, 5, mM);
  }

}
#!queue	A271423	1	->	0	Triangle	--------------------------------
package irvine.oeis.a271;

import irvine.math.MemoryFunctionInt3;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A271423 Number T(n,k) of set partitions of [n] with maximal block length multiplicity equal to k; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A271423 extends Triangle {

  /** Construct the sequence. */
  public A271423() {
    super(1, 1, -1);
    hasRAM(true);
  }

  /* Maple:
    with(combinat):
    b:= proc(n, i, k) option remember; `if`(n=0, 1,
          `if`(i<1, 0, add(multinomial(n, n-i*j, i$j)
            *b(n-i*j, i-1, k)/j!, j=0..min(k, n/i))))
        end:
    T:= (n, k)-> b(n$2, k)-`if`(k=0, 0, b(n$2, k-1)):
    seq(seq(T(n, k), k=0..n), n=0..12);
  */
  private final MemoryFunctionInt3<Z> mB = new MemoryFunctionInt3<Z>() {
    @Override
    protected Z compute(final int n, final int i, final int k) {
      if (n == 0) {
        return Z.ONE;
      }
      if (i < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int ni = n / i;
      final int jmax = k < ni ? k : ni;
      for (int j = 0; j <= jmax; ++j) {
        final int[] list = new int[j + 1];
        list[0] = n - i * j;
        for (int l = 1; l <= j; ++l) {
          list[l] = i;
        }
        sum = sum.add(Binomial.multinomial(n, list).multiply(get(n - i * j, i - 1, k)).divide(MemoryFactorial.SINGLETON.factorial(j)));
      }
      return sum;
    }
  };

  @Override
  public Z compute(final int n, final int k) {
    Z result = mB.get(n, n, k);
    if (k != 0) {
      result = result.subtract(mB.get(n, n, k - 1));
    }
    return result;
  }
}
#!queue	A271425	1	->	0	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271425 Number of set partitions of [2n] with maximal block length multiplicity equal to n.
 * @author Georg Fischer
 */
public class A271425 extends A271423 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(2 * mN, mN);
  }
}

#!queue	A272090	0	->	1	A045906	--------------------------------
package irvine.oeis.a272;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a045.A045906;

/**
 * A272090 Number of chiral partitions of n; number of irreducible representations of the symmetric group S_n with nontrivial determinant.
 * @author Sean A. Irvine
 */
public class A272090 extends A045906 {

  // After Michel Marcus

  private long mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ZERO;
    }
    final long e = mN & 1;
    final long m = mN / 2;
    int k1 = 1;
    long r = m;
    assert r != 0;
    while ((r & 1) == 0) {
      ++k1;
      r >>>= 1;
    }
    r >>>= 1;
    int s = 0;
    for (long j = k1 + 1; r != 0; r >>>= 1, ++j) {
      if ((r & 1) == 1) {
        s += j;
      }
    }
    Z sum = Z.ONE.shiftLeft(k1 - 1);
    if (e != 0) {
      sum = sum.add(Z.ONE.shiftLeft(Binomial.binomial(k1, 2).longValueExact()));
    }
    for (long v = 1; v < k1; ++v) {
      sum = sum.add(Z.ONE.shiftLeft((v + 1) * (k1 - 2) - Binomial.binomial(v, 2).longValueExact()));
    }
    return sum.shiftLeft(s);
  }
}
#!queue	A274303	1	->	0	A007346	--------------------------------
package irvine.oeis.a274;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a007.A007346;


/**
 * A274303 A bisection of A007346.
 * @author Georg Fischer
 */
public class A274303 extends A007346 {
  
  /** Construct the sequence. */
  public A274303() {
    super.next();
  }

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A276639	0	->	1	A084546	--------------------------------
package irvine.oeis.a276;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a084.A084546;

/**
 * A276639 Triangle T(m, n) = the number of point-labeled graphs with n points and m edges, no points isolated. By rows, n &gt;= 0, ceiling(n/2) &lt;= m &lt;= binomial(n,2).
 * @author Sean A. Irvine
 */
public class A276639 extends A084546 {

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z t(final int n, final int m) {
    if (n == 1) {
      return m == 1 ? Z.ONE : Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k <= n; ++k) {
      sum = sum.signedAdd(((n - k) & 1) == 0, Binomial.binomial(n, k).multiply(super.t(k, m)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN * (mN - 1) / 2) {
      ++mN;
      mM = (mN + 1) / 2;
    }
    return t(mN, mM);
  }
}
#!queue	A276681	0	->	1	A000567	--------------------------------
package irvine.oeis.a276;
// Generated by gen_seq4.pl sigman0/sigma0s at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000567;

/**
 * A276681 Number of divisors of the n-th octagonal number.
 * @author Georg Fischer
 */
public class A276681 extends A000567 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A276682	0	->	1	A001106	--------------------------------
package irvine.oeis.a276;
// Generated by gen_seq4.pl sigman0/sigma0s at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001106;

/**
 * A276682 Number of divisors of the n-th 9-gonal number.
 * @author Georg Fischer
 */
public class A276682 extends A001106 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A279081	0	->	1	A000292	--------------------------------
package irvine.oeis.a279;
// Generated by gen_seq4.pl sigman0/sigma0s at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000292;

/**
 * A279081 Number of divisors of the n-th tetrahedral number.
 * @author Georg Fischer
 */
public class A279081 extends A000292 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A280509	0	->	1	A057889	--------------------------------
package irvine.oeis.a280;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a057.A057889;

/**
 * A280509 a(n) = A051064(A246200(n)); 3-adic valuation of A057889(3*n).
 * @author Georg Fischer
 */
public class A280509 extends A057889 {

  /** Construct the sequence. */
  public A280509() {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    super.next();
    return Z.valueOf(ZUtils.valuation(super.next(), Z.THREE));
  }
}
#!queue	A281648	0	->	1	A000367	--------------------------------
package irvine.oeis.a281;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A281648 (Numerator of Bernoulli(2*n)) read mod n.
 * @author Georg Fischer
 */
public class A281648 extends A000367 {

  protected int mN;
  
  /** Construct the sequence. */
  public A281648() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A281662	0	->	1	A002445	--------------------------------
package irvine.oeis.a281;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a002.A002445;

/**
 * A281662 (Denominator of Bernoulli(2*n)) read mod n.
 * @author Georg Fischer
 */
public class A281662 extends A002445 {

  protected int mN;
  
  /** Construct the sequence. */
  public A281662() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A282548	1	->	0	A013959	--------------------------------
package irvine.oeis.a282;

import irvine.math.z.Z;
import irvine.oeis.a013.A013959;

/**
 * A282548 Expansion of phi_{12, 1}(x) where phi_{r, s}(x) = Sum_{n, m&gt;0} m^r * n^s * x^{m*n}.
 * @author Sean A. Irvine
 */
public class A282548 extends A013959 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().multiply(mN);
  }
}
#!queue	A286567	0	->	1	A001045	--------------------------------
package irvine.oeis.a286;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001045;

/**
 * A286567 Smallest prime factor of the n-th Jacobsthal number: a(n) = A020639(A001045(n)), with a(1)=a(2)=1.
 * @author Georg Fischer
 */
public class A286567 extends A001045 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A286757	0	->	1	A002829	--------------------------------
package irvine.oeis.a286;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a002.A002829;

/**
 * A286757 Number of labeled connected rooted trivalent graphs with 2n nodes.
 * @author Sean A. Irvine
 */
public class A286757 extends A002829 {

  private final ArrayList<Z> mQ = new ArrayList<>();
  private int mN = 0;
  private Z mA = Z.ZERO;
  private Z mB = Z.ZERO;

  private Z q(final int n) {
    while (n >= mQ.size()) {
      mQ.add(super.next());
    }
    if (n < 0) {
      return Z.ZERO;
    }
    return mQ.get(n);
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      final long p2 = 2L * mN;
      final Z t = mB.multiply(Binomial.binomial(p2, 2)).multiply2()
        .add(mA.multiply(Binomial.binomial(p2, 4)).multiply(12))
        .add(q(mN - 1).multiply(Binomial.binomial(p2, 3)).multiply(6))
        .add(q(mN - 2).multiply(Binomial.binomial(p2, 5)).multiply(60))
        .add(q(mN - 3).multiply(Binomial.binomial(p2, 7)).multiply(1260));
      mA = mB;
      mB = t;
    }
    return mN == 2 ? Z.FOUR : mB;
  }
}

#!queue	A287875	2	->	1	A230627	--------------------------------
package irvine.oeis.a287;

import irvine.math.z.Z;
import irvine.oeis.a230.A230627;

/**
 * A287875 Iterate the map x -&gt; A230625(x) starting at n; sequence gives the first prime (or 1) that is reached, written in base 2, or -1 if no prime is ever reached.
 * @author Sean A. Irvine
 */
public class A287875 extends A230627 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return new Z(super.next().toString(2));
  }
}
#!queue	A291804	0	->	1	A291789	--------------------------------
package irvine.oeis.a291;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A291804 a(n) = sigma(A291789(n)).
 * @author Sean A. Irvine
 */
public class A291804 extends A291789 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A291805	0	->	1	A291789	--------------------------------
package irvine.oeis.a291;

import irvine.math.z.Euler;
import irvine.math.z.Z;

/**
 * A291805 a(n) = phi(A291789(n)).
 * @author Sean A. Irvine
 */
public class A291805 extends A291789 {

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A292118	1	->	0	A003159	--------------------------------
package irvine.oeis.a292;

import irvine.math.z.Z;
import irvine.oeis.a003.A003159;

/**
 * A292118 G.f.: 1 + 2*Sum_{k &gt;= 1} (-1)^k*q^A003159(k).
 * @author Sean A. Irvine
 */
public class A292118 extends A003159 {

  private long mA = super.next().longValueExact();
  private long mM = -1;
  private boolean mSign = true;

  @Override
  public Z next() {
    if (++mM == 0) {
      return Z.ONE;
    } else if (mM != mA) {
      return Z.ZERO;
    } else {
      mSign = !mSign;
      mA = super.next().longValueExact();
      return Z.valueOf(mSign ? 2 : -2);
    }
  }
}
#!queue	A292603	1	->	0	A005940	--------------------------------
package irvine.oeis.a292;
// Generated by gen_seq4.pl moderiv at 2020-07-25 14:53
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a005.A005940;


/**
 * A292603 Doudna-tree reduced modulo 4: a(n) = A005940(1+n) mod 4.
 * @author Georg Fischer
 */
public class A292603 extends A005940 {

  /** Construct the sequence. */
  public A292603() {
    super();
  }

  @Override
  public Z next() {
    return super.next().mod(Z.FOUR);
  }
}
#!queue	A294724	0	->	1	A003168	--------------------------------
package irvine.oeis.a294;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a003.A003168;
import irvine.oeis.a003.A003169;

/**
 * A294724 Number of Q graphs with 2*n vertices rooted at an internal edge.
 * @author Sean A. Irvine
 */
public class A294724 extends A003168 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final A003169 mSeqP = new A003169();
  private Polynomial<Z> mP = RING.zero();
  private Polynomial<Z> mB = Polynomial.create(0, -1);
  private int mN = 0;


  @Override
  public Z next() {
    mN += 2;
    mB = RING.add(mB, RING.monomial(super.next(), mN - 1));
    mP = RING.add(mP, RING.monomial(mSeqP.next(), mN));
    return RING.multiply(RING.pow(mB, 2, mN), mP, mN).coeff(mN);
  }
}
#!queue	A294728	0	->	1	A003168	--------------------------------
package irvine.oeis.a294;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a003.A003168;
import irvine.oeis.a007.A007165;

/**
 * A294728 Number of Q graphs with 2*n vertices symmetrical about a distinguished edge.
 * @author Sean A. Irvine
 */
public class A294728 extends A003168 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final A007165 mSeqH = new A007165();
  private Polynomial<Z> mH = RING.zero();
  private Polynomial<Z> mB = Polynomial.create(0, -1);
  private int mN = 0;


  @Override
  public Z next() {
    mN += 2;
    mB = RING.add(mB, RING.monomial(super.next(), mN - 1));
    mH = RING.add(mH, RING.monomial(mSeqH.next(), mN));
    return RING.multiply(mB.substitutePower(2, mN), mH, mN).coeff(mN);
  }
}
#!queue	A296171	0	->	1	A296170	--------------------------------
package irvine.oeis.a296;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A296171 O.g.f. A(x) satisfies: [x^n] exp( n^2 * A(x) )  =   [x^(n-1)] exp( n^2 * A(x) ) for n&gt;=1.
 * @author Sean A. Irvine
 */
public class A296171 extends A296170 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    stepEgf();
    mA.set(0, Q.ZERO); // so that log1p works
    final Polynomial<Q> log = RING.log1p(RING.create(mA), mN);
    mA.set(0, Q.ONE);
    final Q coeff = log.coeff(mN);
    if (!coeff.isInteger()) {
      throw new UnsupportedOperationException("Sequence is not an integer at n=" + mN);
    }
    return coeff.toZ();
  }

  /**
   * Direct computation to specified number of terms.
   * @param args number of terms
   */
  public static void main(final String[] args) {
    final A296171 seq = new A296171();
    final int limit = Integer.parseInt(args[0]);
    for (int k = 0; k < limit; ++k) {
      System.out.println(String.valueOf(k));
      seq.stepEgf();
    }
    seq.mA.set(0, Q.ZERO);
    System.out.println(RING.log1p(RING.create(seq.mA), limit));
  }
}
#!queue	A300003	4	->	0	A007975	--------------------------------
package irvine.oeis.a300;

import irvine.math.z.Z;
import irvine.oeis.a007.A007975;

/**
 * A300003 Triangle read by rows: T(n, k) = number of permutations that are k "block reversals" away from 12...n, for n &gt;= 0, and (for n&gt;0) 0 &lt;= k &lt;= n-1.
 * @author Sean A. Irvine
 */
public class A300003 extends A007975 {

  private int mM = 0;

  @Override
  protected int start() {
    return -1;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      // Start the next row
      init();
      mM = 0;
    } else {
      step();
    }
    return Z.valueOf(mPrev.size());
  }
}
#!queue	A319394	1	->	0	Triangle	--------------------------------
package irvine.oeis.a319;

import irvine.math.MemoryFunction1;
import irvine.math.MemoryFunctionInt2;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A319394 Number T(n,k) of partitions of n into exactly k positive Fibonacci numbers; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A319394 extends Triangle {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  /** Construct the sequence. */
  public A319394() {
    super(1, 1, -1);
    hasRAM(true);
  }

  /* Maple:
    h:= proc(n) option remember; `if`(n<1, 0, `if`((t->
          issqr(t+4) or issqr(t-4))(5*n^2), n, h(n-1)))
        end:
    b:= proc(n, i) option remember; `if`(n=0 or i=1, x^n,
          b(n, h(i-1))+expand(x*b(n-i, h(min(n-i, i)))))
        end:
    T:= n-> (p-> seq(coeff(p, x, i), i=0..n))(b(n, h(n))):
    seq(T(n), n=0..20);
  */
  private final MemoryFunction1<Integer> mH = new MemoryFunction1<Integer>() {
    @Override
    protected Integer compute(final int n) {
      if (n < 1) {
        return 0;
      }
      final int t = 5 * n * n;
      return Z.valueOf(t + 4).isSquare() || Z.valueOf(t - 4).isSquare() ? n : get(n - 1);
    }
  };

  private final MemoryFunctionInt2<Polynomial<Z>> mB = new MemoryFunctionInt2<Polynomial<Z>>() {
    @Override
    protected Polynomial<Z> compute(final int n, final int i) {
      if (n == 0 || i == 1) {
        return RING.monomial(Z.ONE, n);
      }
      return RING.add(get(n, mH.get(i - 1)), RING.shift(get(n - i, mH.get(Math.min(i, n - i))), 1));
    }
  };

  @Override
  protected Z compute(final int n, final int k) {
    return mB.get(n, mH.get(n)).coeff(k);
  }
}
#!queue	A319395	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319395 Number of partitions of n into exactly two positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319395 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A319396	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319396 Number of partitions of n into exactly three positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319396 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A319397	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319397 Number of partitions of n into exactly four positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319397 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A319398	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319398 Number of partitions of n into exactly five positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319398 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A319399	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319399 Number of partitions of n into exactly six positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319399 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A319400	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319400 Number of partitions of n into exactly seven positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319400 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A319401	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319401 Number of partitions of n into exactly eight positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319401 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A319402	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319402 Number of partitions of n into exactly nine positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319402 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A319403	1	->	0	A319394	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319403 Number of partitions of n into exactly ten positive Fibonacci numbers.
 * @author Georg Fischer
 */
public class A319403 extends A319394 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A319797	1	->	0	Triangle	--------------------------------
package irvine.oeis.a319;

import irvine.math.MemoryFunction1;
import irvine.math.MemoryFunctionInt2;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A319797 Number T(n,k) of partitions of n into exactly k positive triangular numbers; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A319797 extends Triangle {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  /** Construct the sequence. */
  public A319797() {
    super(1);
    hasRAM(true);
  }

  /* Maple:
    h:= proc(n) option remember; `if`(n<1, 0,
          `if`(issqr(8*n+1), n, h(n-1)))
        end:
    b:= proc(n, i) option remember; `if`(n=0 or i=1, x^n,
          b(n, h(i-1))+expand(x*b(n-i, h(min(n-i, i)))))
        end:
    T:= n-> (p-> seq(coeff(p, x, i), i=0..n))(b(n, h(n))):
    seq(T(n), n=0..20);
  */
  private final MemoryFunction1<Integer> mH = new MemoryFunction1<Integer>() {
    @Override
    protected Integer compute(final int n) {
      if (n < 1) {
        return 0;
      }
      return Z.valueOf(8 * n + 1).isSquare() ? n : get(n - 1);
    }
  };

  private final MemoryFunctionInt2<Polynomial<Z>> mB = new MemoryFunctionInt2<Polynomial<Z>>() {
    @Override
    protected Polynomial<Z> compute(final int n, final int i) {
      if (n == 0 || i == 1) {
        return RING.monomial(Z.ONE, n);
      }
      return RING.add(get(n, mH.get(i - 1)), RING.shift(get(n - i, mH.get(i < n - i ? i : n - i)), 1));
    }
  };

  @Override
  protected Z compute(final int n, final int k) {
    return mB.get(n, mH.get(n)).coeff(k);
  }
}
#!queue	A319799	1	->	0	A319797	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319799 Number of partitions of 2n into exactly n positive triangular numbers.
 * @author Georg Fischer
 */
public class A319799 extends A319797 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(2 * mN, mN);
  }
}

#!queue	A324054	1	->	0	A005940	--------------------------------
package irvine.oeis.a324;
// Generated by gen_seq4.pl sigman1/sigma1 at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a005.A005940;

/**
 * A324054 a(n) = A000203(A005940(1+n)).
 * @author Georg Fischer
 */
public class A324054 extends A005940 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A325334	1	->	0	A007862	--------------------------------
package irvine.oeis.a325;
// Generated by gen_seq4.pl dersimple at 2021-08-25 19:44

import irvine.math.z.Z;
import irvine.oeis.a007.A007862;

/**
 * A325334 Number of integer partitions of n with adjusted frequency depth 3 whose parts cover an initial interval of positive integers.
 * @author Georg Fischer
 */
public class A325334 extends A007862 {

  private int mN = 0;
  
  @Override
  public Z next() {
    ++mN;
    return mN <= 1 ? Z.ZERO : super.next().subtract(1);
  }
}
#!queue	A327737	2	->	1	A043000	--------------------------------
package irvine.oeis.a327;
// manually dersimpln at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a043.A043000;

/**
 * A327737 a(n) is the sum of the lengths of the base-b expansions of n for all b with 1 &lt;= b &lt;= n.
 * @author Georg Fischer
 */
public class A327737 extends A043000 {

  protected int mN;
  
  /** Construct the sequence. */
  public A327737() {
    mN = 0;
  }

  @Override
  public Z next() {
    ++mN;
    return mN == 1 ? Z.ONE : super.next().add(mN);
  }
}
#!queue	A329488	0	->	1	A001350	--------------------------------
package irvine.oeis.a329;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a001.A001350;

/**
 * A329488 a(n) = A001350(n)^4.
 * @author Georg Fischer
 */
public class A329488 extends A001350 {

  /** Construct the sequence. */
  public A329488() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().pow(4);
  }
}
#!queue	A331729	1	->	0	A002858	--------------------------------
package irvine.oeis.a331;

import irvine.math.z.Z;
import irvine.oeis.a002.A002858;

/**
 * A331729 Number of Ulam numbers u (A002858) between powers of 2, 2^n &lt; u &lt;= 2^(n+1).
 * @author Sean A. Irvine
 */
public class A331729 extends A002858 {

  private Z mLim = Z.ONE;
  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    mLim = mLim.shiftLeft(1);
    long cnt = 1; // start at 1 from value in previous iteration
    while (super.next().compareTo(mLim) <= 0) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A331759	1	->	0	A115004	--------------------------------
package irvine.oeis.a331;
// Generated by gen_seq4.pl n2 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a115.A115004;

/**
 * A331759 a(n) = A115004(2n+1).
 * @author Georg Fischer
 */
public class A331759 extends A115004 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A333361	1	->	0	A052107	--------------------------------
package irvine.oeis.a333;

import irvine.math.IntegerUtils;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a052.A052107;

/**
 * A333361 Array read by antidiagonals: T(n,k) is the number of directed loopless multigraphs with n arcs and k vertices.
 * @author Sean A. Irvine
 */
public class A333361 extends A052107 {

  // After Andrew Howroyd

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private int mM = 0;

  protected Polynomial<Z> edgesPoly(final int[] v, final int degree) {
    Polynomial<Z> prod = RING.one();
    for (int i = 1; i < v.length; ++i) {
      for (int j = 0; j < i; ++j) {
        final int g = IntegerUtils.gcd(v[i], v[j]);
        final int u = v[i] * v[j] / g;
        prod = RING.multiply(prod, RING.pow(RING.oneMinusXToTheN(u), 2 * g, degree), degree);
      }
    }
    for (final int j : v) {
      prod = RING.multiply(prod, RING.pow(RING.oneMinusXToTheN(j), j - 1, degree), degree);
    }
    return prod;
  }

  protected Polynomial<Z> g(final int n, final int degree) {
    if (n <= 0) {
      return RING.one();
    }
    Polynomial<Z> s = RING.zero();
    final IntegerPartition part = new IntegerPartition(n);
    int[] p;
    while ((p = part.next()) != null) {
      s = RING.add(s, RING.multiply(RING.series(RING.one(), edgesPoly(p, degree), degree), IntegerPartition.permCount(p, 1)));
    }
    return RING.divide(s, mF.factorial(n));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return g(mN - mM, mM).coeff(mM);
  }
}
#!queue	A336759	0	->	1	A010785	--------------------------------
package irvine.oeis.a336;

import java.util.Map;
import java.util.TreeMap;

import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A336759 a(n) is the smallest positive number that is the sum of no fewer than n distinct repdigits.
 * @author Sean A. Irvine
 */
public class A336759 extends A010785 {

  private final TreeMap<Z, Integer> mMap = new TreeMap<>();
  {
    super.next();
  }
  private Z mNextRepDigit = super.next();
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    while (true) {
      for (final Map.Entry<Z, Integer> e : mMap.entrySet()) {
        if (e.getKey().compareTo(mNextRepDigit) >= 0) {
          break; // We need to process another repdigit
        } else if (e.getValue() >= mN) {
          return e.getKey();
        }
      }
      // Process the next repdigit updating the minimal numbers
      final TreeMap<Z, Integer> revised = new TreeMap<>();
      for (final Map.Entry<Z, Integer> e : mMap.entrySet()) {
        final Z s = e.getKey().add(mNextRepDigit);
        final int cnt = e.getValue() + 1;
        final Integer prev = mMap.get(s);
        if (prev == null || cnt < prev) {
          revised.put(s, cnt);
        }
      }
      revised.put(mNextRepDigit, 1);
      mMap.putAll(revised);
      mNextRepDigit = super.next();
    }
  }
}
#!queue	A337165	1	->	0	Triangle	--------------------------------
package irvine.oeis.a337;

import irvine.math.IntegerUtils;
import irvine.math.MemoryFunction1;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A337165 Number T(n,k) of compositions of n into k nonzero squares; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A337165 extends Triangle {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  /** Construct the sequence. */
  public A337165() {
    super(1);
    hasRAM(true);
  }

  /* Maple:
    b:= proc(n) option remember; `if`(n=0, 1, add((s->
         `if`(s>n, 0, expand(x*b(n-s))))(j^2), j=1..isqrt(n)))
        end:
    T:= n-> (p-> seq(coeff(p, x, i), i=0..n))(b(n)):
    seq(T(n), n=0..14);
  */
  private final MemoryFunction1<Polynomial<Z>> mB = new MemoryFunction1<Polynomial<Z>>() {
    @Override
    protected Polynomial<Z> compute(final int n) {
      if (n == 0) {
        return RING.one();
      }
      Polynomial<Z> sum = RING.zero();
      final int jmax = IntegerUtils.sqrt(n);
      for (int j = 1; j <= jmax; ++j) {
        final int s = j * j;
        if (s <= n) {
          sum = RING.add(sum, RING.shift(get(n - s), 1));
        }
      }
      return sum;
    }
  };

  @Override
  public Z compute(final int n, final int k) {
    return mB.get(n).coeff(k);
  }
}
#!queue	A337171	0	->	1	A004186	--------------------------------
package irvine.oeis.a337;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a004.A004186;

/**
 * A337171 a(n) = A004186(n) mod n.
 * @author Georg Fischer
 */
public class A337171 extends A004186 {

  protected int mN;
  
  /** Construct the sequence. */
  public A337171() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A337884	1	->	2	A003190	--------------------------------
package irvine.oeis.a337;

import irvine.math.polynomial.PalmerSymPowerCycleIndex;
import irvine.math.z.Z;
import irvine.oeis.a003.A003190;

/**
 * A337884 Array read by descending antidiagonals: T(n,k) is the number of unoriented colorings of the triangular faces of a regular n-dimensional simplex using k or fewer colors.
 * @author Sean A. Irvine
 */
public class A337884 extends A003190 {

  private int mN = 3;
  private int mM = 2;

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 3;
    }
    return new PalmerSymPowerCycleIndex().cycleIndex(3, mM).eval(mN - mM).toZ();
  }
}
#!queue	A338464	1	->	0	A337165	--------------------------------
package irvine.oeis.a338;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a337.A337165;

/**
 * A338464 Number of ways to write 2*n as an ordered sum of n squares of positive integers.
 * @author Georg Fischer
 */
public class A338464 extends A337165 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(2 * mN, mN);
  }
}

#!queue	A338736	0	->	1	A005371	--------------------------------
package irvine.oeis.a338;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a005.A005371;

/**
 * A338736 a(n) = L(L(n)) mod n, where L = Lucas numbers = A000032.
 * @author Georg Fischer
 */
public class A338736 extends A005371 {

  protected int mN;
  
  /** Construct the sequence. */
  public A338736() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A339063	1	->	0	A052107	--------------------------------
package irvine.oeis.a339;

import java.util.Arrays;

import irvine.math.IntegerUtils;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a052.A052107;

/**
 * A339063 Number of unlabeled simple graphs with n edges rooted at two noninterchangeable vertices.
 * @author Sean A. Irvine
 */
public class A339063 extends A052107 {

  // After Andrew Howroyd

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final int[] PREFIX = {1, 1};
  private int mM = -1;

  private Polynomial<Z> edgesPoly(final int[] v, final int degreeLimit) {
    Polynomial<Z> prod = RING.one();
    for (int i = 1; i < v.length; ++i) {
      for (int j = 0; j < i; ++j) {
        final int g = IntegerUtils.gcd(v[i], v[j]);
        final Polynomial<Z> t = RING.pow(RING.onePlusXToTheN(v[i] * v[j] / g), g, degreeLimit);
        prod = RING.multiply(prod, t);
      }
    }
    for (final int c : v) {
      Polynomial<Z> t = RING.pow(RING.onePlusXToTheN(c), (c - 1) / 2, degreeLimit);
      if ((c & 1) == 0) {
        t = RING.multiply(t, RING.onePlusXToTheN(c / 2), degreeLimit);
      }
      prod = RING.multiply(prod, t, degreeLimit);
    }
    return prod;
  }

  private Polynomial<Z> g(final int n, final int[] prefix, final int degreeLimit) {
    Polynomial<Z> sum = RING.zero();
    final IntegerPartition part = new IntegerPartition(n);
    int[] p;
    while ((p = part.next()) != null) {
      final int[] q = Arrays.copyOf(prefix, p.length + prefix.length);
      System.arraycopy(p, 0, q, prefix.length, p.length);
      final Polynomial<Z> t = RING.multiply(edgesPoly(q, degreeLimit), IntegerPartition.permCount(p, 1));
      sum = RING.add(sum, t);
    }
    return RING.divide(sum, mF.factorial(n));
  }

  protected int[] getPrefix() {
    return PREFIX;
  }

  @Override
  public Z next() {
    if (++mM == 0) {
      return Z.ONE;
    }
    final Polynomial<Z> sum = g(2 * mM, getPrefix(), mM);
    return sum.coeff(mM);
  }
}
#!queue	A339812	0	->	1	A339809	--------------------------------
package irvine.oeis.a339;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A339812 Number of prime divisors of (A019565(n) - 1), counted with multiplicity.
 * @author Georg Fischer
 */
public class A339812 extends A339809 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A339813	0	->	1	A339809	--------------------------------
package irvine.oeis.a339;
// manually valuation/valuat at 2022-03-16 13:50

import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A339813 The exponent of the highest power of 2 dividing (A019565(n) - 1).
 * @author Georg Fischer
 */
public class A339813 extends A339809 {

  /** Construct the sequence. */
  public A339813() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.TWO));
  }
}
#!queue	A339814	0	->	1	A339809	--------------------------------
package irvine.oeis.a339;
// manually valuation/valuat at 2022-03-16 13:50

import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A339814 The exponent of the highest power of 2 dividing (A019565(2n) - 1).
 * @author Georg Fischer
 */
public class A339814 extends A339809 {

  /** Construct the sequence. */
  public A339814() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z result = Z.valueOf(ZUtils.valuation(super.next(), Z.TWO));
    super.next();
    return result;
  }
}
#!queue	A340101	1	->	0	A001055	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl n2 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a001.A001055;

/**
 * A340101 Number of factorizations of 2n + 1 into odd factors &gt; 1.
 * @author Georg Fischer
 */
public class A340101 extends A001055 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A340592	1	->	2	A037276	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a037.A037276;

/**
 * A340592 a(n) is the concatenation of the prime factors (with multiplicity) of n mod n.
 * @author Georg Fischer
 */
public class A340592 extends A037276 {

  protected int mN;
  
  /** Construct the sequence. */
  public A340592() {
    mN = 1;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341409	0	->	1	A001550	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001550 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001550;

/**
 * A341409 a(n) = (Sum_{k=1..3} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341409 extends A001550 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341409() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341410	0	->	1	A001551	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001551 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001551;

/**
 * A341410 a(n) = (Sum_{k=1..4} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341410 extends A001551 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341410() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341411	0	->	1	A001552	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001552 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001552;

/**
 * A341411 a(n) = (Sum_{k=1..5} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341411 extends A001552 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341411() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341412	0	->	1	A001553	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001553 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001553;

/**
 * A341412 a(n) = (Sum_{k=1..6} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341412 extends A001553 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341412() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341413	0	->	1	A001554	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001554 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001554;

/**
 * A341413 a(n) = (Sum_{k=1..7} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341413 extends A001554 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341413() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A342014	0	->	1	A003415	--------------------------------
package irvine.oeis.a342;
// Generated by gen_seq4.pl seqop a003 A003415 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a003.A003415;

/**
 * A342014 Arithmetic derivative of n, taken modulo n: a(n) = A003415(n) mod n.
 *
 * @author Georg Fischer
 */
public class A342014 extends A003415 {
  private int mN = 0;

  /** Construct the sequence. */
  public A342014() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A342122	0	->	1	A030101	--------------------------------
package irvine.oeis.a342;
// Generated by gen_seq4.pl seqop a030 A030101 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a030.A030101;

/**
 * A342122 a(n) is the remainder when the binary reverse of n is divided by n.
 *
 * @author Georg Fischer
 */
public class A342122 extends A030101 {
  private int mN = 0;

  /** Construct the sequence. */
  public A342122() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A344852	0	->	1	A000120	--------------------------------
package irvine.oeis.a344;
// manually 2021-06-15

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000120;
import irvine.oeis.a001.A001147;

/**
 * A344852 Number of rooted binary trees with n leaves with minimal Symmetry Nodes Index (SNI) or, equivalently, with the maximal number of symmetry nodes.
 * @author Georg Fischer
 */
public class A344852 extends A000120 {

  protected MemorySequence mSeqDF;

  /** Construct the sequence. */
  public A344852() {
    mSeqDF = MemorySequence.cachedSequence(new A001147()); // double factorials of odd numbers
    super.next(); // skip A000120(0)
  }

  @Override
  public Z next() {
    return mSeqDF.a(super.next().intValue() - 1);
  }
}
#!queue	A346865	0	->	1	A000384	--------------------------------
package irvine.oeis.a346;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A346865 Sum of divisors of the n-th hexagonal number.
 * @author Georg Fischer
 */
public class A346865 extends A000384 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A350361	2	->	1	A003057	--------------------------------
package irvine.oeis.a350;
// Generated by gen_seq4.pl dersimple at 2022-12-15 23:30

import irvine.math.z.Z;
import irvine.oeis.a003.A003057;

/**
 * A350361 2-tone chromatic number of a tree with maximum degree n.
 * @author Georg Fischer
 */
public class A350361 extends A003057 {

  @Override
  public Z next() {
    return super.next().add(2);
  }
}
#!queue	A350796	1	->	0	A350795	--------------------------------
package irvine.oeis.a350;

import irvine.math.z.Z;

/**
 * A350796 Number of unlabeled digraphs with n arcs and a global source and sink.
 * @author Sean A. Irvine
 */
public class A350796 extends A350795 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(gfRow(k, mN).coeff(mN).toZ());
    }
    return sum;
  }
}
#!queue	A350798	1	->	0	A350797	--------------------------------
package irvine.oeis.a350;

import irvine.math.z.Z;

/**
 * A350798 Number of unlabeled digraphs with n arcs and a global source (or sink).
 * @author Sean A. Irvine
 */
public class A350798 extends A350797 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(gfRow(k, mN).coeff(mN).toZ());
    }
    return sum;
  }
}
#!queue	A350906	1	->	0	A057278	--------------------------------
package irvine.oeis.a350;

import irvine.math.z.Z;
import irvine.oeis.a057.A057278;

/**
 * A350906 Number of unlabeled initially-finally connected digraphs with n arcs.
 * @author Sean A. Irvine
 */
public class A350906 extends A057278 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      sum = sum.add(gfRow(k, mN - 1).coeff(mN - 1).toZ());
    }
    return sum;
  }
}
#!queue	A350907	1	->	0	A057277	--------------------------------
package irvine.oeis.a350;

import irvine.math.z.Z;
import irvine.oeis.a057.A057277;

/**
 * A350907 Number of unlabeled initially connected digraphs with n arcs.
 * @author Sean A. Irvine
 */
public class A350907 extends A057277 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      sum = sum.add(gfRow(k, mN - 1).coeff(mN - 1).toZ());
    }
    return sum;
  }
}
#!queue	A359127	0	->	1	A002378	--------------------------------
package irvine.oeis.a359;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a002.A002378;

/**
 * A359127 Oblong numbers which are products of six distinct primes.
 * @author Sean A. Irvine
 */
public class A359127 extends A002378 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      final FactorSequence fs = Jaguar.factor(t);
      if (fs.bigOmega() == 6 && fs.omega() == 6) {
        return t;
      }
    }
  }
}

#!queue	A359304	0	->	1	A002378	--------------------------------
package irvine.oeis.a359;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a002.A002378;

/**
 * A359304 Oblong numbers which are products of five distinct primes.
 * @author Sean A. Irvine
 */
public class A359304 extends A002378 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      final FactorSequence fs = Jaguar.factor(t);
      if (fs.bigOmega() == 5 && fs.omega() == 5) {
        return t;
      }
    }
  }
}

#!queue	A361671	0	->	1	A000292	--------------------------------
package irvine.oeis.a361;
// manually knest at 2023-06-02 20:44

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000292;

/**
 * A361671 Squarefree part of the n-th tetrahedral number.
 * @author Georg Fischer
 */
public class A361671 extends A000292 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).core();
  }
}
#!queue	A999999	0	0	0	0
