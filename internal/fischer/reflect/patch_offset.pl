#!perl

# Patch offsets in Java source files
# @(#) $Id$
# 2023-06-21: moved here from ..
# 2022-08-20: -m; UHZ=3. Tag
# 2022-08-16, Georg Fischer
#
#:# Usage:
#:#   perl patch_offset.pl [-d debug] [-m {modpre|pre}] infile > outfile
#:#       -m modpre  modify offset or prefix it
#:#       -m prefix  prefix offset in any case
#:#       infile has tsv fields aseqno, offo -> offn, superclass
#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);
if (0 && scalar(@ARGV) == 0) {
    print `grep -E "^#:#" $0 | cut -b3-`;
    exit;
}
my $mode = "modpre";
my $debug = 0;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } elsif ($opt  =~ m{m}) {
        $mode      = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

my %tardirs;
my $srcroot = "../../../../joeis/src/irvine/oeis";
my $tarroot = "../../../src/irvine/oeis";
my $patch_count = 0;
my $aseqno;
my $otrans;
my ($offo, $offn);
my $superclass;
my $comment = "// generated by patch_offset.pl at $timestamp\n";
while (<>) { # read inputfile
    s{\s+\Z}{}; # chompr
    my $line = $_;
    next if ($line !~ m{\AA\d+});
    if ($debug >= 1) {
        print "$line\n";
    }
    ($aseqno, $otrans, $superclass) = split(/\t/, $line);
    $otrans =~ s{ \-\> }{\,}; # split "0 -> 1"
    ($offo, $offn) = split(/ *\, */, $otrans);
    &patch1();
} # while <>
print STDERR "# $patch_count files modified\n";
#----
sub patch1 {
    my $adir = lc(substr($aseqno, 0, 4));
    my $srcname = "$srcroot/$adir/$aseqno.java";
    my $tarpath = "$tarroot/$adir";
    if (! defined($tardirs{$tarpath}) or ! -d "$tarpath") { # tarpath not yet readable
        $tardirs{$tarpath} = 1;
        mkdir($tarpath); # || die "cannot mkdir $tarpath";
    }
    open(SRC, "<", $srcname) || die "cannot read $srcname\n";
    my $buffer;
    my $read_len = 100000000; # 100 MB
    read(SRC, $buffer, $read_len);
    close(SRC);
    $buffer =~ s{\n\/\/ *DO NOT EDIT[^\n]*}{}; # remove this
    $buffer =~ s{\n\n\n}{\n\n}mg; # remove duplicate newlines
    my $offset;
    my $write_it = 0; # assume that the target needs not be written
    # the real patch follows:
    if (0) {
    #========
    } elsif($mode =~ m{cond}) { # conditionally
        if (0) {
        #                     1               12      2
        } elsif ($buffer =~ m{(\n\s*super\(\s*)(\-?\d+)}m) { # there was already some offset "super(0, "
            $offset = $2;
            if ($offset ne $offn) {
        #                     1               12      2  
                $buffer  =~ s{(\n\s*super\(\s*)(\-?\d+)}   {$1$offn}m;
                $write_it = 1;
            } else {
                print "#?? $aseqno: $offn is already ok\n";
            }
        #                     1               1
        } elsif ($buffer =~ m{(\n\s*super\(\s*)\)}m)       { # no offset so far: "super()"
                $buffer  =~ s{(\n\s*super\(\s*)\)}         {$1$offn\)}m;
                $write_it = 1;
        #                     1            1
        } elsif ($buffer =~ m{(\n\s*super\(\s*)[\'\"a-zA-Z]}m) { # no offset so far: super(new, super(" ...
                $buffer  =~ s{(\n\s*super\(\s*)}           {$1$offn, }m;
                $write_it = 1;
        } else {
                print "#?? $aseqno: super not found:\n$buffer\n";
        }

    } elsif($mode =~ m{pref}) { # prefix always
        if (0) {
        #                     1               1
        } elsif ($buffer =~ m{(\n\s*super\(\s*)}m)         { # insert after "super("
                $buffer  =~ s{(\n\s*super\(\s*)}           {$1$offn, }m;
                $write_it = 1;
        } else {
                print "#?? $aseqno: super not found:\n$buffer\n";
        }
    } elsif($mode =~ m{fini}) { # prefix always with offset and attr
        if (0) {
        #                     1               1
        } elsif ($buffer =~ m{(\n\s*super\(\s*)}m)         { # insert after "super("
                my $attr = uc(substr($superclass, 0, 5));
                $attr =~ s{BRIEF.*}{BRIEF};
                $attr =~ s{FINIT.*}{FINITE};
                $attr =~ s{NONCO.*}{NONCOMPUTABLE};
                $buffer  =~ s{(\n\s*super\(\s*)}           {$1$offn, $attr, }m;
                $write_it = 1;
        } else {
                print "#?? $aseqno: super not found:\n$buffer\n";
        }
    }
    #========
    if ($write_it > 0) {
        $patch_count ++;
        if ($patch_count % 256 == 0) {
            print "# +$patch_count: write $tarpath/$aseqno.java\n";
        }
        if ($debug >= 2) {
            print "#----------------\n$buffer";
        }
        open(TAR, ">", "$tarpath/$aseqno.java") || die "cannot write $tarpath/$aseqno.java\n";
        print TAR $buffer;
        close(TAR);
    } # write_it
} # patch1
__DATA__
# Starting report at 2022-08-16 15:32:35
A002162 1 -> 0  DecimalExpansionSequence
A002285 1 -> 0  DecimalExpansionSequence
A002389 1 -> 0  DecimalExpansionSequence
A002390 1 -> 0  DecimalExpansionSequence
A002580 0 -> 1  DecimalExpansionSequence
A002794 1 -> 0  A030125
A002795 1 -> 0  A002794
A003077 1 -> 0  DecimalExpansionSequence
A003676 1 -> -33    DecimalExpansionSequence