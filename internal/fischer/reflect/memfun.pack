#!queue	A001430	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a001;

import java.util.Map;

import irvine.math.IntegerUtils;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.MultivariateMonomial;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.util.Pair;

/**
 * A001430 Number of graphs with n nodes and n-2 edges.
 * @author Sean A. Irvine
 */
public class A001430 extends MemoryFunction1Sequence<Polynomial<Q>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // See p. 145 in Riordan "Introduction to Combinatorial Analysis"
  private MultivariateMonomial slepian(final MultivariateMonomial t) {
    final int mm = t.maxIndex();
    final MultivariateMonomial m = new MultivariateMonomial();
    for (final Map.Entry<Pair<String, Integer>, Z> e : t.entrySet()) {
      final int j = e.getKey().right();
      // Handle terms of form a_j^k
      final Z k = e.getValue();
      if ((j & 1) == 0) {
        final int y = j / 2;
        m.add(y, k);
        m.add(j, k.multiply(k).multiply(y).subtract(k));
      } else {
        m.add(j, k.multiply(k).multiply(j).subtract(k).divide2());
      }
      // Handle all other composition terms; i.e. a_j^k o a_i^d
      for (int i = j + 1; i <= mm; ++i) {
        final Z d = t.get(new Pair<>(MultivariateMonomial.DEFAULT_VARIABLE, i));
        final int gcd = IntegerUtils.gcd(i, j);
        m.add(i * j / gcd, d.multiply(k).multiply(gcd));
      }
    }
    m.setCoefficient(t.getCoefficient());
    return m;
  }

  private CycleIndex slepian(final int n) {
    final CycleIndex zn = SymmetricGroup.create(n).cycleIndex();
    final CycleIndex ans = new CycleIndex("G");
    for (final MultivariateMonomial t : zn.values()) {
      ans.add(slepian(t));
    }
    return ans;
  }

  @Override
  protected Polynomial<Q> compute(final int n) {
    return n == 0 ? null : slepian(n).applyOnePlusXToTheN();
  }

  protected Z numberLinearGraphs(final int nodes, final int edges) {
    if (nodes == 1) {
      return edges == 0 ? Z.ONE : Z.ZERO;
    }
    if (edges < 0) {
      return Z.ZERO;
    }
    return get(nodes).coeff(edges).toZ();
  }

  protected int mN = 0;

  @Override
  public Z next() {
    return numberLinearGraphs(++mN, mN - 2);
  }

}
#!queue	A002302	0	->	3	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a002;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A002302 Generalized tangent numbers.
 * @author Sean A. Irvine
 */
public class A002302 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k < 0 || k > n) {
      return Z.ZERO;
    }
    if (n == 1 && k == 1) {
      return Z.ONE;
    }
    return get(n - 1, k - 1).multiply(k - 1).add(get(n - 1, k + 1).multiply(k + 1));
  }

  @Override
  public Z next() {
    ++mN;
    return get(mN + 4, mN);
  }
}
#!queue	A002672	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a002;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A002672 Denominators of central difference coefficients M_{3}^(2n+1).
 * @author Sean A. Irvine
 */
public class A002672 extends MemoryFunction2Sequence<Integer, Q> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  @Override
  protected Q compute(final Integer k, final Integer q) {
    if (k.equals(q)) {
      return Q.ONE;
    }
    if (k == 0 || k > q || ((k + q) & 1) == 1) {
      return Q.ZERO;
    }
    if (k == 1 && (q & 1) == 1) {
      return new Q(Z.ONE, Z.ONE.shiftLeft(q - 1));
    }
    if (k == 2 && (q & 1) == 0) {
      return Q.ONE;
    }
    return get(k - 2, q - 2).add(get(k, q - 2).multiply(k * (long) k).divide(4));
  }

  protected Q bigM(final int k, final int q) {
    return get(k, q).multiply(mF.factorial(k)).divide(mF.factorial(q));
  }

  private int mN = 1;

  @Override
  public Z next() {
    mN += 2;
    return bigM(3, mN).den();
  }
}
#!queue	A002723	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.partitions.IntegerPartition;
import irvine.math.partitions.MultidimensionalIntegerPartition;
import irvine.math.partitions.MultidimensionalIntegerPartition.PartitionUser;
import irvine.math.z.Z;


/**
 * A002723 Rotatable partitions.
 * @author Sean A. Irvine
 */
public class A002723 extends MemoryFunction1Sequence<Long> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // This currently is given different values for later terms
  // It could be an error in the original sequence?

  private static class UnitPartitionFilter implements PartitionUser {
    final PartitionUser mParent;
    UnitPartitionFilter(final PartitionUser parent) {
      mParent = parent;
    }

    @Override
    public void use(final int[][] partition) {
      final int[] lastDimension = partition[partition.length - 1];
      for (int v : lastDimension) {
        if (v != 0) {
          return;
        }
      }
      mParent.use(partition);
    }
  }

  private static class RotatablePartitionFilter implements PartitionUser {
    final PartitionUser mParent;
    RotatablePartitionFilter(final PartitionUser parent) {
      mParent = parent;
    }

    private List<Integer> rotateList(final List<Integer> orig) {
      final List<Integer> rotatedList = new ArrayList<>(orig.size());
      for (int k = 1; k < orig.size(); ++k) {
        rotatedList.add(orig.get(k));
      }
      rotatedList.add(orig.get(0));
      return rotatedList;
    }

    @Override
    public void use(final int[][] partition) {
      final Collection<List<Integer>> ferrier = MultidimensionalIntegerPartition.nodesToFerrier(partition);
      for (final List<Integer> coords : ferrier) {
        if (!ferrier.contains(rotateList(coords))) {
          return;
        }
      }
      mParent.use(partition);
    }
  }

  private int mN = 0;

  private long computeUnitRotatablePartitions(final int dimensions, final int n) {
    final MultidimensionalIntegerPartition partitions = new MultidimensionalIntegerPartition(n, dimensions);
    final MultidimensionalIntegerPartition.CountPartitionUser user = new MultidimensionalIntegerPartition.CountPartitionUser();
    final UnitPartitionFilter unitFilter = new UnitPartitionFilter(new RotatablePartitionFilter(user));
    partitions.generate(unitFilter);
    return user.count();
  }

  @Override
  protected Long compute(final int n) {
    return n == 0 ? 0L : computeUnitRotatablePartitions(dimension(), n);
  }

  protected int dimension() {
    return 4;
  }

  @Override
  public Z next() {
    Z s = Z.ZERO;
    int[] p;
    final IntegerPartition part = new IntegerPartition(++mN);
    while ((p = part.next()) != null) {
      Z t = Z.ONE;
      for (int v : p) {
        t = t.multiply(get(v));
      }
      s = s.add(t);
    }
    return s;
  }
}
#!queue	A002735	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a002;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A002735 Related to Euler numbers.
 * @author Sean A. Irvine
 */
public class A002735 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  @Override
  protected Z compute(final Long m, final Long n) {
    if (n == 1) {
      return Z.valueOf(m).square();
    }
    if ((n & 1) == 0) {
      Z s = Z.ZERO;
      for (long k = 1; k <= m + 1; ++k) {
        s = s.add(get(k, n - 1));
      }
      return s;
    } else {
      return get(m, n - 1).multiply(get(m, 1L));
    }
  }

  @Override
  public Z next() {
    return get(2L, ++mN);
  }
}
#!queue	A003125	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.MemoryFunction2;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A003125 Value of an urn with n balls of type -1 and n+2 balls of type +1.
 * @author Sean A. Irvine
 */
public class A003125 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static class AFunction extends MemoryFunction2<Integer, Z> {
    @Override
    protected Z compute(final Integer m, final Integer p) {
      if (m < 0 || p < 0) {
        return Z.ZERO;
      }
      if (m == 0 && p == 0) {
        return Z.ZERO;
      }
      if (m == 1 && p == 0) {
        return Z.NEG_ONE;
      }
      if (m == 0 && p == 1) {
        return Z.ONE;
      }
      return get(m - 1, p).add(get(m, p - 1));
    }
  }

  private final MemoryFunction2<Integer, Z> mA = new AFunction();
  private int mN = -1;

  @Override
  protected Z compute(final Integer m, final Integer p) {
    if (m < 0 || p < 0) {
      return Z.ZERO;
    }
    return Z.ZERO.max(mA.get(m, p).add(get(m - 1, p).add(get(m, p - 1))));
  }

  protected int delta() {
    return 2;
  }

  @Override
  public Z next() {
    ++mN;
    return get(mN, mN + delta());
  }

}

#!queue	A003190	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a003;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.Mobius;
import irvine.math.polynomial.PalmerSymPowerCycleIndex;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A003190 Number of connected 2-plexes.
 * @author Sean A. Irvine
 */
public class A003190 extends MemoryFunction2Sequence<Integer, Q> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // This is close, but currently differs from existing sequence in later terms
  // It is unclear if this implementation or the original results are wrong.
  // In particular, for the monomial a_3a_4 I get a_1a_4a_6a_{12}^2, but it
  // looks like the papers has a_1a_2^3a_4^7.  Tracing this further, the
  // difference occurs in the calculation of M2 where I get a_6a_{12}^2 and
  // it apparently should be a_2^3a_4^6.
  //
  // Extra evidence that my implementation is correct comes from A000665 which
  // is the Euler transform of this sequence.

  private int mN = 0;

  private final PalmerSymPowerCycleIndex mSym = new PalmerSymPowerCycleIndex();

  @Override
  protected Q compute(final Integer n, final Integer p) {
    Q s = Q.ZERO;
    for (int k = 1; k < p; ++k) {
      s = s.add(mSym.get(n, p - k).multiply(get(n, k)).multiply(k));
    }
    return mSym.get(n, p).subtract(s.divide(p));
  }

  protected Z c(final int n, final int p) {
    Q s = Q.ZERO;
    for (final Z dd : Jaguar.factor(p).divisors()) {
      final int d = dd.intValueExact();
      s = s.add(get(n, p / d).multiply(Mobius.mobius(d)).divide(d));
    }
    assert s.isInteger();
    return s.toZ();
  }

  @Override
  public Z next() {
    return c(2, ++mN);
  }
}
#!queue	A004747	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a004;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A004747 Triangle read by rows: the Bell transform of the triple factorial numbers A008544 without column 0.
 * @author Sean A. Irvine
 */
public class A004747 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < m || m == 0) {
      return Z.ZERO;
    }
    if (m == 1 && n == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(3 * (n - 1) - m).add(get(n - 1, m - 1));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }

}
#!queue	A005198	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.List;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000081;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A005198 a(n) is the number of forests with n (unlabeled) nodes in which each component tree is planted, that is, is a rooted tree in which the root has degree 1.
 * @author Sean A. Irvine
 */
public class A005198 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA81 = new A000081();
  private final List<Z> mT = new ArrayList<>();
  {
    mT.add(null);
  }

  private Z getT(final int i) {
    while (i >= mT.size()) {
      mT.add(mA81.next());
    }
    return mT.get(i);
  }

  @Override
  protected Z compute(final int n, final int i, final int p) {
    if (p > n) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    if (Math.min(i, p) < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = 0; j <= Math.min(n / i, p); ++j) {
      sum = sum.add(get(n - i * j, i - 1, p - j).multiply(Binomial.binomial(getT(i).add(j - 1), Z.valueOf(j))));
    }
    return sum;
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      sum = sum.add(get(mN, mN, k));
    }
    return sum;
  }
}
#!queue	A005264	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A005264 Number of labeled rooted Greg trees with n nodes.
 * @author Sean A. Irvine
 */
public class A005264 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }
  
  // After Peter Luschny

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (k < 0 || k > n) {
      return Z.ZERO;
    }
    if (k == 0 && (n == 0 || n == 1)) {
      return Z.ONE;
    }
    return get(n - 1, k - 1).multiply(n - 1).add(get(n - 1, k).multiply(3 * n - k - 4)).subtract(get(n - 1, k + 1).multiply(k + 1));
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.signedAdd((k & 1) == 0, get(mN, k).shiftLeft(mN - k - 1));
    }
    return sum;
  }
}
#!queue	A005328	0	->	2	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A005328 Certain subgraphs of a directed graph.
 * @author Sean A. Irvine
 */
public class A005328 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 1;

  @Override
  protected Z compute(final int n) {
    Z prod = Z.ONE;
    for (int i = 1; i <= n; ++i) {
      prod = prod.multiply(Z.ONE.shiftLeft(i).subtract(1));
    }
    return prod;
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final Z p = get(mN - 1);
    for (int k = 0; k <= mN - 2; ++k) {
      sum = sum.signedAdd((k & 1) == 0, p.multiply(mN - 1 - k).divide(get(k)));
    }
    return sum;
  }

}
#!queue	A005333	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005333 Number of 2-colored connected labeled graphs with n vertices of the first color and n vertices of the second color.
 * @author Sean A. Irvine
 */
public class A005333 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n == 0) {
      return m == 1 ? Z.ONE : Z.ZERO;
    }
    if (m > n) {
      return get(m, n);
    }
    Z sum = Z.ONE.shiftLeft(n * m);
    for (int a = 1; a <= n; ++a) {
      final Z ba = Binomial.binomial(n - 1, a - 1);
      for (int b = 0; b <= m; ++b) {
        if (a < n || b < m) {
          sum = sum.subtract(ba.multiply(Binomial.binomial(m, b)).multiply(get(a, b)).shiftLeft((n - a) * (m - b)));
        }
      }
    }
    return sum;
  }


  @Override
  public Z next() {
    ++mN;
    return get(mN, mN);
  }
}
#!queue	A005489	0	->	1	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a005;

import java.util.Arrays;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRing;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.util.Permutation;

/**
 * A005489 Number of nonzero coefficients of order n in Baker-Campbell-Hausdorff expansion.
 * @author Sean A. Irvine
 */
public class A005489 extends MemoryFunctionSequence<Integer, Polynomial<Q>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Andrey Zabolotskiy

  private static final PolynomialRing<Q> RING = new PolynomialRing<>(Rationals.SINGLETON);
  private static final Polynomial<Q> C1 = RING.create(Arrays.asList(Q.NEG_ONE, Q.TWO));
  private static final Polynomial<Q> C2 = RING.create(Arrays.asList(Q.ZERO, Q.NEG_ONE, Q.ONE));
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;

  @Override
  protected Polynomial<Q> compute(final Integer s) {
    if (s == 1) {
      return RING.one();
    }
    return RING.add(
      RING.multiply(get(s - 1), C1),
      RING.multiply(C2, RING.diff(get(s - 1)))
    );
  }

  private Q cx(final int[] ss) {
    final int m = ss.length + 1;
    final int mp = m / 2;
    Polynomial<Q> gamma = RING.one();
    for (final int s : ss) {
      gamma = RING.multiply(gamma, get(s));
    }
    Q sum = Q.ZERO;
    for (int k = 0; k < gamma.size(); ++k) {
      sum = sum.add(gamma.coeff(k).multiply(mF.factorial(mp + k)).divide(mF.factorial(m + k)));
    }
    // Strictly there should be a multiplier applied to the sum as below, but
    // because we only care if the sum if 0 and the multiplier is never 0, then
    // we do not need to compute it.
    return sum;
//    final int mpp = (m - 1) / 2;
//    Q multiplier = new Q(mF.factorial(mpp));
//    for (final int s : ss) {
//      multiplier = multiplier.divide(mF.factorial(s));
//    }
//    final Q sm = sum.multiply(multiplier);
//    return (mpp & 1) == 0 ? sm : sm.negate();
  }

  private long per(final int[] p) {
    final Permutation perm = new Permutation(p);
    long c = 0;
    while (perm.next() != null) {
      ++c;
    }
    return c;
  }

  private Z cxs(final int n) {
    final IntegerPartition part = new IntegerPartition(n - 1);
    int[] p;
    Z sum = Z.ZERO;
    while ((p = part.next()) != null) {
      final Q cx = cx(p);
      if (!Q.ZERO.equals(cx)) {
        sum = sum.add(per(p));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return cxs(mN);
  }
}
#!queue	A005490	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A005490 Number of partitions of [n] where the first k elements are marked (0 &lt;= k &lt;= n-1) and at least k blocks contain their own index.
 * @author Sean A. Irvine
 */
public class A005490 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Z compute(final Integer n, final Integer i) {
    if (i == 1) {
      return Z.valueOf(n);
    }
    return get(n - 1, i - 1).multiply(n - i).add(get(n, i - 1));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}

#!queue	A005612	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005612 Number of Boolean functions of n variables that are variously called "unate cascades" or "1-decision list functions" or "read-once threshold functions".
 * @author Sean A. Irvine
 */
public class A005612 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  protected Z compute(final int n) {
    if (n == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 1; k <= n; ++k) {
      sum = sum.add(Binomial.binomial(n, k).multiply(get(n - k)));
    }
    return sum;
  }

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.TWO;
    }
    return get(mN).subtract(get(mN - 1).multiply(mN)).shiftLeft(mN + 1);
  }
}
#!queue	A005751	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.factor.factor.Jaguar;
import irvine.math.MemoryFunction1;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A005751 Number of matched trees with 2n nodes.
 * @author Sean A. Irvine
 */
public class A005751 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private static class R2Function extends MemoryFunction1<Z> {

    @Override
    protected Z compute(final int n) {
      if (n == 1) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (int m = 1; m < n; ++m) {
        Z t = Z.ZERO;
        for (final Z d : Jaguar.factor(n - m).divisors()) {
          t = t.add(get(d.intValueExact()).multiply(d));
        }
        sum = sum.add(t.multiply(get(m)));
      }
      return sum.multiply2().divide(n - 1);
    }
  }

  private final R2Function mR2 = new R2Function();
  private int mN = 0;

  @Override
  protected Z compute(final int n) {
    if (n == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int m = 1; m < n; ++m) {
      Z t = Z.ZERO;
      for (final Z d : Jaguar.factor(n - m).divisors()) {
        t = t.add(mR2.get(d.intValueExact()).multiply(d));
      }
      sum = sum.add(t.multiply(get(m)));
    }
    return sum.divide(n - 1);
  }

  @Override
  public Z next() {
    Z t = mR2.get(++mN);
    for (int m = 1; m < mN; ++m) {
      t = t.subtract(mR2.get(m).multiply(mR2.get(mN - m)));
    }
    if ((mN & 1) == 0) {
      t = t.add(mR2.get(mN / 2));
    } else {
      t = t.add(get((mN + 1) / 2));
    }
    return t.divide2();
  }
}
#!queue	A005753	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.util.array.LongDynamicArray;

/**
 * A005753 Number of rooted identity matched trees with n nodes.
 * @author Sean A. Irvine
 */
public class A005753 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private final LongDynamicArray<Z> mA = new LongDynamicArray<>();
  private long mN = -1;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 0) {
      return Z.ONE;
    }
    if (k < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    final Z m = mA.get(k).multiply2();
    for (long j = 0; j <= n / k; ++j) {
      sum = sum.add(Binomial.binomial(m, Z.valueOf(j)).multiply(get(n - k * j, k - 1)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      mA.set(mN + 1, Z.ONE);
      return Z.ONE;
    }
    final Z z = get(mN, mN);
    mA.set(mN + 1, z);
    return z;
  }

}
#!queue	A005754	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.MemoryFunction2;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005754 Number of planted identity matched trees with n nodes.
 * @author Sean A. Irvine
 */
public class A005754 extends MemoryFunction2Sequence<Long, Z> {

  protected int mLeaves;

  /** Construct the sequence. */
  public A005754() {
    this(2);
  }

  /**
   * Generic constructor with parameter
   * @param leaves number of leaves
   */
  public A005754(final int leaves) { 
    super($(OFFSET));
    mLeaves = leaves;
  }

  // After Alois P. Heinz

  private class BFunction extends MemoryFunction2<Long, Z> {
    @Override
    protected Z compute(final Long n, final Long k) {
      if (n == 0) {
        return Z.ONE;
      }
      if (k < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final Z m = get(k - 1, k - 1).multiply(mLeaves);
      for (long j = 0; j <= n / k; ++j) {
        sum = sum.add(Binomial.binomial(m, Z.valueOf(j)).multiply(get(n - k * j, k - 1)));
      }
      return sum;
    }
  }

  private final BFunction mB = new BFunction();
  private long mN = -1;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 0) {
      return Z.ONE;
    }
    if (k < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long j = 0; j <= n / k; ++j) {
      sum = sum.add(Binomial.binomial(mB.get(k - 1, k - 1), Z.valueOf(j)).multiply(get(n - k * j, k - 1)));
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    return get(mN, mN);
  }
}
#!queue	A005755	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.factor.factor.Jaguar;
import irvine.math.MemoryFunction1;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A005755 Number of identity matched trees with n nodes.
 * @author Sean A. Irvine
 */
public class A005755 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private static class BFunction extends MemoryFunction1<Z> {
    @Override
    protected Z compute(final int n) {
      if (n <= 1) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (int m = 1; m < n; ++m) {
        Z t = Z.ZERO;
        for (final Z d : Jaguar.factor(n - m).divisors()) {
          final int dd = d.intValueExact();
          t = t.signedAdd((((n - m) / dd) & 1) == 1, get(dd).multiply(d));
        }
        sum = sum.add(t.multiply(get(m)));
      }
      return sum.multiply2().divide(n - 1);
    }
  }

  private final BFunction mB2 = new BFunction();
  private int mN = 0;

  @Override
  protected Z compute(final int n) {
    if (n <= 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int m = 1; m < n; ++m) {
      Z t = Z.ZERO;
      for (final Z d : Jaguar.factor(n - m).divisors()) {
        final int dd = d.intValueExact();
        t = t.signedAdd((((n - m) / dd) & 1) == 1, mB2.get(dd).multiply(d));
      }
      sum = sum.add(t.multiply(get(m)));
    }
    return sum.divide(n - 1);
  }

  @Override
  public Z next() {
    Z t = mB2.get(++mN);
    for (int m = 1; m < mN; ++m) {
      t = t.subtract(mB2.get(m).multiply(mB2.get(mN - m)));
    }
    if ((mN & 1) == 0) {
      t = t.subtract(mB2.get(mN / 2));
    } else {
      t = t.subtract(get((mN + 1) / 2));
    }
    return t.divide2();
  }
}
#!queue	A005895	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A005895 Weighted count of partitions with distinct parts.
 * @author Sean A. Irvine
 */
public class A005895 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long i) {
    if (n > i * (i + 1) / 2) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    Z b = get(n, i - 1);
    if (i <= n) {
      b = b.add(get(n - i, Math.min(n - i, i - 1)));
    }
    return b;
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long j = 1; j <= mN; ++j) {
      sum = sum.add(get(mN - j, Math.min(mN - j, j - 1)).multiply(j));
    }
    return sum;
  }
}
#!queue	A005941	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.MemoryFunction3;
import irvine.math.z.Z;

/**
 * A005941 Inverse of the Doudna sequence A005940.
 * @author Sean A. Irvine
 */
public class A005941 extends MemoryFunction2Sequence<Z, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After R. J. Mathar

  private long mN = 0;

  @Override
  protected Z compute(final Z n, final Z m) {
    return n.signum() == 0 ? m : get(n.divide2(), m.multiply2().add(n.and(Z.ONE)));
  }

  private static class GFunction extends MemoryFunction3<Z, Z> {

    private final Fast mPrime = new Fast();
    private final ArrayList<Long> mP = new ArrayList<>();
    {
      mP.add(null);
      mP.add(2L);
    }

    private long ithPrime(final Z ii) {
      final int i = ii.intValueExact();
      while (i >= mP.size()) {
        mP.add(mPrime.nextPrime(mP.get(mP.size() - 1)));
      }
      return mP.get(i);
    }

    @Override
    protected Z compute(final Z n, final Z i, final Z x) {
      if (Z.ONE.equals(n)) {
        return x;
      }
      if (n.mod(ithPrime(i)) == 0) {
        return get(n.divide(ithPrime(i)), i, x.multiply2().add(1));
      } else {
        return get(n, i.add(1), x.multiply2());
      }
    }
  }

  private final GFunction mG = new GFunction();

  @Override
  public Z next() {
    ++mN;
    return get(mG.get(Z.valueOf(mN), Z.ONE, Z.ONE), Z.ZERO).add(1).divide2();
  }
}
#!queue	A005946	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;

/**
 * A005946 Number of n-step mappings with 5 inputs.
 * @author Sean A. Irvine
 */
public class A005946 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;
  protected int mN = 0;

  protected static Z per(final int[] a) {
    Z c = Z.ONE;
    for (int i = 1; i < a.length; ++i) {
      c = c.multiply(FACTORIAL.factorial(a[i])).multiply(FACTORIAL.factorial(i).pow(a[i]));
    }
    return c;
  }

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 1 || n == 1) {
      return Z.ONE;
    }
    if (n == 2) {
      return Z.valueOf(m);
    }
    // Eqn (16) Hogg & Huberman
    Z sum = Z.ZERO;
    final IntegerPartition part = new IntegerPartition(n);
    final int[] lambda = new int[n + 1];
    int[] p;
    while ((p = part.next()) != null) {
      IntegerPartition.toCountForm(p, lambda);
      Z t = Z.ONE;
      for (int k = 1; k < lambda.length; ++k) {
        t = t.multiply(get(k, m - 1).pow(lambda[k]));
      }
      t = t.multiply(FACTORIAL.factorial(n));
      t = t.divide(per(lambda));
      sum = sum.add(t);
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(5, ++mN);
  }
}
#!queue	A006022	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a006;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A006022 Sprague-Grundy (or Nim) values for the game of Maundy cake on an n X 1 sheet.
 * @author Sean A. Irvine
 */
public class A006022 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z compute(final int n) {
    if (n <= 2) {
      return Z.valueOf(n - 1);
    }
    final Z[] p = Jaguar.factor(n).toZArray();
    final int np = n / p[0].intValue();
    return get(np).add(np);
  }

  private int mN = 0;

  @Override
  public Z next() {
    return get(++mN);
  }
}
#!queue	A006081	0	->	2	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.MemoryFunction1;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A006081 Number of line-rooted projective plane trees with n nodes.
 * @author Sean A. Irvine
 */
public class A006081 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final class BFunction extends MemoryFunction1<Z> {

    @Override
    protected Z compute(final int n) {
      return Binomial.binomial(n, n / 2);
    }
  }

  private final BFunction mB = new BFunction();
  private int mN = -1;

  @Override
  protected Z compute(final int n) {
    return Binomial.binomial(2L * n, n).divide(n + 1);
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      sum = sum.add(get(k).multiply(get(mN - k)).add(mB.get(k).multiply(mB.get(mN - k))));
    }
    if ((mN & 1) == 0) {
      sum = sum.add(get(mN / 2).multiply2());
    }
    return sum.divide(4);
  }

}
#!queue	A006801	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a006;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A006801 Number of 2-dimensional directed compact animals of size n.
 * @author Sean A. Irvine
 */
public class A006801 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After David Bevan

  private int mN = 0;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (n < 1 || k < 1 || k * (k + 1) / 2 > n) {
      return Z.ZERO;
    }
    if (n == 1 && k == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int j = k - 1; j <= n - k; ++j) {
      sum = sum.add(get(n - k, j).multiply(j - k + 2));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 1; k < mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A006875	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a006;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.Mobius;
import irvine.math.z.Euler;
import irvine.math.z.Z;

/**
 * A006875 Non-seed mu-atoms of period n in Mandelbrot set.
 * @author Sean A. Irvine
 */
public class A006875 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Z compute(final int n) {
    Z sum = Z.ZERO;
    for (final Z cc : Jaguar.factor(n).divisors()) {
      final int c = cc.intValueExact();
      sum = sum.add(Z.ONE.shiftLeft(c - 1).multiply(Mobius.mobius(n / c)));
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(mN).divisors()) {
      final int d = dd.intValueExact();
      if (d < mN) {
        sum = sum.add(get(d).multiply(Euler.phiAsLong(mN / d)));
      }
    }
    return sum;
  }
}
#!queue	A007046	0	->	3	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A007046 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007046 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 2;

  @Override
  protected Z compute(final Long n, final Long k) {
    final long kh = k * (k + 1) / 2;
    if (n == kh) {
      return Z.ONE;
    } else if (n < kh) {
      return Z.ZERO;
    }
    Z sum = get(n, k + 1);
    for (long r = 1; r <= k; ++r) {
      sum = sum.add(get(n - kh + r * (r - 1) / 2, r).multiply(Binomial.binomial(k + 1, r)));
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, 2L);
  }
}
#!queue	A007048	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A007048 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007048 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    final long kh = k * (k + 1) / 2;
    if (n == kh) {
      return Z.ONE;
    } else if (n < kh) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long r = k - 1; r * (r + 1) <= 2 * n; ++r) {
      if (r > 0) {
        sum = sum.add(get(n - k, r).multiply(Binomial.binomial(r + 1, k)));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, 1L);
  }
}
#!queue	A007062	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A007062 Let P(n) of a sequence s(1),s(2),s(3),... be obtained by leaving s(1),...,s(n) fixed and reversing every n consecutive terms thereafter; apply P(2) to 1,2,3,... to get PS(2), then apply P(3) to PS(2) to get PS(3), then apply P(4) to PS(3), etc. This sequence is the limit of PS(n).
 * @author Sean A. Irvine
 */
public class A007062 extends MemoryFunction2Sequence<Integer, Integer> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  protected Integer compute(final Integer n, final Integer m) {
    if (n == 0) {
      return m;
    }
    return get(n - 1, n * (m / n) + n - m % n);
  }

  private int mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(get(++mN, 0) + 1);
  }
}
#!queue	A007071	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A007071 First row of 2-shuffle of spectral array W( sqrt 2 ).
 * @author Sean A. Irvine
 */
public class A007071 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After R. J. Mathar.

  private int mN = 0;

  private Z wythSpec(final Z n, final CR x) {
    return x.multiply(n).floor();
  }

  private Z a1951(final Z n) {
    return wythSpec(n, CR.SQRT2);
  }

  private Z a1952(final Z n) {
    return a1951(n).add(n.multiply2());
  }

  private Z wSqrt(final long i, final long j) {
    if (j == 1) {
      return a1951(a1951(Z.valueOf(i)));
    } else if (j == 2) {
      return a1952(a1951(Z.valueOf(i)));
    } else if ((j & 1) == 1) {
      return a1951(wSqrt(i, j - 1));
    } else {
      return a1952(wSqrt(i, j - 2));
    }
  }

  @Override
  protected Z compute(final int n) {
    if (n <= 1) {
      return Z.ONE;
    }
    Z a = get(n - 1);
    while (true) {
      a = a.add(1);
      for (int j = 1; j <= 2; ++j) {
        int c;
        int k = 0;
        while ((c = wSqrt(++k, j).compareTo(a)) <= 0) {
          if (c == 0) {
            return a;
          }
        }
      }
    }
  }

  @Override
  public Z next() {
    return get(++mN);
  }
}
#!queue	A007077	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A007077 Optimal cost of search tree for searching an ordered array of n elements with cost k of probing element k.
 * @author Sean A. Irvine
 */
public class A007077 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long d) {
    if (n == 0) {
      return Z.ZERO;
    }
    Z min = null;
    for (long r = 1; r <= n; ++r) {
      final Z t = get(r - 1, d).add(get(n - r, r + d)).add(Z.valueOf(n).multiply(r + d));
      min = min == null ? t : min.min(t);
    }
    return min;
  }

  @Override
  public Z next() {
    return get(++mN, 0L);
  }
}
#!queue	A007099	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A007099 Number of labeled trivalent (or cubic) 2-connected graphs with 2n nodes.
 * @author Sean A. Irvine
 */
public class A007099 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private Z mF = Z.ONE;

  @Override
  protected Z compute(final int n) {
    if (n <= 1) {
      return Z.ZERO;
    }
    if (n == 2) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int i = 2; i < n - 2; ++i) {
      sum = sum.add(get(i).multiply(get(n - 1 - i)));
    }
    return sum.multiply(3L * n - 1).add(get(n - 2).multiply2()).add(get(n - 1).multiply(3L * n));
  }

  @Override
  public Z next() {
    ++mN;
    mF = mF.multiply(2L * mN).multiply(2L * mN - 1);
    return get(mN).subtract(get(mN - 1).multiply2()).multiply(mF).shiftRight(mN).divide(3L * mN);
  }
}
#!queue	A007100	0	->	2	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A007100 Number of labeled trivalent (or cubic) 3-connected graphs with 2n nodes.
 * @author Sean A. Irvine
 */
public class A007100 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 1;
  private Z mF = Z.TWO;

  @Override
  protected Z compute(final int n) {
    if (n < 2) {
      return Z.ZERO;
    }
    if (n == 2) {
      return Z.ONE;
    }
    Z sum = get(n - 1);
    for (int i = 2; i < n - 1; ++i) {
      sum = sum.add(get(i).multiply(get(n - i)));
    }
    return sum.multiply(3L * n - 2);
  }

  @Override
  public Z next() {
    ++mN;
    mF = mF.multiply(2L * mN).multiply(2L * mN - 1);
    return get(mN).multiply(mF).shiftRight(mN).divide(3L * mN);
  }
}
#!queue	A007101	0	->	2	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A007101 Number of labeled trivalent (or cubic) cyclically 4-connected graphs with 2n nodes.
 * @author Sean A. Irvine
 */
public class A007101 extends MemoryFunction1Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 1;
  private Z mF = Z.TWO;

  @Override
  protected Z compute(final int n) {
    if (n < 2) {
      return Z.ZERO;
    }
    if (n == 2) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int i = 1; i < n - 1; ++i) {
      sum = sum.add(get(n - i).multiply(get(i + 1).multiply(2L * i + 1).add(get(i).multiply(i + 1))));
    }
    return sum.multiply2().subtract(get(n - 1).multiply(n + 2));
  }

  @Override
  public Z next() {
    ++mN;
    mF = mF.multiply(2L * mN).multiply(2L * mN - 1);
    return get(mN).multiply(mF).shiftRight(mN).divide(3L * mN);
  }
}
#!queue	A007141	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.math.MemoryFunction2;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A007141 E-trees with at most 2 colors.
 * @author Sean A. Irvine
 */
public class A007141 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private final SFunction mS = new SFunction();

  private class SFunction extends MemoryFunction2<Integer, Z> {
    @Override
    protected Z compute(final Integer c, final Integer n) {
      if (n == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (final Z d : Jaguar.factor(n).divisors()) {
        sum = sum.add(A007141.this.get(c, d.intValueExact()));
      }
      return sum;
    }
  }

  // E(c,n)
  @Override
  protected Z compute(final Integer c, final Integer n) {
    if (n == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int i = 1; i < n; ++i) {
      sum = sum.add(get(c, n - i).multiply(mS.get(c, i)).multiply((c + 1) * i - n + 1));
    }
    return sum.divide(n - 1);
  }

  @Override
  public Z next() {
    return get(2, ++mN);
  }
}
#!queue	A007152	0	->	1	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.z.Z;

/**
 * A007152 Evolutionary trees of magnitude n.
 * @author Sean A. Irvine
 */
public class A007152 extends MemoryFunctionSequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After R. J. Mathar

  private final A007151 mA007151 = new A007151();
  private final ArrayList<Z> mA = new ArrayList<>();
  {
    mA.add(null);
  }
  private int mN = 0;

  private Z a7151(final int n) {
    while (n >= mA.size()) {
      mA.add(mA007151.next());
    }
    return mA.get(n);
  }

  @Override
  protected Z compute(final Integer n) {
    return n <= 1 ? Z.ZERO : a7151(n).subtract(a7151(n - 1)).add(get(n - 1).multiply(n - 1)).divide2();
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return a7151(mN - 1).add(get(mN - 1));
  }
}
#!queue	A007178	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A007178 Number of ways to write 1 as ordered sum of n powers of 1/2, allowing repeats.
 * @author Sean A. Irvine
 */
public class A007178 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;

  @Override
  protected Z compute(final int n, final int r, final int p) {
    if (n < r) {
      return Z.ZERO;
    }
    if (r == 0) {
      if (n == 0) {
        return mF.factorial(p);
      }
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = 0; j <= Math.min(n, r); ++j) {
      sum = sum.add(get(n - j, 2 * (r - j), p + j).divide(mF.factorial(j)));
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, 1, 0);
  }
}
#!queue	A007223	0	->	2	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Euler;
import irvine.math.z.Z;

/**
 * A007223 Number of distinct perforation patterns for deriving (v,b) = (n+2,n) punctured convolutional codes from (2,1).
 * @author Sean A. Irvine
 */
public class A007223 extends MemoryFunction2Sequence<Integer, Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = 1;

  @Override
  protected Polynomial<Z> compute(final Integer b, final Integer v) {
    Polynomial<Z> p = RING.zero();
    for (final Z dd : Jaguar.factor(b).divisors()) {
      final int d = dd.intValue();
      p = RING.add(p, RING.multiply(RING.pow(RING.onePlusXToTheN(d), v * b / d), Euler.phi(dd)));
    }
    return RING.divide(p, Z.valueOf(b));
  }

  @Override
  public Z next() {
    return get(++mN, 2).coeff(mN + 2);
  }
}
#!queue	A007343	0	->	3	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import irvine.math.IntegerUtils;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;
import irvine.util.Pair;

/**
 * A007343 Number of homogeneous primitive partition identities with largest part n.
 * @author Sean A. Irvine
 */
public class A007343 extends MemoryFunction2Sequence<Integer, Integer> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 2;
  private Z mA = Z.ZERO;

  private void getPartitions(final List<int[]> result, final int[] current, final int maxPart, final int remaining) {
    if (remaining == 0) {
      result.add(current);
    } else {
      for (int k = maxPart; k > 0; --k) {
        final int[] next = Arrays.copyOf(current, current.length + 1);
        next[current.length] = k;
        getPartitions(result, next, k, remaining - 1);
      }
    }
  }

  private void subsums(final Set<Pair<Integer, Integer>> sums, final int[] a) {
    for (long syndrome = 1; syndrome < (1L << a.length) - 1; ++syndrome) {
      long t = syndrome;
      int sum = 0;
      int cnt = 0;
      int k = 0;
      while (t != 0) {
        if ((t & 1) == 1) {
          sum += a[k];
          ++cnt;
        }
        ++k;
        t >>= 1;
      }
      sums.add(new Pair<>(sum, cnt));
    }
  }

  private boolean isPrimitive(final int[] a, final int[] b) {
    // a.length == b.length is always true by our construction
//    if (a.length != b.length) {
//      return false;
//    }
    // This quick test gets a lot of bad cases
    for (final int u : a) {
      for (final int v : b) {
        if (u == v) {
          return false;
        }
      }
    }

    final HashSet<Pair<Integer, Integer>> sumsA = new HashSet<>();
    final HashSet<Pair<Integer, Integer>> sumsB = new HashSet<>();
    subsums(sumsA, a);
    subsums(sumsB, b);
    for (final Pair<Integer, Integer> as : sumsA) {
      if (sumsB.contains(as)) {
        return false;
      }
    }
    return true;
  }

  @Override
  protected Integer compute(final Integer maxPart, final Integer degree) {
    final ArrayList<int[]> parts = new ArrayList<>();
    getPartitions(parts, new int[0], maxPart, degree);
    final long[] sums = new long[parts.size()];
    for (int k = 0; k < sums.length; ++k) {
      sums[k] = IntegerUtils.sum(parts.get(k));
    }
    int count = 0;
    for (int k = 0; k < sums.length; ++k) {
      final int[] a = parts.get(k);
      final long as = sums[k];
      if (a[0] == maxPart) {
        for (int j = k + 1; j < sums.length; ++j) {
          if (sums[j] == as && isPrimitive(a, parts.get(j))) {
            ++count;
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    ++mN;
    for (int d = 1; d < mN; ++d) {
      mA = mA.add(get(mN, d));
    }
    return mA;
  }
}
#!queue	A007560	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A007560 Number of planted identity trees where non-root, non-leaf nodes an even distance from root are of degree 2.
 * @author Sean A. Irvine
 */
public class A007560 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private final ArrayList<Z> mA = new ArrayList<>();
  {
    mA.add(null);
  }

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 0) {
      return Z.ONE;
    }
    if (k < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    final Z ak = mA.get(k.intValue());
    for (long j = 0; j <= n / k; ++j) {
      sum = sum.add(Binomial.binomial(ak, Z.valueOf(j)).multiply(get(n - k * j, k - 1)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mN < 2) {
      mA.add(Z.valueOf(mN));
    } else {
      mA.add(get(mN - 2, mN - 2));
    }
    return mA.get(mA.size() - 1);
  }
}
#!queue	A007653	0	->	1	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.z.Z;

/**
 * A007653 Coefficients of L-series for elliptic curve "37a1": y^2 + y = x^3 - x.
 * @author Sean A. Irvine
 */
public class A007653 extends MemoryFunctionSequence<Z, Long> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  // Number of solutions to y^2+y == x^3-x (mod p), p prime, excluding infinity
  @Override
  protected Long compute(final Z p) {
    long cnt = 0;
    for (Z x = Z.ZERO; x.compareTo(p) < 0; x = x.add(1)) {
      final Z xp = x.pow(3).add(p).subtract(x).mod(p);
      for (Z y = Z.ZERO; y.compareTo(p) < 0; y = y.add(1)) {
        if (y.square().add(y).mod(p).equals(xp)) {
          ++cnt;
        }
      }
    }
    return cnt;
  }

  private Z a(final Z p, final int exponent) {
    if (exponent <= 0) {
      return Z.ONE;
    }
    final Z c = p.subtract(get(p));
    if (exponent == 1) {
      return c;
    }
    return c.multiply(a(p, exponent - 1)).subtract(p.multiply(a(p, exponent - 2)));
  }

  @Override
  public Z next() {
    Z prod = Z.ONE;
    final FactorSequence fs = Jaguar.factor(++mN);
    for (final Z p : fs.toZArray()) {
      prod = prod.multiply(a(p, fs.getExponent(p)));
    }
    return prod;
  }
}
#!queue	A007657	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.MemoryFunction2;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A007657 Maximal coefficient in (x + x^2 + x^4 + x^8 + ...)^n.
 * @author Sean A. Irvine
 */
public class A007657 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // M function from Giorgilli and Molteni,
  // "Representation of a 2-power as sum of k 2-powers: A recursive formula"
  // Note this is essentially A007178
  private static class MFunction extends MemoryFunction2<Integer, Z> {

    @Override
    protected Z compute(final Integer k, final Integer l) {
      if (l >= k) {
        return Z.ZERO;
      }
      if (k > 1 && l == k - 1) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (int s = 1; s <= 2 * l; ++s) {
        sum = sum.add(Binomial.binomial(k + l - 1, 2L * l - s).multiply(get(k - l, s)));
      }
      return sum;
    }
  }

  private final MFunction mM = new MFunction();
  private int mN = 0;

  // W function
  @Override
  protected Z compute(final Integer sigma, final Integer k) {
    if (sigma == 1) {
      return k == 1 ? Z.ONE : mM.get(k, 1);
    }
    Z sum = Z.ZERO;
    for (int n = 1; n < k; ++n) {
      sum = sum.add(Binomial.binomial(k, n).multiply(get(1, n)).multiply(get(sigma - 1, k - n)));
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    int sigma = 1;
    Z res = get(sigma, mN);
    while (true) {
      final Z t = get(++sigma, mN);
      if (t.compareTo(res) < 0) {
        return res;
      }
      res = t;
    }
  }
}
#!queue	A007755	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a007;

import java.util.TreeSet;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A007755 Smallest number m such that the trajectory of m under iteration of Euler's totient function phi(n) [A000010] contains exactly n distinct numbers, including m and the fixed point.
 * @author Sean A. Irvine
 */
public class A007755 extends MemoryFunction1Sequence<TreeSet<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After T. D. Noe
  // I omit the alpha of Noe and instead simply limit each S_n to MAX_SIZE elements

  private static final int MAX_SIZE = 40;
  private int mN = -2;

  private TreeSet<Z> primes(final int n, final Z limit) {
    final TreeSet<Z> primes = new TreeSet<>();
    for (int k = 1; k <= n; ++k) {
      for (final Z v : get(n - k)) {
        final Z u = v.shiftLeft(k).add(1);
        if (u.compareTo(limit) > 0) {
          break;
        }
        if (u.isProbablePrime()) {
          primes.add(u);
        }
      }
    }
    return primes;
  }

  private TreeSet<Z> composites(final int n, final Z limit) {
    final TreeSet<Z> composites = new TreeSet<>();
    for (int k = 1; k < n; ++k) {
      for (final Z u : get(k)) {
        for (final Z v : get(n - k)) {
          final Z w = u.multiply(v);
          if (w.compareTo(limit) > 0) {
            break;
          }
          composites.add(w);
        }
      }
    }
    return composites;
  }

  private TreeSet<Z> s(final int n) {
    final Z limit = Z.ONE.shiftLeft(n + 1);
    final TreeSet<Z> s = primes(n, limit);
    while (s.size() > MAX_SIZE) {
      s.pollLast();
    }
    s.addAll(composites(n, limit));
    while (s.size() > MAX_SIZE) {
      s.pollLast();
    }
    return s;
  }

  @Override
  protected TreeSet<Z> compute(final int n) {
    if (n == 0) {
      final TreeSet<Z> s = new TreeSet<>();
      s.add(Z.ONE);
      return s;
    }
    return s(n);
  }

  @Override
  public Z next() {
    if (++mN <= 0) {
      return mN == 0 ? Z.TWO : Z.ONE;
    }
    return get(mN).first();
  }
}

#!queue	A007799	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A007799 Irregular triangle read by rows: Whitney numbers of the second kind a(n,k), n &gt;= 1, k &gt;= 0, for the star poset.
 * @author Sean A. Irvine
 */
public class A007799 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n <= 0) {
      return Z.ZERO;
    }
    if (m == 0) {
      return Z.ONE;
    }
    if (m == 1) {
      return Z.valueOf(n - 1);
    }
    if (m == 2) {
      return Z.valueOf(n - 1).multiply(n - 2);
    }
    return get(n - 1, m)
      .add(get(n - 1, m - 1).multiply(n - 1))
      .subtract(get(n - 2, m - 1).multiply(n - 2))
      .add(get(n - 2, m - 3).multiply(n - 2));
  }

  @Override
  public Z next() {
    if (++mM > 3 * (mN - 1) / 2) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A007902	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A007902 Number of pebbling configurations with n pebbles.
 * @author Sean A. Irvine
 */
public class A007902 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = 0;

  @Override
  protected Z compute(final Long k, final Long m) {
    if (k < 1) {
      return Z.ZERO;
    }
    if (m == 0) {
      final Z t = get(k - 1, 0L).multiply2().add(get(k, 1L));
      return k == 2 ? t.add(1) : t;
    }
    if (m == 1) {
      return get(k - 3, 0L).add(get(k - 2, 1L).multiply2()).add(get(k - 1, 2L)).add(get(k - 4, 1L));
    }
    return get(k - m - 2, m - 1).add(get(k - m - 1, m).multiply2()).add(get(k - m, m + 1));
  }

  @Override
  public Z next() {
    return ++mN == 1 ? Z.ONE : get(mN, 0L);
  }
}
#!queue	A008289	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.LongUtils;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008289 Triangle read by rows: Q(n,m) = number of partitions of n into m distinct parts, n&gt;=1, m&gt;=1.
 * @author Sean A. Irvine
 */
public class A008289 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k <= 0 || n <= 0) {
      return Z.ZERO;
    }
    if (n == 1 && k == 1) {
      return Z.ONE;
    }
    return get(n - k, k).add(get(n - k, k - 1));
  }

  @Override
  public Z next() {
    if (++mM > (LongUtils.sqrt(8 * mN + 1) - 1) / 2) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A008296	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008296 Triangle of Lehmer-Comtet numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A008296 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n.equals(k)) {
      return Z.ONE;
    }
    if (k < 0 || k > n) {
      return Z.ZERO;
    }
    return get(n - 2, k - 1).multiply(n - 1).add(get(n - 1, k - 1)).add(get(n - 1, k).multiply(k - n + 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A008298	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A008298 Triangle of D'Arcais numbers.
 * @author Sean A. Irvine
 */
public class A008298 extends MemoryFunction1Sequence<Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int n) {
    if (n == 0) {
      return RING.one();
    }
    Polynomial<Z> sum = RING.zero();
    for (int k = 1; k <= n; ++k) {
      sum = RING.add(sum, RING.multiply(get(n - k).shift(1), mF.factorial(n - 1).divide(mF.factorial(n - k)).multiply(Jaguar.factor(k).sigma())));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN).coeff(mM);
  }
}
#!queue	A008302	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008302 Triangle of Mahonian numbers T(n,k): coefficients in expansion of Product_{i=0..n-1} (1 + x + ... + x^i), where k ranges from 0 to A000217(n-1). Also enumerates permutations by their major index.
 * @author Sean A. Irvine
 */
public class A008302 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 1) {
      return k == 1 ? Z.ONE : Z.ZERO;
    }
    if (k < 0) {
      return Z.ZERO;
    }
    return get(n, k - 1).add(get(n - 1, k)).subtract(get(n - 1, k - n));
  }

  @Override
  public Z next() {
    if (++mM > mN * (mN - 1) / 2) {
      ++mN;
      mM = 0;
      return Z.ONE;
    }
    return get(mN, mM);
  }
}
#!queue	A008303	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A008303 Triangle read by rows: T(n,k) (n &gt;= 1, 0 &lt;= k &lt;= ceiling(n/2)-1) = number of permutations of [n] with k peaks.
 * @author Sean A. Irvine
 */
public class A008303 extends MemoryFunctionInt3Sequence<Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int u, final int o, final int t) {
    if (u + o == 0) {
      return RING.one();
    }
    Polynomial<Z> res = RING.zero();
    for (int j = 1; j <= u; ++j) {
      res = RING.add(res, get(u - j, o + j - 1, 1).shift(t == 2 ? 1 : 0));
    }
    for (int j = 1; j <= o; ++j) {
      res = RING.add(res, get(u + j - 1, o - j, 2));
    }
    return res;
  }

  @Override
  public Z next() {
    if (++mM >= (mN + 1) / 2) {
      ++mN;
      mM = 0;
    }
    return get(mN, 0, 1).coeff(mM);
  }
}
#!queue	A008307	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008307 Table T(n,k) giving number of permutations of [1..n] with order dividing k, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A008307 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n <= 0) {
      return n == 0 ? Z.ONE : Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(k).divisors()) {
      final long d = dd.longValue();
      Z t = get(n - d, k);
      for (int i = 1; i < d; ++i) {
        t = t.multiply(n - i);
      }
      sum = sum.add(t);
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN + 1 - mM, mM);
  }
}
#!queue	A008826	0	->	2	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Stirling;
import irvine.math.z.Z;

/**
 * A008826 Triangle of coefficients from fractional iteration of e^x - 1.
 * @author Sean A. Irvine
 */
public class A008826 extends MemoryFunction1Sequence<Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = 1;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int n) {
    if (n < 1) {
      return RING.zero();
    }
    if (n == 1) {
      return RING.one();
    }
    Polynomial<Z> sum = RING.zero();
    for (int k = 1; k < n; ++k) {
      sum = RING.add(sum, RING.multiply(get(k).shift(1), Stirling.secondKind(n, k)));
    }
    return sum;
  }

  @Override
  public Z next() {
    Polynomial<Z> row = get(mN);
    if (++mM > row.degree()) {
      ++mN;
      mM = 1;
      row = get(mN);
    }
    return row.coeff(mM);
  }

}


#!queue	A008957	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008957 Triangle of central factorial numbers T(2*n,2*n-2*k), k &gt;= 0, n &gt;= 1 (in Riordan's notation).
 * @author Sean A. Irvine
 */
public class A008957 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (k == 1 || n.equals(k)) {
      return Z.ONE;
    }
    return get(n - 1, k - 1).add(get(n - 1, k).multiply(k * (long) k));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mN - mM);
  }
}
#!queue	A008964	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008964 Number of elements of order &lt;= 2 in group of n X n upper triangular matrices over GF(2).
 * @author Sean A. Irvine
 */
public class A008964 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // See Involutions and Characters of Upper Triangular Matrix Groups
  // I. M. Isaac and Dikran B. Karagueuzian

  private int mN = 0;

  @Override
  protected Z compute(final Integer n, final Integer r) {
    if (r == 0) {
      return Z.ONE;
    }
    if (n == 1) {
      return Z.ZERO;
    }
    return get(n - 1, r).shiftLeft(r).add(get(n - 1, r - 1).multiply(Z.ONE.shiftLeft(n - r).subtract(Z.ONE.shiftLeft(r - 1))));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int r = 0; r <= mN / 2; ++r) {
      sum = sum.add(get(mN, r));
    }
    return sum;
  }
}

#!queue	A008970	0	->	2	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008970 Triangle T(n,k) = P(n,k)/2, n &gt;= 2, 1 &lt;= k &lt; n, of one-half of number of permutations of 1..n such that the differences have k runs with the same signs.
 * @author Sean A. Irvine
 */
public class A008970 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mRow = 0;
  private int mPos = 2;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (k <= 0 || k > n) {
      return Z.ZERO;
    } else if (k == 1) {
      return Z.TWO;
    } else {
      return get(n - 1, k).multiply(k).add(get(n - 1, k - 1).multiply2()).add(get(n - 1, k - 2).multiply(n - k + 1));
    }
  }

  @Override
  public Z next() {
    if (mPos > mRow) {
      ++mRow;
      mPos = 1;
    }
    return get(mRow, mPos++).divide2();
  }

}


#!queue	A010028	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a010;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A010028 Triangle read by rows: T(n,k) is one-half the number of permutations of length n with exactly n-k rising or falling successions, for n &gt;= 1, 1 &lt;= k &lt;= n. T(1,1) = 1 by convention.
 * @author Sean A. Irvine
 */
public class A010028 extends MemoryFunction1Sequence<Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private static final Polynomial<Z> X1 = RING.oneMinusXToTheN(1);
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int n) {
    switch (n) {
      case 0:
      case 1:
        return RING.one();
      case 2:
        return RING.monomial(Z.TWO, 1);
      case 3:
        return Polynomial.create(0, 4, 2);
      default:
        return RING.add(RING.subtract(RING.subtract(RING.multiply(get(n - 1), Polynomial.create(mN + 1, -1)),
          RING.multiply(get(n - 2), RING.multiply(Polynomial.create(mN - 2, 3), X1))),
          RING.multiply(get(n - 3), RING.multiply(Polynomial.create(mN - 5, 1), RING.pow(X1, 2)))),
          RING.multiply(get(n - 4), RING.multiply(RING.pow(X1, 3), Z.valueOf(mN - 3))));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN).coeff(mN - mM).add(1).divide2();
  }
}
#!queue	A010094	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a010;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A010094 Triangle of Euler-Bernoulli or Entringer numbers.
 * @author Sean A. Irvine
 */
public class A010094 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (k == 0) {
      return n == 0 ? Z.ONE : Z.ZERO;
    }
    return get(n, k - 1).add(get(n - 1, n - k));
  }

  @Override
  public Z next() {
    if (--mM <= 0) {
      mM = ++mN;
    }
    return get(mN, mM);
  }
}
#!queue	A011794	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a011;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A011794 Triangle defined by a(n+1,k)=a(n,k-1)+a(n-1,k), a(n,1)=1, a(1,k)=1, a(2,k)=min(2,k).
 * @author Sean A. Irvine
 */
public class A011794 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n <= 1 || k <= 1) {
      return Z.ONE;
    }
    if (n == 2) {
      return Z.TWO.min(Z.valueOf(k));
    }
    return get(n - 1, k - 1).add(get(n - 2, k));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A011801	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a011;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A011801 Triangle read by rows, the inverse Bell transform of n!*binomial(4,n) (without column 0).
 * @author Sean A. Irvine
 */
public class A011801 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < m || m == 0) {
      return Z.ZERO;
    }
    if (n == 1 && m == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(5 * (n - 1) - m).add(get(n - 1, m - 1));
  }

 @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A011859	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a011;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.expression.Add;
import irvine.math.expression.Expression;
import irvine.math.expression.HyperbolicTangent;
import irvine.math.expression.Identifier;
import irvine.math.expression.Literal;
import irvine.math.expression.LiteralQ;
import irvine.math.expression.LiteralZ;
import irvine.math.expression.Multiply;
import irvine.math.expression.Power;
import irvine.math.q.Q;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A011859 Normalized sequence of cumulants formed from moments in a quantum many-body problem at its critical point.
 * @author Sean A. Irvine
 */
public class A011859 extends MemoryFunction1Sequence<Q> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final Identifier X = new Identifier("x");
  private static final LiteralQ NEG_HALF = new LiteralQ(Q.HALF.negate());
  private Expression mTanhDerivative = null;
  private Z mFours = Z.ONE;

  @Override
  protected Q compute(final int n) {
    // There is a fairly simple reduction formula:
    //
    // \int\frac{\sinh^{m}x}{\cosh^{n}x}\,dx=\frac{\sinh^{m-1}x}{(n-1)\cosh^{n-1}x}+\frac{m-1}{n-1}\int\frac{\sinh^{m-2}x}{\cosh^{n-2}x}\,dx
    //
    // the non-integral part goes to 0 for -infinity..infinity, hence
    //
    // \int\frac{\sinh^{m}x}{\cosh^{n}x=-infinity..infinity}\,dx=\frac{m-1}{n-1}\int\frac{\sinh^{m-2}x}{\cosh^{n-2}x=-infinity..infinity}\,dx
    //
    // Further n = m + 1, thus we get ratios 1/2, 3/4, 5/6, 7/8 etc.
    if (n == 0) {
      return Q.ONE;
    }
    return get(n - 1).multiply(2L * n - 1).divide(2L * n);
  }

  private Q integral(final int n) {
    // Want (1/Pi) * integral(tanh^n(x)/cosh(x), x=-infinity..infinity)
    // Note tanh = sinh / cosh so really want sinh^n(x) / cosh^{n+1}(x)
    // In our use of this n is always even -- but all odd values are 0 anyway
    return (n & 1) == 0 ? get(n / 2) : Q.ZERO;
  }

  private Q integral(final int r, final int s) {
    // Given r, s in tanh(x)^r * (1-tanh(x)^2)^s
    final int n = 2 * s + r;

    // Apply binomial expansion to s part
    Q sum = Q.ZERO;
    for (int k = 0; k <= s; ++k) {
      sum = sum.signedAdd((k & 1) == 0, integral(n + r + 2 * k).multiply(Binomial.binomial(s, k)));
    }
    return sum;
  }

  private Q split(final Expression t) {
    if (t instanceof Add) {
      return split(((Add) t).left()).add(split(((Add) t).right()));
    }
    // t is of the general form C * tanh(x)^r * (1-tanh(x)^2)^s, but
    // note that one of other of the tanh terms could be missing
    final Q c;
    final int r;
    final int s;
    // We care about C, r, s

    // Lots of convoluted logic to pull these out of the expression
    // Find C
    Expression e = t;
    if (e instanceof Multiply) {
      final Expression left = ((Multiply) e).left();
      if (left instanceof Literal) {
        // Left most term is the C we are looking for
        if (left instanceof LiteralQ) {
          c = ((LiteralQ) left).value();
        } else if (left instanceof LiteralZ) {
          c = new Q(((LiteralZ) left).value());
        } else {
          throw new UnsupportedOperationException(e.toString());
        }
        e = ((Multiply) e).right();
      } else {
        c = Q.ONE;
      }
    } else {
      c = Q.ONE;
    }

    // Find r
    if (e instanceof HyperbolicTangent) {
      r = 1;
      s = 0;
    } else if (e instanceof Add) {
      r = 0;
      s = 1;
    } else if (e instanceof Power) {
      final Expression u = ((Power) e).left();
      final int exponent = ((LiteralZ) ((Power) e).right()).value().intValueExact();
      if (u instanceof HyperbolicTangent) {
        r = exponent;
        s = 0;
      } else {
        r = 0;
        s = exponent;
      }
    } else {
      assert e instanceof Multiply;
      final Expression left = ((Multiply) e).left();
      if (left instanceof Power) {
        r = ((LiteralZ) ((Power) left).right()).value().intValueExact();
      } else {
        r = 1;
      }
      e = ((Multiply) e).right();
      // Find s
      if (e instanceof Add) {
        s = 1;
      } else {
        s = ((LiteralZ) ((Power) e).right()).value().intValueExact();
      }
    }
    //System.out.println("C=" + c + " r=" + r + " s=" + s + " t=" + t);
    return c.multiply(integral(r, s));
  }

  @Override
  public Z next() {
    mTanhDerivative = mTanhDerivative == null ? new HyperbolicTangent(X) : mTanhDerivative.diff(X);
    mFours = mFours.multiply(-4);
    // Deal with the leading -2 factor present in all terms for n > 1
    final Expression t = Multiply.create(NEG_HALF, mTanhDerivative).eval();
    //System.out.println("t=" + t);
    // t comprises a sum of terms of the form C * tanh^r x * (1-tanh^2 x)^s with n = 2 * s +r.
    // Final negate to compensate for the -2 multiply we did earlier
    return split(t).multiply(mFours).toZ().negate();
  }

}
#!queue	A013924	0	->	4	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a013;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.PrependSequence;

/**
 * A013924 Number of labeled connected graphs with n nodes and 2 cutpoints.
 * @author Sean A. Irvine
 */
public class A013924 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private final MemorySequence mB = MemorySequence.cachedSequence(new PrependSequence(new A013922(), 0));

  // [x^m z^n]{(\PhiS(x,z))}^q=\sum_{j,k}[x^j z^k]\Phi S(x,z)[x^{m-j}z^{n-k}]{(\Phi S(x,z))}^{q-1}
  // Not particularly efficient
  private Q coeffSmnq(final int m, final int n, final int q) {
    assert q >= 1;
    if (q == 1) {
      return new Q(get(m, n).multiply(m).add(get(m - 1, n).multiply(n - m + 1)), mF.factorial(n));
    }
    Q u = Q.ZERO;
    for (int k = 1; k < n; ++k) {
      for (int j = 1; j < m; ++j) {
        final Q t = coeffSmnq(j, k, 1).multiply(coeffSmnq(m - j, n - k, q - 1));
        u = u.add(t);
      }
    }
    return u;
  }

  @Override
  protected Z compute(final Integer m, final Integer n) {
    if (m == 0) {
      return mB.a(n);
    }
    if (n.equals(m)) {
      return Z.ZERO;
    }
    Q smn = Q.ZERO;
    for (int k = 2; k <= n - m; ++k) {
      Q t = Q.ZERO;
      for (int q = 1; q <= Math.min(k - 1, m); ++q) {
        final Q u = coeffSmnq(m, n + q - k, q)
          .divide(mF.factorial(q))
          .divide(mF.factorial(k - 1 - q));
        t = t.add(u);
      }
      smn = smn.add(t.multiply(mB.a(k)));
    }
    return smn.multiply(mF.factorial(n)).divide(n - m).toZ();
  }

  private int mN = 3;

  @Override
  public Z next() {
    return get(2, ++mN);
  }
}
#!queue	A014780	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a014;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A014780 Triangle of numbers associated with Genocchi numbers.
 * @author Sean A. Irvine
 */
public class A014780 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (n == 1) {
      return Z.ONE;
    }
    Z sum;
    if (k == 2) {
      sum = Z.ZERO;
      for (int j = 2; j <= 2 * n - 2; ++j) {
        sum = sum.add(get(n - 1, j));
      }
    } else {
      sum = get(n, k - 1);
      if ((k & 1) == 0) {
        for (int j = k - 1; j <= 2 * n - 2; ++j) {
          sum = sum.add(get(n - 1, j));
        }
      } else {
        for (int j = 2; j < k - 1; ++j) {
          sum = sum.subtract(get(n - 1, j));
        }
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 2;
    }
    return get(mN, mM);
  }
}
#!queue	A014781	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a014;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A014781 Seidel's triangle, read by rows.
 * @author Sean A. Irvine
 */
public class A014781 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Jean-Fran&ccedil;ois Alcover

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (n == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    if ((n & 1) == 0) {
      for (int j = k; j <= (n + 1) / 2; ++j) {
        sum = sum.add(get(n - 1, j));
      }
    } else {
      for (int j = 1; j <= k; ++j) {
        sum = sum.add(get(n - 1, j));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > (mN + 1) / 2) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A018818	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a018;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A018818 Number of partitions of n into divisors of n.
 * @author Sean A. Irvine
 */
public class A018818 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Z compute(final int n, final int m, final int k) {
    if (k > m) {
      return m == 0 ? Z.ONE : Z.ZERO;
    }
    return get(n, m, k + 1).add(n % k == 0 ? get(n, m - k, k) : Z.ZERO);
  }

  @Override
  public Z next() {
    return get(++mN, mN, 1);
  }
}
#!queue	A019575	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a019;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A019575 Place n distinguishable balls in n boxes (in n^n ways); let T(n,k) = number of ways that the maximum in any box is k, for 1 &lt;= k &lt;= n; sequence gives triangle of numbers T(n,k).
 * @author Sean A. Irvine
 */
public class A019575 extends MemoryFunctionInt3Sequence<Q> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private Z mF = Z.ONE;
  private int mM = 0;

  @Override
  protected Q compute(final int n, final int i, final int k) {
    if (n == 0) {
      return Q.ONE;
    }
    Q sum = Q.ZERO;
    if (i >= 1) {
      Z jf = Z.ONE;
      for (int j = 0; j <= Math.min(k, n); ++j) {
        if (j > 1) {
          jf = jf.multiply(j);
        }
        sum = sum.add(get(n - j, i - 1, k).divide(jf));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      mF = mF.multiply(++mN);
      mM = 1;
    }
    return get(mN, mN, mM).subtract(get(mN, mN, mM - 1)).multiply(mF).toZ();
  }
}
#!queue	A020474	0	->	2	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a020;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A020474 A Motzkin triangle: a(n,k), n &gt;= 2, 2 &lt;= k &lt;= n, = number of complete, strictly subdiagonal staircase functions.
 * @author Sean A. Irvine
 */
public class A020474 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k < 0 || n < k) {
      return Z.ZERO;
    }
    if (k == 0) {
      return n == 0 ? Z.ONE : Z.ZERO;
    }
    return get(n, k - 1).add(get(n - 1, k - 1)).add(get(n - 2, k - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A024938	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a024;

import irvine.factor.prime.Fast;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000040;

/**
 * A024938 Total number of parts in all partitions of n into distinct prime parts.
 * @author Sean A. Irvine
 */
public class A024938 extends MemoryFunction2Sequence<Integer, Z[]> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private static final Z[] C1 = {Z.ONE, Z.ZERO};
  private static final Z[] C2 = {Z.ZERO, Z.ZERO};
  private int mN = 0;
  private int mPi = 0;
  private final Fast mFast = new Fast();
  private final MemorySequence mPrimes = MemorySequence.cachedSequence(new A000040());

  private int p(final int n) {
    return mPrimes.a(n - 1).intValueExact();
  }

  @Override
  protected Z[] compute(final Integer n, final Integer m) {
    if (n == 0) {
      return C1;
    }
    if (m < 1) {
      return C2;
    }
    final Z[] b = get(n, m - 1);
    if (p(m) > n) {
      return b;
    }
    final Z[] g = get(n - p(m), m - 1);
    return new Z[] {
      b[0].add(g[0]),
      b[1].add(g[1]).add(g[0])
    };
  }

  @Override
  public Z next() {
    if (mFast.isPrime(++mN)) {
      ++mPi;
    }
    return get(mN, mPi)[1];
  }
}
#!queue	A025194	0	->	3	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025194 a(n) = [ 3rd elementary symmetric function of {sqrt(k)} ], k = 1,2,...,n.
 * @author Sean A. Irvine
 */
public class A025194 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 2;
  private CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).sqrt();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sk = get(key);
    for (long j = 2; j < mN; ++j) {
      final CR sj = sk.multiply(get(j));
      for (long i = 1; i < j; ++i) {
        mSum = mSum.add(sj.multiply(get(i)));
      }
    }
    return mSum.floor();
  }
}
#!queue	A025195	0	->	4	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025195 [ 4th elementary symmetric function of {sqrt(k)} ], k = 1,2,...,n.
 * @author Sean A. Irvine
 */
public class A025195 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 3;
  private CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).sqrt();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sl = get(key);
    for (long k = 3; k < mN; ++k) {
      final CR sk = sl.multiply(get(k));
      for (long j = 2; j < k; ++j) {
        final CR sj = sk.multiply(get(j));
        for (long i = 1; i < j; ++i) {
          mSum = mSum.add(sj.multiply(get(i)));
        }
      }
    }
    return mSum.floor();
  }
}
#!queue	A025196	0	->	2	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025196 a(n) = floor(Sum_{1&lt;=i&lt;j&lt;=n} (sqrt(j)-sqrt(i))^2).
 * @author Sean A. Irvine
 */
public class A025196 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;
  private CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).sqrt();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sk = get(key);
    for (long j = 1; j < mN; ++j) {
      final CR d = sk.subtract(get(j));
      mSum = mSum.add(d.multiply(d));
    }
    return mSum.floor();
  }
}
#!queue	A025197	0	->	2	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.cr.ComputableReals;
import irvine.math.z.Z;

/**
 * A025197 a(n) = floor( Sum_{1 &lt;= i &lt; j &lt;= n} ((sqrt(j)-sqrt(i))^3) ).
 * @author Sean A. Irvine
 */
public class A025197 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;
  private CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).sqrt();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sk = get(key);
    for (long j = 1; j < mN; ++j) {
      final CR d = sk.subtract(get(j));
      mSum = mSum.add(ComputableReals.SINGLETON.pow(d, 3));
    }
    return mSum.floor();
  }
}
#!queue	A025198	0	->	1	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025198 [ (n-1)st elementary symmetric function of {sqrt(k)} ], k = 1,2,...,n.
 * @author Sean A. Irvine
 */
public class A025198 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).sqrt();
  }

  private CR sym(final CR prod, final long a, final long max, final long n) {
    if (n == 0) {
      return prod;
    }
    CR sum = CR.ZERO;
    for (long b = a; b <= max; ++b) {
      sum = sum.add(sym(prod.multiply(get(b)), b + 1, max, n - 1));
    }
    return sum;
  }

  @Override
  public Z next() {
    return sym(CR.ONE, 0, ++mN, mN - 1).floor();
  }
}
#!queue	A025202	0	->	3	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025202 a(n) = [ 2nd elementary symmetric function of {log(k)} ], k = 2,3,...,n.
 * @author Sean A. Irvine
 */
public class A025202 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected long mN = 2;
  protected CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).log();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sk = get(key);
    for (long j = 1; j < mN; ++j) {
      mSum = mSum.add(sk.multiply(get(j)));
    }
    return mSum.floor();
  }
}
#!queue	A025203	0	->	4	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025203 a(n) = [ 3rd elementary symmetric function of {log(k)} ], k = 2,3,...,n.
 * @author Sean A. Irvine
 */
public class A025203 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected long mN = 3;
  protected CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).log();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sk = get(key);
    for (long j = 2; j < mN; ++j) {
      final CR sj = sk.multiply(get(j));
      for (long i = 1; i < j; ++i) {
        mSum = mSum.add(sj.multiply(get(i)));
      }
    }
    return mSum.floor();
  }
}
#!queue	A025204	0	->	5	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025204 [ 4th elementary symmetric function of {log(k)} ], k = 2,3,...,n.
 * @author Sean A. Irvine
 */
public class A025204 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected long mN = 4;
  protected CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).log();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sl = get(key);
    for (long k = 3; k < mN; ++k) {
      final CR sk = sl.multiply(get(k));
      for (long j = 2; j < k; ++j) {
        final CR sj = sk.multiply(get(j));
        for (long i = 1; i < j; ++i) {
          mSum = mSum.add(sj.multiply(get(i)));
        }
      }
    }
    return mSum.floor();
  }
}
#!queue	A025206	0	->	3	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025206 [ Sum{(log(j)-log(i))^2} ], 2 &lt;= i &lt; j &lt;= n.
 * @author Sean A. Irvine
 */
public class A025206 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 2;
  private CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).log();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sk = get(key);
    for (long j = 2; j < mN; ++j) {
      final CR d = sk.subtract(get(j));
      mSum = mSum.add(d.multiply(d));
    }
    return mSum.floor();
  }
}
#!queue	A025207	0	->	3	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.cr.ComputableReals;
import irvine.math.z.Z;

/**
 * A025207 a(n) = [ Sum{(log(j)-log(i))^3} ], 2 &lt;= i &lt; j &lt;= n.
 * @author Sean A. Irvine
 */
public class A025207 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 2;
  private CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).log();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sk = get(key);
    for (long j = 2; j < mN; ++j) {
      final CR d = sk.subtract(get(j));
      mSum = mSum.add(ComputableReals.SINGLETON.pow(d, 3));
    }
    return mSum.floor();
  }
}
#!queue	A025208	0	->	2	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A025208 a(n) = [ (n-2)nd elementary symmetric function of {log(k)} ], k = 2,3,...,n.
 * @author Sean A. Irvine
 */
public class A025208 extends MemoryFunctionSequence<Long, CR> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).log();
  }

  private CR sym(final CR prod, final long a, final long max, final long n) {
    if (n == 0) {
      return prod;
    }
    CR sum = CR.ZERO;
    for (long b = a; b <= max; ++b) {
      sum = sum.add(sym(prod.multiply(get(b)), b + 1, max, n - 1));
    }
    return sum;
  }

  @Override
  public Z next() {
    return sym(CR.ONE, 2, ++mN, mN - 2).floor();
  }
}
#!queue	A026082	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A026082 Irregular triangular array T read by rows: T(n,k) = C(n,k) for k=0..n for n = 0,1,2,3. For n &gt;= 4, T(n,0) = T(n,2n)=1, T(n,1) = T(n,2n-1) = n - 3, T(4,2) = 4, T(4,3) = 3, T(4,4) = 6; T(4,5) = 3, T(4,6)=4; for n &gt;= 5, T(n,k) = T(n-1,k-2) + T(n-1,k-1) + T(n-1,k) for k=2..2n-2.
 * @author Sean A. Irvine
 */
public class A026082 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final Z[] N4 = {Z.ONE, Z.ONE, Z.FOUR, Z.THREE, Z.SIX, Z.THREE, Z.FOUR, Z.ONE, Z.ONE};
  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 0 || m < 0 || m > 2 * n) {
      return Z.ZERO;
    } else if (n <= 3) {
      return Binomial.binomial(n, m);
    } else if (n == 4) {
      return N4[m.intValue()];
    } else if (m == 0 || m == 2 * n) {
      return Z.ONE;
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    do {
      if (++mM > 2 * mN) {
        ++mN;
        mM = 0;
      }
    } while (get(mN, mM).isZero());
    return get(mN, mM);
  }
}

#!queue	A026148	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026148 Irregular triangular array T read by rows: T(n,0) = 1 for i &gt;= 0, T(1,1) = 1,T(2,1) = 1, T(2,2) = 2, T(2,3) = 1, T(2,4) = 1 and for n &gt;= 3, T(n,1) = n-1,  T(n,k) = T(n-1,k-2) + T(n-1,k-1) + T(n-1,k) for k=2,...,n+1, and T(n, k+2) = T(n-1, k) + T(n-1, k+1).
 * @author Sean A. Irvine
 */
public class A026148 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = -1;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || n == 1) {
      return Z.ONE;
    }
    if (n == 2) {
      return m == 2 ? Z.TWO : Z.ONE;
    }
    if (m == 1) {
      return Z.valueOf(n - 1);
    }
    if (m == n + 2) {
      return get(n - 1, m - 2).add(get(n - 1, m - 1));
    }
    return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (mN < 2) {
      ++mN;
      return Z.ONE;
    }
    if (++mM > mN + 2) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026323	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026323 Irregular triangular array T read by rows: T(0,0) = 1, T(0,1) = T(0,2) = 0; T(1,0) = T(1,1) = T(1,2) = 1, T(1,3) = 0; for n &gt;= 2, T(n,0) = 1, T(n,1) = T(n-1,0) + T(n-1,1), T(n,k) = T(n-1,k-2) + T(n-1,k-1) + T(n-1,k) for k = 2,3,...,n+1 and T(n,n+2) = T(n-1,n) + T(n-1,n+1).
 * @author Sean A. Irvine
 */
public class A026323 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 1;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0) {
      return m == 0 ? Z.ONE : Z.ZERO;
    }
    if (n == 1) {
      return m <= 2 ? Z.ONE : Z.ZERO;
    }
    if (m == 0) {
      return Z.ONE;
    }
    if (m == 1) {
      return get(n - 1, 0L).add(get(n - 1, 1L));
    }
    if (m == n + 2) {
      return get(n - 1, n).add(get(n - 1, n + 1));
    }
    return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN + 2) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026568	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026568 Irregular triangular array T read by rows: T(i,0) = T(i,2i) = 1 for i &gt;= 0; T(i,1) = T(i,2i-1) = [ (i+1)/2 ] for i &gt;= 1; and for i &gt;= 2 and 2 &lt;=j &lt;= i - 2, T(i,j) = T(i-1,j-2) + T(i-1,j-1) + T(i-1,j) if i + j is even, T(i,j) = T(i-1,j-2) + T(i-1,j) if i + j is odd.
 * @author Sean A. Irvine
 */
public class A026568 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m == 2 * n) {
      return Z.ONE;
    }
    if (m == 1 || m == 2 * n - 1) {
      return Z.valueOf((n + 1) / 2);
    }
    if (((n + m) & 1) == 0) {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026584	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026584 Irregular triangular array T read by rows: T(i,0) = T(i,2i) = 1 for i &gt;= 0; T(i,1) = T(i,2i-1) = floor(i/2) for i &gt;= 1; and for i &gt;= 2 and j = 2..2i-2, T(i,j) = T(i-1,j-2) + T(i-1,j-1) + T(i-1,j) if i+j is odd, and T(i,j) = T(i-1,j-2) + T(i-1,j) if i+j is even.
 * @author Sean A. Irvine
 */
public class A026584 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m == 2 * n) {
      return Z.ONE;
    }
    if (m == 1 || m == 2 * n - 1) {
      return Z.valueOf(n / 2);
    }
    if (((n + m) & 1) == 0) {
      return get(n - 1, m - 2).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026615	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026615 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; T(n,1)=T(n,n-1)=2n-1 for n &gt;= 1; T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=k&lt;=n-2, n &gt;= 4.
 * @author Sean A. Irvine
 */
public class A026615 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == 1 || m == n - 1) {
      return Z.valueOf(2 * n - 1);
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026626	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026626 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; T(n,1)=T(n,n-1)=[ 3n/2 ] for n &gt;= 1; T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=k&lt;=n-2, n &gt;= 4.
 * @author Sean A. Irvine
 */
public class A026626 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == 1 || m == n - 1) {
      return Z.valueOf(3 * n / 2);
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026648	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026648 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k) if n is even and k is odd, else T(n,k)=t(n-1,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026648 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if ((n & 1) == 0 && (m & 1) == 1) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026659	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026659 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, if n is odd, then T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k) if k is odd and &lt;=[ n/2 ] or if k is even and &gt;[ n/2 ]; in all other cases, T(n,k)=T(n-1,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026659 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if ((n & 1) == 1 && ((m <= n / 2 && (m & 1) == 1) || (m > n / 2 && (m & 1) == 0))) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026681	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026681 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k)=T(n-1,k-1)+T(n-1,k) if k or n-k is of form 2h for h=1,2,...,[ n/4 ], else T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026681 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (((m & 1) == 0 && m / 2 <= n / 4) || (((n - m) & 1) == 0 && (n - m) / 2 <= n / 4)) {
      return get(n - 1, m - 1).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026692	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026692 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k) if k or n-k is of form 2h for h=1,2,...,[ n/4 ], else T(n,k)=T(n-1,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026692 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (((m & 1) == 0 && m / 2 <= n / 4) || (((n - m) & 1) == 0 && (n - m) / 2 <= n / 4)) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026703	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026703 Triangular array T read by rows: T(n,1) = T(n,n) = 1, T(n,k) = T(n-1, k-1) + T(n-2,k-1) + T(n-1,k) if k=(n/2) or k=((n+1)/2), otherwise T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026703 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == n / 2 || m == (n + 1) / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026714	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026714 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k) if k=[ (n-1)/2 ] or k=[ n/2 ] or k=[ (n+2)/2 ], else T(n,k)=T(n-1,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026714 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == n / 2 || m == (n - 1) / 2 || m == (n + 2) / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026794	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026794 Triangular array T read by rows: T(n,k) = number of partitions of n in which least part is k, 1&lt;=k&lt;=n.
 * @author Sean A. Irvine
 */
public class A026794 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 1;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n.equals(m)) {
      return Z.ONE;
    }
    if (m > n / 2) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long k = m; k <= n - m; ++k) {
      sum = sum.add(get(n - m, k));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A026804	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026804 Number of partitions of n in which the least part is odd.
 * @author Sean A. Irvine
 */
public class A026804 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 1 || m < 1) {
      return Z.ZERO;
    }
    Z t = get(n, m - 1);
    if (n.equals(m)) {
      t = t.add(n & 1);
    }
    if (m <= n) {
      t = t.add(get(n - m, m));
    }
    return t;
  }

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A026805	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026805 Number of partitions of n in which the least part is even.
 * @author Sean A. Irvine
 */
public class A026805 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 1 || m < 1) {
      return Z.ZERO;
    }
    Z t = get(n, m - 1);
    if (n.equals(m)) {
      t = t.add(1 - (n & 1));
    }
    if (m <= n) {
      t = t.add(get(n - m, m));
    }
    return t;
  }

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A026807	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026807 Triangular array T read by rows: T(n,k) = number of partitions of n in which every part is &gt;=k, for k=1,2,...,n.
 * @author Sean A. Irvine
 */
public class A026807 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 1 || m > n) {
      return Z.ZERO;
    }
    if (m.equals(n)) {
      return Z.ONE;
    }
    return get(n, m + 1).add(get(n - m, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A026820	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026820 Euler's table: triangular array T read by rows, where T(n,k) = number of partitions in which every part is &lt;= k for 1 &lt;= k &lt;= n. Also number of partitions of n into at most k parts.
 * @author Sean A. Irvine
 */
public class A026820 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 1) {
      return Z.ONE;
    }
    return m > n ? get(n, m - 1) : get(n, m - 1).add(get(n - m, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A026821	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026821 Triangular array T read by rows: T(n,k) = number of partitions of n into distinct parts, the least being k, for k=1,2,...,n.
 * @author Sean A. Irvine
 */
public class A026821 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n.equals(m)) {
      return Z.ONE;
    }
    final long r = (n + 1) / 2;
    if (m > r) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= n - 2 * m; ++k) {
      sum = sum.add(get(n - m, m + k));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A026835	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A026835 Triangular array read by rows: T(n,k) = number of partitions of n into distinct parts in which every part is &gt;=k, for k=1,2,...,n.
 * @author Sean A. Irvine
 */
public class A026835 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m, final int leastPart) {
    if (n < 0) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    if ((m - leastPart) * (m + leastPart + 1) < 2 * n) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k <= Math.min(1, n / m); ++k) {
      sum = sum.add(get(n - m * k, m - 1, leastPart));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mN, mM);
  }
}
#!queue	A027113	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A027113 Triangular array T given by rows: T(n,0)=1 for n &gt;= 0, T(n,1)=1,T(n,2)=2 for n &gt;= 1 and for n &gt;= 2, T(n,k)=T(n-1,k-3)+T(n-1,k-2)+T(n-1,k-1) for 3&lt;=k&lt;=2n-1, T(n,2n)=T(n-1,2n-3)+T(n-1,2n-2).
 * @author Sean A. Irvine
 */
public class A027113 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 0 || m > 2 * n) {
      return Z.ZERO;
    }
    if (m <= 1) {
      return Z.ONE;
    }
    if (m == 2) {
      return Z.TWO;
    }
    if (m == 2 * n) {
      return get(n - 1, 2 * n - 3).add(get(n - 1, 2 * n - 2));
    }
    return get(n - 1, m - 3).add(get(n - 1, m - 2)).add(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A027144	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A027144 Triangular array T given by rows: T(n,0)=1 for n &gt;= 0, T(1,1)=2; for even n &gt;= 2, T(n,k)=T(n-2,k-1)+T(n-1,k-1)+T(n-1,k) for 1&lt;=(odd k)&lt;=n-1 and T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=(even k)&lt;=n-2, T(n,n)=T(n-1,n-1); for odd n&lt;=3, T(n,k)=T(n,k-1)+T(n-1,k-1)+T(n-1,k) for 1&lt;=(odd k)&lt;=n-2 and T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=(even k)&lt;=n-1, T(n,n)=T(n-1,n-1)+T(n,n-1).
 * @author Sean A. Irvine
 */
public class A027144 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0) {
      return Z.ONE;
    }
    if (m == 1 && n == 1) {
      return Z.TWO;
    }
    if (n <= 1) {
      return Z.ZERO;
    }
    if ((n & 1) == 0) {
      if (n.equals(m)) {
        return get(n - 1, m - 1);
      }
      if ((m & 1) == 0) {
        return get(n - 1, m - 1).add(get(n - 1, m));
      } else {
        return get(n - 2, m - 1).add(get(n - 1, m - 1)).add(get(n - 1, m));
      }
    } else {
      // odd n
      if (n.equals(m)) {
        return get(n - 1, m - 1).add(get(n, n - 1));
      }
      if ((m & 1) == 0) {
        return get(n - 1, m - 1).add(get(n - 1, m));
      } else {
        return get(n, m - 1).add(get(n - 1, m - 1)).add(get(n - 1, m));
      }
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A027356	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A027356 Array read by rows: T(n,k) = number of partitions of n into distinct odd parts in which k is the greatest part, for k=1,2,...,n, n&gt;=1.
 * @author Sean A. Irvine
 */
public class A027356 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = 0;
  private long mK = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n > k * k) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    final long p = 2 * k - 1;
    if (p > n) {
      return get(n, k - 1);
    }
    return get(n, k - 1).add(get(n - p, k - 1));
  }

  protected Z t(final long n, final long m) {
    return (m & 1) == 0 ? Z.ZERO : get(n - m, (m - 1) / 2);
  }

  @Override
  public Z next() {
    if (++mK > mN) {
      ++mN;
      mK = 1;
    }
    return t(mN, mK);
  }
}
#!queue	A028417	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a028;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A028417 Sum over all n! permutations of n elements of minimum lengths of cycles.
 * @author Sean A. Irvine
 */
public class A028417 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0) {
      return Z.valueOf(m);
    }
    Z sum = Z.ZERO;
    Z f = Z.ONE;
    for (long j = 1; j <= n; ++j) {
      sum = sum.add(get(n - j, Math.min(m, j)).multiply(Binomial.binomial(n - 1, j - 1)).multiply(f));
      f = f.multiply(j);
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A028418	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a028;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A028418 Sum over all n! permutations of n letters of maximum cycle length.
 * @author Sean A. Irvine
 */
public class A028418 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0) {
      return Z.valueOf(m);
    }
    Z sum = Z.ZERO;
    Z f = Z.ONE;
    for (long j = 1; j <= n; ++j) {
      sum = sum.add(get(n - j, Math.max(m, j)).multiply(Binomial.binomial(n - 1, j - 1)).multiply(f));
      f = f.multiply(j);
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, 0L);
  }
}
#!queue	A030274	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a030;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.q.Q;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A030274 Numerators of sequence {b(1), b(2), ...} which when COMPOSED with itself gives {1,2,3,...}.
 * @author Sean A. Irvine
 */
public class A030274 extends MemoryFunction2Sequence<Long, Q> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;

  @Override
  protected Q compute(final Long n, final Long m) {
    if (n.equals(m)) {
      return Q.ONE;
    }
    if (n <= m) {
      return Q.ZERO;
    }
    Q sum = Q.ZERO;
    for (long i = m + 1; i < n; ++i) {
      sum = sum.add(get(n, i).multiply(get(i, m)));
    }
    return sum.subtract(Binomial.binomial(n + m - 1, 2 * m - 1)).divide(2).negate();
  }

  protected Z select(final Q n) {
    return n.num();
  }

  @Override
  public Z next() {
    return select(get(++mN, 1L));
  }
}
#!queue	A030276	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a030;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A030276 Shifts left under COMPOSE transform.
 * @author Sean A. Irvine
 */
public class A030276 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n.equals(m)) {
      return Z.ONE.shiftLeft(n);
    }
    if (m >= n) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int k = 1; k <= n; ++k) {
      sum = sum.add(Binomial.binomial(n, k).multiply(get(n - m, k)).shiftLeft(n - k));
    }
    return sum.multiply(m).divide(n);
  }

  @Override
  public Z next() {
    return get(++mN, 1);
  }
}
#!queue	A030523	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a030;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A030523 A convolution triangle of numbers obtained from A001792.
 * @author Sean A. Irvine
 */
public class A030523 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected long mN = 0;
  protected long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m <= 0) {
      return n == 0 ? Z.ONE : Z.ZERO;
    }
    if (m > n) {
      return Z.ZERO;
    }
    return get(n - 1, m).multiply(4).subtract(get(n - 2, m).multiply(4)).add(get(n - 1, m - 1)).subtract(get(n - 2, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A030524	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a030;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A030524 A convolution triangle of numbers obtained from A036068.
 * @author Sean A. Irvine
 */
public class A030524 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected int mN = 0;
  protected int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n < m) {
      return Z.ZERO;
    }
    if (n == 1) {
      return m == 1 ? Z.ONE : Z.ZERO;
    }
    return get(n - 1, m).multiply(3L * m + n - 1).multiply(3).add(get(n - 1, m - 1).multiply(m)).divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A030526	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a030;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A030526 A convolution triangle of numbers obtained from A036070.
 * @author Sean A. Irvine
 */
public class A030526 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected int mN = 0;
  protected int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n < m) {
      return Z.ZERO;
    }
    if (n == 1) {
      return m == 1 ? Z.ONE : Z.ZERO;
    }
    return get(n - 1, m).multiply(4L * m + n - 1).multiply(4).add(get(n - 1, m - 1).multiply(m)).divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A030527	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a030;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A030527 A convolution triangle of numbers obtained from A036083.
 * @author Sean A. Irvine
 */
public class A030527 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected int mN = 0;
  protected int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n < m) {
      return Z.ZERO;
    }
    if (n == 1) {
      return m == 1 ? Z.ONE : Z.ZERO;
    }
    return get(n - 1, m).multiply(5L * m + n - 1).multiply(5).add(get(n - 1, m - 1).multiply(m)).divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A032301	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a032;

import java.util.Arrays;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A032301 Shifts left under "EFJ" (unordered, size, labeled) transform.
 * @author Sean A. Irvine
 */
public class A032301 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private int mN = -1;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    if (m >= 1) {
      for (int j = 0; j <= Math.min(1, n / m); ++j) {
        final int[] t = new int[j + 1];
        Arrays.fill(t, m);
        t[0] = n - m * j;
        sum = sum.add(Binomial.binomial(get(m - 1, m - 1), Z.valueOf(j)).multiply(Binomial.multinomial(n, t)).multiply(get(n - m * j, m - 1)));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A032305	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a032;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A032305 Number of rooted trees where any 2 subtrees extending from the same node have a different number of nodes.
 * @author Sean A. Irvine
 */
public class A032305 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = -1;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    if (m >= 1) {
      for (int j = 0; j <= Math.min(1, n / m); ++j) {
        sum = sum.add(get(n - m * j, m - 1).multiply(j == 0 ? Z.ONE : get(m - 1, m - 1)));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A032317	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a032;

import java.util.Arrays;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A032317 Shifts left under "EGJ" (unordered, element, labeled) transform.
 * @author Sean A. Irvine
 */
public class A032317 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private int mN = -1;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n == 0) {
      return Z.ONE;
    }
    if (m < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = 0; j <= n / m; ++j) {
      final int[] t = new int[j + 1];
      Arrays.fill(t, m);
      t[0] = n - m * j;
      sum = sum.add(Binomial.multinomial(n, t).multiply(Binomial.binomial(get(m - 1, m - 1), Z.valueOf(j))).multiply(get(n - m * j, m - 1)));
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A032428	0	->	5	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A032428 Coefficients of Jacobi elliptic function c(5,m).
 * @author Sean A. Irvine
 */
public class A032428 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // Based on (2) in Dominique Dumont
  // A Combinatorial Interpretation for the Schett Recurrence on the Jacobian Elliptic Functions

  private int mN = j() - 1;

  @Override
  protected Z compute(final int m, final int i, final int j) {
    if (m == 1 && i == 0 && j == 0) {
      return Z.ONE;
    }
    if (i + j < 0 || i + j > m / 2) {
      return Z.ZERO;
    }
    if ((m & 1) == 0) {
      return get(m - 1, i, j).multiply(2 * j + 1)
        .add(get(m - 1, i + 1, j - 1).multiply(2 * i + 2))
        .add(get(m - 1, i, j - 1).multiply(m - 2 * i - 2 * j + 1));
    } else {
      return get(m - 1, i, j).multiply(2 * i + 1)
        .add(get(m - 1, i - 1, j + 1).multiply(2 * j + 2))
        .add(get(m - 1, i - 1, j).multiply(m - 1 - 2 * i - 2 * j + 2));
    }
  }

  protected int j() {
    return 5;
  }

  @Override
  public Z next() {
    return get(2 * ++mN + 1, 0, j());
  }
}
#!queue	A032434	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a032;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A032434 Triangle read by rows: last survivors of Josephus elimination process.
 * @author Sean A. Irvine
 */
public class A032434 extends MemoryFunction2Sequence<Long, Long> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Long compute(final Long n, final Long m) {
    if (n == 1) {
      return 1L;
    }
    final long r = (get(n - 1, m) + m) % n;
    return r == 0 ? n : r;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return Z.valueOf(get(mN, mM));
  }

}
#!queue	A033185	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a033;

import java.util.ArrayList;
import java.util.List;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000081;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A033185 Rooted tree triangle read by rows: a(n,k) = number of forests with n nodes and k rooted trees.
 * @author Sean A. Irvine
 */
public class A033185 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private final Sequence mA55 = new A000081();
  private final List<Z> mT = new ArrayList<>();

  private Z getT(final int i) {
    if (i < 0) {
      return Z.ZERO;
    }
    while (i >= mT.size()) {
      mT.add(mA55.next());
    }
    return mT.get(i);
  }

  // b function
  @Override
  protected Z compute(final int n, final int i, final int p) {
    if (p > n) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    if (Math.min(i, p) < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = 0; j <= Math.min(n / i, p); ++j) {
      sum = sum.add(get(n - i * j, i - 1, p - j).multiply(Binomial.binomial(getT(i).add(j - 1), Z.valueOf(j))));
    }
    return sum;
  }

  private int mN = 0;
  private int mK = 0;

  @Override
  public Z next() {
    if (++mK > mN) {
      ++mN;
      mK = 1;
    }
    return get(mN, mN, mK);
  }
}
#!queue	A033833	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A033833 Highly factorable numbers: numbers with a record number of proper factorizations.
 * @author Sean A. Irvine
 */
public class A033833 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected Z mPrevBest = Z.ZERO;
  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n <= 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(n).divisors()) {
      final long d = dd.longValue();
      if (d > 1 && d >= m) {
        sum = sum.add(get(n / d, d));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    while (true) {
      final Z cnt = get(++mN, 1L);
      if (cnt.compareTo(mPrevBest) > 0) {
        mPrevBest = cnt;
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A033877	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a033;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A033877 Triangular array read by rows associated with Schroeder numbers: T(1,k) = 1; T(n,k) = 0 if k &lt; n; T(n,k) = T(n,k-1) + T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A033877 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 1) {
      return Z.ONE;
    }
    if (m < n) {
      return Z.ZERO;
    }
    return get(n, m - 1).add(get(n - 1, m - 1)).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mM, mN);
  }
}
#!queue	A034781	0	->	2	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A034781 Triangle of number of rooted trees with n &gt;= 2 nodes and height h &gt;= 1.
 * @author Sean A. Irvine
 */
public class A034781 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  @Override
  protected Z compute(final int n, final int i, final int k) {
    if (n == 0) {
      return Z.ONE;
    }
    if (i < 1 || k < 1) {
      return Z.ZERO;
    }
    Z s = Z.ZERO;
    for (int j = 0; j <= n / i; ++j) {
      s = s.add(Binomial.binomial(get(i - 1, i - 1, k - 1).add(j - 1), Z.valueOf(j)).multiply(get(n - i * j, i - 1, k)));
    }
    return s;
  }

  protected Z t(final int n, final int d) {
    return get(n - 1, n - 1, d).subtract(get(n - 1, n - 1, d - 1));
  }

  private int mN = 1;
  private int mD = 0;

  @Override
  public Z next() {
    if (++mD >= mN) {
      ++mN;
      mD = 1;
    }
    return t(mN, mD);
  }

}
#!queue	A035002	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a035;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A035002 Square array a(m,n) read by antidiagonals, where a(m,n) = sum(a(m-k,n), k=1..m-1) + sum(a(m,n-k), k=1..n-1).
 * @author Sean A. Irvine
 */
public class A035002 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer m, final Integer n) {
    if (m == 1) {
      return n == 1 ? Z.ONE : Z.ONE.shiftLeft(n - 2);
    }
    if (n == 1) {
      return Z.ONE.shiftLeft(m - 2);
    }
    Z sum = Z.ZERO;
    for (int k = 1; k < m; ++k) {
      sum = sum.add(get(m - k, n));
    }
    for (int k = 1; k < n; ++k) {
      sum = sum.add(get(m, n - k));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM + 1, mM);
  }
}
#!queue	A035513	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a035;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.cr.CR;
import irvine.math.z.Z;

/**
 * A035513 Wythoff array read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A035513 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k == -1) {
      return Z.valueOf(n - 1);
    }
    if (k == 0) {
      return CR.PHI.multiply(n).floor();
    }
    return get(n, k - 1).add(get(n, k - 2));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mM, mN - mM + 1);
  }
}

#!queue	A035529	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a035;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A035529 A convolution triangle of numbers obtained from A034171.
 * @author Sean A. Irvine
 */
public class A035529 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  protected long degree() {
    return 3;
  }

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m > n) {
      return Z.ZERO;
    }
    if (n == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(degree()).multiply(degree() * (n - 1) + m).add(get(n - 1, m - 1).multiply(m)).divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A036367	0	->	4	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a036;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A036367 Number of free orthoplex n-ominoes with cell centers determining n-2 space.
 * @author Sean A. Irvine
 */
public class A036367 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 3;

  private Z s(final long n, final long k) {
    return get(n + 1 - k, 1L).add(n < 2 * k ? Z.ZERO : s(n - k, k));
  }

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k == 1) {
      if (n == 1) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (long j = 1; j < n; ++j) {
        sum = sum.add(get(j, 1L).multiply(s(n - 1, j)).multiply(j));
      }
      return sum.divide(n - 1);
    }
    Z sum = Z.ZERO;
    for (long j = 1; j < n; ++j) {
      sum = sum.add(get(j, 1L).multiply(get(n - j, k - 1)));
    }
    return sum;
  }

  private Z inner(final long j) {
    Z sum = Z.ZERO;
    for (long k = 5; k <= mN; k += 2) {
      sum = sum.add(get(j, (k - 1) / 2).multiply(get(mN - 2 * j, 1L)));
    }
    return sum.multiply(4);
  }

  @Override
  public Z next() {
    final Z a = get(++mN, 4L);
    Z b = Z.ZERO;
    for (long j = 5; j <= mN; ++j) {
      b = b.add(get(mN, j));
    }
    b = b.multiply(4);
    if ((mN & 1) == 0) {
      b = b.add(get(mN / 2, 2L).multiply(3));
      if ((mN & 3) == 0) {
        b = b.add(get(mN / 4, 1L).multiply2());
      }
      Z c = Z.ZERO;
      for (long j = 3; j <= mN / 2; ++j) {
        c = c.add(get(mN / 2, j));
      }
      c = c.multiply(4);
      b = b.add(c);
    }
    Z d = Z.ZERO;
    for (long j = 1; j <= (mN - 1) / 2; ++j) {
      d = d.add(get(j, 1L).multiply(get(mN - 2 * j, 2L)).multiply2());
      d = d.add(inner(j));
    }
    b = b.add(d);
    return a.add(b).divide(8);
  }
}
#!queue	A036368	0	->	4	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a036;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A036368 Number of chiral orthoplex n-ominoes in n-2 space.
 * @author Sean A. Irvine
 */
public class A036368 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 3;

  private Z s(final long n, final long k) {
    return get(n + 1 - k, 1L).signedAdd((k & 1) == 0, n < 2 * k ? Z.ZERO : s(n - k, k));
  }

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k == 1) {
      if (n == 1) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (long j = 1; j < n; ++j) {
        sum = sum.add(get(j, 1L).multiply(s(n - 1, j)).multiply(j));
      }
      return sum.divide(n - 1);
    }
    Z sum = Z.ZERO;
    for (long j = 1; j < n; ++j) {
      sum = sum.add(get(j, 1L).multiply(get(n - j, k - 1)));
    }
    return sum;
  }

  private Z inner(final long j) {
    Z sum = Z.ZERO;
    for (long k = 5; k <= mN; k += 2) {
      sum = sum.add(get(j, (k - 1) / 2).multiply(get(mN - 2 * j, 1L)));
    }
    return sum.multiply((j & 1) == 0 ? 4 : -4);
  }

  @Override
  public Z next() {
    final Z a = get(++mN, 4L);
    Z b = Z.ZERO;
    for (long j = 5; j <= mN; ++j) {
      b = b.add(get(mN, j));
    }
    b = b.multiply(4);
    if ((mN & 1) == 0) {
      final long i2 = mN / 2;
      Z c = Z.ZERO;
      for (long j = 3; j <= i2; ++j) {
        c = c.add(get(i2, j));
      }
      c = c.multiply((i2 & 1) == 0 ? 4 : -4);
      c = c.signedAdd((i2 & 1) == 0, get(i2, 2L));
      if ((mN & 3) == 0) {
        c = c.signedAdd((mN & 4) == 0, get(mN / 4, 1L).multiply2());
      }
      b = b.subtract(c);
    }
    Z d = Z.ZERO;
    for (long j = 1; j <= (mN - 1) / 2; ++j) {
      d = d.signedAdd((j & 1) == 0, get(j, 1L).multiply(get(mN - 2 * j, 2L)).multiply2());
      d = d.subtract(inner(j));
    }
    return a.add(b).add(d).divide(8);
  }
}
#!queue	A036369	0	->	4	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a036;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A036369 Number of asymmetric orthoplex n-ominoes in n-2 space.
 * @author Sean A. Irvine
 */
public class A036369 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 3;

  private Z s(final long n, final long k) {
    return get(n + 1 - k, 1L).subtract(n < 2 * k ? Z.ZERO : s(n - k, k));
  }

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k == 1) {
      if (n == 1) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (long j = 1; j < n; ++j) {
        sum = sum.add(get(j, 1L).multiply(s(n - 1, j)).multiply(j));
      }
      return sum.divide(n - 1);
    }
    Z sum = Z.ZERO;
    for (long j = 1; j < n; ++j) {
      sum = sum.add(get(j, 1L).multiply(get(n - j, k - 1)));
    }
    return sum;
  }

  private Z inner(final long j) {
    Z sum = Z.ZERO;
    for (long k = 5; k <= mN; k += 2) {
      sum = sum.add(get(j, (k - 1) / 2).multiply(get(mN - 2 * j, 1L)));
    }
    return sum.multiply(4);
  }

  @Override
  public Z next() {
    final Z a = get(++mN, 4L);
    Z b = Z.ZERO;
    for (long j = 5; j <= mN; ++j) {
      b = b.add(get(mN, j));
    }
    b = b.multiply(4);
    if ((mN & 1) == 0) {
      Z c = Z.ZERO;
      for (long j = 3; j <= mN / 2; ++j) {
        c = c.add(get(mN / 2, j));
      }
      c = c.multiply(4);
      c = c.add(get(mN / 2, 2L));
      if ((mN & 3) == 0) {
        c = c.subtract(get(mN / 4, 1L).multiply2());
      }
      b = b.subtract(c);
    }
    Z d = Z.ZERO;
    for (long j = 1; j <= (mN - 1) / 2; ++j) {
      d = d.add(get(j, 1L).multiply(get(mN - 2 * j, 2L)).multiply2());
      d = d.add(inner(j));
    }
    return a.add(b).subtract(d).divide(8);
  }
}
#!queue	A036969	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a036;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A036969 Triangle read by rows: T(n,k) = T(n-1,k-1) + k^2*T(n-1,k), 1 &lt; k &lt;= n, T(n,1) = 1.
 * @author Sean A. Irvine
 */
public class A036969 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 1 || m > n) {
      return Z.ZERO;
    }
    if (m == 1) {
      return Z.ONE;
    }
    return get(n - 1, m - 1).add(get(n - 1, m).multiply(m).multiply(m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A037202	0	->	1	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a037;

import irvine.factor.factor.Jaguar;
import irvine.factor.prime.Fast;
import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.z.Z;

/**
 * A037202 Number of lines in Pratt certificate for n-th prime.
 * @author Sean A. Irvine
 */
public class A037202 extends MemoryFunctionSequence<Long, Long> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected final Fast mPrime = new Fast();
  protected long mP = 1;

  @Override
  protected Long compute(final Long key) {
    if (key == 2) {
      return 1L;
    }
    long sum = 1;
    for (final Z p : Jaguar.factor(key - 1).toZArray()) {
      sum += get(p.longValue());
    }
    return sum;
  }

  @Override
  public Z next() {
    mP = mPrime.nextPrime(mP);
    return Z.valueOf(get(mP));
  }
}
#!queue	A037254	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a037;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A037254 Triangle read by rows: T(n,k) (n &gt;= 1, 1 &lt;= k&lt; = n) gives number of non-distorting tie-avoiding integer vote weights.
 * @author Sean A. Irvine
 */
public class A037254 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k == 1) {
      if (n == 1) {
        return Z.ONE;
      }
      return get(n - 1, (n + 1L) / 2);
    }
    return get(n, 1L).add(get(n - 1, k - 1));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A038792	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a038;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A038792 Rectangular array defined by T(i,1) = T(1,j) = 1 for i &gt;= 1 and j &gt;= 1; T(i,j) = max(T(i-1,j) + T(i-1,j-1), T(i-1,j-1) + T(i,j-1)) for i &gt;= 2, j &gt;= 2, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A038792 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 1 || m == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).add(get(n - 1, m - 1)).max(get(n - 1, m - 1).add(get(n, m - 1)));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN + 1 - mM, mM);
  }
}
#!queue	A039621	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A039621 Triangle of Lehmer-Comtet numbers of 2nd kind.
 * @author Sean A. Irvine
 */
public class A039621 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Vladimir Kruchinin

  @Override
  protected Z compute(final int n, final int k, final int m) {
    if (k < 0 || n < 0) {
      return Z.ZERO;
    }
    if (k == 0) {
      return Z.ONE;
    }
    return get(n, k - 1, m).multiply(m).add(get(n - 1, k, m + 1));
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    final int k = mN - mM;
    final Z t = get(mM, k, k);
    return (k & 1) == 0 ? t : t.negate();
  }
}
#!queue	A039683	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a039;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A039683 Signed double Pochhammer triangle: expansion of x(x-2)(x-4)..(x-2n+2).
 * @author Sean A. Irvine
 */
public class A039683 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m <= 0 || m > n) {
      return Z.ZERO;
    }
    if (n == 1) {
      return Z.ONE;
    }
    return get(n - 1, m - 1).subtract(get(n - 1, m).multiply(2 * mN - 2));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A039917	0	->	1	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a039;

import java.util.ArrayList;
import java.util.List;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.z.Z;

/**
 * A039917 Number of orderings of 1,2,...,n^2 in an n X n matrix such that each row, each column and both diagonals are increasing.
 * @author Sean A. Irvine
 */
public class A039917 extends MemoryFunctionSequence<List<Integer>, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private int mN = 0;

  private boolean isZero(final List<Integer> l) {
    for (final int v : l) {
      if (v != 0) {
        return false;
      }
    }
    return true;
  }

  @Override
  protected Z compute(final List<Integer> l) {
    if (isZero(l)) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    final int n = l.size();
    for (int i = 0; i < n; ++i) {
      if ((l.get(i) != n - i || i == 0 || l.get(i - 1) <= n - i)
        && l.get(i) > (i == n - 1 ? 0 : l.get(i + 1))) {
        // We need to make a copy to ensure the cache remains consistent
        final ArrayList<Integer> t = new ArrayList<>(l);
        t.set(i, l.get(i) - 1);
        sum = sum.add(get(t));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    final List<Integer> lst = new ArrayList<>(++mN);
    for (int k = 0; k < mN; ++k) {
      lst.add(mN);
    }
    return get(lst);
  }
}
#!queue	A045450	0	->	5	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a045;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.PrependSequence;
import irvine.oeis.a000.A000040;
import irvine.oeis.a000.A000720;
import irvine.oeis.a007.A007504;

/**
 * A045450 Number of partitions of n into a prime number of distinct prime parts.
 * @author Sean A. Irvine
 */
public class A045450 extends MemoryFunction2Sequence<Integer, Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final MemorySequence mPiSeq = MemorySequence.cachedSequence(new A000720());
  private final MemorySequence mS = MemorySequence.cachedSequence(new A007504());
  private final MemorySequence mPrime = MemorySequence.cachedSequence(new PrependSequence(new A000040(), 0));
  private int mN = 4;

  @Override
  protected Polynomial<Z> compute(final Integer n, final Integer m) {
    if (n == 0) {
      return RING.one();
    }
    if (mS.a(m).intValueExact() < n) {
      return RING.zero();
    }
    final Polynomial<Z> b = get(n, m - 1);
    final int pi = mPrime.a(m).intValueExact();
    return pi > n ? b : RING.add(b, get(n - pi, m - 1).shift(1));
  }

  @Override
  public Z next() {
    final Polynomial<Z> p = get(++mN, mPiSeq.a(mN).intValue());
    Z sum = Z.ZERO;
    int pr;
    for (int k = 1; (pr = mPrime.a(k).intValueExact()) <= p.degree(); ++k) {
      sum = sum.add(p.coeff(pr));
    }
    return sum;
  }
}
#!queue	A045778	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a045;

import irvine.factor.factor.Jaguar;
import irvine.factor.prime.Fast;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A045778 Number of factorizations of n into distinct factors greater than 1.
 * @author Sean A. Irvine
 */
public class A045778 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private final Fast mPrime = new Fast();
  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    Z t = n > m ? Z.ZERO : Z.ONE;
    if (mPrime.isPrime(n)) {
      return t;
    }
    for (final Z dd : Jaguar.factor(n).divisors()) {
      final long d = dd.longValue();
      if (d <= m && d > 1 && d < n) {
        t = t.add(get(n / d, d - 1));
      }
    }
    return t;
  }

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A046214	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a046;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A046214 First denominator and then numerator of 1/2-Pascal triangle (by row).
 * @author Sean A. Irvine
 */
public class A046214 extends MemoryFunction2Sequence<Long, Q> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private boolean mNumerator = true;
  private long mN = -1;
  private long mM = 0;

  @Override
  protected Q compute(final Long n, final Long m) {
    if (m < 0 || m > n) {
      return Q.ZERO;
    }
    if (n < 2) {
      return Q.ONE;
    }
    if (n == 2) {
      return m == 1 ? Q.HALF : Q.ONE;
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    mNumerator = !mNumerator;
    if (!mNumerator && ++mM > mN) {
      ++mN;
      mM = 0;
    }
    return mNumerator ? get(mN, mM).num() : get(mN, mM).den();
  }
}
#!queue	A046663	0	->	2	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a046;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A046663 Triangle: T(n,k) = number of partitions of n (&gt;=2) with no subsum equal to k (1 &lt;= k &lt;= n-1).
 * @author Sean A. Irvine
 */
public class A046663 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private int mN = 1;
  private int mM = 1;
  private final HashMap<String, Z> mBCache = new HashMap<>();

  private Z b(final int n, final int i, final Set<Integer> s) {
    final String key = n + "," + i + "," + s;
    final Z res = mBCache.get(key);
    if (res != null) {
      return res;
    }

    if (s.contains(0) || s.contains(n)) {
      return Z.ZERO;
    }
    if (n == 0 || s.isEmpty()) {
      return get(n, i);
    }
    if (i < 1) {
      return Z.ZERO;
    }
    Z r = b(n, i - 1, s);
    if (i <= n) {
      final HashSet<Integer> h = new HashSet<>();
      for (final int v : s) {
        if (v <= n - i) {
          h.add(v);
        }
        if (v - i >= 0) {
          h.add(v - i);
        }
      }
      r = r.add(b(n - i, i, h));
    }

    mBCache.put(key, r);
    return r;
  }

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n == 0) {
      return Z.ONE;
    }
    return (m > 1 ? get(n, m - 1) : Z.ZERO).add(m > n ? Z.ZERO : get(n - m, m));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    return b(mN, mN, Collections.singleton(Math.min(mM, mN - mM)));
  }
}
#!queue	A046739	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a046;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A046739 Triangle read by rows, related to number of permutations of [n] with 0 successions and k rises.
 * @author Sean A. Irvine
 */
public class A046739 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n <= 0 || m <= 0 || m > n) {
      return Z.ZERO;
    }
    if (n.equals(m)) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(m).add(get(n - 1, m - 1).multiply(n + 1 - m)).add(get(n - 2, m - 1).multiply(n));
  }


  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A046740	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a046;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A046740 Triangle of number of permutations of [n] with 0 successions, by number of rises.
 * @author Sean A. Irvine
 */
public class A046740 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 1) {
      return Z.ONE;
    }
    if (n <= 0 || m <= 0 || m >= n) {
      return Z.ZERO;
    }
    return get(n - 1, m).multiply(m).add(get(n - 1, m - 1).multiply(n - m)).add(get(n - 2, m - 1).multiply(n - 2));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A046752	0	->	3	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a046;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.graph.Multigraph;
import irvine.math.z.Z;

/**
 * A046752 Triangle read by rows: T(n,k) is the number of unlabeled nonseparable (or 2-connected) loopless multigraphs with n edges on k nodes and degree &gt;= 3 at each node, n &gt;= 3, 2 &lt;= k &lt;= floor(2*n/3).
 * @author Sean A. Irvine
 */
public class A046752 extends MemoryFunction2Sequence<Integer, Set<Multigraph>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 1;
  private int mM = 2;

  @Override
  protected Set<Multigraph> compute(final Integer n, final Integer m) {
    if (n < 2 || m < 3 || n > 2 * m / 3) {
      return Collections.emptySet();
    }
    if (n == 2 && m == 3) {
      final Multigraph g = new Multigraph(2);
      g.addEdge(0, 1);
      g.addEdge(0, 1);
      g.addEdge(0, 1);
      return Collections.singleton(g);
    }
    final HashSet<Multigraph> newStars = new HashSet<>();
    for (final Multigraph g : get(n, m - 1)) {
      // (a) join any two distinct vertices by an edge
      for (int u = 0; u < n; ++u) {
        for (int v = u + 1; v < n; ++v) {
          final Multigraph h = g.copy();
          h.addEdge(u, v);
          newStars.add(h.canon());
        }
      }
    }
    for (final Multigraph g : get(n - 1, m - 2)) {
      // (b) insert a second-degree vertex on any edge and join to any vertex
      final int o = g.order();
      for (int u = 0; u < o; ++u) {
        for (int v = u + 1; v < o; ++v) {
          if (g.edge(u, v) > 0) {
            // Found an edge (it might have multiplicity, but all are equivalent
            // Choose another vertex
            for (int w = 0; w < o; ++w) {
              final Multigraph h = g.copy(o + 1);
              h.removeEdge(u, v);
              h.addEdge(u, o);
              h.addEdge(v, o);
              h.addEdge(w, o);
              newStars.add(h.canon());
            }
          }
        }
      }
    }
    for (final Multigraph g : get(n - 2, m - 3)) {
      // (c) insert two second-degree vertices on (not necessarily distinct) edges and join by an edge
      final int o = g.order();
      for (int u = 0; u < o; ++u) {
        for (int v = u + 1; v < o; ++v) {
          final int e = g.edge(u, v);
          if (e > 0) {
            for (int w = u; w < o; ++w) {
              for (int x = w + 1; x < o; ++x) {
                if (g.edge(w, x) > 0) {
                  if (u == w && v == x) {
                    // Special case where both new vertices on same edge
                    final Multigraph h = g.copy(o + 2);
                    h.removeEdge(u, v);
                    h.addEdge(u, o);
                    h.addEdge(v, o + 1);
                    h.addEdge(o, o + 1);
                    h.addEdge(o, o + 1); // this edge has multiplicity 2
                    newStars.add(h.canon());
                  }
                  if (u != w || v != x || e > 1) {
                    // We might have (u,v) = (w,x), but still different edges!
                    final Multigraph h = g.copy(o + 2);
                    h.removeEdge(u, v);
                    h.removeEdge(w, x);
                    h.addEdge(u, o);
                    h.addEdge(v, o);
                    h.addEdge(w, o + 1);
                    h.addEdge(x, o + 1);
                    h.addEdge(o, o + 1);
                    newStars.add(h.canon());
                  }
                }
              }
            }
          }
        }
      }
    }
    return newStars;
  }

  @Override
  public Z next() {
    if (++mN > 2 * mM / 3) {
      ++mM;
      mN = 2;
    }
    return Z.valueOf(get(mN, mM).size());
  }
}
#!queue	A046860	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a046;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A046860 Triangle giving a(n,k) = number of k-colored labeled graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A046860 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 && m == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long r = 0; r < n; ++r) {
      sum = sum.add(Binomial.binomial(n, r).multiply(get(r, m - 1)).shiftLeft(r * (n - r)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A047265	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a121.A121373;

/**
 * A047265 Triangle a(n,k) (n &gt;= 1, 1&lt;=k&lt;=n) giving coefficient of x^n in expansion of (Product_{j&gt;=1} (1-(-x)^j) - 1 )^k.
 * @author Sean A. Irvine
 */
public class A047265 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private final MemorySequence mG = MemorySequence.cachedSequence(new A121373());
  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0) {
      return n == 0 ? Z.ONE : Z.ZERO;
    }
    if (m == 1) {
      return n == 0 ? Z.ZERO : mG.a(n.intValue());
    }
    final long q = m / 2;
    Z sum = Z.ZERO;
    for (long j = 0; j <= n; ++j) {
      sum = sum.add(get(j, q).multiply(get(n - j, m - q)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A047666	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047666 Square array a(n,k) read by antidiagonals: a(n,1)=n, a(1,k)=k, a(n,k) = a(n-1,k-1) + a(n-1,k) + a(n,k-1).
 * @author Sean A. Irvine
 */
public class A047666 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 1) {
      return Z.valueOf(k);
    }
    if (k == 1) {
      return Z.valueOf(n);
    }
    return get(n - 1, k - 1).add(get(n, k - 1)).add(get(n - 1, k));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM + 1, mM);
  }
}
#!queue	A047671	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047671 Square array a(n,k) read by antidiagonals: a(n,1)=1, a(1,k)=1, a(n,k) = 1 + a(n-1,k-1) + a(n-1,k) + a(n,k-1).
 * @author Sean A. Irvine
 */
public class A047671 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    return n == 1 || k == 1 ? Z.ONE : get(n - 1, k - 1).add(get(n, k - 1)).add(get(n - 1, k)).add(1);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM + 1, mM);
  }
}

#!queue	A047675	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047675 Square array a(n,k) read by antidiagonals: a(n,1)=n, a(1,k)=k, a(n,k) = a(n-1,k-1)*a(n-1,k)*a(n,k-1).
 * @author Sean A. Irvine
 */
public class A047675 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 1) {
      return Z.valueOf(k);
    }
    if (k == 1) {
      return Z.valueOf(n);
    }
    return get(n - 1, k - 1).multiply(get(n, k - 1)).multiply(get(n - 1, k));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM + 1, mM);
  }
}
#!queue	A047812	0	->	1	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunctionSequence;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A047812 Parker's partition triangle T(n,k) read by rows (n &gt;= 1 and 0 &lt;= k &lt;= n-1).
 * @author Sean A. Irvine
 */
public class A047812 extends MemoryFunctionSequence<Integer, Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final Integer n) {
    final int n2 = n * n;
    Polynomial<Z> prod = RING.one();
    for (int k = 0; k < n; ++k) {
      prod = RING.multiply(prod, RING.series(RING.oneMinusXToTheN(2 * n - k), RING.oneMinusXToTheN(k + 1), n2), n2);
    }
    return prod;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN).coeff(mM * (mN + 1));
  }
}
#!queue	A047844	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000040;

/**
 * A047844 Patrick De Geest's "Generations" array read by antidiagonals: a(n,1) = n-th prime, a(1,k+1) = a(2,k), a(n,k+1) = a(n-1,k) + a(n+1,k).
 * @author Sean A. Irvine
 */
public class A047844 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemorySequence mPrime = MemorySequence.cachedSequence(new A000040());
  private long mN = 1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 1) {
      return mPrime.a((int) (n - 1));
    }
    return n == 1 ? get(2L, m - 1) : get(n - 1, m - 1).add(get(n + 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM, mM);
  }
}
#!queue	A047913	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047913 Triangle of numbers a(n,k) = number of partitions of k such that k = n + n_1 + n_2 + ... + n_t where n_1 &lt;= 2n and n_{i+1} &lt;= 2n_i for all i.
 * @author Sean A. Irvine
 */
public class A047913 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n.equals(m)) {
      return Z.ONE;
    }
    if (n < 1 || m < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= 2 * n; ++k) {
      sum = sum.add(get(k, m - n));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (--mM < 1) {
      mM = ++mN;
    }
    return get(mM, mN);
  }
}
#!queue	A048003	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A048003 Triangular array T read by rows: T(h,k) = number of binary words of length h and maximal runlength k.
 * @author Sean A. Irvine
 */
public class A048003 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 1 || m > n) {
      return Z.ZERO;
    }
    if (m == 1 || m.equals(n)) {
      return Z.TWO;
    }
    return get(n - 1, m).multiply2()
      .add(get(n - 1, m - 1))
      .subtract(get(n - 2, m - 1).multiply2())
      .add(get(n - m, m - 1))
      .subtract(get(n - m - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A048159	0	->	2	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A048159 Triangle giving a(n,k) = number of (n,k) labeled Greg trees (n &gt;= 2, 0 &lt;= k &lt;= n-2).
 * @author Sean A. Irvine
 */
public class A048159 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 1;
  private int mM = 1;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 0) {
      return Z.valueOf(n).pow(n - 2);
    }
    if (m < 0 || m > n) {
      return Z.ZERO;
    }
    return get(n - 1, m - 1).multiply(n + m - 3)
      .add(get(n - 1, m).multiply(2 * n + 2 * m - 3))
      .add(get(n - 1, m + 1).multiply(m + 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 2;
    }
    return get(mN, mM - 2);
  }
}

#!queue	A048160	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A048160 Triangle giving T(n,k) = number of (n,k) labeled rooted Greg trees (n &gt;= 1, 0&lt;=k&lt;=n-1).
 * @author Sean A. Irvine
 */
public class A048160 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 0) {
      return Z.valueOf(n).pow(n - 1);
    }
    if (m < 0 || m > n) {
      return Z.ZERO;
    }
    return get(n - 1, m - 1).multiply(n + m - 2)
      .add(get(n - 1, m).multiply(2 * n + 2 * m - 2))
      .add(get(n - 1, m + 1).multiply(m + 1));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}

#!queue	A048176	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A048176 Generalized Stirling number triangle of first kind.
 * @author Sean A. Irvine
 */
public class A048176 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mM = 0;
  private int mN = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 0 || n < m) {
      return Z.ZERO;
    }
    if (n.equals(m)) {
      return Z.ONE;
    }
    return get(n - 1, m - 1).subtract(get(n - 1, m).multiply(10L * n - 10));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A048600	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.Mobius;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;

/**
 * A048600 Triangle a(n,k) = number of colors that can be produced by n units of paint from k primary colors.
 * @author Sean A. Irvine
 */
public class A048600 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    Z sum = Z.ZERO;
    for (final Z d : Jaguar.factor(n).divisors()) {
      final int mobius = Mobius.mobius(n / d.intValueExact());
      if (mobius != 0) {
        Z prod = Z.ONE;
        for (int j = 1; j <= k; ++j) {
          prod = prod.multiply(d.add(j));
        }
        sum = sum.signedAdd(mobius == 1, prod.divide(mF.factorial(k)));
      }
    }
    return sum;
  }

  private Z t(final int n, final int k) {
    Z sum = Z.ZERO;
    for (int j = 1; j <= n; ++j) {
      sum = sum.add(get(j, k));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return t(mN - mM, mM);
  }
}

#!queue	A048887	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A048887 Array T read by antidiagonals, where T(m,n) = number of compositions of n into parts &lt;= m.
 * @author Sean A. Irvine
 */
public class A048887 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= Math.min(n, m); ++k) {
      sum = sum.add(get(n - k, m));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mM, 1 + mN - mM);
  }
}

#!queue	A048966	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A048966 A convolution triangle of numbers obtained from A025748.
 * @author Sean A. Irvine
 */
public class A048966 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m > n) {
      return Z.ZERO;
    }
    if (n == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(3 * (n - 1) - m).multiply(3).add(get(n - 1, m - 1).multiply(m)).divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A049029	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a049;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A049029 Triangle read by rows, the Bell transform of the quartic factorial numbers A007696(n+1) without column 0.
 * @author Sean A. Irvine
 */
public class A049029 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m <= 0 || m > n) {
      return Z.ZERO;
    }
    if (n == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(4 * (n - 1) + m).add(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A049061	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a049;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A049061 Triangle a(n,k) (1&lt;=k&lt;=n) of "signed Eulerian numbers" read by rows.
 * @author Sean A. Irvine
 */
public class A049061 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Jean-Fran&ccedil;ois Alcover

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0) {
      return Z.ZERO;
    }
    if (n == 1 && m == 1) {
      return Z.ONE;
    }
    if ((n & 1) == 0) {
      return get(n - 1, m).subtract(get(n - 1, m - 1));
    } else {
      return get(n - 1, m).multiply(m).add(get(n - 1, m - 1).multiply(n - m + 1));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A049089	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a049;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A049089 Array read by antidiagonals: T(1,j)=2j+2 i&gt;=1, T(i,1)=2i+2 i&gt;=1, T(i,j)=T(i-1,j-1)+T(i-1,j).
 * @author Sean A. Irvine
 */
public class A049089 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 1) {
      return Z.valueOf(2 * m + 2);
    }
    if (m == 1) {
      return Z.valueOf(2 * n + 2);
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      mM = 1;
      ++mN;
    }
    return get(mN - mM + 1, mM);
  }
}
#!queue	A049213	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a049;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A049213 A convolution triangle of numbers obtained from A025749.
 * @author Sean A. Irvine
 */
public class A049213 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  protected long param() {
    return 4;
  }

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 1 || m > n) {
      return Z.ZERO;
    }
    if (n == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(param() * (n - 1) - m).multiply(param()).add(get(n - 1, m - 1).multiply(m)).divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A049286	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a049;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A049286 Triangle of partitions v(d,c) defined in A002572.
 * @author Sean A. Irvine
 */
public class A049286 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long c, final Long d) {
    if (d < 0 || c < 0) {
      return Z.ZERO;
    }
    if (c.equals(d)) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= 2 * c; ++k) {
      sum = sum.add(get(k, d - c));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mM, mN);
  }
}
#!queue	A049290	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a049;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;

/**
 * A049290 Array T(n,k) = number of subgroups of index k in free group of rank n, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A049290 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    Z sum = Z.ZERO;
    for (int k = 1; k < m; ++k) {
      sum = sum.add(mF.factorial(k).pow(n - 1).multiply(get(n, m - k)));
    }
    return mF.factorial(m).pow(n - 1).multiply(m).subtract(sum);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN + 1 - mM, mM);
  }
}
#!queue	A049375	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a049;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A049375 A convolution triangle of numbers obtained from A034687.
 * @author Sean A. Irvine
 */
public class A049375 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected int mN = 0;
  protected int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n < m) {
      return Z.ZERO;
    }
    if (n == 1) {
      return m == 1 ? Z.ONE : Z.ZERO;
    }
    return get(n - 1, m).multiply(5L * (n - 1) + m).multiply(5).add(get(n - 1, m - 1).multiply(m)).divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A049463	0	->	2	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A049463 Number of basic interval orders of length n.
 * @author Sean A. Irvine
 */
public class A049463 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Z compute(final int n, final int k, final int l) {
    if (n < 1 || k < 1 || l < 1) {
      return Z.ZERO;
    }
    if (k == 1 && l == 1) {
      return Z.ONE;
    }
    Z sum = get(n - 1, k - 1, l - 1).multiply(n - l)
      .add(Binomial.binomial(k, k - 1).multiply(get(n - 1, k, l)));
    for (int j = k + 1; j <= l - 1; ++j) {
      if (j != l - 2) {
        sum = sum.add(Binomial.binomial(j, k - 1).multiply(get(n - 1, j, l - 1)));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int l = 1; l < mN; ++l) {
      for (int k = 1; k <= l; ++k) {
        if (k != l - 1) {
          sum = sum.add(get(mN, k, l).multiply(Z.ONE.shiftLeft(k).add(mN - l - 1)));
        }
      }
    }
    return sum;
  }
}
#!queue	A050143	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a050;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A050143 A(n,k) = Sum_{h=0..n-1, m=0..k} A(h,m) for n &gt;= 1 and k &gt;= 1, with A(n,0) = 1 for n &gt;= 0 and A(0,k) = 0 for k &gt;= 1; square array A, read by descending antidiagonals.
 * @author Sean A. Irvine
 */
public class A050143 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 0) {
      return Z.ONE;
    }
    if (n == 0) {
      return Z.ZERO;
    }
    if (m == 1) {
      return Z.ONE.shiftLeft(n).subtract(1);
    }
    return get(n - 1, m).multiply2().add(get(n, m - 1)).subtract(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A050211	0	->	3	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a050;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A050211 Triangle of number of permutations of {1, 2, ..., n} having exactly k cycles, each of which is of length &gt;=r for r=3.
 * @author Sean A. Irvine
 */
public class A050211 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 2;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 3 || m < 1) {
      return Z.ZERO;
    }
    if (n == 3 && m == 1) {
      return Z.TWO;
    }
    return get(n - 1, m).multiply(n - 1).add(get(n - 3, m - 1).multiply(n - 1).multiply(n - 2));
  }

  @Override
  public Z next() {
    if (++mM > mN / 3) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A050212	0	->	4	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a050;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A050212 Triangle of number of permutations of {1, 2, ..., n} having exactly k cycles, each of which is of length &gt;=r for r=4.
 * @author Sean A. Irvine
 */
public class A050212 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 3;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 4 || m < 1) {
      return Z.ZERO;
    }
    if (n == 4 && m == 1) {
      return Z.SIX;
    }
    return get(n - 1, m).multiply(n - 1).add(get(n - 4, m - 1).multiply(n - 1).multiply(n - 2).multiply(n - 3));
  }

  @Override
  public Z next() {
    if (++mM > mN / 4) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A050213	0	->	5	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a050;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A050213 Triangle of number of permutations of {1, 2, ..., n} having exactly k cycles, each of which is of length &gt;=r for r=5.
 * @author Sean A. Irvine
 */
public class A050213 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 4;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 5 || m < 1) {
      return Z.ZERO;
    }
    if (n == 5 && m == 1) {
      return Z.valueOf(24);
    }
    return get(n - 1, m).multiply(n - 1).add(get(n - 5, m - 1).multiply(n - 1).multiply(n - 2).multiply(n - 3).multiply(n - 4));
  }

  @Override
  public Z next() {
    if (++mM > mN / 5) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A050227	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a050;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A050227 Triangle of number of n-tosses having a run of r or more heads for a fair coin with r=1 to n across and n=1, 2, ... down.
 * @author Sean A. Irvine
 */
public class A050227 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n.equals(m)) {
      return Z.ONE;
    }
    if (m > n) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int k = n - m; k < n; ++k) {
      sum = sum.add(get(k, m));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return Z.ONE.shiftLeft(mN).subtract(get(mN + mM + 1, mM));
  }
}
#!queue	A050298	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a050;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a008.A008578;

/**
 * A050298 Triangle read by rows: T(n,k) = p(r), where r is the (n-k+1)-th number such that A001222(r+1) = k, and p(r) is the r-th prime.
 * @author Sean A. Irvine
 */
public class A050298 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemorySequence mPrimes = MemorySequence.cachedSequence(new A008578());
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n.equals(m)) {
      return Z.ONE.shiftLeft(n).subtract(1);
    }
    Z k = get(n - 1, m);
    while (true) {
      k = k.add(1);
      if (Jaguar.factor(k.add(1)).bigOmega() == m) {
        return k;
      }
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return mPrimes.a(get(mN, mM).intValueExact());
  }
}
#!queue	A050970	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a050;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A050970 Numerator of S(n)/Pi^n, where S(n) = Sum_{k=-inf..+inf} (4k+1)^(-n).
 * @author Sean A. Irvine
 */
public class A050970 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = -1;
  private Z mF = Z.ONE;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0) {
      return n == 0 ? Z.ONE : Z.ZERO;
    }
    return get(n, m - 1).add(get(n - 1, n - m));
  }

  protected Z select(final Q n) {
    return n.num();
  }

  @Override
  public Z next() {
    if (++mN >= 1) {
      mF = mF.multiply(2 * mN);
    }
    return select(new Q(get(mN, mN), mF));
  }
}
#!queue	A051685	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a051;

import irvine.math.IntegerUtils;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;

/**
 * A051685 Auxiliary sequence for calculation of number of even permutations of degree n and order exactly 4.
 * @author Sean A. Irvine
 */
public class A051685 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n == 0 && m == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 1; k <= n; ++k) {
      Z s = Z.ZERO;
      for (int l = 1; l <= m; ++l) {
        if (IntegerUtils.lcm(l, k) == m) {
          s = s.add(get(n - k, l));
        }
      }
      sum = sum.signedAdd((k & 1) == 1, s.multiply(mF.factorial(n - 1).divide(mF.factorial(n - k))));
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, 4);
  }
}
#!queue	A051707	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a051;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;
import irvine.util.Point;

/**
 * A051707 Number of factorizations of (n,n) into pairs (j,k).
 * @author Sean A. Irvine
 */
public class A051707 extends MemoryFunction2Sequence<Integer, Set<Map<Point, Integer>>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final Set<Map<Point, Integer>> ONE_ONE = Collections.singleton(Collections.singletonMap(new Point(1, 1), 1));
  private int mN = 0;

  @Override
  protected Set<Map<Point, Integer>> compute(final Integer n, final Integer m) {
    if (n == 1) {
      return m == 1 ? ONE_ONE : Collections.emptySet();
    }
    final HashSet<Map<Point, Integer>> factorizations = new HashSet<>();
    factorizations.add(Collections.singletonMap(new Point(n, m), 1));
    for (final Z dd : Jaguar.factor(n).divisors()) {
      final int d = dd.intValue();
      if (d > 1 && d < n) {
        for (final Z ee : Jaguar.factor(m).divisors()) {
          final int e = ee.intValue();
          for (final Map<Point, Integer> t : get(n / d, m / e)) {
            final Map<Point, Integer> f = new HashMap<>();
            f.put(new Point(d, e), 1);
            for (Map.Entry<Point, Integer> entry : t.entrySet()) {
              final Point pt = entry.getKey();
              final int multiplicity = entry.getValue();
              f.merge(pt, multiplicity, Integer::sum);
            }
            factorizations.add(f);
          }
        }
      }
    }
    return factorizations;
  }

  @Override
  public Z next() {
    return Z.valueOf(get(++mN, mN).size());
  }
}
#!queue	A052138	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a052;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Stirling;
import irvine.math.z.Z;

/**
 * A052138 Numerators of coefficients in function a(x) such that a(a(a(x))) = log (1+x).
 * @author Sean A. Irvine
 */
public class A052138 extends MemoryFunction2Sequence<Integer, Q> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;

  @Override
  protected Q compute(final Integer n, final Integer m) {
    if (n.equals(m)) {
      return Q.ONE;
    }
    Q sum = new Q(Stirling.firstKind(n, m).multiply(mF.factorial(m)), mF.factorial(n));
    for (int k = m + 1; k < n; ++k) {
      Q s1 = Q.ZERO;
      for (int i = k; i <= n; ++i) {
        s1 = s1.add(get(n, i).multiply(get(i, k)));
      }
      sum = sum.subtract(s1.multiply(get(k, m)));
    }
    Q s2 = Q.ZERO;
    for (int i = m + 1; i < n; ++i) {
      s2 = s2.add(get(n, i).multiply(get(i, m)));
    }
    s2 = s2.multiply(get(m, m));
    sum = sum.subtract(s2);
    return sum.divide(3);
  }

  protected Z select(final Q n) {
    return n.num();
  }

  @Override
  public Z next() {
    return select(get(++mN, 1));
  }
}

#!queue	A052154	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a052;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A052154 Array read by antidiagonals: a(n,k)= coefficient of z^n of p_k(z), where p_k+1(z)=(p_k(z))^2+z, p_1(z)=z.
 * @author Sean A. Irvine
 */
public class A052154 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 1) {
      return Z.ONE;
    }
    if (n > 1L << (m - 1)) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k < n; ++k) {
      sum = sum.add(get(k, m - 1).multiply(get(n - k, m - 1)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mM, mN - mM + 1);
  }
}
#!queue	A052178	0	->	2	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a052;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A052178 Number of walks of length n on the simple cubic lattice terminating at height 2 above the (x,y)-plane.
 * @author Sean A. Irvine
 */
public class A052178 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 1;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n.equals(m)) {
      return Z.ONE;
    }
    if (m < 0 || m > n) {
      return Z.ZERO;
    }
    return get(n - 1, m - 1).add(get(n - 1, m).multiply(4)).add(get(n - 1, m + 1));
  }

  @Override
  public Z next() {
    return get(++mN, 2L);
  }
}
#!queue	A053477	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a053;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;

/**
 * A053477 Sum of iterates of divisor number function A000005.
 * @author Sean A. Irvine
 */
public class A053477 extends MemoryFunction1Sequence<Long> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Long compute(final int n) {
    return n <= 2 ? n : n + get((int) Jaguar.factor(n).sigma0AsLong());
  }

  @Override
  public Z next() {
    return Z.valueOf(get(++mN));
  }
}

#!queue	A053478	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a053;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Euler;
import irvine.math.z.Z;

/**
 * A053478 Sum of iterates when phi, A000010, is iterated until fixed point 1.
 * @author Sean A. Irvine
 */
public class A053478 extends MemoryFunction1Sequence<Long> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Long compute(final int n) {
    return n <= 1 ? n : n + get((int) Euler.phiAsLong(n));
  }

  @Override
  public Z next() {
    return Z.valueOf(get(++mN));
  }
}

#!queue	A053480	0	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a053;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Euler;
import irvine.math.z.Z;

/**
 * A053480 Sum of values when cototient function A051953 is iterated until fixed point is reached.
 * @author Sean A. Irvine
 */
public class A053480 extends MemoryFunction1Sequence<Long> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Long compute(final int n) {
    return n <= 1 ? 1L : n + get(n - (int) Euler.phiAsLong(n));
  }

  @Override
  public Z next() {
    return Z.valueOf(get(++mN));
  }
}

#!queue	A054589	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a054;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A054589 Table related to labeled rooted trees, cycles and binary trees.
 * @author Sean A. Irvine
 */
public class A054589 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 0 || m >= n) {
      return Z.ZERO;
    }
    if (n == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(n - 1).add(get(n - 1, m - 1).multiply(n + m - 2));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A054722	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a054;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Euler;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A054722 Triangle of coefficients of polynomials arising in enumeration of periodic sequences.
 * @author Sean A. Irvine
 */
public class A054722 extends MemoryFunction2Sequence<Integer, Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private Polynomial<Z> mQ = RING.zero();
  private int mN = 0;
  private int mM = 1;

  @Override
  protected Polynomial<Z> compute(final Integer n, final Integer m) {
    if (m == 0) {
      return RING.one();
    }
    if (m == 1) {
      final Z[] t = new Z[n + 1];
      t[0] = Z.ZERO;
      for (int k = 1; k < t.length; ++k) {
        t[k] = n % k == 0 ? Z.ONE : Z.ZERO;
      }
      return Polynomial.create(t);
    }
    return RING.add(RING.multiply(get(n, 1), get(n, m - 1)), RING.diff(get(n, m - 1)).shift(1));
  }

  @Override
  public Z next() {
    if (--mM < 1) {
      ++mN;
      mQ = RING.zero();
      for (final Z dd : Jaguar.factor(mN).divisors()) {
        final int d = dd.intValue();
        mQ = RING.add(mQ, RING.multiply(get(d, mN / d), Euler.phi(dd)));
      }
      mM = mQ.degree();
    }
    return mQ.coeff(mM).divide(mN);
  }
}

#!queue	A055167	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A055167 Number of optimal binary prefix-free codes with n words all ending in 1.
 * @author Sean A. Irvine
 */
public class A055167 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;

  @Override
  protected Z compute(final int n, final int a, final int b) {
    //System.out.println(n + " " + a + " " + b);
    if (1 <= n && n <= 4) {
      return a == 1 && b == 1 ? Z.ONE : Z.ZERO;
    }
    if (b == 1 && a >= 1) {
      Z sum = Z.ZERO;
      for (int k = a & 1; k <= a; k += 2) {
        sum = sum.add(get(n - 1, k, a));
      }
      return sum;
    }
    if (2 <= b && b <= a) {
      return get(n - 1, a, b - 1);
    }
    if (b - a >= 2 && ((b - a) & 1) == 0 && a >= 0) {
      return get(n - 1, a, b - 1);
    }
    if (b - a >= 1 && ((b - a) & 1) == 1 && a >= 0) {
      return get(n - 1, a + 1, b);
    }
    return Z.ZERO;
  }

  @Override
  public Z next() {
    if (++mN <= 3) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int a = 0; a <= mN / 3; ++a) {
      for (int b = 0; b <= mN / 3; ++b) {
        sum = sum.add(get(mN, a, b));
      }
    }
    return sum;
  }
}
#!queue	A055633	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a055;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A055633 Number of nested algorithms a(m,n) where m is the number of items in a contaminated group and n is the total number of unclassified items (0 &lt;= m &lt;= n) (values read by antidiagonals).
 * @author Sean A. Irvine
 */
public class A055633 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    //System.out.println("n=" +n + " m=" + m);
    if (n == 0) {
      if (m <= 1) {
        return Z.ONE;
      }
      Z prod = Binomial.catalan(m);
      for (int k = 1; k < m; ++k) {
        prod = prod.multiply(get(0, k));
      }
      return prod;
    }
    if (m < n) {
      return Z.ZERO;
    }
    Z prod = Binomial.catalan(n - 1);
    for (int k = 1; k <= n; ++k) {
      prod = prod.multiply(get(0, m - k));
    }
    return prod;
  }

  @Override
  public Z next() {
    if (--mM < 0) {
      mM = ++mN / 2;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A056858	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a056;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A056858 Triangle of number of rises in restricted growth strings (RGS) for the set partitions of n.
 * @author Sean A. Irvine
 */
public class A056858 extends MemoryFunctionInt3Sequence<Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int n, final int i, final int m) {
    return n == 0 ? RING.x() : RING.sum(1, m + 1, j -> get(n - 1, j, Math.max(m, j)).shift(j > i ? 1 : 0));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, 1, 0).coeff(mM);
  }
}
#!queue	A056859	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a056;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A056859 Triangle of number of falls in set partitions of n.
 * @author Sean A. Irvine
 */
public class A056859 extends MemoryFunctionInt3Sequence<Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int n, final int i, final int m) {
    return n == 0 ? RING.x() : RING.sum(1, m + 1, j -> get(n - 1, j, Math.max(m, j)).shift(j < i ? 1 : 0));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, 1, 0).coeff(mM);
  }
}
#!queue	A057568	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a057;

import irvine.factor.prime.Fast;
import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A057568 Number of partitions of n where n divides the product of the parts.
 * @author Sean A. Irvine
 */
public class A057568 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private final Fast mPrime = new Fast();
  private int mN = 0;

  @Override
  protected Z compute(final int n, final int i, final int t) {
    if (n == 0) {
      return t == 1 ? Z.ONE : Z.ZERO;
    }
    if (i < 1) {
      return Z.ZERO;
    }
    final Z b = get(n, i - 1, t);
    return i > n ? b : b.add(get(n - i, Math.min(i, n - i), t / IntegerUtils.gcd(i, t)));
  }

  @Override
  public Z next() {
    return mPrime.isPrime(++mN) ? Z.ONE : get(mN, mN, mN);
  }
}
#!queue	A057623	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a057;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.util.Pair;

/**
 * A057623 a(n) = n! * (sum of reciprocals of all parts in unrestricted partitions of n).
 * @author Sean A. Irvine
 */
public class A057623 extends MemoryFunctionInt2Sequence<Pair<Q, Q>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final Pair<Q, Q> ZERO = new Pair<>(Q.ZERO, Q.ZERO);
  private static final Pair<Q, Q> ONE = new Pair<>(Q.ONE, Q.ZERO);
  private int mN = 0;

  @Override
  protected Pair<Q, Q> compute(final int n, final int i) {
    if (n == 0) {
      return ONE;
    }
    if (i < 1) {
      return ZERO;
    }
    final Pair<Q, Q> a = get(n, i - 1);
    if (i > n) {
      return a;
    }
    final Pair<Q, Q> b = get(n - i, i);
    return new Pair<>(a.left().add(b.left()), a.right().add(b.right()).add(b.left().divide(i)));
  }

  @Override
  public Z next() {
    return get(++mN, mN).right().multiply(MemoryFactorial.SINGLETON.factorial(mN)).toZ();
  }
}
#!queue	A057731	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a057;

import irvine.math.IntegerUtils;
import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Binomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A057731 Irregular triangle read by rows: T(n,k) = number of elements of order k in symmetric group S_n, for n &gt;= 1, 1 &lt;= k &lt;= g(n), where g(n) = A000793(n) is Landau's function.
 * @author Sean A. Irvine
 */
public class A057731 extends MemoryFunctionInt2Sequence<Polynomial<Z>> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private Polynomial<Z> mP = RING.zero();
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int n, final int g) {
    if (n == 0) {
      return RING.monomial(Z.ONE, g);
    }
    return RING.sum(1, n, j -> RING.multiply(
      get(n - j, IntegerUtils.lcm(g, j)),
      Binomial.binomial(n - 1, j - 1).multiply(MemoryFactorial.SINGLETON.factorial(j - 1))
    ));
  }

  @Override
  public Z next() {
    if (++mM > mP.degree()) {
      mP = get(++mN, 1);
      mM = 1;
    }
    return mP.coeff(mM);
  }

}
#!queue	A058127	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A058127 Triangle read by rows: T(j,k) is the number of acyclic functions from {1,...,j} to {1,...,k}. For n &gt;= 1, a(n) = (k-j)*k^(j-1), where k is such that C(k,2) &lt; n &lt;= C(k+1,2) and j = (n-1) mod C(k,2). Alternatively, table T(k,j) read by antidiagonals with k &gt;= 1, 0 &lt;= j &lt;= k: T(k,j) = number of acyclic-function digraphs on k vertices with j vertices of outdegree 1 and (k-j) vertices of outdegree 0; T(k,j) = (k-j)*k^(j-1).
 * @author Sean A. Irvine
 */
public class A058127 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m) {
    if (n == 1) {
      return m == 0 ? Z.ONE : Z.ZERO;
    }
    if (m >= n) {
      return Z.ZERO;
    }
    return Integers.SINGLETON.sum(0, m, k -> get(n - 1, k).multiply(Binomial.binomial(m, k)));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A058377	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;

/**
 * A058377 Number of solutions to 1 +- 2 +- 3 +- ... +- n = 0.
 * @author Sean A. Irvine
 */
public class A058377 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  protected int mN = 0;

  @Override
  protected Z compute(final int n, final int i) {
    final int m = i * (i + 1) / 2;
    if (n > m) {
      return Z.ZERO;
    }
    if (n == m) {
      return Z.ONE;
    }
    return get(Math.abs(n - i), i - 1).add(get(n + i, i - 1));
  }

  @Override
  public Z next() {
    return (mN++ & 3) < 2 ? Z.ZERO : get(mN, mN - 1);
  }
}
#!queue	A058399	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A058399 Triangle of partial row sums of partition triangle A008284.
 * @author Sean A. Irvine
 */
public class A058399 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }
  
  // After Alois P. Heinz

  private int mN = 0;
  private int mM = 0;
  
  @Override
  protected Z compute(final int n, final int m) {
    if (n == 0) {
      return Z.ONE;
    }
    if (m < 1) {
      return Z.ZERO;
    }
    return Integers.SINGLETON.sum(0, n / m, k -> get(n - k * m, m - 1));
  }

  private Z t(final int n, final int m) {
    return get(n, n).subtract(get(n, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}

#!queue	A058498	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;

/**
 * A058498 Number of solutions to c(1)t(1) + ... + c(n)t(n) = 0, where c(i) = +-1 for i&gt;1, c(1) = t(1) = 1, t(i) = triangular numbers (A000217).
 * @author Sean A. Irvine
 */
public class A058498 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private int mN = 0;

  @Override
  protected Z compute(final int n, final int i) {
    final long m = (2 + (3L + i) * i) * i / 6;
    if (n > m) {
      return Z.ZERO;
    }
    if (n == m) {
      return Z.ONE;
    }
    return get(Math.abs(n - i * (i + 1) / 2), i - 1).add(get(n + i * (i + 1) / 2, i - 1));
  }

  @Override
  public Z next() {
    if ((++mN & 3) == 1) {
      return Z.ZERO;
    }
    return get(mN * (mN + 1) / 2, mN - 1);
  }
}
#!queue	A058843	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A058843 Triangle T(n,k) = C_n(k) where C_n(k) = number of k-colored labeled graphs with n nodes (n &gt;= 1, 1&lt;=k&lt;=n).
 * @author Sean A. Irvine
 */
public class A058843 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int k) {
    if (k == 1) {
      return Z.ONE;
    }
    return Integers.SINGLETON.sum(1, n - 1, j -> Binomial.binomial(n, j).multiply(get(j, k - 1)).shiftLeft(j * (n - j))).divide(k);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A058875	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A058875 Triangle T(n,k) = C_n(k)/2^(k*(k-1)/2) where C_n(k) = number of k-colored labeled graphs with n nodes (n &gt;= 1, 1 &lt;= k &lt;= n).
 * @author Sean A. Irvine
 */
public class A058875 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m) {
    if (m == 1) {
      return Z.ONE;
    }
    return Integers.SINGLETON.sum(1, n - 1, k -> Binomial.binomial(n, k).multiply(get(k, m - 1)).shiftLeft(k * (n - k))).divide(m);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM).shiftRight(mM * (mM - 1) / 2);
  }
}
#!queue	A058876	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A058876 Triangle read by rows: T(n,k) = number of labeled acyclic digraphs with n nodes, containing exactly n+1-k points of in-degree zero (n &gt;= 1, 1&lt;=k&lt;=n).
 * @author Sean A. Irvine
 */
public class A058876 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer p, final Integer k) {
    if (p.equals(k)) {
      return Z.ONE;
    }
    final Z u = Z.ONE.shiftLeft(k).subtract(1);
    Z v = u;
    Z s = Z.ZERO;
    for (int j = 1; j <= p - k; ++j, v = v.multiply(u)) {
      s = s.add(Binomial.binomial(p, k).multiply(get(p - k, j)).multiply(v).shiftLeft(k * (p - j - k)));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mN - mM);
  }

}
#!queue	A059022	0	->	3	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A059022 Triangle of Stirling numbers of order 3.
 * @author Sean A. Irvine
 */
public class A059022 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 2;
  private int mM = 2;

  @Override
  protected Z compute(final int n, final int m) {
    if (n < 3) {
      return Z.ZERO;
    }
    if (n < 6 && m == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(m).add(get(n - 3, m - 1).multiply(Binomial.binomial(n - 1, 2)));
  }

  @Override
  public Z next() {
    if (++mM > mN / 3) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059023	0	->	4	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A059023 Triangle of Stirling numbers of order 4.
 * @author Sean A. Irvine
 */
public class A059023 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 3;
  private int mM = 3;

  @Override
  protected Z compute(final int n, final int m) {
    if (n < 4) {
      return Z.ZERO;
    }
    if (n < 8 && m == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(m).add(get(n - 4, m - 1).multiply(Binomial.binomial(n - 1, 3)));
  }

  @Override
  public Z next() {
    if (++mM > mN / 4) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059024	0	->	5	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A059024 Triangle of Stirling numbers of order 5.
 * @author Sean A. Irvine
 */
public class A059024 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 4;
  private int mM = 4;

  @Override
  protected Z compute(final int n, final int m) {
    if (n < 5) {
      return Z.ZERO;
    }
    if (n < 9 && m == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(m).add(get(n - 5, m - 1).multiply(Binomial.binomial(n - 1, 4)));
  }

  @Override
  public Z next() {
    if (++mM > mN / 5) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059025	0	->	6	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A059025 Triangle of Stirling numbers of order 6.
 * @author Sean A. Irvine
 */
public class A059025 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 5;
  private int mM = 5;

  @Override
  protected Z compute(final int n, final int m) {
    if (n < 6) {
      return Z.ZERO;
    }
    if (n < 10 && m == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(m).add(get(n - 6, m - 1).multiply(Binomial.binomial(n - 1, 5)));
  }

  @Override
  public Z next() {
    if (++mM > mN / 6) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059216	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;

/**
 * A059216 Variation of Boustrophedon transform applied to all-1's sequence (see Comments for details).
 * @author Sean A. Irvine
 */
public class A059216 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;

  @Override
  protected Z compute(final int n, final int m) {
    if (n == 0) {
      return Z.ONE;
    }
    if ((n & 1) == 0) {
      if (m == n) {
        return Z.ONE;
      }
      Z sum = get(n, m + 1);
      for (int row = n - 1; row >= m; --row) {
        sum = sum.add(get(row, m));
      }
      return sum;
    } else {
      if (m == 0) {
        return Z.ONE;
      }
      Z sum = get(n, m - 1);
      for (int row = n - 1; row >= 0 && m >= n - row; --row) {
        sum = sum.add(get(row, m - (n - row)));
      }
      return sum;
    }
  }

  @Override
  public Z next() {
    ++mN;
    return (mN & 1) == 0 ? get(mN, 0) : get(mN, mN);
  }
}
#!queue	A059418	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;

/**
 * A059418 Triangle T(n,k) arising from enumeration of permutations with ordered orbits, read by rows (1&lt;=k&lt;=n).
 * @author Sean A. Irvine
 */
public class A059418 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 1;

  @Override
  protected Z compute(final int n, final int m) {
    if (n == m) {
      return Z.ONE;
    }
    if (m == 1) {
      return MemoryFactorial.SINGLETON.factorial(n).divide2();
    }
    return get(n - 1, m).multiply(n - 2).add(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059419	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A059419 Triangle T(n,k) (1 &lt;= k &lt;= n) of tangent numbers, read by rows: T(n,k) = coefficient of x^n/n! in expansion of (tan x)^k/k!.
 * @author Sean A. Irvine
 */
public class A059419 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n.equals(k)) {
      return Z.ONE;
    }
    if (k < 0 || k > n) {
      return Z.ZERO;
    }
    return get(n - 1, k - 1).add(get(n - 1, k + 1).multiply(k).multiply(k + 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059438	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a003.A003319;

/**
 * A059438 Triangle T(n,k) (1 &lt;= k &lt;= n) read by rows: T(n,k) is the number of permutations of [1..n] with k components.
 * @author Sean A. Irvine
 */
public class A059438 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemorySequence mP = new A003319();
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m) {
    if (n < m) {
      return Z.ZERO;
    }
    if (m == 1) {
      return mP.a(n);
    }
    return Integers.SINGLETON.sum(1, n, k -> get(n - k, m - 1).multiply(mP.a(k)));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059513	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A059513 Variation of Boustrophedon transform applied to 1,1,1,1,... Fill an array by diagonals, in alternating directions. The first entry is 1 each time. For the next element of a diagonal, add to the previous element the elements of the row and the column the new element is in. The final element of each diagonal gives a(n).
 * @author Sean A. Irvine
 */
public class A059513 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;

  @Override
  protected Z compute(final int n, final int m) {
    final int bit = (n + m) & 1;
    if (bit == 0) {
      if (n == 0) {
        return Z.ONE;
      }
      return get(n - 1, m + 1)
        .add(Integers.SINGLETON.sum(0, n - 1, k -> get(k, m)))
        .add(Integers.SINGLETON.sum(0, m - 1, k -> get(n, k)));
    } else {
      if (m == 0) {
        return Z.ONE;
      }
      return get(n + 1, m - 1)
        .add(Integers.SINGLETON.sum(0, n - 1, k -> get(k, m)))
        .add(Integers.SINGLETON.sum(0, m - 1, k -> get(n, k)));
    }
  }

  @Override
  public Z next() {
    ++mN;
    return (mN & 1) == 0 ? get(mN, 0) : get(0, mN);
  }
}
#!queue	A059578	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A059578 Variation of Boustrophedon transform applied to 1,1,1,1,... Fill an array by diagonals, all in the 'up' direction. The first column is 1,1,1,1,.... For the next element of a diagonal, add to the previous element the elements of the row and the column the new element is in. The first row gives a(n).
 * @author Sean A. Irvine
 */
public class A059578 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = -1;

  @Override
  protected Z compute(final int n, final int m) {
    if (m == 0) {
      return Z.ONE;
    }
    return get(n + 1, m - 1)
      .add(Integers.SINGLETON.sum(0, n - 1, k -> get(k, m)))
      .add(Integers.SINGLETON.sum(0, m - 1, k -> get(n, k)));
  }

  @Override
  public Z next() {
    return get(0, ++mN);
  }
}
#!queue	A059623	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a008.A008284;

/**
 * A059623 As upper right triangle, number of weakly unimodal partitions of n where initial part is k (n &gt;= k &gt;= 1).
 * @author Sean A. Irvine
 */
public class A059623 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final A008284 mS = new A008284();
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m) {
    if (n == m) {
      return Z.ONE;
    }
    return mS.get((long) n, (long) m).subtract(mS.get((long) n - m, (long) m)).add(Integers.SINGLETON.sum(m, n, k -> get(n - m, k)));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059871	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a008.A008578;
import irvine.oeis.a026.A026905;

/**
 * A059871 Number of solutions to the equation p_i = (1+mod(i,2))*p_{i-1} +- p_{i-2} +- p_{i-3} +- ... +- 2 +- 1, where p_i is the i-th prime number (where p_1 = 2 and the "zeroth prime" p_0 is defined to be 1).
 * @author Sean A. Irvine
 */
public class A059871 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemorySequence mP = MemorySequence.cachedSequence(new A008578());
  private final MemorySequence mSP = MemorySequence.cachedSequence(new A026905());
  private int mN = 0;

  private int sp(final int m) {
    return m < 0 ? 0 : mSP.a(m).intValueExact();
  }

  @Override
  protected Z compute(final int n, final int m) {
    if (n > sp(m)) {
      return Z.ZERO;
    }
    if (m < 0) {
      return Z.ONE;
    }
    final int pm = mP.a(m).intValueExact();
    return get(n + pm, m - 1).add(get(Math.abs(n - pm), m - 1));
  }

  @Override
  public Z next() {
    ++mN;
    final int pn = mP.a(mN).intValueExact();
    final int pnm1 = mP.a(mN - 1).intValue();
    return get(pn - pnm1 * (1 + (mN & 1)), mN - 2);
  }
}
#!queue	A060016	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a060;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;

/**
 * A060016 Triangle T(n,k) = number of partitions of n into k distinct parts, 1 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A060016 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m) {
    if (m < 0 || m > n) {
      return Z.ZERO;
    }
    return m == 0 ? (n == 0 ? Z.ONE : Z.ZERO) : get(n - m, m).add(get(n - m, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A095133	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a095;

import java.util.ArrayList;
import java.util.List;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000055;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A095133 Triangle of numbers of forests on n nodes containing k trees.
 * @author Sean A. Irvine
 */
public class A095133 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final Sequence mA55 = new A000055();
  private final List<Z> mT = new ArrayList<>();

  private Z getT(final int i) {
    while (i >= mT.size()) {
      mT.add(mA55.next());
    }
    return mT.get(i);
  }

  // g function
  @Override
  protected Z compute(final int n, final int i, final int p) {
    if (p > n) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    if (Math.min(i, p) < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = 0; j <= Math.min(n / i, p); ++j) {
      sum = sum.add(get(n - i * j, i - 1, p - j).multiply(Binomial.binomial(getT(i).add(j - 1), Z.valueOf(j))));
    }
    return sum;
  }

  private int mN = 0;
  private int mK = 0;

  @Override
  public Z next() {
    if (++mK > mN) {
      ++mN;
      mK = 1;
    }
    return get(mN, mN, mK);
  }
}
#!queue	A111999	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a111;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A111999 T(n, k) = [x^k] (-1)^n*Sum_{k=0..n} E2(n, n-k)*(1+x)^(n-k) where E2(n, k) are the second-order Eulerian numbers. Triangle read by rows, T(n, k) for n &gt;= 1 and 0 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A111999 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n < k + 1) {
      return Z.ZERO;
    }
    if (n == 1 && k == 0) {
      return Z.NEG_ONE;
    }
    if (k == -1) {
      return Z.ZERO;
    }
    return get(n - 1, k).add(get(n - 1, k - 1)).multiply(k + 1 - 2 * n);
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A133709	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a133;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Stirling;
import irvine.math.z.Z;

/**
 * A133709 Triangle read by rows: T(m,l) = number of labeled covers of size l of a finite set of m unlabeled elements (m &gt;= 1, 1 &lt;= l &lt;= 2^m - 1).
 * @author Sean A. Irvine
 */
public class A133709 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mL = 0;

  @Override
  protected Z compute(final Integer m, final Integer l) {
    if (l == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int i = 0; i < l; ++i) {
      sum = sum.signedAdd((i & 1) == 0, Binomial.binomial(l, i).multiply(Binomial.binomial((1L << (l - i)) + m - 2, m)));
    }
    for (int i = 1; i < l; ++i) {
      sum = sum.subtract(Stirling.secondKind(l, i).multiply(get(m, i)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mL >= 1 << mN) {
      ++mN;
      mL = 1;
    }
    return get(mN, mL);
  }
}
#!queue	A137251	0	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a137;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A137251 Triangle T(n,k) read by rows: number of k X k triangular matrices with nonnegative integer entries and without zero rows or columns such that sum of all entries is equal to n, n&gt;=1, 1&lt;=k&lt;=n.
 * @author Sean A. Irvine
 */
public class A137251 extends MemoryFunctionInt3Sequence<Z[]> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z[] compute(final int n, final int i, final int t) {
    if (n < 1) {
      final Z[] res = new Z[t + 1];
      Arrays.fill(res, Z.ZERO);
      res[t] = Z.ONE;
      return res;
    }
    List<Z> res = Collections.emptyList();
    for (int j = 0; j <= t + 1; ++j) {
      final Z[] row = get(n - 1, j, t + (j > i ? 1 : 0));
      final int lim = Math.max(res.size(), row.length);
      final List<Z> r = new ArrayList<>(lim);
      for (int k = 0; k < lim; ++k) {
        final Z x = k < res.size() ? res.get(k) : Z.ZERO;
        final Z y = k < row.length ? row[k] : Z.ZERO;
        r.add(x.add(y));
      }
      res = r;
    }
    return res.toArray(new Z[0]);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, 0, 0)[mM];
  }
}
#!queue	A198300	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a198;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A198300 Square array M(k,g), read by antidiagonals, of the Moore lower bound on the order of a (k,g)-cage.
 * @author Sean A. Irvine
 */
public class A198300 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  protected int mN = 0;
  protected int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 3) {
      return Z.valueOf(n + 1);
    }
    return get(n, m - 1).add(Z.valueOf(n - 1).pow((m - 1) / 2));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN + 1 - mM, mM + 3);
  }
}
#!queue	A212801	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a212;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.cc.CC;
import irvine.math.cc.ComputableComplexField;
import irvine.math.cr.CR;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A212801 Square array read by antidiagonals: T(m,n) = number of Eulerian circuits in the Cartesian product of two directed cycles of lengths m and n.
 * @author Sean A. Irvine
 */
public class A212801 extends MemoryFunction2Sequence<Long, CC> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private static final ComputableComplexField CCF = ComputableComplexField.SINGLETON;
  private static final CC TAU_I = CCF.multiply(CC.I, CR.TAU);
  private static final CC EXP_TAU_I = CCF.exp(TAU_I);

  private long mN = 0;
  private long mM = 0;

  // Root of unity
  @Override
  protected CC compute(final Long h, final Long m) {
    return h.equals(m) ? EXP_TAU_I : CCF.exp(CCF.multiply(TAU_I, CR.valueOf(new Q(h, m))));
  }

  protected Z t(final long m, final long n) {
    if (m > n) {
      return t(n, m); // exploit symmetry
    }
    CC prod = CC.ONE;
    for (long k = 1; k < n; ++k) {
      final CC a = CCF.subtract(CC.TWO, get(k, n));
      for (long h = 1; h < m; ++h) {
        prod = CCF.multiply(prod, CCF.subtract(a, get(h, m)));
      }
    }
    return prod.re().toZ();
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN - mM + 1, mM);
  }

}
#!queue	A227061	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a227;

import irvine.math.IntegerUtils;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A227061 T(n,k) = Number of (n+k-1) X (n+k-1) binary arrays with k 1s in every row and column with rows and columns in lexicographically nondecreasing order.
 * @author Sean A. Irvine
 */
public class A227061 extends MemoryFunction2Sequence<Integer, Long> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  private long mCount = 0;
  private int mMaxSum = 0;
  private int mLimit;

  private boolean isColSafe(final int[] colSums, final int element) {
    for (int k = 0, j = 1; k < colSums.length; ++k, j <<= 1) {
      if ((element & j) != 0 && colSums[k] >= mMaxSum) {
        return false;
      }
    }
    return true;
  }

  private static void incColSums(final int[] colSums, final int element) {
    for (int k = 0, j = 1; k < colSums.length; ++k, j <<= 1) {
      if ((element & j) != 0) {
        ++colSums[k];
      }
    }
  }

  private static void decColSum(final int[] colSums, final int element) {
    for (int k = 0, j = 1; k < colSums.length; ++k, j <<= 1) {
      if ((element & j) != 0) {
        --colSums[k];
      }
    }
  }

  private static int[] transpose(final int[] m) {
    final int[] r = new int[m.length];
    for (int v : m) {
      for (int j = m.length - 1; j >= 0; --j) {
        r[j] <<= 1;
        r[j] += v & 1;
        v >>= 1;
      }
    }
    return r;
  }

  private static boolean isSorted(final int[] m) {
    for (int k = 1; k < m.length; ++k) {
      if (m[k] < m[k - 1]) {
        return false;
      }
    }
    return true;
  }

  // Construct in a way that maintains both the matrix and transpose in lexicographic sorted order
  private void search(final int[] matrix, final int[] transpose, final int[] colSums, final int row, final int element) {
    if (row == matrix.length) {
      assert isSorted(matrix);
      assert isSorted(transpose);
      if (accept(matrix, transpose)) {
        ++mCount;
      }
      return;
    }
    if (element >= mLimit) {
      return;
    }
    final int bit = 1 << (matrix.length - row - 1);
    for (int e = element; e < mLimit; e = IntegerUtils.swizzle(e)) {
      // Place element in matrix[row] and move to next row
      if (isColSafe(colSums, e)) {
        incColSums(colSums, e);
        matrix[row] = e;
        for (int k = transpose.length - 1, j = e; k >= 0; --k, j >>>= 1) {
          transpose[k] |= bit * (j & 1);
        }
        if (isSorted(transpose)) {
          search(matrix, transpose, colSums, row + 1, e);
        }
        for (int k = 0; k < transpose.length; ++k) {
          transpose[k] &= ~bit;
        }
        //matrix[row] = 0;
        decColSum(colSums, e);
      }
    }
  }

  protected boolean accept(final int[] matrix, final int[] transpose) {
    return true;
  }

  @Override
  protected Long compute(final Integer n, final Integer m) {
    if (m > n) {
      return 0L;
    }
    if (m < 1) {
      return 1L;
    }
    mCount = 0;
    mMaxSum = m;
    mLimit = 1 << n;
    search(new int[n], new int[n], new int[n], 0, (1 << m) - 1);
    return mCount;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return Z.valueOf(get(mN, mN - mM));
  }
}
#!queue	A236542	0	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a236;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a007.A007821;
import irvine.oeis.a008.A008578;

/**
 * A236542 Array T(n,k) read along descending antidiagonals: row n contains the primes with n steps in the prime index chain.
 * @author Sean A. Irvine
 */
public class A236542 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private final MemorySequence mA = MemorySequence.cachedSequence(new A007821());
  private final MemorySequence mPrimes = MemorySequence.cachedSequence(new A008578());
  private int mN = 1;
  private int mM = 0;


  @Override
  protected Z compute(final int n, final int k) {
    if (n == 1) {
      return mA.a(k - 1);
    }
    return mPrimes.a(get(n - 1, k).intValueExact());
  }

  @Override
  public Z next() {
    if (--mM < 1) {
      mM = mN;
      ++mN;
    }
    return get(mN - mM, mM);
  }
}
#!queue	A244925	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a244;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A244925 Number T(n,k) of n-node unlabeled rooted trees with every leaf at height k; triangle T(n,k), n&gt;=1, 0&lt;=k&lt;=n-1, read by rows.
 * @author Sean A. Irvine
 */
public class A244925 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  // After Alois P. Heinz

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 1) {
      return Z.ONE;
    }
    if (m == 0) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long j = 1; j < n; ++j) {
      Z s = Z.ZERO;
      for (final Z dd : Jaguar.factor(j).divisors()) {
        final long d = dd.longValue();
        if (d >= m) {
          s = s.add(get(d, m - 1).multiply(d));
        }
      }
      sum = sum.add(s.multiply(get(n - j, m)));
    }
    return sum.divide(n - 1);
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A262554	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a262;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A262554 Triangle read by rows: coefficients in Bell's formula for number of ways of making change when coins have denominations which are powers of 2.
 * @author Sean A. Irvine
 */
public class A262554 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private Z a(final int i, final int j) {
    return Binomial.binomial(i, j - i).shiftLeft(2 * i - j).add(Binomial.binomial(i - 1, j - i + 1).shiftLeft(2 * i - j - 2));
  }

  @Override
  protected Z compute(final Integer m, final Integer i) {
    if (i >= m) {
      return Z.ZERO;
    }
    if (i == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    for (int j = i - 1; j <= 2 * i; ++j) {
      s = s.add(a(i, j).multiply(get(m - 1, j)));
    }
    return s;
  }

  private int mN = 0;
  private int mI = 0;

  @Override
  public Z next() {
    if (++mI >= mN) {
      ++mN;
      mI = 0;
    }
    return get(mN, mI);
  }

}

#!queue	A304972	0	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a304;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A304972 Triangle read by rows of achiral color patterns (set partitions) for a row or loop of length n. T(n,k) is the number using exactly k colors (sets).
 * @author Sean A. Irvine
 */
public class A304972 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    Z res = n < 2 && n >= 0 && n.equals(k) ? Z.ONE : Z.ZERO;
    if (n > 1) {
      res = res.add(get(n - 2, k).multiply(k).add(get(n - 2, k - 1).add(get(n - 2, k - 2))));
    }
    return res;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A999999	0	0	0	0
