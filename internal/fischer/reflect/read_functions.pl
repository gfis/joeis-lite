#!perl

# Read joeis/src/irvine/math/function/Functions.java and extract the corresponding A-numbers
# @(#) $Id$
# 2024-05-17, Georg Fischer: copied from packex.pl
#
#:# Usage:
#:#   perl read_functions.pl [-d debug] infile.java > outfile.gen
#:#

#--------------------------------------------------------
use strict;
use integer;
use warnings;
my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
my $timestamp = sprintf ("%04d-%02d-%02d %02d:%02d", $year + 1900, $mon + 1, $mday, $hour, $min);
if (0 && scalar(@ARGV) == 0) {
    print `grep -E "^#:#" $0 | cut -b3-`;
    exit;
}
my $pwd = `pwd`;
$pwd =~ m{(\/joeis\-lite\/internal\/fischer\S*)};
print "# Generated by ..$1/$0 at $timestamp\n";
my $mode = "u";
my $debug = 0;
my $callcode = "functions";
my $offset = 0;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug     = shift(@ARGV);
    } elsif ($opt  =~ m{m}) {
        $mode      = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

my $aseqno;
my $parm;
my ($varph1, $varph2) = ("_V1", "_V2"); # 1st and 2nd placeholder for parameters
while (<>) { # read inputfile
    s{\s+\Z}{}; # chompr
    my $line = $_;
    if ($line =~ m{\/\/ *\= *(A\d+.*)}) {
        my $list = $1; # rest behind "// = "
        $list =~ s{ |\;.*}{}g; # remove all whitespace and comments
        if ($line =~ m{Function(\d?\w?) +([A-Z0-9_]+)}) {
            my ($ifunc, $funame) = ($1, $2);
            foreach my $seq (split(/\, *\= */, $list)) {
                #           1    12    2
                $seq =~ m{\A(A\d+)(\(.*)?};
                ($aseqno, my $parm) = ($1, $2 || "(");
                if ($parm =~ m{\d\Z}) {
                   $parm .= ",";
                }
                print join("\t", $aseqno, "Funct$ifunc", "Functions.$funame.z$parm") . "\n";
            } # foreach seq
        } else {
            print "2: $line\n" if $debug >= 1;
        }
    } else {
        print "1: $line\n" if $debug >= 1;
    }
} # while <>

# append some additional ones
while(<DATA>) {
    if (m{^A\d+}) {
        print;
    }
} # while DATA
#   public static final Function2D DIGIT_SUM =  new DigitSum(); // =A001370(10, = A000120(2, -> A007953(10,
__DATA__
# A000720	Funct1	Functions.PRIME_PI.z(
# A001157	Funct2	Functions.SIGMA.z(2,
# A001158	Funct2	Functions.SIGMA.z(3,
A002024	Funct1	Functions.TRINV.z(	??? also A123578
# A002326	Funct2	Functions.ORDER.z(Z.TWO,
# A003132	Funct2D	Functions.DIGIT_SUM_SQUARES.z(10,
# A004185	Funct2D	Functions.DIGIT_SORT_ASCENDING.z(10,
# A004186	Funct2D	Functions.DIGIT_SORT_DESCENDING.z(10,
# A007917	Funct1	Functions.PREV_PRIME.z(
# A007918	Funct1	Functions.NEXT_PRIME.z(
# A007953	Funct2D	Functions.DIGIT_SUM.z(10,
# A007954	Funct2D	Functions.DIGIT_PRODUCT.z(10,
# A007955	Funct1	Functions.POD.z(
# A053735	Funct2D	Functions.DIGIT_SUM.z(3,
# A055012	Funct2D	Functions.DIGIT_SUM_CUBES.z(10,
# A151799	Funct1	Functions.PREV_PRIME.z(
# A151800	Funct1	Functions.NEXT_PRIME.z(
              
A007318	Funct2	BI(
# A008275	Funct2	S1(
# A008277	Funct2	S2(
# A008306	Funct2	Functions.ASSOCIATED_STIRLING1.z(
# A008297	Funct2	Functions.LAH.z(