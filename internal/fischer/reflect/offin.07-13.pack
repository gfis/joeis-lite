#!queue	A000094	0	->	1	A000041	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000094 Number of trees of diameter 4.
 * @author Sean A. Irvine
 */
public class A000094 extends A000041 {

  @Override
  public Z next() {
    final Z z = super.next().add(-mN);
    return mN == 0 ? Z.ZERO : z;
  }
}

#!queue	A000181	3	->	4	A000159	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000181 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A000181 extends A000159 {

  private int mA181 = 3;

  @Override
  public Z next() {
    return menageHitPolynomial(++mA181).coeff(4);
  }
}
#!queue	A000184	0	->	2	A029887	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a029.A029887;

/**
 * A000184 Number of genus 0 rooted maps with 3 faces with n vertices.
 * @author Sean A. Irvine
 */
public class A000184 extends A029887 {

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}

#!queue	A000185	3	->	5	A000159	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000185 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A000185 extends A000159 {

  private int mA185 = 4;

  @Override
  public Z next() {
    return menageHitPolynomial(++mA185).coeff(5);
  }
}
#!queue	A000187	1	->	0	A000233	--------------------------------
package irvine.oeis.a000;

/**
 * A000187 Generalized Euler numbers, c(5,n).
 * @author Sean A. Irvine
 */
public class A000187 extends A000233 {

  @Override
  protected int getA() {
    return 5;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A000191	1	->	0	A000061	--------------------------------
package irvine.oeis.a000;

/**
 * A000191 Generalized tangent numbers d(3, n).
 * @author Sean A. Irvine
 */
public class A000191 extends A000061 {

  @Override
  protected int getA() {
    return 3;
  }

  @Override
  protected int getN() {
    return ++mT;
  }
}
#!queue	A000192	1	->	0	A000233	--------------------------------
package irvine.oeis.a000;

/**
 * A000192 Generalized Euler numbers c(6,n).
 * @author Sean A. Irvine
 */
public class A000192 extends A000233 {

  @Override
  protected int getA() {
    return 6;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A000199	0	->	1	A000025	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000199 Coefficient of q^(2n-1) in the series expansion of Ramanujan's mock theta function f(q).
 * @author Sean A. Irvine
 */
public class A000199 extends A000025 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A000239	0	->	1	A000130	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000239 One-half of number of permutations of [n] with exactly one run of adjacent symbols differing by 1.
 * @author Sean A. Irvine
 */
public class A000239 extends A000130 {

  /** Construct the sequence. */
  public A000239() {
    super.next();
  }

  private Z mS = Z.ZERO;

  @Override
  public Z next() {
    mS = mS.add(super.next());
    return mS.max(Z.ONE);
  }
}
#!queue	A000250	0	->	1	A000666	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000250 Number of symmetric reflexive relations on n nodes: (1/2)*A000666.
 * @author Sean A. Irvine
 */
public class A000250 extends A000666 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A000281	1	->	0	A000233	--------------------------------
package irvine.oeis.a000;

/**
 * A000281 Expansion of cos(x)/cos(2x).
 * @author Sean A. Irvine
 */
public class A000281 extends A000233 {

  @Override
  protected int getA() {
    return 2;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A000363	0	->	4	A008971	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a008.A008971;

/**
 * A000363 Number of permutations of [n] with exactly 2 increasing runs of length at least 2.
 * @author Sean A. Irvine
 */
public class A000363 extends A008971 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}

#!queue	A000370	1	->	0	A000610	--------------------------------
package irvine.oeis.a000;

import irvine.math.polynomial.CycleIndex;
import irvine.math.z.Z;

/**
 * A000370 Number of NPN-equivalence classes of Boolean functions of n or fewer variables.
 * @author Sean A. Irvine
 */
public class A000370 extends A000610 {

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final CycleIndex ans = f(mN);
    return ans.apply(1).add(ans.apply(0, 1)).toZ().divide2();
  }
}
#!queue	A000373	0	->	1	A000275	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A000373 Conjectured dimension of a module associated with the free commutative Moufang loop with n generators.
 * @author Sean A. Irvine
 */
public class A000373 extends A000275 {

  {
    super.next();
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  private Z a(final int n) {
    return n == 1 ? Z.ZERO : mA.get(n);
  }

  @Override
  public Z next() {
    super.next();
    Z sum = Z.ZERO;
    final Z nf = mF.factorial(mN);
    for (int k = 1; k <= (mN - 1) / 2; ++k) {
      final Z f2k = mF.factorial(2 * k + 1);
      for (int p = 0; p <= mN - 2 * k - 1; ++p) {
        sum = sum.add(a(k).add(Binomial.binomial(p + k - 1, k - 1))
                      .multiply(nf)
                      .divide(mF.factorial(p))
                      .divide(f2k)
                      .divide(mF.factorial(mN - p - 2 * k - 1)));
      }
    }
    return sum;
  }
}
#!queue	A000401	0	->	1	A000394	--------------------------------
package irvine.oeis.a000;

/**
 * A000401 Numbers of form x^2 + y^2 + 2z^2.
 * @author Sean A. Irvine
 */
public class A000401 extends A000394 {

  @Override
  protected int multiplier() {
    return 2;
  }
}

#!queue	A000425	3	->	1	A000159	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000425 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A000425 extends A000159 {

  private int mA425 = 0;

  @Override
  public Z next() {
    return menageHitPolynomial(++mA425).coeff(1);
  }
}
#!queue	A000436	1	->	0	A000233	--------------------------------
package irvine.oeis.a000;

/**
 * A000436 Generalized Euler numbers c(3,n).
 * @author Sean A. Irvine
 */
public class A000436 extends A000233 {

  @Override
  protected int getA() {
    return 3;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A000440	3	->	4	A000380	--------------------------------
package irvine.oeis.a000;

/**
 * A000440 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-4 places.
 * @author Sean A. Irvine
 */
public class A000440 extends A000380 {

  @Override
  protected int coeff() {
    return 4;
  }
}
#!queue	A000449	0	->	3	A000166	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000449 Rencontres numbers: number of permutations of [n] with exactly 3 fixed points.
 * @author Sean A. Irvine
 */
public class A000449 extends AbstractSequence {

  protected int mFixP;
  private final A000166 mSeq = new A000166();

  /** Construct the sequence. */
  public A000449() {
    this(3);
  }

  /**
   * Generic constructor with parameter.
   * @param fixP number of fixed points
   */
  public A000449(final int fixP) {
    super(fixP);
    mFixP = fixP;
  }

  @Override
  public Z next() {
    return mSeq.next().multiply(Binomial.binomial(mSeq.mN + mFixP, mFixP));
  }

}
#!queue	A000464	1	->	0	A000061	--------------------------------
package irvine.oeis.a000;

/**
 * A000464 Expansion of sin x /cos 2x.
 * @author Sean A. Irvine
 */
public class A000464 extends A000061 {

  @Override
  protected int getA() {
    return 2;
  }

  @Override
  protected int getN() {
    return ++mT;
  }
}
#!queue	A000470	3	->	5	A000380	--------------------------------
package irvine.oeis.a000;

/**
 * A000470 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-5 places.
 * @author Sean A. Irvine
 */
public class A000470 extends A000380 {

  @Override
  protected int coeff() {
    return 5;
  }
}
#!queue	A000475	0	->	4	A000449	--------------------------------
package irvine.oeis.a000;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

/**
 * A000475 Rencontres numbers: number of permutations of [n] with exactly 4 fixed points.
 * @author Georg Fischer
 */
public class A000475 extends A000449 {

  /** Construct the sequence. */
  public A000475() {
    super(4);
  }
}
#!queue	A000479	1	->	0	A000315	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000479 Number of 1-factorizations of K_{n,n}.
 * @author Sean A. Irvine
 */
public class A000479 extends A000315 {

  private int mN = -1;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    if (mN > 2) {
      mF = mF.multiply(mN - 1);
    }
    return super.next().multiply(mF);
  }
}
#!queue	A000486	0	->	5	A060158	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a060.A060158;

/**
 * A000486 One half of the number of permutations of [n] such that the differences have 4 runs with the same signs.
 * @author Sean A. Irvine
 */
public class A000486 extends A060158 {

  {
    super.next();
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A000492	3	->	6	A000380	--------------------------------
package irvine.oeis.a000;

/**
 * A000492 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-6 places.
 * @author Sean A. Irvine
 */
public class A000492 extends A000380 {

  @Override
  protected int coeff() {
    return 6;
  }
}
#!queue	A000500	3	->	7	A000380	--------------------------------
package irvine.oeis.a000;

/**
 * A000500 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-7 places.
 * @author Sean A. Irvine
 */
public class A000500 extends A000380 {

  @Override
  protected int coeff() {
    return 7;
  }
}
#!queue	A000506	2	->	6	A008970	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a008.A008970;

/**
 * A000506 One half of the number of permutations of [n] such that the differences have 5 runs with the same signs.
 * @author Sean A. Irvine
 */
public class A000506 extends A008970 {

  private int mN = 4;

  @Override
  public Z next() {
    return get(++mN, 5).divide2();
  }
}
#!queue	A000551	1	->	3	A074728	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a074.A074728;

/**
 * A000551 Number of labeled rooted trees of height 2 with n nodes.
 * @author Sean A. Irvine
 */
public class A000551 extends A074728 {

  protected int mN = 2;

  @Override
  public Z next() {
    return super.next().multiply(mN).multiply(++mN);
  }
}
#!queue	A000555	1	->	5	A000551	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000555 Number of labeled trees of diameter 4 with n nodes.
 * @author Sean A. Irvine
 */
public class A000555 extends A000551 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(Z.ONE.shiftLeft(mN - 2)
                                 .subtract(1)
                                 .multiply(mN)
                                 .multiply(mN - 1));
  }
}
#!queue	A000560	0	->	2	A000682	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000560 Number of ways of folding a strip of n labeled stamps.
 * @author Sean A. Irvine
 */
public class A000560 extends A000682 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A000599	0	->	1	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A000599 Number of secondary alcohols (alkanols or alkyl alcohols C_n H_{2n+1} OH) with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000599 extends A000598 {

  @Override
  public Z next() {
    super.next();
    final Polynomial<Q> f = RING.subtract(mG, RING.one());
    return RING.add(RING.pow(f, 2, mN), f.substitutePower(2, mN)).coeff(mN).toZ().divide2();
  }
}

#!queue	A000618	-1	->	0	A000616	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000618 Number of nondegenerate Boolean functions of n variables: For n &gt; 0, a(n) = A000616(n) - A000616(n-1).
 * @author Sean A. Irvine
 */
public class A000618 extends A000616 {

  private Z mPrev = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    final Z r = t.subtract(mPrev);
    mPrev = t;
    return r;
  }
}
#!queue	A000625	1	->	0	A000620	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000625 Number of n-node steric rooted ternary trees; number of n carbon alkyl radicals C(n)H(2n+1) taking stereoisomers into account.
 * @author Sean A. Irvine
 */
public class A000625 extends A000620 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    super.next();
    return mT.get(mN);
  }
}
#!queue	A000628	1	->	0	A000625	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.ConvolutionSequence;

/**
 * A000628 Number of n-node unrooted steric quartic trees; number of n-carbon alkanes C(n)H(2n+2) taking stereoisomers into account.
 * @author Sean A. Irvine
 */
public class A000628 extends A000625 {

  private final ConvolutionSequence mCQ = new ConvolutionSequence(new A000625());
  private final ArrayList<Z> mQ = new ArrayList<>();
  private final ArrayList<Z> mA625 = new ArrayList<>();

  @Override
  public Z next() {
    mA625.add(super.next());
    mQ.add(mCQ.next());
    Z r = Z.ZERO;
    for (int j = 0; j < (mN + 2) / 3; ++j) {
      r = r.add(mA625.get(j).multiply(mA625.get(mN - 3 * j - 1)));
    }
    r = r.multiply2().add(mA625.get(mN).multiply(3).subtract(mQ.get(mN)));
    if ((mN & 1) == 0) {
      r = r.add(mA625.get(mN / 2).multiply2());
    } else {
      r = r.add(mQ.get(mN / 2));
    }
    return r.divide(4);
  }
}
#!queue	A000631	0	->	2	A000642	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Z;

/**
 * A000631 Number of ethylene derivatives with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000631 extends A000642 {

  private final ArrayList<Z> mA642 = new ArrayList<>();

  @Override
  public Z next() {
    do {
      mA642.add(super.next());
    } while (mN < 2);
    Z s = Z.ZERO;
    if ((mN & 1) == 0) {
      for (int k = 1; k < mN / 2; ++k) {
        s = s.add(mA642.get(k).multiply(mA642.get(mN - k)));
      }
      final Z f = mA642.get(mN / 2);
      s = s.add(f.multiply(f.add(1)).divide2());
    } else {
      for (int k = 1; k <= mN / 2; ++k) {
        s = s.add(mA642.get(k).multiply(mA642.get(mN - k)));
      }
    }
    return s;
  }
}

#!queue	A000632	0	->	2	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000632 Number of esters with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000632 extends A000598 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return RING.multiply(mG, RING.subtract(mG, RING.one()), mN).coeff(mN).toZ();
  }
}

#!queue	A000633	0	->	4	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.PolynomialRingField;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A000633 Number of acyclic quaternary ammonium ions with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000633 extends A000598 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final CycleIndex S4 = SymmetricGroup.create(4).cycleIndex();
  private final Polynomial<Q> mG = RING.empty();
  private int mN = -1;
  {
    super.next();
  }

  @Override
  public Z next() {
    mG.add(new Q(super.next()));
    return S4.apply(mG, ++mN).coeff(mN).toZ();
  }
}
#!queue	A000634	0	->	2	A000636	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000634 Number of glycols with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000634 extends A000636 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(g().coeff(mN - 1).toZ());
  }
}

#!queue	A000636	0	->	1	A000642	--------------------------------
package irvine.oeis.a000;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A000636 Number of paraffins C_n H_{2n} X_2 with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A000636 extends A000642 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    final Polynomial<Q> bigR = g();
    final Q a = RING.coeff(RING.one(), RING.subtract(RING.one(), bigR.shift(1)), mN);
    final Q b = RING.coeff(RING.add(RING.one(), bigR.shift(1)), RING.subtract(RING.one(), bigR.substitutePower(2).shift(2)), mN);
    return a.add(b).toZ().divide2();
  }
}

#!queue	A000639	0	->	1	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A000639 Number of alkyl benzenes with n carbon atoms: C(n)H(2n-6).
 * @author Sean A. Irvine
 */
public class A000639 extends A000598 {

  private static final Q FOUR = Q.FOUR;
  private int mL = 0;


  @Override
  public Z next() {
    if (mL < 5) {
      ++mL;
      return Z.ZERO;
    }
    super.next();
    final Polynomial<Q> g2 = mG.substitutePower(2, mN);
    return RING.add(RING.add(RING.add(RING.add(RING.pow(mG, 6, mN),
      RING.multiply(RING.pow(g2, 3, mN), FOUR)),
      RING.multiply(RING.pow(mG.substitutePower(3, mN), 2, mN), Q.TWO)),
      RING.multiply(RING.multiply(RING.pow(mG, 2, mN), RING.pow(g2, 2, mN), mN), Q.THREE)),
      RING.multiply(mG.substitutePower(6, mN), Q.TWO))
      .coeff(mN).divide(12).toZ();
  }
}

#!queue	A000642	0	->	1	A000598	--------------------------------
package irvine.oeis.a000;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A000642 a(1)=0; for n&gt;1, a(n) = number of isomeric hydrocarbons of the acetylene series with carbon content n.
 * @author Sean A. Irvine
 */
public class A000642 extends A000598 {

  @Override
  public Polynomial<Q> g() {
    return RING.multiply(RING.add(mG.substitutePower(2, mN), RING.pow(mG, 2, mN)), Q.HALF);
  }

  @Override
  public Z next() {
    super.next();
    if (mN == 0) {
      return Z.ZERO;
    }
    return g().coeff(mN - 1).toZ();
  }
}

#!queue	A000662	0	->	1	A000595	--------------------------------
package irvine.oeis.a000;

import irvine.math.IntegerUtils;

/**
 * A000662 Number of relations with 3 arguments on n nodes.
 * @author Sean A. Irvine
 */
public class A000662 extends A000595 {

  {
    super.next();
  }

  @Override
  protected int t(final int[] s) {
    int sum = 0;
    for (int i = 1; i < s.length; ++i) {
      for (int j = 1; j < s.length; ++j) {
        final int ij = i * j;
        final int lij = IntegerUtils.lcm(i, j);
        for (int k = 1; k < s.length; ++k) {
          final int lcm = IntegerUtils.lcm(lij, k);
          sum += (ij * k / lcm) * s[i] * s[j] * s[k];
        }
      }
    }
    return sum;
  }
}
#!queue	A000682	0	->	1	A005316	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a005.A005316;

/**
 * A000682 Semi-meanders: number of ways a semi-infinite directed curve can cross a straight line n times.
 * @author Sean A. Irvine
 */
public class A000682 extends A005316 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final SimpleProcessor<Z> processor = new SimpleProcessor<>();
    processor.setCreateStateMachine(BasicMeanderProblem::new);
    return processor.process(mN, new BasicMeanderProblem(mN).semiMeanderInitialStates());
  }
}

#!queue	A000683	0	->	1	A047863	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.a047.A047863;

/**
 * A000683 Number of colorings of labeled graphs on n nodes using exactly 2 colors, divided by 4.
 * @author Sean A. Irvine
 */
public class A000683 extends A047863 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(2).shiftRight(2);
  }
}
#!queue	A000684	0	->	1	A000683	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000684 Number of colored labeled n-node graphs with 2 interchangeable colors.
 * @author Sean A. Irvine
 */
public class A000684 extends A000683 {

  @Override
  public Z next() {
    return super.next().multiply2().add(1);
  }
}
#!queue	A000685	0	->	1	A047863	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a047.A047863;

/**
 * A000685 Number of 3-colored labeled graphs on n nodes, divided by 3.
 * @author Sean A. Irvine
 */
public class A000685 extends A047863 {

  private final ArrayList<Z> mC = new ArrayList<>();

  {
    mC.add(super.next());
  }

  @Override
  public Z next() {
    mC.add(super.next());
    Z s = Z.ZERO;
    for (int j = 0; j <= mN; ++j) {
      s = s.add(Binomial.binomial(mN, j).shiftLeft(j * (mN - j)).multiply(mC.get(j)));
    }
    return s.divide(3);
  }
}
#!queue	A000686	0	->	1	A000685	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A000686 Number of 4-colored labeled graphs on n nodes, divided by 4.
 * @author Sean A. Irvine
 */
public class A000686 extends A000685 {

  private final ArrayList<Z> mC = new ArrayList<>();
  {
    mC.add(Z.ONE);
  }

  @Override
  public Z next() {
    mC.add(super.next().multiply(3));
    Z s = Z.ZERO;
    for (int j = 0; j <= mN; ++j) {
      s = s.add(Binomial.binomial(mN, j).shiftLeft(j * (mN - j)).multiply(mC.get(j)));
    }
    return s.shiftRight(2);
  }
}
#!queue	A000702	0	->	1	A000700	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000702 a(n) is the number of conjugacy classes in the alternating group A_n.
 * @author Sean A. Irvine
 */
public class A000702 extends A000700 {

  private final A000041 mA41 = new A000041();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      super.next();
      mA41.next();
      super.next();
      mA41.next();
      return Z.ONE;
    }
    return mA41.next().add(super.next().multiply(3)).divide2();
  }
}

#!queue	A000742	1	->	4	A000741	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000742 Number of compositions of n into 4 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A000742 extends A000741 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  protected Z p(final Z n) {
    final Z nm = n.subtract(1);
    final Z ns = nm.square();
    return ns.multiply(nm).subtract(ns.multiply(3)).add(n.multiply2()).divide(6);
  }
}
#!queue	A000743	1	->	5	A000741	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A000743 Number of compositions of n into 5 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A000743 extends A000741 {

  {
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 4);
  }
}
#!queue	A000760	0	->	1	A000759	--------------------------------
package irvine.oeis.a000;

/**
 * A000760 Number of n-step self-avoiding walks on cubic lattice ending at point with x=1.
 * @author Sean A. Irvine
 */
public class A000760 extends A000759 {

  {
    super.next();
  }

  @Override
  protected long targetX() {
    return 1;
  }
}
#!queue	A000761	0	->	2	A000759	--------------------------------
package irvine.oeis.a000;

/**
 * A000761 Number of n-step self-avoiding walks on cubic lattice ending at point with x=2.
 * @author Sean A. Irvine
 */
public class A000761 extends A000759 {

  {
    super.next();
    super.next();
  }

  @Override
  protected long targetX() {
    return 2;
  }
}
#!queue	A000762	0	->	3	A000759	--------------------------------
package irvine.oeis.a000;

/**
 * A000762 Number of n-step self-avoiding walks on cubic lattice ending at point with x=3.
 * @author Sean A. Irvine
 */
public class A000762 extends A000759 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  protected long targetX() {
    return 3;
  }
}
#!queue	A000766	0	->	1	A000765	--------------------------------
package irvine.oeis.a000;

/**
 * A000766 Number of n-step self-avoiding walks on f.c.c. lattice ending at point with x = 1.
 * @author Sean A. Irvine
 */
public class A000766 extends A000765 {

  {
    super.next();
  }

  @Override
  protected long targetX() {
    return 1;
  }
}
#!queue	A000767	0	->	2	A000765	--------------------------------
package irvine.oeis.a000;

/**
 * A000767 Number of n-step self-avoiding walks on f.c.c. lattice ending at point with x = 2.
 * @author Sean A. Irvine
 */
public class A000767 extends A000765 {

  {
    super.next();
    super.next();
  }

  @Override
  protected long targetX() {
    return 2;
  }
}
#!queue	A000768	0	->	3	A000765	--------------------------------
package irvine.oeis.a000;

/**
 * A000768 Number of n-step self-avoiding walks on f.c.c. lattice ending at point with x = 3.
 * @author Sean A. Irvine
 */
public class A000768 extends A000765 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  protected long targetX() {
    return 3;
  }
}
#!queue	A000810	1	->	0	A000436	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A000810 Expansion of e.g.f. (sin x + cos x)/cos 3x.
 * @author Sean A. Irvine
 */
public class A000810 extends A000436 {

  private final ArrayList<Z> mOdd = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    if ((++mN & 1) == 0) {
      return super.next();
    }
    Z s = Z.ONE;
    final int n = mN / 2;
    for (int k = 0; k < n; ++k) {
      final Z t = Binomial.binomial(mN, 2 * k + 1).multiply(Z.THREE.pow(mN - 1 - 2 * k)).multiply(mOdd.get(k));
      s = s.signedAdd((k & 1) == 1, t);
    }
    mOdd.add((n & 1) == 0 ? s : s.negate());
    return mOdd.get(n);
  }
}

#!queue	A000901	0	->	1	A037223	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a037.A037223;
import irvine.oeis.a122.A122670;

/**
 * A000901 Number of solutions to the rook problem on a 2n X 2n board having a certain symmetry group (see Robinson for details).
 * @author Sean A. Irvine
 */
public class A000901 extends A037223 {

  private final Sequence mA898 = new A000898();
  private final Sequence mA122670 = new A122670();

  {
    mA898.next();
    mA122670.next();
    mA122670.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    mA122670.next();
    return super.next().subtract(mA898.next()).subtract(mA122670.next()).divide(4);
  }
}

#!queue	A000903	0	->	1	A037223	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a037.A037223;
import irvine.oeis.a122.A122670;

/**
 * A000903 Number of inequivalent ways of placing n nonattacking rooks on n X n board up to rotations and reflections of the board.
 * @author Sean A. Irvine
 */
public class A000903 extends A037223 {

  private final Sequence mA85 = new A000085();
  private final Sequence mA122670 = new A122670();
  private final Sequence mA142 = new A000142();

  {
    mA85.next();
    mA142.next();
    mA122670.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.ONE.max(super.next()
                     .add(mA142.next())
                     .add(mA122670.next().multiply2())
                     .add(mA85.next().multiply2())
                     .divide(8));
  }
}

#!queue	A000919	4	->	1	A000453	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000919 a(n) = 4^n - C(4,3)*3^n + C(4,2)*2^n - C(4,1).
 * @author Sean A. Irvine
 */
public class A000919 extends A000453 {

  private int mN = 3;

  @Override
  public Z next() {
    if (mN > 0) {
      --mN;
      return Z.ZERO;
    }
    return super.next().multiply(24);
  }
}
#!queue	A000928	0	->	1	A000367	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;

/**
 * A000928 Irregular primes: primes p such that at least one of the numerators of the Bernoulli numbers B_2, B_4, ..., B_{p-3} (A000367) is divisible by p.
 * @author Sean A. Irvine
 */
public class A000928 extends A000367 {

  private final ArrayList<Z> mB = new ArrayList<>();
  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      final long q = mP / 2;
      while (mB.size() < q) {
        mB.add(super.next());
      }
      for (int k = 1; k <= (mP - 3) / 2; ++k) {
        if (mB.get(k).mod(mP) == 0) {
          return Z.valueOf(mP);
        }
      }
    }
  }
}
#!queue	A000947	5	->	7	A000063	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000947 Number of free nonplanar polyenoids with n nodes and symmetry point group C_{2v}.
 * @author Sean A. Irvine
 */
public class A000947 extends A000063 {

  private final A000936 mPlanar = new A000936();

  {
    for (int k = 1; k < 7; ++k) {
      mPlanar.next();
    }
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mPlanar.next());
  }
}

#!queue	A000950	0	->	1	A000949	--------------------------------
package irvine.oeis.a000;

import java.util.Arrays;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A000950 Number of forests with n nodes and height at most 3.
 * @author Sean A. Irvine
 */
public class A000950 extends A000949 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private Polynomial<Q> mS = RING.create(Arrays.asList(Q.ZERO, new Q(super.next())));
  protected Z mF = Z.ONE;

  protected Q nextEgf() {
    final Z t = super.next();
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    mS = RING.add(mS, RING.monomial(new Q(t, mF), mN + 1));
    return RING.exp(mS, mN).coeff(mN);
  }

  @Override
  public Z next() {
    return nextEgf().multiply(mF).toZ();
  }
}
#!queue	A000951	0	->	1	A000950	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A000951 Number of forests with n nodes and height at most 4.
 * @author Sean A. Irvine
 */
public class A000951 extends A000950 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private Polynomial<Q> mS = RING.x();

  @Override
  public Z next() {
    mS = RING.add(mS, RING.monomial(super.nextEgf(), mN + 1));
    return RING.exp(mS, mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A000953	1	->	7	A000207	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;

/**
 * A000953 Number of free nonplanar polyenoids with n nodes.
 * @author Sean A. Irvine
 */
public class A000953 extends A000207 {

  private final A000942 mPlanar = new A000942();

  {
    for (int k = 1; k < 7; ++k) {
      super.next();
      mPlanar.next();
    }
  }

  @Override
  public Z next() {
    return super.next().subtract(mPlanar.next());
  }
}

#!queue	A001036	0	->	1	A001037	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001036 Partial sums of A001037, omitting A001037(1).
 * @author Sean A. Irvine
 */
public class A001036 extends A001037 {

  private Z mSum = null;

  @Override
  public Z next() {
    if (mSum == null) {
      super.next();
      super.next();
      mSum = Z.ONE;
    } else {
      mSum = mSum.add(super.next());
    }
    return mSum;
  }
}
#!queue	A001173	0	->	1	A000595	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000595;

/**
 * A001173 Half the number of binary relations on n unlabeled points.
 * @author Sean A. Irvine
 */
public class A001173 extends A000595 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}

#!queue	A001225	0	->	2	A003141	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a003.A003141;

/**
 * A001225 Number of consistent arcs in a tournament with n nodes.
 * @author Sean A. Irvine
 */
public class A001225 extends A003141 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return Binomial.binomial(mN, 2).subtract(t);
  }

}

#!queue	A001266	0	->	2	A002464	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a002.A002464;

/**
 * A001266 One-half the number of permutations of length n without rising or falling successions.
 * @author Sean A. Irvine
 */
public class A001266 extends A002464 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A001270	0	->	1	A001265	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001270 Table of prime factors of 10^n - 1 (with multiplicity).
 * @author Sean A. Irvine
 */
public class A001270 extends A001265 {

  {
    super.next();
  }

  @Override
  protected Z base() {
    return Z.TEN;
  }
}
#!queue	A001279	4	->	6	A001278	--------------------------------
package irvine.oeis.a001;

/**
 * A001279 Number of permutations of length n by rises.
 * @author Sean A. Irvine
 */
public class A001279 extends A001278 {

  @Override
  protected int order() {
    return 3;
  }
}
#!queue	A001280	4	->	8	A001278	--------------------------------
package irvine.oeis.a001;

/**
 * A001280 Number of permutations of length n by rises.
 * @author Sean A. Irvine
 */
public class A001280 extends A001278 {

  @Override
  protected int order() {
    return 4;
  }
}
#!queue	A001331	0	->	1	A001329	--------------------------------
package irvine.oeis.a001;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;

/**
 * A001331 Number of n-element algebras with 1 ternary operation.
 * @author Sean A. Irvine
 */
public class A001331 extends A001329 {

  @Override
  protected int start() {
    return 0;
  }

  @Override
  protected Z fix(final int[] j) {
    Z prod = Z.ONE;
    for (int r = 1; r < j.length; ++r) {
      for (int s = 1; s < j.length; ++s) {
        final int g = IntegerUtils.gcd(r, s);
        final int l = IntegerUtils.lcm(r, s);
        for (int t = 1; t < j.length; ++t) {
          prod = prod.multiply(innerSum(j, IntegerUtils.lcm(l, t)).pow(scale() * j[r] * j[s] * j[t] * IntegerUtils.gcd(g, t)));
        }
      }
    }
    return prod;
  }
}
#!queue	A001374	0	->	1	A004105	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a004.A004105;

/**
 * A001374 Number of relational systems on n nodes. Also number of directed 3-multigraphs with loops on n nodes.
 * @author Sean A. Irvine
 */
public class A001374 extends A004105 {

  {
    super.next();
  }

  @Override
  protected Z base() {
    return Z.FOUR;
  }
}

#!queue	A001375	0	->	1	A004105	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a004.A004105;

/**
 * A001375 Relational systems on n nodes.
 * @author Sean A. Irvine
 */
public class A001375 extends A004105 {

  {
    super.next();
  }

  @Override
  protected Z base() {
    return Z.EIGHT;
  }
}

#!queue	A001376	0	->	1	A000662	--------------------------------
package irvine.oeis.a001;

import irvine.oeis.a000.A000662;

/**
 * A001376 Relational systems on n nodes.
 * @author Sean A. Irvine
 */
public class A001376 extends A000662 {

  @Override
  protected int t(final int[] s) {
    return super.t(s) * 2;
  }
}
#!queue	A001377	0	->	1	A000595	--------------------------------
package irvine.oeis.a001;

import irvine.math.IntegerUtils;
import irvine.oeis.a000.A000595;

/**
 * A001377 Number of relations with 4 arguments on n nodes.
 * @author Sean A. Irvine
 */
public class A001377 extends A000595 {

  {
    super.next();
  }

  @Override
  protected int t(final int[] s) {
    int sum = 0;
    for (int i = 1; i < s.length; ++i) {
      for (int j = 1; j < s.length; ++j) {
        final int ij = i * j;
        final int lij = IntegerUtils.lcm(i, j);
        for (int k = 1; k < s.length; ++k) {
          final int ijk = ij * k;
          final int lijk = IntegerUtils.lcm(lij, k);
          for (int l = 1; l < s.length; ++l) {
            final int lcm = IntegerUtils.lcm(lijk, l);
            sum += (ijk * l / lcm) * s[i] * s[j] * s[k] * s[l];
          }
        }
      }
    }
    return sum;
  }
}
#!queue	A001395	1	->	0	A007180	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a007.A007180;

/**
 * A001395 Number of (2n+1)-step self-avoiding walks on diamond lattice ending at point with x = 1.
 * @author Sean A. Irvine
 */
public class A001395 extends A007180 {

  private boolean mFirst = true;

  @Override
  protected boolean check(final long point, final int n) {
    return !contains(point, n);
  }

  @Override
  protected long count(final long point) {
    final long t = x(point) + y(point) - z(point) - t(point);
    return Math.abs(t) == 1 ? 1 : 0;
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      ++mN;
      return Z.TWO;
    }
    mN += 2;
    setPathLength(mN);
    setPathElement(0, ORIGIN);
    return Z.valueOf(count(ORIGIN + 1, -1, 1)).multiply2();
  }
}
#!queue	A001396	1	->	0	A007180	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a007.A007180;

/**
 * A001396 Number of 2n-step self-avoiding walks on diamond lattice ending at point with x = 0.
 * @author Sean A. Irvine
 */
public class A001396 extends A007180 {
  private boolean mFirst = true;

  @Override
  protected boolean check(final long point, final int n) {
    return !contains(point, n);
  }

  @Override
  protected long count(final long point) {
    final long t = x(point) + y(point) - z(point) - t(point);
    return t == 0 ? 1 : 0;
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    mN += 2;
    setPathLength(mN);
    setPathElement(0, ORIGIN);
    return Z.valueOf(count(ORIGIN + 1, -1, 1)).shiftLeft(2);
  }
}
#!queue	A001437	1	->	2	A001435	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001437 Number of connected graphs with n nodes and ceiling(n(n-1)/4) edges.
 * @author Sean A. Irvine
 */
public class A001437 extends A001435 {

  {
    next();
  }

  @Override
  public final Z next() {
    return numberConnectedGraphs(++mN, (mN * (mN - 1) + 3) / 4);
  }
}
#!queue	A001454	1	->	3	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001454 Number of permutations of length n with longest increasing subsequence of length 3.
 * @author Sean A. Irvine
 */
public class A001454 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(3);
    return g(mN, Math.min(mN, 3), l);
  }
}
#!queue	A001455	1	->	4	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001455 Number of permutations of length n with longest increasing subsequence of length 4.
 * @author Sean A. Irvine
 */
public class A001455 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(4);
    return g(mN, Math.min(mN, 4), l);
  }
}
#!queue	A001456	1	->	5	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001456 Number of permutations of length n with longest increasing subsequence of length 5.
 * @author Sean A. Irvine
 */
public class A001456 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(5);
    return g(mN, Math.min(mN, 5), l);
  }
}
#!queue	A001457	1	->	6	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001457 Number of permutations of length n with longest increasing subsequence of length 6.
 * @author Sean A. Irvine
 */
public class A001457 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(6);
    return g(mN, Math.min(mN, 6), l);
  }
}
#!queue	A001458	1	->	7	A047874	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a047.A047874;

/**
 * A001458 Number of permutations of length n with longest increasing subsequence of length 7.
 * @author Sean A. Irvine
 */
public class A001458 extends A047874 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(7);
    return g(mN, Math.min(mN, 7), l);
  }
}
#!queue	A001511	0	->	1	A000120	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000120;

/**
 * A001511 The ruler function: 2^a(n) divides 2n. Or, a(n) = 2-adic valuation of 2n.
 * @author Sean A. Irvine
 */
public class A001511 extends A000120 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return Z.TWO.add(t).subtract(mA);
  }
}
#!queue	A001560	0	->	1	A000041	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A001560 Numbers with an even number of partitions.
 * @author Sean A. Irvine
 */
public class A001560 extends A000041 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isEven()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A001572	1	->	0	A000084	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.a000.A000084;

/**
 * A001572 Related to series-parallel networks.
 * @author Sean A. Irvine
 */
public class A001572 extends A000084 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final ArrayList<Z> mA84 = new ArrayList<>();
  {
    mA84.add(Z.ONE);
  }
  private int mN = -1;

  @Override
  public Z next() {
    // INVERTi transform of A000084
    mA84.add(super.next());
    return RING.coeff(RING.one(), RING.create(mA84), ++mN).abs();
  }
}
#!queue	A001626	0	->	1	A000186	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000186;

/**
 * A001626 Number of 3-line Latin rectangles.
 * @author Sean A. Irvine
 */
public class A001626 extends A000186 {

  {
    super.next();
  }

  private int mN = -1;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    mA = mA.multiply(++mN).multiply2().add(super.next());
    return mA;
  }
}

#!queue	A001627	0	->	1	A000186	--------------------------------
package irvine.oeis.a001;

import java.io.Serializable;

import irvine.math.z.Z;
import irvine.oeis.a000.A000186;

/**
 * A001627 Related to Latin rectangles.
 * @author Sean A. Irvine
 */
public class A001627 extends A000186 implements Serializable {

  private int mN = -1;
  private Z mMu1 = super.next();
  private final A001626 mDeltaSeq = new A001626();

  @Override
  public Z next() {
    final Z mu0 = mMu1;
    mMu1 = super.next();
    if (++mN == 0) {
      return Z.ONE;
    }
    return mu0.add(mMu1).add(mDeltaSeq.next().multiply(mN).multiply(3));
  }
}

#!queue	A001632	0	->	1	A000230	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A001632 Smallest prime p such that there is a gap of 2n between p and previous prime.
 * @author Sean A. Irvine
 */
public class A001632 extends A000230 {

  private long mN = 0;

  {
    super.next();
  }

  @Override
  public Z next() {
    mN += 2;
    return super.next().add(mN);
  }
}
#!queue	A001677	1	->	2	A000084	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a000.A000084;

/**
 * A001677 Number of series-parallel networks with n edges.
 * @author Sean A. Irvine
 */
public class A001677 extends A000084 {

  private final ArrayList<Z> mA84 = new ArrayList<>();
  {
    mA84.add(super.next());
  }

  private int mN = 0;

  @Override
  public Z next() {
    final Z t = super.next();
    mA84.add(t);
    ++mN;
    Z s = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      s = s.add(mA84.get(k).multiply(mA84.get(mN - 1 - k)));
    }
    if ((mN & 1) != 0) {
      s = s.add(mA84.get(mN / 2));
    }
    return t.subtract(s.divide2());
  }
}
#!queue	A001758	0	->	2	A001250	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001758 Number of quasi-alternating permutations of length n.
 * @author Sean A. Irvine
 */
public class A001758 extends A001250 {

  {
    super.next();
    super.next();
  }

  protected Z mT = super.next();
  protected Z mA1758;

  @Override
  public Z next() {
    final Z t = super.next();
    final Z r = t.subtract(mT.multiply2());
    mT = t;
    mA1758 = r;
    return r;
  }
}
#!queue	A001759	0	->	4	A001758	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001759 Number of permutations of [n] with n-3 sequences.
 * @author Sean A. Irvine
 */
public class A001759 extends A001758 {

  private Z mR;

  {
    super.next();
    super.next();
    mR = mT;
  }

  private int mN = 3;
  private Z mB = super.next();

  @Override
  public Z next() {
    ++mN;
    final Z q = mT;
    final Z t = super.next();
    final Z r = t.divide2().subtract(mB).subtract(mR.multiply(mN - 1).divide2());
    mR = q;
    mB = t;
    return r;
  }
}
#!queue	A001760	0	->	1	A001759	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001760 Number of permutations of [n] with n-4 sequences.
 * @author Sean A. Irvine
 */
public class A001760 extends A001759 {

  {
    super.next();
  }

  private int mN = 2;
  private Z mW = mA1758;
  private Z mC = super.next();

  @Override
  public Z next() {
    final Z w = mA1758;
    final Z t = super.next();
    final Z r = t.subtract(mW.multiply(++mN)).subtract(mC.multiply2()).divide(3);
    mC = t;
    mW = w;
    return r;
  }
}
#!queue	A001766	2	->	1	A000114	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a000.A000114;

/**
 * A001766 Index of (the image of) the modular group Gamma(n) in PSL_2(Z).
 * @author Sean A. Irvine
 */
public class A001766 extends A000114 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    } else {
      return super.next().multiply(mN);
    }
  }
}
#!queue	A001852	2	->	1	A034854	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a034.A034854;

/**
 * A001852 Total diameter of labeled trees with n nodes.
 * @author Sean A. Irvine
 */
public class A001852 extends A034854 {

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 2) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    for (int k = 2; k < mN; ++k) {
      s = s.add(t(k, mN).multiply(k));
    }
    return s;
  }
}
#!queue	A001853	2	->	1	A034781	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a034.A034781;

/**
 * A001853 Total height of trees with n nodes.
 * @author Sean A. Irvine
 */
public class A001853 extends A034781 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k < mN; ++k) {
      s = s.add(t(mN, k).multiply(k));
    }
    return s;
  }
}
#!queue	A001854	2	->	1	A034855	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.a034.A034855;

/**
 * A001854 Total height of all rooted trees on n labeled nodes.
 * @author Sean A. Irvine
 */
public class A001854 extends A034855 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k < mN; ++k) {
      s = s.add(r(mN, k).multiply(k));
    }
    return s;
  }
}
#!queue	A001880	0	->	4	A001497	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001880 Coefficients of Bessel polynomials y_n (x).
 * @author Sean A. Irvine
 */
public class A001880 extends A001497 {

  private int mN = 3;

  @Override
  public Z next() {
    return t(++mN, 4);
  }
}
#!queue	A001881	0	->	5	A001497	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;

/**
 * A001881 Coefficients of Bessel polynomials y_n (x).
 * @author Sean A. Irvine
 */
public class A001881 extends A001497 {

  private int mN = 4;

  @Override
  public Z next() {
    return t(++mN, 5);
  }
}
#!queue	A001885	1	->	2	A001884	--------------------------------
package irvine.oeis.a001;

/**
 * A001885 Hit polynomials.
 * @author Sean A. Irvine
 */
public class A001885 extends A001884 {

  @Override
  protected int coeff() {
    return 2;
  }
}
#!queue	A001886	1	->	3	A001884	--------------------------------
package irvine.oeis.a001;

/**
 * A001886 Hit polynomials.
 * @author Sean A. Irvine
 */
public class A001886 extends A001884 {

  @Override
  protected int coeff() {
    return 3;
  }
}
#!queue	A001889	1	->	2	A001888	--------------------------------
package irvine.oeis.a001;

/**
 * A001889 Hit polynomials.
 * @author Sean A. Irvine
 */
public class A001889 extends A001888 {

  @Override
  protected int coeff() {
    return 2;
  }
}
#!queue	A001890	1	->	3	A001888	--------------------------------
package irvine.oeis.a001;

/**
 * A001890 Hit polynomials.
 * @author Sean A. Irvine
 */
public class A001890 extends A001888 {

  @Override
  protected int coeff() {
    return 3;
  }
}
#!queue	A001893	2	->	3	A001892	--------------------------------
package irvine.oeis.a001;

/**
 * A001893 Number of permutations of (1,...,n) having n-3 inversions (n&gt;=3).
 * @author Sean A. Irvine
 */
public class A001893 extends A001892 {

  @Override
  protected int delta() {
    return 2;
  }
}
#!queue	A001894	2	->	4	A001892	--------------------------------
package irvine.oeis.a001;

/**
 * A001894 Number of permutations of {1,...,n} having n-4 inversions (n&gt;=4).
 * @author Sean A. Irvine
 */
public class A001894 extends A001892 {

  @Override
  protected int delta() {
    return 3;
  }
}
#!queue	A001985	1	->	3	A002223	--------------------------------
package irvine.oeis.a001;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.a002.A002223;

/**
 * A001985 Class numbers of quadratic fields.
 * @author Sean A. Irvine
 */
public class A001985 extends A002223 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z np = super.next();
    return Z.valueOf(LongUtils.hurwitzClassNumber(-np.longValueExact()));
  }
}
#!queue	A002051	0	->	1	A000670	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000670;

/**
 * A002051 Steffensen's bracket function [n,2].
 * @author Sean A. Irvine
 */
public class A002051 extends A000670 {

  private Z mT = Z.ONE;

  @Override
  public Z next() {
    final Z t = super.next();
    if (!Z.ONE.equals(t)) {
      mT = mT.multiply2();
    }
    return t.subtract(mT);
  }
}
#!queue	A002076	1	->	0	A002075	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A002076 Number of equivalence classes of base-3 necklaces of length n, where necklaces are considered equivalent under both rotations and permutations of the symbols.
 * @author Sean A. Irvine
 */
public class A002076 extends A002075 {

  private final ArrayList<Z> mA = new ArrayList<>();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    mA.add(super.next());
    Z s = Z.ZERO;
    for (final Z dd : Jaguar.factor(mA.size()).divisors()) {
      final int d = dd.intValue();
      s = s.add(mA.get(d - 1));
    }
    return s;
  }
}
#!queue	A002094	0	->	1	A000642	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.DihedralGroup;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a000.A000642;

/**
 * A002094 Number of unlabeled connected loop-less graphs on n nodes containing exactly one cycle (of length at least 2) and with all nodes of degree &lt;= 4.
 * @author Sean A. Irvine
 */
public class A002094 extends A000642 {

  // After R. J. Mathar

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    final Polynomial<Q> g = g().truncate(mN - 1).shift(1);
    final ArrayList<Polynomial<Q>> lst = new ArrayList<>();
    for (int k = 1; k <= mN; ++k) {
      lst.add(g.substitutePower(k, mN));
    }
    Polynomial<Q> gf = RING.zero();
    for (int k = 2; k <= mN; ++k) {
      gf = RING.add(gf, DihedralGroup.cycleIndex(k).apply(lst, Z.valueOf(mN)));
    }
    return gf.coeff(mN).toZ();
  }
}
#!queue	A002136	0	->	3	A002135	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002136 Matrices with 2 rows.
 * @author Sean A. Irvine
 */
public class A002136 extends A002135 {

  private Z mPP = Z.ZERO;
  private Z mP = Z.ZERO;

  @Override
  public Z next() {
    super.next();
    final Z t = mB.multiply(mN).add(mC).add(mPP.multiply(mN).multiply(mN - 1));
    mPP = mP;
    mP = t;
    return mP;
  }
}
#!queue	A002139	0	->	1	A002326	--------------------------------
package irvine.oeis.a002;

import irvine.factor.prime.Fast;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A002139 Shuffling 2n cards.
 * @author Sean A. Irvine
 */
public class A002139 extends A002326 {

  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    final Z f = super.next();
    if (!mN.equals(Z.ONE) && ZUtils.isPrimitiveRoot(Z.TWO, mN)) {
      if (mPrime.isPrime(mN)) {
        return f.add(1);
      }
      // 2n-1 must have the form q^k, k>1
      final Z q = mN.isPower();
      return f.add(1).multiply(Euler.phi(mN.divide(q)));
    } else {
      return f.lcm(f.add(1));
    }
  }
}
#!queue	A002179	1	->	2	A002176	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a100.A100640;

/**
 * A002179 Numerators of Cotesian numbers (not in lowest terms): A002176*C(n,2).
 * @author Sean A. Irvine
 */
public class A002179 extends A002176 {

  @Override
  public Z next() {
    final Z t = super.next();
    return A100640.cotesian(mN, 2).multiply(t).toZ();
  }
}
#!queue	A002180	1	->	2	A002202	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002180 Values taken by the half-totient function phi(m)/2.
 * @author Sean A. Irvine
 */
public class A002180 extends A002202 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A002216	1	->	0	A002215	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A002216 Harary-Read numbers: restricted hexagonal polyominoes (cata-polyhexes) with n cells.
 * @author Sean A. Irvine
 */
public class A002216 extends A002215 {

  private final Sequence mA002214 = new A002214();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().add(mA002214.next()).divide2();
  }
}
#!queue	A002303	3	->	4	A002302	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002303 Generalized tangent numbers.
 * @author Sean A. Irvine
 */
public class A002303 extends A002302 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    return get(mN + 6, mN);
  }
}
#!queue	A002311	0	->	1	A000292	--------------------------------
package irvine.oeis.a002;

import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.a000.A000292;

/**
 * A002311 n-th tetrahedral number is the sum of 2 tetrahedral numbers.
 * @author Sean A. Irvine
 */
public class A002311 extends A000292 {

  private long mN = 0;
  private final HashSet<Z> mSum = new HashSet<>();

  {
    super.next(); // skip leading 0
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z n = super.next();
      final A000292 tetra = new A000292();
      tetra.next(); // skip leading 0
      while (true) {
        final Z q = tetra.next();
        mSum.add(n.add(q));
        if (q.equals(n)) {
          break;
        }
      }
      if (mSum.contains(n)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A002318	0	->	1	A001934	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a001.A001934;

/**
 * A002318 Expansion of (1/theta_4(q)^2 -1)/4 in powers of q.
 * @author Sean A. Irvine
 */
public class A002318 extends A001934 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(4);
  }
}
#!queue	A002367	1	->	2	A007645	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a007.A007645;

/**
 * A002367 Let p = A007645(n) be the n-th generalized cuban prime and write p^2 =  x^2 + 3*y^2 with y &gt; 0; a(n) = x.
 * @author Sean A. Irvine
 */
public class A002367 extends A007645 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z p2 = super.next().square();
    Z y = Z.ZERO;
    while (true) {
      y = y.add(1);
      final Z x2 = p2.subtract(y.square().multiply(3));
      final Z[] x = x2.sqrtAndRemainder();
      if (x[1].isZero()) {
        return x[0];
      }
    }
  }
}
#!queue	A002368	1	->	2	A007645	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a007.A007645;

/**
 * A002368 Let p = A007645(n) be the n-th generalized cuban prime and write p^2 =  x^2 + 3*y^2 with y&gt;0; a(n) = y.
 * @author Sean A. Irvine
 */
public class A002368 extends A007645 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z p2 = super.next().square();
    Z y = Z.ZERO;
    while (true) {
      y = y.add(1);
      final Z x2 = p2.subtract(y.square().multiply(3));
      final Z[] x = x2.sqrtAndRemainder();
      if (x[1].isZero()) {
        return y;
      }
    }
  }
}
#!queue	A002399	0	->	1	A002398	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002399 Coefficients for step-by-step integration.
 * @author Sean A. Irvine
 */
public class A002399 extends A002398 {

  private int mN = 0;

  @Override
  public Z next() {
    return delta(1, ++mN).abs();
  }
}
#!queue	A002400	0	->	2	A002398	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002400 Coefficients for step-by-step integration.
 * @author Sean A. Irvine
 */
public class A002400 extends A002398 {

  private int mN = 1;

  @Override
  public Z next() {
    return delta(2, ++mN).abs();
  }
}
#!queue	A002402	0	->	1	A002398	--------------------------------
package irvine.oeis.a002;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A002402 Coefficients for step-by-step integration.
 * @author Sean A. Irvine
 */
public class A002402 extends A002398 {

  private int mN = 0;

  Z alefStar(final int n) {
    Polynomial<Z> a = RING.one();
    for (int i = 0; i < n; ++i) {
      a = RING.multiply(a, Polynomial.create(i, 1));
    }
    Z x = Z.ZERO;
    for (int d = 0; d <= a.degree(); ++d) {
      final Z b = a.coeff(d);
      if (!Z.ZERO.equals(b)) {
        x = x.signedAdd((d & 1) == 0, b.multiply(l(n).divide(d + 1)));
      }
    }
    return x;
  }

  Z deltaStar(final int p, final int j) {
    Z sum = Z.ZERO;
    for (int k = p; k <= j; ++k) {
      sum = sum.add(gamma(p, k).multiply(bigA(k, j)).multiply(alefStar(k)));
    }
    return sum;
  }

  @Override
  public Z next() {
    return deltaStar(1, ++mN);
  }
}

#!queue	A002403	0	->	2	A002402	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002403 Coefficients for step-by-step integration.
 * @author Sean A. Irvine
 */
public class A002403 extends A002402 {

  private int mN = 1;

  @Override
  public Z next() {
    return deltaStar(2, ++mN).abs();
  }
}
#!queue	A002425	0	->	1	A001511	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.BernoulliSequence;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a001.A001511;

/**
 * A002425 Denominator of Pi^(2n)/(Gamma(2n)*(1-2^(-2n))*zeta(2n)).
 * @author Sean A. Irvine
 */
public class A002425 extends A001511 {

  private final BernoulliSequence mB = new BernoulliSequence(1);
  private int mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    ++mN;
    mB.nextQ(); // skip odd terms
    final Q b = mB.nextQ();
    mA = mA.multiply(4);
    return b.multiply(Z.ONE.subtract(mA)).divide(mN).multiply(Z.ONE.shiftLeft(super.next().longValueExact())).toZ().abs();
  }
}
#!queue	A002438	0	->	1	A000364	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A002438 Multiples of Euler numbers.
 * @author Sean A. Irvine
 */
public class A002438 extends A000364 {

  private Z mMul = null;

  @Override
  public Z next() {
    mMul = mMul == null ? Z.ONE : mMul.multiply(9);
    return super.next().multiply(mMul.add(1)).divide2();
  }
}
#!queue	A002461	0	->	2	A002596	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002461 Coefficients of Legendre polynomials.
 * @author Sean A. Irvine
 */
public class A002461 extends A002596 {

  private int mN = 1;

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    if (++mN == 2) {
      return Z.ONE;
    } else {
      return super.next().abs().multiply(mN);
    }
  }
}
#!queue	A002468	0	->	1	A002469	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a001.A001563;

/**
 * A002468 The game of Mousetrap with n cards: the number of permutations of n cards having at least one hit after 2.
 * @author Sean A. Irvine
 */
public class A002468 extends A002469 {

  private final A001563 mA1563 = new A001563();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return mA1563.next().subtract(super.next());
  }

}
#!queue	A002469	0	->	2	A000166	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000166;

/**
 * A002469 The game of Mousetrap with n cards: the number of permutations of n cards in which 2 is the only hit.
 * @author Sean A. Irvine
 */
public class A002469 extends A000166 {

  private long mN = -3;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    final Z t = mA;
    mA = super.next();
    return Z.ZERO.max(t.multiply(mN).add(mA.multiply(mN + 1)));
  }

}
#!queue	A002500	1	->	0	A002499	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002500 Number of self-converse relations on n points.
 * @author Sean A. Irvine
 */
public class A002500 extends A002499 {

  private boolean mFirst = true;
  
  private int sum3(final int[] j) {
    int s = 0;
    for (final int q : j) {
      s += q;
    }
    return s;
  }

  @Override
  protected int epsilon(final int p, final int[] j) {
    return super.epsilon(p, j) + sum3(j);
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next();
  }
}
#!queue	A002539	1	->	0	A002538	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002539 Eulerian numbers of the second kind: &lt;&lt;n+3, n&gt;&gt;.
 * @author Sean A. Irvine
 */
public class A002539 extends A002538 {

  private Z mA = Z.ZERO;
  private long mN = 0;

  @Override
  public Z next() {
    mA = super.next().multiply(++mN).add(mA.multiply(mN + 4));
    return mA;
  }
}
#!queue	A002546	3	->	1	A002545	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002546 Denominator of Sum_{i+j+k=n; i,j,k &gt; 0} 1/(i*j*k).
 * @author Sean A. Irvine
 */
public class A002546 extends A002545 {

  @Override
  public Z next() {
    return step().den();
  }
}
#!queue	A002548	1	->	2	A002547	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002548 Denominators of coefficients for numerical differentiation.
 * @author Sean A. Irvine
 */
public class A002548 extends A002547 {

  @Override
  public Z next() {
    return step().den();
  }
}
#!queue	A002554	0	->	1	A001824	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a001.A001824;

/**
 * A002554 Numerators of coefficients for numerical differentiation.
 * @author Sean A. Irvine
 */
public class A002554 extends A001824 {

  private Z mF = Z.ONE;
  private long mN = 0;

  protected Q step() {
    if (++mN > 1) {
      mF = mF.multiply(2 * mN).multiply(2 * mN - 1).shiftLeft(2).negate();
    }
    return new Q(super.next(), mF);
  }

  @Override
  public Z next() {
    return step().num();
  }
}
#!queue	A002555	0	->	1	A002554	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002555 Denominators of coefficients for numerical differentiation.
 * @author Sean A. Irvine
 */
public class A002555 extends A002554 {

  @Override
  public Z next() {
    return step().den().abs();
  }
}
#!queue	A002562	0	->	1	A000170	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000170;

/**
 * A002562 Number of ways of placing n nonattacking queens on n X n board (symmetric solutions count only once).
 * @author Sean A. Irvine
 */
public class A002562 extends A000170 {

  {
    next();
  }

  private int[] rotate90(final int[] q) {
    final int n = q.length;
    final int[] r = new int[n];
    for (int x = 0; x < n; ++x) {
      r[q[x]] = n - x - 1;
    }
    return r;
  }

  private int[] reflect(final int[] q) {
    final int n = q.length;
    final int[] r = new int[n];
    for (int x = 0; x < n; ++x) {
      r[x] = n - q[x] - 1;
    }
    return r;
  }

  private boolean checkFlip(final int[] q) {
    final int n = q.length;
    for (int x = 0; x < n; ++x) {
      final int y = q[x];
      final int otherY = n - y - 1;
      if (y < otherY) {
        return false;
      } else if (y > otherY) {
        return true;
      }
    }
    return false; // symmetric
  }

  private boolean lt(final int[] a, final int[] b) {
    for (int x = 0; x < a.length; ++x) {
      if (a[x] < b[x]) {
        return true;
      } else if (a[x] > b[x]) {
        return false;
      }
    }
    return false;
  }

  @Override
  protected Z count(final int[] q) {
    if (checkFlip(q)) {
      return Z.ZERO;
    }
    // All these explicit rotations are probably slow.  But doing these
    // checks was error prone when I first tried to implement it that
    // way.
    final int[] q1 = rotate90(q);
    if (lt(q1, q) || lt(reflect(q1), q)) {
      return Z.ZERO;
    }
    final int[] q2 = rotate90(q1);
    if (lt(q2, q) || lt(reflect(q2), q)) {
      return Z.ZERO;
    }
    final int[] q3 = rotate90(q2);
    if (lt(q3, q) || lt(reflect(q3), q)) {
      return Z.ZERO;
    }
    return Z.ONE;
  }
}
#!queue	A002575	0	->	2	A125790	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.Conjectural;
import irvine.oeis.a125.A125790;

/**
 * A002575 Coefficients of Bell's formula for making change.
 * @author Sean A. Irvine
 */
public class A002575 extends A125790 implements Conjectural {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, 2L);
  }
}
#!queue	A002576	1	->	3	A262554	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a262.A262554;

/**
 * A002576 Coefficients of Bell's formula for making change.
 * @author Sean A. Irvine
 */
public class A002576 extends A262554 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}

#!queue	A002597	1	->	0	A002599	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;


/**
 * A002597 Number of partitions into one kind of 1's, two kinds of 2's, and three kinds of 3's.
 * @author Sean A. Irvine
 */
public class A002597 extends A002599 {

  private boolean mFirst = true;

  @Override
  protected int limit() {
    return 3;
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next();
  }
}
#!queue	A002615	0	->	1	A002288	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A002615 Glaisher's function T_1(n).
 * @author Sean A. Irvine
 */
public class A002615 extends A002288 {

  {
    super.next(); // skip 0th
  }

  private final Sequence mA = new A002614();

  @Override
  public Z next() {
    return super.next().multiply(19).subtract(mA.next());
  }
}
#!queue	A002616	1	->	3	A002322	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002616 Reduced totient function (divided by 2).
 * @author Sean A. Irvine
 */
public class A002616 extends A002322 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A002634	1	->	3	A000183	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000183;

/**
 * A002634 From discordant permutations.
 * @author Sean A. Irvine
 */
public class A002634 extends A000183 {

  private Z mB1 = null;
  private Z mB2 = null;

  private long mAdd = -4;
  private Z mA = null;
  private Z mB = null;
  private Z mC = null;
  private Z mD = null;

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z b0 = mB1;
    mB1 = mB2;
    mB2 = super.next();
    mAdd = -mAdd;
    final Z t;
    if (mA == null) {
      if (mD == null) {
        t = Z.valueOf(-2);
      } else if (mC == null) {
        t = Z.THREE;
      } else if (mB == null) {
        t = Z.ZERO;
      } else {
        t = Z.valueOf(25);
      }
    } else {
      t = mB2.subtract(mB1.multiply2()).add(b0).add(mD.multiply2()).add(mC.multiply2()).subtract(mB.multiply2()).add(mA).add(mAdd);
    }
    mA = mB;
    mB = mC;
    mC = mD;
    mD = t;
    return mD;
  }
}
#!queue	A002638	0	->	1	A000568	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000568;

/**
 * A002638 a(n) = (number of nonisomorphic nontransitive prime tournaments on n nodes) - Moebius(n).
 * @author Sean A. Irvine
 */
public class A002638 extends A000568 {

  private final ArrayList<Z> mA = new ArrayList<>();
  private final ArrayList<Z> mB = new ArrayList<>();
  {
    mA.add(super.next());
    mB.add(null);
  }
  private int mN = 0;

  @Override
  public Z next() {
    mA.add(super.next());
    if (++mN == 1) {
      mB.add(Z.NEG_ONE);
    } else {
      Z s = mA.get(mN);
      for (final Z dd : Jaguar.factor(mN).divisors()) {
        final int d = dd.intValueExact();
        if (d != 1 && d != mN) {
          s = s.subtract(mA.get(mN / d).multiply(mB.get(d)));
        }
      }
      mB.add(s);
    }
    return mB.get(mB.size() - 1);
  }
}
#!queue	A002669	0	->	1	A265607	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a265.A265607;

/**
 * A002669 Numerator of constant term in polynomial arising from numerical integration formula.
 * @author Sean A. Irvine
 */
public class A002669 extends A265607 {

  private int mN = 0;
  private Z mF = Z.ONE;

  {
    super.next();
  }

  protected Z select(final Q n) {
    return n.num();
  }

  @Override
  public Z next() {
    ++mN;
    mF = mF.multiply(mN).multiply(mN);
    Z sum = Z.ZERO;
    Z v = Z.ONE;
    for (int j = 0; j <= mN; ++j) {
      sum = sum.add(super.next().multiply(v));
      v = v.multiply(-mN);
    }
    return select(new Q(sum, mF));
  }
}
#!queue	A002670	0	->	1	A002669	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A002670 Denominator of constant term in polynomial arising from numerical integration formula.
 * @author Sean A. Irvine
 */
public class A002670 extends A002669 {

  @Override
  protected Z select(final Q n) {
    return n.den();
  }
}
#!queue	A002675	1	->	2	A002672	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002675 Numerators of coefficients for central differences M_{4}^(2*n).
 * @author Sean A. Irvine
 */
public class A002675 extends A002672 {

  private int mN = 2;

  @Override
  public Z next() {
    mN += 2;
    return bigM(4, mN).num();
  }
}
#!queue	A002676	1	->	2	A002672	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002676 Denominators of coefficients for central differences M_{4}^(2*n).
 * @author Sean A. Irvine
 */
public class A002676 extends A002672 {

  private int mN = 2;

  @Override
  public Z next() {
    mN += 2;
    return bigM(4, mN).den();
  }
}
#!queue	A002701	0	->	2	A002455	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A002701 Coefficients for numerical differentiation.
 * @author Sean A. Irvine
 */
public class A002701 extends A002455 {

  private int mN = -1;
  private Z mDen = Z.SIX;

  {
    super.next();
  }

  protected Q computeNext() {
    if (++mN > 0) {
      mDen = mDen.multiply(2 * mN + 3).multiply(2 * mN + 2).shiftLeft(2);
    }
    return new Q(super.next().multiply(6), mDen);
  }

  @Override
  public Z next() {
    return computeNext().num();
  }
}
#!queue	A002702	0	->	2	A002701	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002702 Coefficients for numerical differentiation.
 * @author Sean A. Irvine
 */
public class A002702 extends A002701 {

  @Override
  public Z next() {
    return computeNext().den();
  }
}
#!queue	A002703	-1	->	3	A262568	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a262.A262568;

/**
 * A002703 Sets with a congruence property.
 * @author Sean A. Irvine
 */
public class A002703 extends A262568 {

  @Override
  public Z next() {
    return super.next().subtract(2);
  }
}
#!queue	A002730	0	->	1	A002729	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;

/**
 * A002730 Number of equivalence classes of binary sequences of primitive period n.
 * @author Sean A. Irvine
 */
public class A002730 extends A002729 {

  private final ArrayList<Z> mA2729 = new ArrayList<>();
  {
    mA2729.add(super.next());
  }

  @Override
  public Z next() {
    final int n = mA2729.size();
    mA2729.add(super.next());
    Z s = Z.ZERO;
    for (final Z dd : Jaguar.factor(n).divisors()) {
      final int d = dd.intValueExact();
      s = s.add(mA2729.get(d).multiply(Mobius.mobius(n / d)));
    }
    return s;
  }
}
#!queue	A002748	1	->	0	A000203	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A002748 Sum of logarithmic numbers.
 * @author Sean A. Irvine
 */
public class A002748 extends A000203 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = -1;
  private Z mF = Z.ONE;
  private final ArrayList<Q> mSeq = new ArrayList<>();

  @Override
  public Z next() {
    mSeq.add(new Q(super.next()));
    final Polynomial<Q> egf = RING.series(RING.create(mSeq), RING.exp(RING.x(), ++mN), mN);
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A002749	1	->	0	A000005	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000005;

/**
 * A002749 Sum of logarithmic numbers.
 * @author Sean A. Irvine
 */
public class A002749 extends A000005 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = -1;
  private Z mF = Z.ONE;
  private final ArrayList<Q> mSeq = new ArrayList<>();

  @Override
  public Z next() {
    mSeq.add(new Q(super.next()));
    final Polynomial<Q> egf = RING.series(RING.create(mSeq), RING.exp(RING.x(), ++mN), mN);
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A002750	1	->	0	A000203	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A002750 Sum of logarithmic numbers.
 * @author Sean A. Irvine
 */
public class A002750 extends A000203 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = -1;
  private Z mF = Z.ONE;
  private final ArrayList<Q> mSeq = new ArrayList<>();

  @Override
  public Z next() {
    mSeq.add(new Q(super.next()));
    final Polynomial<Q> egf = RING.multiply(RING.create(mSeq), RING.exp(RING.x(), ++mN), mN);
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A002751	1	->	0	A000005	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000005;

/**
 * A002751 Sum of logarithmic numbers.
 * @author Sean A. Irvine
 */
public class A002751 extends A000005 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = -1;
  private Z mF = Z.ONE;
  private final ArrayList<Q> mSeq = new ArrayList<>();

  @Override
  public Z next() {
    mSeq.add(new Q(super.next()));
    final Polynomial<Q> egf = RING.multiply(RING.create(mSeq), RING.exp(RING.x(), ++mN), mN);
    if (mN > 1) {
      mF = mF.multiply(mN);
    }
    return egf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A002766	0	->	1	A002762	--------------------------------
package irvine.oeis.a002;

/**
 * A002766 Number of bipartite partitions.
 * @author Sean A. Irvine
 */
public class A002766 extends A002762 {

  @Override
  protected int m() {
    return 9;
  }

  @Override
  protected int k() {
    return 3;
  }
}
#!queue	A002770	1	->	2	A002306	--------------------------------
package irvine.oeis.a002;

import irvine.factor.prime.Fast;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A002770 Integers connected with coefficients in expansion of Weierstrass P-function.
 * @author Sean A. Irvine
 */
public class A002770 extends A002306 {

  private final Fast mPrime = new Fast();
  private int mN = 1;

  @Override
  public Z next() {
    final Q e = hurwitz(++mN);
    final A002172 glaisher = new A002172(); // Glaisher, 2 * a
    long p = 3; // first prime to consider is 5
    Q sum = Q.ZERO;
    final long n4 = 4L * mN;
    while ((p = mPrime.nextPrime(p)) - 1 <= n4) {
      if ((p & 3) == 1) {
        // i.e. p steps through index for chi(p)
        final Z a2 = glaisher.next();
        if (n4 % (p - 1) == 0) {
          final Q t = new Q(a2.pow(n4 / (p - 1)), Z.valueOf(p));
          sum = sum.add(t);
        }
      }
    }
    //System.out.println(e + " " + mSum);
    return e.subtract(Q.HALF).subtract(sum).toZ();
  }
}
#!queue	A002772	1	->	2	A002771	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.z.Z;

/**
 * A002772 Number of terms in a bordered skew determinant.
 * @author Sean A. Irvine
 */
public class A002772 extends A002771 {

  private final ArrayList<Z> mSkew = new ArrayList<>();
  {
    mSkew.add(Z.ONE); // easier to keep indexes in sync
    mSkew.add(super.next());
  }
  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    mSkew.add(super.next());
    Z s = Z.ZERO;
    Z f = Z.ONE;
    for (int k = 1; k <= mN; ++k) {
      s = s.add(mSkew.get(mN - k).multiply(f));
      f = f.multiply(mN - k);
    }
    return s;
  }
}
#!queue	A002809	0	->	1	A000793	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000793;

/**
 * A002809 Increasing values of A000793 (largest order of permutation of n elements).
 * @author Sean A. Irvine
 */
public class A002809 extends A000793 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.compareTo(mA) <= 0);
    mA = t;
    return mA;
  }
}
#!queue	A002815	1	->	0	A000720	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A002815 a(n) = n + Sum_{k=1..n} pi(k), where pi() = A000720.
 * @author Sean A. Irvine
 */
public class A002815 extends A000720 {

  private Z mSum = Z.ZERO;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN > 0) {
      mSum = mSum.add(super.next());
    }
    return mSum.add(mN);
  }
}

#!queue	A002824	0	->	2	A001035	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a001.A001035;

/**
 * A002824 Number of precomplete Post functions.
 * @author Sean A. Irvine
 */
public class A002824 extends A001035 {

  private long mN = 1;

  @Override
  public Z next() {
    return super.next().multiply(Binomial.binomial(++mN, 2));
  }
}
#!queue	A002848	1	->	0	A002849	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;

/**
 * A002848 Number of maximal collections of pairwise disjoint subsets {X,Y,Z} of {1, 2, ..., n} with X + Y = Z (as in A002849), with the property that n is in one of the subsets.
 * @author Sean A. Irvine
 */
public class A002848 extends A002849 {

  // After Franklin T. Adams-Watters

  private int mN = -1;
  private Z mPrev = super.next();

  @Override
  public Z next() {
    if (++mN <= 1) {
      return Z.ZERO;
    }
    final Z t = super.next();
    final int r = mN % 12;
    final Z res;
    if (r == 0 || r == 3 || r == 7 || r == 10) {
      res = t;
    } else {
      res = t.subtract(mPrev);
    }
    mPrev = t;
    return res;
  }
}
#!queue	A002857	0	->	1	A000612	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000612;

/**
 * A002857 Number of Post functions of n variables.
 * @author Sean A. Irvine
 */
public class A002857 extends A000612 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A002869	1	->	0	A019538	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a019.A019538;

/**
 * A002869 Largest number in n-th row of triangle A019538.
 * @author Sean A. Irvine
 */
public class A002869 extends A019538 {

  private long mN = -1;

  @Override
  public Z next() {
    Z m = Z.ONE;
    ++mN;
    for (int k = 1; k <= mN; ++k) {
      m = m.max(super.next());
    }
    return m;
  }
}
#!queue	A002878	1	->	0	A000204	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a000.A000204;

/**
 * A002878 Bisection of Lucas sequence: a(n) = L(2*n+1).
 * @author Sean A. Irvine
 */
public class A002878 extends A000204 {

  @Override
  public Z next() {
    final Z res = super.next();
    super.next();
    return res;
  }
}

#!queue	A002902	0	->	1	A001412	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.a001.A001412;

/**
 * A002902 Number of n-step self-avoiding walks on a cubic lattice with a first step along the positive x, y, or z axis.
 * @author Sean A. Irvine
 */
public class A002902 extends A001412 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A002966	0	->	1	A000058	--------------------------------
package irvine.oeis.a002;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a000.A000058;

/**
 * A002966 Egyptian fractions: number of solutions of 1 = 1/x_1 + ... + 1/x_n where 0 &lt; x_1 &lt;= ... &lt;= x_n.
 * @author Sean A. Irvine
 */
public class A002966 extends A000058 {

  // Based on a C++ implementation by Jacques Le Normand
  // Correctly calculates to a(8) -- there might be overflow beyond that -- not tested

  private static final class FastVector {
    // todo make this dynamic in mSize?
    private final int[] mPrime = new int[14];
    private final int[] mExponent = new int[14];
    private int mSize;

    private FastVector() {
      mSize = 0;
    }

    private void add(final int a, final int value) {
      for (int i = 0; i < mSize; ++i) {
        if (mPrime[i] == a) {
          mExponent[i] += value;
          return;
        }
      }
      mPrime[mSize] = a;
      mExponent[mSize] = value;
      ++mSize;
    }

    private int get(final int a) {
      for (int i = 0; i < mSize; ++i) {
        if (mPrime[i] == a) {
          return mExponent[i];
        }
      }
      mPrime[mSize] = a;
      mExponent[mSize] = 0;
      ++mSize;
      return 0;
    }

    private void erase(final int a) {
      for (int i = 0; i < mSize; ++i) {
        if (mPrime[i] == a) {
          mPrime[i] = mPrime[mSize - 1];
          mExponent[i] = mExponent[mSize - 1];
          --mSize;
          return;
        }
      }
    }

  }

  private final FastVector mSoFar = new FastVector();
  private final FastVector mTempFar = new FastVector();

  // This is the meat. it generates all the divisors of denum, and then tests using Polytope's test.
  // mSoFar contains all the prime divisors of denum and their multiplicity. mSoFar is like a map.
  int getDivisors(final long[] num, final long[] denum, long d, final int c, final int start) {
    if (c >= mTempFar.mSize) {
      return (denum[0] + d) % num[0] == 0 && (denum[0] + d) / num[0] >= start ? 1 : 0;
    }
    while (num[0] % mTempFar.mPrime[c] == 0 && mTempFar.mExponent[c] > 0) {
      num[0] /= mTempFar.mPrime[c];
      denum[0] /= mTempFar.mPrime[c];
      mTempFar.mExponent[c]--;
    }
    int ret = 0;
    for (int i = 0; i <= mTempFar.mExponent[c] * 2; ++i) {
      ret += getDivisors(num, denum, d, c + 1, start);
      d *= mTempFar.mPrime[c];
      if (d > denum[0]) {
        break;
      }
    }
    return ret;
  }

  // Recursive with a special case when n = 2.
  private long count(final int n, final long num, final long denum, int start) {
    if (n == 2) {
      System.arraycopy(mSoFar.mPrime, 0, mTempFar.mPrime, 0, mSoFar.mSize);
      System.arraycopy(mSoFar.mExponent, 0, mTempFar.mExponent, 0, mSoFar.mSize);
      mTempFar.mSize = mSoFar.mSize;
      return getDivisors(new long[] {num}, new long[] {denum}, 1, 0, start);
    }
    final long least = denum % num != 0 ? (denum + num - 1) / num : (denum / num) + 1;
    if (start < least) {
      start = (int) least;
    }
    long ret = 0;
    for (int toCheck = (int) ((denum * n) / num); toCheck >= start; --toCheck) {
      final long top = num * toCheck - denum;
      final long bot = toCheck * denum;
      final FactorSequence fs = Jaguar.factor(toCheck);
      for (final Z p : fs.toZArray()) {
        mSoFar.add(p.intValueExact(), fs.getExponent(p));
      }
      ret += count(n - 1, top, bot, toCheck);
      if ((ret >> 32) > 0) { // was 32 in C version
        throw new RuntimeException("overflow");
      }
      for (final Z p : fs.toZArray()) {
        final int pi = p.intValueExact();
        mSoFar.add(pi, -fs.getExponent(p));
        if (mSoFar.get(pi) <= 0) {
          mSoFar.erase(pi);
        }
      }
    }
    return ret;
  }


  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return Z.valueOf(count(mN, 1, 1, 2));
  }
}
#!queue	A003026	1	->	2	A058876	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a058.A058876;

/**
 * A003026 Number of n-node labeled acyclic digraphs with 2 out-points.
 * @author Sean A. Irvine
 */
public class A003026 extends A058876 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}
#!queue	A003033	2	->	3	A003032	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003033 Smallest integer m such that the product of every 4 consecutive integers &gt; m has a prime factor &gt; prime(n).
 * @author Sean A. Irvine
 */
public class A003033 extends A003032 {

  @Override
  protected int getNumberOfConsecutivePrimes() {
    return 4;
  }

  @Override
  protected Z firstPrime() {
    return Z.THREE;
  }

}
#!queue	A003040	0	->	1	A060240	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a060.A060240;

/**
 * A003040 Highest degree of an irreducible representation of symmetric group S_n of degree n.
 * @author Sean A. Irvine
 */
public class A003040 extends A060240 {

  private int mN = 0;

  @Override
  public Z next() {
    Z max = Z.ZERO;
    for (final Z r : representations(++mN)) {
      max = max.max(r);
    }
    return max;
  }
}
#!queue	A003065	1	->	0	A003313	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.util.array.DynamicLongArray;

/**
 * A003065 Number of integers with a shortest addition chain of length n.
 * @author Sean A. Irvine
 */
public class A003065 extends A003313 {

  private final DynamicLongArray mCounts = new DynamicLongArray();
  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    ++mN;
    final int limit = 1 << mN;
    while (mM <= limit) {
      final int length = super.next().intValueExact();
      mCounts.set(length, mCounts.get(length) + 1);
      ++mM;
    }
    return Z.valueOf(mCounts.get(mN));
  }
}
#!queue	A003069	0	->	1	A126067	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a126.A126067;

/**
 * A003069 Number of n-node digraphs with same converse as complement.
 * @author Sean A. Irvine
 */
public class A003069 extends A126067 {

  private int mN = 0;

  @Override
  public Z next() {
    return i(++mN).apply(0, 1).toZ();
  }
}
#!queue	A003083	0	->	1	A000088	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000088;

/**
 * A003083 Sum a(n) x^n / n = log (1 + Sum g(n) x^n ), where g(n) is # graphs on n nodes (A000088).
 * @author Sean A. Irvine
 */
public class A003083 extends A000088 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mA88 = new ArrayList<>();
  {
    // skip 0th term
    super.next();
    mA88.add(Q.ZERO);
  }

  @Override
  public Z next() {
    final int n = mA88.size();
    mA88.add(new Q(super.next()));
    return RING.log1p(RING.create(mA88), n).coeff(n).multiply(n).toZ();
  }
}
#!queue	A003084	0	->	1	A000273	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000273;

/**
 * A003084 Related to number of digraphs.
 * @author Sean A. Irvine
 */
public class A003084 extends A000273 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mA = new ArrayList<>();
  {
    // skip 0th term
    super.next();
    mA.add(Q.ZERO);
  }

  @Override
  public Z next() {
    final int n = mA.size();
    mA.add(new Q(super.next()));
    return RING.log1p(RING.create(mA), n).coeff(n).multiply(n).toZ();
  }
}
#!queue	A003089	0	->	1	A002905	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a002.A002905;

/**
 * A003089 Number of connected line graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A003089 extends A002905 {

  {
    super.next(); // skip 0th term
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return mN == 4 ? Z.TWO : t;
  }
}
#!queue	A003144	0	->	1	A080843	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a080.A080843;

/**
 * A003144 Positions of letter a in the tribonacci word abacabaabacababac... generated by a-&gt;ab, b-&gt;ac, c-&gt;a (cf. A092782).
 * @author Sean A. Irvine
 */
public class A003144 extends A080843 {

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A003145	0	->	1	A080843	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a080.A080843;

/**
 * A003145 Positions of letter b in the tribonacci word abacabaabacababac... generated by a-&gt;ab, b-&gt;ac, c-&gt;a (cf. A092782).
 * @author Sean A. Irvine
 */
public class A003145 extends A080843 {

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A003146	0	->	1	A080843	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a080.A080843;

/**
 * A003146 Positions of letter c in the tribonacci word abacabaabacababac... generated by a-&gt;ab, b-&gt;ac, c-&gt;a (cf. A092782).
 * @author Sean A. Irvine
 */
public class A003146 extends A080843 {

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A003265	0	->	1	A000073	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a000.A000073;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A003265 Not representable by truncated tribonacci sequence 2, 4, 7, 13, 24, 44, 81, ....
 * @author Sean A. Irvine
 */
public class A003265 extends A000073 {

  private final LongDynamicBooleanArray mSeen = new LongDynamicBooleanArray();
  {
    mSeen.set(0);
  }
  private long mTribonacci = -1;
  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (mN >= mTribonacci) {
        do {
          mTribonacci = super.next().longValueExact();
        } while (mTribonacci <= 1);
        for (long k = mSeen.length() - 1, j = k + mTribonacci; k >= 0; --k, --j) {
          if (mSeen.isSet(k)) {
            mSeen.set(j);
          }
        }
      }
      if (!mSeen.isSet(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A003270	0	->	1	A099054	--------------------------------
package irvine.oeis.a003;

import irvine.oeis.Conjectural;
import irvine.oeis.a099.A099054;

/**
 * A003270 A nonrepetitive sequence.
 * @author Sean A. Irvine
 */
public class A003270 extends A099054 implements Conjectural {
}
#!queue	A003289	2	->	1	A003290	--------------------------------
package irvine.oeis.a003;

/**
 * A003289 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (0,1).
 * @author Sean A. Irvine
 */
public class A003289 extends A003290 {

  @Override
  protected int first() {
    return 1;
  }

  @Override
  protected long search() {
    final int tx = 2;
    final int ty = 0;
    // return search(0, 0, tx, ty, mN, 1); // Basic search
    // Expanding first few links to exploit symmetries
    use(0, 0);
    long total = search(2, 0, tx, ty, mN - 1, 1);
    total += search(1, 1, tx, ty, mN - 1, 2);
    total += search(-1, 1, tx, ty, mN - 1, 2);
    use(-2, 0);
    total += search(-4, 0, tx, ty, mN - 2, 1);
    total += search(-1, 1, tx, ty, mN - 2, 2);
    total += search(-3, 1, tx, ty, mN - 2, 2);
    clear(-2, 0);
    clear(0, 0);
    return total;
  }

}
#!queue	A003304	1	->	2	A002931	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A003304 Number of figure 8's with 2n edges on the square lattice.
 * @author Sean A. Irvine
 */
public class A003304 extends A002931 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));

  {
    super.next(); // skip size 2, there are no figure 8s of this size
  }

  private Polygon augment(final int... coords) {
    Polygon p = null;
    for (int k = 0; k < coords.length; k += 2) {
      p = new Polygon(p, new Point(coords[k], coords[k + 1]));
    }
    return p;
  }

  private String latexPolygon(final Polygon polygon) {
    final StringBuilder sb = new StringBuilder("\\draw ");
    Point first = null;
    for (final Point pt : polygon) {
      if (first == null) {
        first = pt;
      } else {
        sb.append(" -- ");
      }
      sb.append(pt);
    }
    sb.append(" -- ").append(first).append(";\n");
    for (final Point pt : polygon) {
      sb.append("\\fill ").append(pt).append(" circle (3pt);\n");
    }
    return sb.toString();
  }

  private void dump(final Polygon polygon, final int... coords) {
    System.out.println("\\begin{tikzpicture}[scale=0.3]");
    System.out.print(latexPolygon(polygon));
    System.out.print(latexPolygon(augment(coords)));
    System.out.println("\\end{tikzpicture}");
  }

  @Override
  protected Z postFilter() {
    if (mN == 4) {
      // This is the only case where translation of the polygon could get you the same thing
      // after adding a simple square.  Rather than slowing down all the calculations by
      // checking for this, special case this smallest value.
      return Z.TWO;
    }
    // Need to try adding a square at each position of each polygon
    long c = 0;
    for (final Polygon polygon : mPolygons) {
      for (final Point pt : polygon) {
        final int x = pt.left();
        final int y = pt.right();
        if (!polygon.contains(new Point(x + 1, y))) {
          if (!polygon.contains(new Point(x + 1, y + 1)) && !polygon.contains(new Point(x, y + 1))) {
            ++c;
            if (mVerbose) {
              dump(polygon, x, y, x + 1, y, x + 1, y + 1, x, y + 1);
            }
          }
          if (!polygon.contains(new Point(x + 1, y - 1)) && !polygon.contains(new Point(x, y - 1))) {
            ++c;
            if (mVerbose) {
              dump(polygon, x, y, x + 1, y, x + 1, y - 1, x, y - 1);
            }
          }
        }
        if (!polygon.contains(new Point(x - 1, y))) {
          if (!polygon.contains(new Point(x - 1, y + 1)) && !polygon.contains(new Point(x, y + 1))) {
            ++c;
            if (mVerbose) {
              dump(polygon, x, y, x - 1, y, x - 1, y + 1, x, y + 1);
            }
          }
          if (!polygon.contains(new Point(x - 1, y - 1)) && !polygon.contains(new Point(x, y - 1))) {
            ++c;
            if (mVerbose) {
              dump(polygon, x, y, x - 1, y, x - 1, y - 1, x, y - 1);
            }
          }
        }
      }
    }
    return Z.valueOf(c);
  }
}

#!queue	A003305	1	->	4	A002931	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;
import java.util.Collection;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A003305 Figure 8's with 2n edges on the square lattice.
 * @author Sean A. Irvine
 */
public class A003305 extends A002931 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private final ArrayList<Collection<Polygon>> mFigures = new ArrayList<>();

  {
    mFigures.add(null); // No polygons of length 0
    super.next();
    mFigures.add(null); // No polygons of length 2
  }

  private boolean juxtapose(final Polygon big, final Polygon small, final int crossX, final int crossY, final int dx, final int dy) {
    for (final Point pt : small) {
      final int x = pt.left() + dx;
      final int y = pt.right() + dy;
      if (x != crossX || y != crossY) {
        final Point p = new Point(x, y);
        if (big.contains(p)) {
          return false;
        }
      }
    }
    return true;
  }

  private long juxtapose(final Polygon big, final Polygon small) {
    // Add s to big in all possible ways
    long count = 0;
    for (final Point pt : big) {
      // Select the point where the two polygons will intersect
      final int crossX = pt.left();
      final int crossY = pt.right();
      for (final Point pt2 : small) {
        final int sx = pt2.left();
        final int sy = pt2.right();
        // Compute translation to adjoin small to big at selected points
        final int dx = crossX - sx;
        final int dy = crossY - sy;
        if (juxtapose(big, small, crossX, crossY, dx, dy)) {
          ++count;
        }
      }
    }
    return count;
  }

  private long count(final int k, final int j) {
    assert k >= j;
    long count = 0;
    final Collection<Polygon> small = mFigures.get(j / 2);
    final Collection<Polygon> big = mFigures.get(k / 2);
    for (final Polygon b : big) {
      for (final Polygon s : small) {
        count += juxtapose(b, s);
      }
    }
    if (k == j) {
      // If k == j we will have counted each figure twice, so make the correction here
      assert (count & 1) == 0;
      count /= 2;
    }
    if (mVerbose) {
      System.out.println("(" + k + "," + j + ")=" + count);
    }
    return count;
  }

  @Override
  public Z next() {
    super.next(); // Adds one more set of polygons to mFigures
    mFigures.add(new ArrayList<>(mPolygons));
    final int n = mN + 4;
    Z sum = Z.ZERO;
    for (int k = n - 4; 2 * k >= n; k -= 2) {
      // k tracks the larger of the two polygons in the figure
      sum = sum.add(count(k, n - k));
    }
    return sum;
  }

}

#!queue	A003426	0	->	1	A000055	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a000.A000055;
import irvine.oeis.a002.A002988;

/**
 * A003426 Number of stable trees with n nodes.
 * @author Sean A. Irvine
 */
public class A003426 extends A000055 {

  private long mN = 0;
  private final A002988 mB = new A002988();
  {
    super.next();
    mB.next();
  }

  @Override
  public Z next() {
    final Z v = super.next().subtract(mB.next());
    return ++mN <= 2 ? v.add(1) : v;
  }
}
#!queue	A003437	0	->	1	A007474	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.a007.A007474;

/**
 * A003437 Number of unlabeled Hamiltonian circuits on n-octahedron (cross polytope); also number of circular chord diagrams with n chords, modulo symmetries.
 * @author Sean A. Irvine
 */
public class A003437 extends A007474 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply2().add(get(mN, 2L)).subtract(get(mN - 1, 2L)).add(get(mN - 2, 2L)).divide(4);
  }
}

#!queue	A003443	4	->	5	A003442	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003443 Number of nonequivalent dissections of an n-gon into n-4 polygons by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A003443 extends A003442 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return f(mN, mN + 4).coeff(mN + 4).toZ();
  }
}

#!queue	A003448	4	->	5	A003447	--------------------------------
package irvine.oeis.a003;

/**
 * A003448 Number of nonequivalent dissections of an n-gon into n-4 polygons by nonintersecting diagonals rooted at a cell up to rotation and reflection.
 * @author Sean A. Irvine
 */
public class A003448 extends A003447 {

  @Override
  protected int s() {
    return mN + 4;
  }
}

#!queue	A003452	4	->	5	A003447	--------------------------------
package irvine.oeis.a003;

/**
 * A003452 Number of nonequivalent dissections of an n-gon into 3 polygons by nonintersecting diagonals rooted at a cell up to rotation and reflection.
 * @author Sean A. Irvine
 */
public class A003452 extends A003447 {

  @Override
  protected int s() {
    return mN + 4;
  }

  @Override
  protected int r() {
    return 3;
  }
}

#!queue	A003454	4	->	3	A003442	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003454 Number of nonequivalent dissections of an n-gon by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A003454 extends A003442 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      s = s.add(f(k, mN + 2).coeff(mN + 2).toZ());
    }
    return s;
  }
}

#!queue	A003455	4	->	3	A003447	--------------------------------
package irvine.oeis.a003;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A003455 Number of nonequivalent dissections of an n-gon by nonintersecting diagonals up to rotation.
 * @author Sean A. Irvine
 */
public class A003455 extends A003447 {

  private int mN = 0;

  private Polynomial<Q> h(final int r, final int n) {
    Polynomial<Q> sum = RING.zero();
    for (int k = 1; k < r; ++k) {
      sum = RING.add(sum, RING.multiply(mV.get(k, n), mV.get(r - k, n), n));
    }
    if ((r & 1) == 0) {
      sum = RING.subtract(sum, mV.get(r / 2, (n + 1) / 2).substitutePower(2));
    }
    return RING.subtract(f(r, n), RING.multiply(sum, Q.HALF));
  }

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      s = s.add(h(k, mN + 3).coeff(mN + 2).toZ());
    }
    return s;
  }
}

#!queue	A003456	4	->	3	A003447	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003456 Number of nonequivalent dissections of an n-gon by nonintersecting diagonals rooted at a cell up to rotation and reflection.
 * @author Sean A. Irvine
 */
public class A003456 extends A003447 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      s = s.add(smallF(k, mN + 2).coeff(mN + 2).toZ());
    }
    return s;
  }
}

#!queue	A003651	1	->	2	A003658	--------------------------------
package irvine.oeis.a003;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;

/**
 * A003651 Class number of real quadratic field with discriminant 4n, n == 2,3 ( mod 4).
 * @author Sean A. Irvine
 */
public class A003651 extends A003658 {

  @Override
  public Z next() {
    while (true) {
      final Z n = super.next();
      if (n.mod(4) == 0) {
        return Z.valueOf(QuadraticFieldUtils.classNumber(n));
      }
    }
  }
}
#!queue	A003652	1	->	2	A003658	--------------------------------
package irvine.oeis.a003;

import irvine.oeis.Conjectural;
import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;

/**
 * A003652 Class number of real quadratic field with discriminant A003658(n), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A003652 extends A003658 implements Conjectural {

  // contains heuristics.

  {
    super.next(); // skip 1
  }

  @Override
  public Z next() {
    return Z.valueOf(QuadraticFieldUtils.classNumber(super.next()));
  }
}
#!queue	A003923	1	->	0	A003920	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003923 Order of universal Chevalley group B_n (2) or symplectic group Sp(2n,2).
 * @author Sean A. Irvine
 */
public class A003923 extends A003920 {

  @Override
  protected Z q() {
    return Z.TWO;
  }

  @Override
  protected int start() {
    return -1;
  }
}
#!queue	A003924	1	->	0	A003920	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003924 Order of universal Chevalley group B_n (7).
 * @author Sean A. Irvine
 */
public class A003924 extends A003920 {

  @Override
  protected Z q() {
    return Z.SEVEN;
  }
}
#!queue	A003928	2	->	1	A003927	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003928 Order of simple Chevalley group B_n (5).
 * @author Sean A. Irvine
 */
public class A003928 extends A003927 {

  @Override
  protected Z q() {
    return Z.FIVE;
  }

  @Override
  protected int start() {
    return 0;
  }
}
#!queue	A003929	2	->	1	A003928	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003929 Order of simple Chevalley group B_n (7).
 * @author Sean A. Irvine
 */
public class A003929 extends A003928 {

  @Override
  protected Z q() {
    return Z.SEVEN;
  }
}
#!queue	A003930	2	->	1	A003928	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;

/**
 * A003930 Order of simple Chevalley group B_n (9).
 * @author Sean A. Irvine
 */
public class A003930 extends A003928 {

  @Override
  protected Z q() {
    return Z.NINE;
  }
}
#!queue	A004005	5	->	2	A032428	--------------------------------
package irvine.oeis.a004;

import irvine.oeis.a032.A032428;

/**
 * A004005 Coefficients of elliptic function sn.
 * @author Sean A. Irvine
 */
public class A004005 extends A032428 {

  @Override
  protected int j() {
    return 2;
  }
}
#!queue	A004016	1	->	0	A002324	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.a002.A002324;

/**
 * A004016 Theta series of planar hexagonal lattice A_2.
 * @author Sean A. Irvine
 */
public class A004016 extends A002324 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().multiply(6);
  }
}
#!queue	A004017	0	->	1	A007331	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.a007.A007331;

/**
 * A004017 Theta series of E_8 lattice with respect to deep hole.
 * @author Sean A. Irvine
 */
public class A004017 extends A007331 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().shiftLeft(4);
  }
}
#!queue	A004102	1	->	0	A063841	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.a063.A063841;

/**
 * A004102 Number of signed graphs with n nodes. Also number of 2-multigraphs on n nodes.
 * @author Sean A. Irvine
 */
public class A004102 extends A063841 {

  private int mN = -1;

  @Override
  public Z next() {
    return t(++mN, 2);
  }
}

#!queue	A004114	1	->	0	A004113	--------------------------------
package irvine.oeis.a004;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A004114 Number of trees with n nodes and 2-colored internal (non-leaf) nodes.
 * @author Sean A. Irvine
 */
public class A004114 extends A004113 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final ArrayList<Z> mB = new ArrayList<>();
  {
    mB.add(Z.ZERO);
  }
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mB.add(super.next());
    final Polynomial<Z> g = RING.create(mB);
    return RING.add(RING.subtract(RING.add(RING.one(), g), g.shift(1)), RING.divide(RING.subtract(g.substitutePower(2), RING.pow(g, 2, mN)), Z.TWO)).coeff(mN);
  }
}
#!queue	A004160	0	->	1	A000292	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000292;

/**
 * A004160 Sum of digits of tetrahedral numbers.
 * @author Sean A. Irvine
 */
public class A004160 extends A000292 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()));
  }
}
#!queue	A004162	0	->	1	A000326	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000326;

/**
 * A004162 Sum of digits of pentagonal numbers.
 * @author Sean A. Irvine
 */
public class A004162 extends A000326 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()));
  }
}
#!queue	A004250	0	->	1	A000041	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A004250 Number of partitions of n into 3 or more parts.
 * @author Sean A. Irvine
 */
public class A004250 extends A000041 {

  private long mN = 2;

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(++mN / 2);
  }
}
#!queue	A004287	1	->	0	A004283	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;

/**
 * A004287 Least positive multiple of n written in base 7 using only 0 and 1.
 * @author Sean A. Irvine
 */
public class A004287 extends A004283 {

  @Override
  protected Z init() {
    return Z.NEG_ONE;
  }

  @Override
  protected int base() {
    return 7;
  }
}
#!queue	A004288	1	->	0	A004283	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;

/**
 * A004288 Least positive multiple of n written in base 8 using only 0 and 1.
 * @author Sean A. Irvine
 */
public class A004288 extends A004283 {

  @Override
  protected Z init() {
    return Z.NEG_ONE;
  }

  @Override
  protected int base() {
    return 8;
  }
}
#!queue	A004290	1	->	0	A004283	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;

/**
 * A004290 Least positive multiple of n that when written in base 10 uses only 0's and 1's.
 * @author Sean A. Irvine
 */
public class A004290 extends A004283 {

  @Override
  protected Z init() {
    return Z.NEG_ONE;
  }

  @Override
  protected int base() {
    return 10;
  }
}
#!queue	A005033	0	->	1	A001764	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.CyclicGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a001.A001764;

/**
 * A005033 Number of nonequivalent dissections of a polygon into n quadrilaterals by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A005033 extends A001764 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final CycleIndex mC4 = new CyclicGroup(4).cycleIndex();
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    mU.add(new Q(super.next()));
    return mC4.apply(RING.create(mU), ++mN).coeff(mN).toZ();
  }
}

#!queue	A005035	0	->	1	A001764	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a001.A001764;

/**
 * A005035 Number of nonequivalent dissections of a polygon into n quadrilaterals by nonintersecting diagonals rooted at a cell up to rotation and reflection.
 * @author Sean A. Irvine
 */
public class A005035 extends A001764 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = -1;

  {
    mU.add(new Q(super.next()));
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mU.add(new Q(super.next()));
    final Polynomial<Q> u = RING.create(mU);
    final Q a = RING.pow(u, 4, mN).coeff(mN);
    final Polynomial<Q> u2 = u.substitutePower(2);
    final Q b = RING.pow(u2, 2, mN).coeff(mN).multiply(3);
    final Q c = u.substitutePower(4).coeff(mN).multiply(2);
    final Polynomial<Q> den = RING.pow(RING.subtract(RING.one(), u2.shift(1)), 2, mN);
    final Q d = RING.coeff(u2, den, mN).multiply(2);
    return a.add(b).add(c).add(d).divide(8).toZ();
  }
}

#!queue	A005037	0	->	1	A002293	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.CyclicGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002293;

/**
 * A005037 Number of nonequivalent dissections of a polygon into n pentagons by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A005037 extends A002293 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final CycleIndex mC4 = new CyclicGroup(5).cycleIndex();
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    mU.add(new Q(super.next()));
    return mC4.apply(RING.create(mU), ++mN).coeff(mN).toZ();
  }
}

#!queue	A005038	0	->	1	A002293	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.CyclicGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002293;

/**
 * A005038 Number of nonequivalent dissections of a polygon into n pentagons by nonintersecting diagonals up to rotation..
 * @author Sean A. Irvine
 */
public class A005038 extends A002293 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final CycleIndex mC5 = new CyclicGroup(5).cycleIndex();
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    mU.add(new Q(super.next()));
    final Polynomial<Q> u = RING.create(mU);
    final Polynomial<Q> u2 = u.substitutePower(2, mN);
    final Z a = RING.pow(u, 2, mN).coeff(mN).subtract(u2.coeff(mN)).toZ().divide2();
    return mC5.apply(u, mN).coeff(mN - 1).toZ().subtract(a);
  }
}

#!queue	A005039	0	->	1	A002293	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002293;

/**
 * A005039 Number of nonequivalent dissections of a polygon into n pentagons by nonintersecting diagonals rooted at a cell up to rotation and reflection.
 * @author Sean A. Irvine
 */
public class A005039 extends A002293 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mU = new ArrayList<>();
  private int mN = -1;

  {
    mU.add(new Q(super.next()));
  }

  @Override
  public Z next() {
    ++mN;
    mU.add(new Q(super.next()));
    final Polynomial<Q> u = RING.create(mU);
    final Polynomial<Q> u2 = u.substitutePower(2, mN);
    final Q a = RING.pow(u, 5, mN).coeff(mN);
    final Q b = u.substitutePower(5, mN).coeff(mN).multiply(4);
    final Q c = RING.pow(u2, 2, mN).coeff(mN).multiply(5);
    final Q d = RING.pow(u2, 4, mN).shift(1).coeff(mN).multiply(5);
    return a.add(b).add(c).add(d).toZ().divide(10);
  }
}

#!queue	A005049	4	->	5	A005048	--------------------------------
package irvine.oeis.a005;

/**
 * A005049 Minimal span of set of n elements with no 5-term arithmetic progression.
 * @author Sean A. Irvine
 */
public class A005049 extends A005048 {

  @Override
  protected int getProgressionLength() {
    return 5;
  }
}

#!queue	A005050	4	->	6	A005048	--------------------------------
package irvine.oeis.a005;

/**
 * A005050 Minimal span of set of n elements with no 6-term arithmetic progression.
 * @author Sean A. Irvine
 */
public class A005050 extends A005048 {

  @Override
  protected int getProgressionLength() {
    return 6;
  }
}

#!queue	A005133	0	->	1	A121355	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a121.A121355;

/**
 * A005133 Number of index n subgroups of modular group PSL_2(Z).
 * @author Sean A. Irvine
 */
public class A005133 extends A121355 {

  @Override
  public Z next() {
    return super.next().divide(mF.divide(mN));
  }
}
#!queue	A005219	0	->	1	A007122	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a007.A007122;

/**
 * A005219 Number of unlabeled identity unit interval graphs.
 * @author Sean A. Irvine
 */
public class A005219 extends A007122 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private int mN = 0;
  private final List<Q> mA = new ArrayList<>();
  {
    mA.add(Q.ZERO);
  }

  @Override
  public Z next() {
    ++mN;
    mA.add(new Q(super.next()));
    final Polynomial<Q> c = RING.create(mA);
    Polynomial<Q> e = RING.zero();
    for (int k = 1; k <= mN; ++k) {
      e = RING.signedAdd((k & 1) == 1, e, RING.divide(c.substitutePower(k, mN), new Q(k)));
    }
    return RING.exp(e, mN).coeff(mN).toZ();
  }
}
#!queue	A005263	1	->	0	A005264	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A005263 Number of labeled Greg trees.
 * @author Sean A. Irvine
 */
public class A005263 extends A005264 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  private final List<Q> mB = new ArrayList<>();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Q.ZERO);
    } else {
      mF = mF.multiply(mN);
      mB.add(new Q(super.next(), mF));
    }
    final Polynomial<Q> b = RING.create(mB);
    return RING.subtract(RING.add(RING.one(), b), RING.pow(b, 2, mN)).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A005291	0	->	1	A005290	--------------------------------
package irvine.oeis.a005;

/**
 * A005291 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005291 extends A005290 {

  @Override
  protected int degree() {
    return 1;
  }
}
#!queue	A005292	0	->	2	A005290	--------------------------------
package irvine.oeis.a005;

/**
 * A005292 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005292 extends A005290 {

  @Override
  protected int degree() {
    return 2;
  }
}
#!queue	A005293	0	->	3	A005290	--------------------------------
package irvine.oeis.a005;

/**
 * A005293 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005293 extends A005290 {

  @Override
  protected int degree() {
    return 3;
  }
}
#!queue	A005294	0	->	4	A005290	--------------------------------
package irvine.oeis.a005;

/**
 * A005294 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005294 extends A005290 {

  @Override
  protected int degree() {
    return 4;
  }
}
#!queue	A005304	0	->	1	A005303	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005304 Representation degeneracies for Ramond strings.
 * @author Sean A. Irvine
 */
public class A005304 extends A005303 {

  // I'm not sure that the continuation of this power function is correct.

  private static final int[] IRREGULAR_POWERS = {0, 1, 1, 3, 3, 4, 3, 4};

  @Override
  protected int power(final int n) {
    return n < IRREGULAR_POWERS.length ? IRREGULAR_POWERS[n] : ((n & 1) == 0 ? 2 : 4);
  }

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A005308	0	->	1	A005303	--------------------------------
package irvine.oeis.a005;

/**
 * A005308 Bosonic string states.
 * @author Sean A. Irvine
 */
public class A005308 extends A005303 {

  @Override
  protected int power(final int n) {
    return n <= 1 ? 0 : (n - 2) / 2;
  }
}
#!queue	A005321	1	->	0	A005327	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.List;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005321 Upper triangular n X n (0,1)-matrices with no zero rows or columns.
 * @author Sean A. Irvine
 */
public class A005321 extends A005327 {

  private final List<Z> mA = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mA.add(super.next());
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      sum = sum.add(Binomial.binomial(mN, k).multiply(mA.get(k)));
    }
    return sum;
  }
}
#!queue	A005331	1	->	0	A005321	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.List;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005331 Certain subgraphs of a directed graph (binomial transform of A005321).
 * @author Sean A. Irvine
 */
public class A005331 extends A005321 {

  private final List<Z> mA = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mA.add(super.next());
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      sum = sum.add(Binomial.binomial(mN, k).multiply(mA.get(k)));
    }
    return sum;
  }
}
#!queue	A005334	2	->	1	A123301	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a123.A123301;

/**
 * A005334 Number of labeled nonseparable (or 2-connected) bicolored graphs with n nodes of the first color and n nodes of the second color.
 * @author Sean A. Irvine
 */
public class A005334 extends A123301 {

  protected int mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A005335	2	->	1	A005334	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005335 Number of labeled nonseparable (or 2-connected) bipartite graphs with 2n nodes and n nodes in each part.
 * @author Sean A. Irvine
 */
public class A005335 extends A005334 {

  @Override
  public Z next() {
    return super.next().multiply(Binomial.binomial(2L * mN, mN)).divide2();
  }
}
#!queue	A005347	2	->	1	A005579	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005347 First differences of A005579.
 * @author Sean A. Irvine
 */
public class A005347 extends A005579 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z a = super.next();
    final Z b = a.subtract(mA);
    mA = a;
    return b;
  }
}

#!queue	A005396	0	->	2	A006774	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a006.A006774;

/**
 * A005396 Number of 2n-step polygons on honeycomb.
 * @author Sean A. Irvine
 */
public class A005396 extends A006774 {

  @Override
  public Z next() {
    return super.next().multiply(Math.max(1, mN));
  }
}
#!queue	A005398	2	->	3	A003288	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a003.A003288;

/**
 * A005398 Number of n-step polygons on f.c.c. lattice.
 * @author Sean A. Irvine
 */
public class A005398 extends A003288 {

  @Override
  protected long search() {
    return search(0, 0, 0, 1, 1, 0, mN, 3);
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(search()).multiply2().divide(mN + 1);
  }

}
#!queue	A005438	0	->	1	A005437	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005438 Column of Kempner tableau.
 * @author Sean A. Irvine
 */
public class A005438 extends A005437 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return mPrev[(mPrev.length - 1) / 2 + 1];
  }
}

#!queue	A005513	12	->	6	A005516	--------------------------------
package irvine.oeis.a005;

/**
 * A005513 Number of n-bead bracelets (turnover necklaces) of two colors with 6 red beads and n-6 black beads.
 * @author Sean A. Irvine
 */
public class A005513 extends A005516 {

  @Override
  protected int beads() {
    return 6;
  }
}
#!queue	A005514	12	->	8	A005516	--------------------------------
package irvine.oeis.a005;

/**
 * A005514 Number of n-bead bracelets (turnover necklaces) with 8 red beads and n-8 black beads.
 * @author Sean A. Irvine
 */
public class A005514 extends A005516 {

  @Override
  protected int beads() {
    return 8;
  }
}
#!queue	A005515	12	->	10	A005516	--------------------------------
package irvine.oeis.a005;

/**
 * A005515 Number of n-bead bracelets (turnover necklaces) of two colors with 10 red beads and n-10 black beads.
 * @author Sean A. Irvine
 */
public class A005515 extends A005516 {

  @Override
  protected int beads() {
    return 10;
  }
}
#!queue	A005545	2	->	3	A003288	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003288;

/**
 * A005545 Number of n-step self-avoiding walks on f.c.c. lattice from (0,0,0) to (0,1,3).
 * @author Sean A. Irvine
 */
public class A005545 extends A003288 {

  @Override
  protected int first() {
    return 3;
  }

  @Override
  protected long search() {
    final int tx = 0;
    final int ty = 1;
    final int tz = 3;
    // todo Cf. A003288 there are probably exploitable symmetries here
    return search(0, 0, 0, tx, ty, tz, mN, 1); // Basic search
  }
}
#!queue	A005546	2	->	3	A003288	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003288;

/**
 * A005546 Number of n-step self-avoiding walks on f.c.c. lattice from (0,0,0) to (0,3,3).
 * @author Sean A. Irvine
 */
public class A005546 extends A003288 {

  @Override
  protected int first() {
    return 3;
  }

  @Override
  protected long search() {
    final int tx = 0;
    final int ty = 3;
    final int tz = 3;
    //return search(0, 0, 0, tx, ty, tz, mN, 1); // Basic search
    use(0, 0, 0);
    return search(0, 1, 1, tx, ty, tz, mN - 1, 1)
      + search(0, -1, -1, tx, ty, tz, mN - 1, 1)
      + search(0, 1, -1, tx, ty, tz, mN - 1, 2)
      + search(1, -1, 0, tx, ty, tz, mN - 1, 4)
      + search(1, 1, 0, tx, ty, tz, mN - 1, 4);
  }
}
#!queue	A005549	2	->	3	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005549 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (0,3).
 * @author Sean A. Irvine
 */
public class A005549 extends A003290 {

  @Override
  protected int first() {
    return 3;
  }

  @Override
  protected long search() {
    final int tx = 6;
    final int ty = 0;
    // return search(0, 0, tx, ty, mN, 1); // Basic search
    // Expanding first few links to exploit symmetries
    use(0, 0);
    long total = search(1, 1, tx, ty, mN - 1, 2);
    total += search(-1, 1, tx, ty, mN - 1, 2);
    use(-2, 0);
    total += search(-4, 0, tx, ty, mN - 2, 1);
    total += search(-1, 1, tx, ty, mN - 2, 2);
    total += search(-3, 1, tx, ty, mN - 2, 2);
    clear(-2, 0);
    use(2, 0);
    total += search(4, 0, tx, ty, mN - 2, 1);
    total += search(1, 1, tx, ty, mN - 2, 2);
    total += search(3, 1, tx, ty, mN - 2, 2);
    clear(2, 0);
    clear(0, 0);
    return total;
  }

}
#!queue	A005550	2	->	3	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005550 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (1,2).
 * @author Sean A. Irvine
 */
public class A005550 extends A003290 {

  @Override
  protected int first() {
    return 3;
  }

  @Override
  protected long search() {
    return search(0, 0, 5, 1, mN, 1);
  }

}
#!queue	A005551	2	->	4	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005551 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (0,4).
 * @author Sean A. Irvine
 */
public class A005551 extends A003290 {

  @Override
  protected int first() {
    return 4;
  }

  @Override
  protected long search() {
    final int tx = 8;
    final int ty = 0;
    // return search(0, 0, tx, ty, mN, 1); // Basic search
    // Expanding first few links to exploit symmetries
    use(0, 0);
    long total = search(1, 1, tx, ty, mN - 1, 2);
    total += search(-1, 1, tx, ty, mN - 1, 2);
    use(-2, 0);
    total += search(-4, 0, tx, ty, mN - 2, 1);
    total += search(-1, 1, tx, ty, mN - 2, 2);
    total += search(-3, 1, tx, ty, mN - 2, 2);
    clear(-2, 0);
    use(2, 0);
    total += search(4, 0, tx, ty, mN - 2, 1);
    total += search(1, 1, tx, ty, mN - 2, 2);
    total += search(3, 1, tx, ty, mN - 2, 2);
    clear(2, 0);
    clear(0, 0);
    return total;
  }

}
#!queue	A005552	2	->	4	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005552 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (1,3).
 * @author Sean A. Irvine
 */
public class A005552 extends A003290 {

  @Override
  protected int first() {
    return 4;
  }

  @Override
  protected long search() {
    return search(0, 0, 7, 1, mN, 1);
  }

}
#!queue	A005553	2	->	4	A003290	--------------------------------
package irvine.oeis.a005;

import irvine.oeis.a003.A003290;

/**
 * A005553 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (2,2).
 * @author Sean A. Irvine
 */
public class A005553 extends A003290 {

  @Override
  protected int first() {
    return 4;
  }

  @Override
  protected long search() {
    //return search(0, 0, 6, 2, mN, 1);
    use(0, 0);
    return search(1, 1, 6, 2, mN - 1, 2) + search(-2, 0, 6, 2, mN - 1, 2) + search(-1, 1, 6, 2, mN - 1, 2);
  }

}
#!queue	A005576	1	->	0	A259095	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a259.A259095;

/**
 * A005576 The limiting sequence [A259095(r(r+1)/2-s,r), s=0,1,2,...,r-1] for very large r.
 * @author Sean A. Irvine
 */
public class A005576 extends A259095 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final int r = mN + 1;
    return a259095(r * (r + 1) / 2 - mN, r);
  }
}

#!queue	A005588	0	->	1	A002658	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.a002.A002658;

/**
 * A005588 Number of free binary trees admitting height n.
 * @author Sean A. Irvine
 */
public class A005588 extends A002658 {

  private int mN = 0;
  private final ArrayList<Z> mP = new ArrayList<>();
  private final ArrayList<Z> mQ = new ArrayList<>();

  {
    mP.add(Z.ZERO);
    mP.add(super.next());
    mQ.add(Z.ZERO);
    mQ.add(Z.ONE);
    super.next();
  }

  private Z bin2(final Z n) {
    return n.multiply(n.subtract(1)).divide2();
  }

  private Z bin3(final Z n) {
    return n.multiply(n.subtract(1)).multiply(n.subtract(2)).divide(6);
  }

  private Z p(final int h) {
    return mP.get(h);
  }

  private Z q(final int h) {
    while (h >= mQ.size()) {
      final int ha = mQ.size() - 1;
      mQ.add(mQ.get(ha).add(p(ha)));
    }
    return mQ.get(h);
  }

  private Z a(final int h) {
    return bin3(p(h).add(2)).add(bin2(p(h).add(1)).multiply(q(h)));
  }

  private Z b(final int h) {
    return bin2(p(h).add(1));
  }

  private Z d(final int h, final int i) {
    if (i == h) {
      return Z.ZERO;
    }
    if (i > h) {
      return p(h);
    }
    if (i == 1) {
      return p(h).subtract(p(h - 1));
    }
    final Z d = d(h - 1, i - 1);
    return bin2(d.add(1)).add(d.multiply(e(h - 1, i - 1)));
  }

  private Z e(final int h, final int i) {
    if (i == 1) {
      return p(h - 1);
    }
    Z sum = Z.ONE;
    for (int j = 1; j < h; ++j) {
      sum = sum.add(d(j, i));
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    Z sum = bin2(p(mN).add(1));
    for (int i = 1; i <= mN / 2; ++i) {
      final int hi = mN - i;
      sum = sum.add(a(hi));
      sum = sum.subtract(bin3(d(hi, i).add(2)));
      sum = sum.subtract(bin2(d(hi, i).add(1)).multiply(e(hi, i)));
    }
    for (int i = 1; i <= (mN + 1) / 2; ++i) {
      sum = sum.add(b(mN - i + 1));
      sum = sum.subtract(bin2(d(mN - i + 1, i).add(1)));
    }
    return sum;
  }
}

#!queue	A005618	1	->	0	A005608	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005618 a(n) = 6*a(n-1) - 8.
 * @author Sean A. Irvine
 */
public class A005618 extends A005608 {

  private int mN = -1;

  @Override
  public Z next() {
    return butlerN(++mN, 2, 2);
  }
}

#!queue	A005632	0	->	1	A122693	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a122.A122693;
import irvine.oeis.a122.A122747;
import irvine.oeis.a123.A123071;

/**
 * A005632 Bishops on a 2n+1 X 2n+1 board (see Robinson paper for details).
 * @author Sean A. Irvine
 */
public class A005632 extends A122693 {

  private final Sequence mS = new A123071();
  private final Sequence mQ = new A122747();
  private long mN = -1;

  {
    next();
  }

  @Override
  public Z next() {
    ++mN;
    if ((mN & 3) == 0) {
      return super.next().subtract(mS.next()).subtract(mQ.next()).divide(4);
    } else {
      return super.next().subtract(mS.next()).divide(4);
    }
  }
}
#!queue	A005633	0	->	1	A122748	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a122.A122748;
import irvine.oeis.a123.A123071;

/**
 * A005633 Bishops on an n X n board (see Robinson paper for details).
 * @author Sean A. Irvine
 */
public class A005633 extends A122748 {

  private final Sequence mS = new A123071();
  private long mN = -1;

  {
    next();
  }

  @Override
  public Z next() {
    ++mN;
    if ((mN & 1) == 1) {
      return super.next().subtract(mS.next()).divide2();
    } else {
      return super.next().divide2();
    }
  }
}
#!queue	A005635	2	->	0	A122749	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a122.A122693;
import irvine.oeis.a122.A122747;
import irvine.oeis.a122.A122748;
import irvine.oeis.a122.A122749;

/**
 * A005635 Number of ways of placing n non-attacking bishops on an n X n board so that every square is attacked (or occupied).
 * @author Sean A. Irvine
 */
public class A005635 extends A122749 {

  private final Sequence mC = new A122693();
  private final Sequence mQ = new A122747();
  private final Sequence mM = new A122748();
  private long mN = -1;

  private Z e() {
    return mN < 2 ? Z.EIGHT : super.next();
  }

  private Z q() {
    return (mN & 7) != 1 ? Z.ZERO : mQ.next();
  }

  private Z c() {
    return (mN & 1) == 0 ? Z.ZERO : mC.next();
  }

  @Override
  public Z next() {
    ++mN;
    return e().add(c()).add(q().add(mM.next()).multiply2()).divide(8);
  }
}
#!queue	A005655	1	->	0	A005654	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005655 Number of board configurations in Mu Torere (for one player).
 * @author Sean A. Irvine
 */
public class A005655 extends A005654 {

  private A005648 mA5648 = new A005648();
  private boolean mFirst = true;

  @Override
  public Z next() {
    final Z t;
    if (mFirst) {
      t = Z.ZERO;
      mFirst = false;
    } else {
      t = super.next().multiply2();
    }
    return t.add(mA5648.next());
  }
}
#!queue	A005671	1	->	0	A002386	--------------------------------
package irvine.oeis.a005;

import irvine.math.cr.CR;
import irvine.math.cr.ComputableReals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002386;

/**
 * A005671 Nearest integer to tan(n)^2.
 * @author Sean A. Irvine
 */
public class A005671 extends A002386 {

  private long mN = -1;

  @Override
  public Z next() {
    final CR tan = ComputableReals.SINGLETON.tan(CR.valueOf(++mN));
    return tan.multiply(tan).round();
  }
}

#!queue	A005680	0	->	1	A001285	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a001.A001285;

/**
 * A005680 A squarefree ternary sequence.
 * @author Sean A. Irvine
 */
public class A005680 extends A001285 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    final Z prev = mA;
    mA = super.next();
    if (mA.equals(prev)) {
      return Z.THREE;
    }
    return mA;
  }
}
#!queue	A005681	0	->	1	A001285	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a001.A001285;

/**
 * A005681 A squarefree quaternary sequence.
 * @author Sean A. Irvine
 */
public class A005681 extends A001285 {

  private int mPrev = super.next().intValueExact();

  @Override
  public Z next() {
    final int t = mPrev;
    mPrev = super.next().intValueExact();
    switch (t * 10 + mPrev) {
      case 11:
        return Z.ONE;
      case 12:
        return Z.TWO;
      case 21:
        return Z.THREE;
      default: // 22
        return Z.FOUR;
    }
  }
}

#!queue	A005688	0	->	5	A102541	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a102.A102541;

/**
 * A005688 Numbers of Twopins positions.
 * @author Sean A. Irvine
 */
public class A005688 extends A102541 {

  private long mN = 4;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= (mN - 1) / 3; ++k) {
      sum = sum.add(t(mN - k - 1, 2 * k));
    }
    return sum;
  }
}

#!queue	A005723	0	->	1	A005190	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005723 Quadrinomial coefficients.
 * @author Sean A. Irvine
 */
public class A005723 extends A005190 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A005724	0	->	1	A008287	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a008.A008287;

/**
 * A005724 Quadrinomial coefficients.
 * @author Sean A. Irvine
 */
public class A005724 extends A008287 {

  private long mN = 0;

  @Override
  public Z next() {
    mN += 2;
    return quadrinomial(mN, 3 * mN / 2 - 1);
  }
}

#!queue	A005726	0	->	1	A008287	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a008.A008287;

/**
 * A005726 Quadrinomial coefficients.
 * @author Sean A. Irvine
 */
public class A005726 extends A008287 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return quadrinomial(mN, mN - 1);
  }
}

#!queue	A005738	0	->	1	A005616	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005738 Number of fanout-free Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A005738 extends A005616 {

  protected final ArrayList<Z> mTerms = new ArrayList<>();

  @Override
  public Z next() {
    mTerms.add(super.next());
    Z sum = Z.ZERO;
    for (int k = 0; k < mTerms.size(); ++k) {
      sum = sum.add(Binomial.binomial(mTerms.size(), k).multiply(mTerms.get(k)));
    }
    return sum;
  }

}

#!queue	A005739	0	->	1	A005738	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005739 Number of disjunctively-realizable functions of n variables.
 * @author Sean A. Irvine
 */
public class A005739 extends A005738 {

  private Z mA = super.next();
  private int mN = 0;

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return t.add(mTerms.get(++mN));
  }

}

#!queue	A005740	0	->	1	A005617	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005740 Number of fanout-free Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A005740 extends A005617 {

  protected final ArrayList<Z> mTerms = new ArrayList<>();

  @Override
  public Z next() {
    mTerms.add(super.next());
    Z sum = Z.ZERO;
    for (int k = 0; k < mTerms.size(); ++k) {
      sum = sum.add(Binomial.binomial(mTerms.size(), k).multiply(mTerms.get(k)));
    }
    return sum;
  }

}

#!queue	A005741	0	->	1	A005740	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005741 Number of fanout-free Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A005741 extends A005740 {

  private Z mA = super.next();
  private int mN = 0;

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return t.add(mTerms.get(++mN));
  }

}

#!queue	A005742	0	->	1	A005615	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A005742 Number of degenerate fanout-free Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A005742 extends A005615 {

  protected final ArrayList<Z> mTerms = new ArrayList<>();

  @Override
  public Z next() {
    mTerms.add(super.next());
    Z sum = Z.ZERO;
    for (int k = 0; k < mTerms.size(); ++k) {
      sum = sum.add(Binomial.binomial(mTerms.size(), k).multiply(mTerms.get(k)));
    }
    return sum;
  }

}

#!queue	A005743	0	->	1	A005742	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005743 Number of fanout-free Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A005743 extends A005742 {

  private Z mA = super.next();
  private int mN = 0;

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return t.add(mTerms.get(++mN));
  }

}

#!queue	A005756	1	->	2	A225171	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a225.A225171;

/**
 * A005756 Number of non-degenerate fanout-free Boolean functions of n variables having AND rank 2.
 * @author Sean A. Irvine
 */
public class A005756 extends A225171 {

  private int mN = 1;

  @Override
  public Z next() {
    return and(++mN, 2);
  }
}
#!queue	A005777	0	->	1	A259985	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a259.A259985;

/**
 * A005777 Rook polynomials.
 * @author Sean A. Irvine
 */
public class A005777 extends A259985 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return get(mN, mN - 1);
  }
}
#!queue	A005778	0	->	1	A259985	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a259.A259985;

/**
 * A005778 Rook polynomials.
 * @author Sean A. Irvine
 */
public class A005778 extends A259985 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    return get(mN, mN - 2);
  }
}
#!queue	A005850	0	->	1	A002315	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a002.A002315;

/**
 * A005850 Primes p such that the NSW number A002315((p-1)/2) is prime.
 * @author Sean A. Irvine
 */
public class A005850 extends A002315 {

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      final Z v = super.next();
      final Z p = mN.multiply2().add(1);
      if (v.isProbablePrime() && p.isProbablePrime()) {
        return p;
      }
    }
  }
}
#!queue	A005870	0	->	1	A004012	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a004.A004012;

/**
 * A005870 Numbers represented by hexagonal close-packing.
 * @author Sean A. Irvine
 */
public class A005870 extends A004012 {

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (!super.next().isZero()) {
        return mN;
      }
    }
  }
}
#!queue	A005947	1	->	0	A005946	--------------------------------
package irvine.oeis.a005;

import irvine.math.MemoryFunction2;
import irvine.math.partitions.IntegerPartition;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A005947 Tumbling distance for n-input mappings with 2 steps.
 * @author Sean A. Irvine
 */
public class A005947 extends A005946 {

  protected class QFunction extends MemoryFunction2<Integer, Q> {

    private Q lambdaPar(final int[] lambda, final int n, final int m) {
      // Eqn (20)
      Q sum = Q.ZERO;
      for (int i = 1; i <= n; ++i) {
        sum = sum.add(get(i, m - 1).multiply(i).multiply(i).add(m * (long) (n - i) * i).multiply(lambda[i]));
      }
      return sum.divide(n).divide(n);
    }

    @Override
    protected Q compute(final Integer n, final Integer m) {
      if (m == 1) {
        return new Q(n - 1, n);
      }
      if (n == 2) {
        return new Q(m + 1, 4);
      }
      final Z hnm = A005947.this.get(n, m);
      // Eqn (21) Hogg & Huberman
      Q sum = Q.ZERO;
      final IntegerPartition part = new IntegerPartition(n);
      final int[] lambda = new int[n + 1];
      int[] p;
      while ((p = part.next()) != null) {
        IntegerPartition.toCountForm(p, lambda);
        Q t = Q.ONE;
        for (int k = 1; k < lambda.length; ++k) {
          t = t.multiply(A005947.this.get(k, m - 1).pow(lambda[k]));
        }
        t = t.multiply(lambdaPar(lambda, n, m));
        t = t.multiply(FACTORIAL.factorial(n));
        t = t.divide(per(lambda));
        sum = sum.add(t);
      }
      return sum.divide(hnm);
    }
  }

  protected final QFunction mQ = new QFunction();

  @Override
  public Z next() {
//    for (int m = 1; m < 5; ++m) {
//      for (int n = 1; n < 5; ++n) {
//        System.out.println("m=" + m + " n=" + n + " " + mQ.get(n, m));
//      }
//    }
    return mQ.get(++mN, 2).multiply(get(mN, 2)).multiply(mN).toZ();
  }
}
#!queue	A005948	1	->	0	A005947	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005948 Tumbling distance for n-input mappings with 3 steps.
 * @author Sean A. Irvine
 */
public class A005948 extends A005947 {

  @Override
  public Z next() {
    return mQ.get(++mN, 3).multiply(get(mN, 3)).multiply(mN).toZ();
  }
}
#!queue	A005949	1	->	0	A005947	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;

/**
 * A005949 Tumbling distance for n-input mappings with 4 steps.
 * @author Sean A. Irvine
 */
public class A005949 extends A005947 {

  @Override
  public Z next() {
    return mQ.get(++mN, 4).multiply(get(mN, 4)).multiply(mN).toZ();
  }
}
#!queue	A005955	1	->	3	A000625	--------------------------------
package irvine.oeis.a005;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000625;

/**
 * A005955 Number of acyclic secondary alcohols with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A005955 extends A000625 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    final Polynomial<Z> a = RING.create(mT);
    final Polynomial<Z> gf = RING.pow(RING.subtract(a, RING.one()), 2, mN);
    return gf.coeff(mN);
  }
}
#!queue	A005956	1	->	4	A000625	--------------------------------
package irvine.oeis.a005;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000625;

/**
 * A005956 Number of acyclic tertiary alcohols with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A005956 extends A000625 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    final Polynomial<Z> a = RING.create(mT);
    final Polynomial<Z> gf = RING.add(RING.pow(RING.subtract(a, RING.one()), 3, mN),
      RING.multiply(RING.subtract(a.substitutePower(3, mN), RING.one()), Z.TWO));
    return gf.coeff(mN).divide(3);
  }
}
#!queue	A005958	1	->	2	A000625	--------------------------------
package irvine.oeis.a005;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000625;

/**
 * A005958 Number of esters with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A005958 extends A000625 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    final Polynomial<Z> a = RING.create(mT);
    final Polynomial<Z> gf = RING.multiply(a, RING.subtract(a, RING.one()), mN);
    return gf.coeff(mN);
  }
}
#!queue	A005959	1	->	2	A000625	--------------------------------
package irvine.oeis.a005;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000625;

/**
 * A005959 Number of acyclic ethylene derivatives with n carbon atoms.
 * @author Sean A. Irvine
 */
public class A005959 extends A000625 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);

  @Override
  public Z next() {
    super.next();
    final Polynomial<Z> a = RING.create(mT);
    final Polynomial<Z> gf = RING.add(RING.pow(a, 4, mN),
      RING.multiply(RING.pow(a.substitutePower(2, mN), 2, mN), Z.THREE));
    return gf.coeff(mN).divide(4);
  }
}
#!queue	A005981	1	->	0	A005982	--------------------------------
package irvine.oeis.a005;

/**
 * A005981 Number of 2 up, 2 down, 2 up, ... permutations of length 2n + 1.
 * @author Sean A. Irvine
 */
public class A005981 extends A005982 {

  @Override
  protected long start() {
    return 1 - size();
  }

  @Override
  protected long size() {
    return 2;
  }
}
#!queue	A005983	1	->	0	A005982	--------------------------------
package irvine.oeis.a005;

/**
 * A005983 Number of 4 up, 4 down, 4 up, ... permutations of length 4n+1.
 * @author Sean A. Irvine
 */
public class A005983 extends A005982 {

  @Override
  protected long start() {
    return -3;
  }

  @Override
  protected long size() {
    return 4;
  }
}
#!queue	A005991	2	->	1	A003509	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.a003.A003509;

/**
 * A005991 Let k(m) denote the least integer such that every m X m (0,1)-matrix with exactly k(m) ones in each row and in each column contains a 2 X 2 submatrix without zeros. The sequence gives the index n of the last term in each string of equal entries in the {k(m)} sequence (see A155934).
 * @author Sean A. Irvine
 */
public class A005991 extends A003509 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A006080	0	->	1	A003239	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a003.A003239;

/**
 * A006080 Number of rooted projective plane trees with n nodes.
 * @author Sean A. Irvine
 */
public class A006080 extends A003239 {

  @Override
  public Z next() {
    return Z.ONE.max(super.next().divide2().add(Z.ONE.shiftLeft(mN - 2)));
  }
}

#!queue	A006082	0	->	1	A006080	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000108;

/**
 * A006082 Number of labeled projective plane trees (or "flat" trees) with n nodes.
 * @author Sean A. Irvine
 */
public class A006082 extends A006080 {

  private long mN = 0;
  private final A006081 mA6081 = new A006081();
  private final A000108 mA108 = new A000108();

  @Override
  public Z next() {
    final Z t = ++mN > 1 ? mA6081.next() : Z.ZERO;
    final Z u = (mN & 1) == 0 ? mA108.next() : Z.ZERO;
    return super.next().subtract(t).add(u);
  }
}

#!queue	A006141	0	->	1	A003114	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a003.A003106;
import irvine.oeis.a003.A003114;

/**
 * A006141 Number of integer partitions of n whose smallest part is equal to the number of parts.
 * @author Sean A. Irvine
 */
public class A006141 extends A003114 {

  private A003106 mOther = new A003106();

  {
    next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mOther.next());
  }
}
#!queue	A006152	0	->	1	A000262	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000262;

/**
 * A006152 Exponential generating function x*exp(x/(1-x)).
 * @author Sean A. Irvine
 */
public class A006152 extends A000262 {

  private long mN = 0;

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}

#!queue	A006197	0	->	1	A000984	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A006197 Least number not dividing binomial(2n,n).
 * @author Sean A. Irvine
 */
public class A006197 extends A000984 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z a = super.next();
    long k = 1;
    while (a.mod(++k) == 0) {
      // do nothing
    }
    return Z.valueOf(k);
  }
}
#!queue	A006198	0	->	1	A000806	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000806;

/**
 * A006198 Number of partitions into pairs.
 * @author Sean A. Irvine
 */
public class A006198 extends A000806 {

  private Z mA = super.next().abs();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next().abs();
    return mA.add(t);
  }
}
#!queue	A006199	0	->	1	A000806	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000806;

/**
 * A006199 Bessel polynomial {y_n}'(-1).
 * @author Sean A. Irvine
 */
public class A006199 extends A000806 {

  private Z mA = super.next();
  private long mN = -1;

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.add(t.multiply(++mN));
  }
}
#!queue	A006200	0	->	1	A079267	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a079.A079267;

/**
 * A006200 Number of partitions into pairs.
 * @author Sean A. Irvine
 */
public class A006200 extends A079267 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3);
  }
}
#!queue	A006220	3	->	1	A006219	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006220 From descending subsequences of permutations.
 * @author Sean A. Irvine
 */
public class A006220 extends A006219 {

  private int mN = 0;

  @Override
  public Z next() {
    return f(++mN, mN);
  }
}
#!queue	A006230	0	->	4	A000392	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000392;

/**
 * A006230 Bitriangular permutations.
 * @author Sean A. Irvine
 */
public class A006230 extends A000392 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(12).add(1);
  }
}
#!queue	A006231	0	->	1	A000522	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000522;

/**
 * A006231 a(n) = Sum_{k=2..n} n(n-1)...(n-k+1)/k.
 * @author Sean A. Irvine
 */
public class A006231 extends A000522 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    mA = mA.add(super.next()).subtract(1);
    return mA;
  }
}
#!queue	A006297	0	->	2	A269920	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A006297 Number of rooted genus-1 maps with n edges.
 * @author Sean A. Irvine
 */
public class A006297 extends A269920 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN, 1, (mN + 1) / 2);
  }
}
#!queue	A006299	0	->	4	A269920	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A006299 Number of rooted genus-2 maps with n edges.
 * @author Sean A. Irvine
 */
public class A006299 extends A269920 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2, (mN - 1) / 2);
  }
}
#!queue	A006300	0	->	2	A269920	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A006300 Number of rooted maps with n edges on torus.
 * @author Sean A. Irvine
 */
public class A006300 extends A269920 {

  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 1, k));
    }
    return sum;
  }
}
#!queue	A006312	2	->	3	A006308	--------------------------------
package irvine.oeis.a006;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A006312 Discriminants of period polynomials.
 * @author Sean A. Irvine
 */
public class A006312 extends A006308 {

//  private CR p(final int p, final int q, final int k) {
//    CR pk = CR.ONE;
//    for (int i = 0; i < p; ++i) {
//      pk = pk.multiply(etaStar(p, q, i).subtract(etaStar(p, q, i + k)));
//    }
//    return pk;
//  }

  @Override
  public Z next() {
    mP = (int) mPrime.nextPrime(mP);
    final long p2 = mP * mP;
    final Z g = ZUtils.leastPrimitiveRoot(Z.valueOf(p2));
    final int q = g.modPow(Z.valueOf(mP), Z.valueOf(p2)).intValueExact();
    final CR[] etaStar = new CR[mP];
    for (int i = 0; i < etaStar.length; ++i) {
      etaStar[i] = etaStar(mP, q, i);
    }
    // The paper gives multiple expressions for D, some where the individual
    // terms in the product are squared.  But it seems to me that the
    // squaring is unnecessary except strangely for p == 3.
    CR d = CR.ONE;
    for (int i = 0; i < mP; ++i) {
      for (int j = i + 1; j < mP; ++j) {
        d = d.multiply(etaStar[i].subtract(etaStar[j]));
      }
    }
    final Z z = d.toZ();
    return mP == 3 ? z.square() : z.abs();
  }
}

#!queue	A006326	0	->	3	A079502	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a079.A079502;

/**
 * A006326 Total preorders.
 * @author Sean A. Irvine
 */
public class A006326 extends A079502 {

  private int mN = 2;

  @Override
  public Z next() {
    return u(++mN, mN - 1);
  }
}

#!queue	A006328	0	->	3	A079502	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a079.A079502;

/**
 * A006328 Total preorders.
 * @author Sean A. Irvine
 */
public class A006328 extends A079502 {

  private int mN = 3;

  @Override
  public Z next() {
    return u(++mN, 4);
  }
}

#!queue	A006329	0	->	3	A079502	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a079.A079502;

/**
 * A006329 Total preorders.
 * @author Sean A. Irvine
 */
public class A006329 extends A079502 {

  private int mN = 3;

  @Override
  public Z next() {
    return u(++mN, mN - 2);
  }
}

#!queue	A006351	0	->	1	A000311	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000311;

/**
 * A006351 Number of series-parallel networks with n labeled edges. Also called yoke-chains by Cayley and MacMahon.
 * @author Sean A. Irvine
 */
public class A006351 extends A000311 {

  {
    super.next();
    super.next();
  }

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().multiply2();
  }
}

#!queue	A006352	1	->	0	A000203	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A006352 Coefficients in expansion of Eisenstein series E_2 (also called E_1 or G_2).
 * @author Sean A. Irvine
 */
public class A006352 extends A000203 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().multiply(-24);
  }
}

#!queue	A006380	1	->	0	A000721	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000721;

/**
 * A006380 Number of equivalence classes of 4 X n binary matrices when one can permute rows, permute columns and complement columns.
 * @author Sean A. Irvine
 */
public class A006380 extends A000721 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  protected Z t(final int n, final int m) {
    if (n == 0) {
      return Z.ONE;
    }
    final CycleIndex ci = f(n);
    final ArrayList<Polynomial<Q>> polys = new ArrayList<>();
    for (int k = 1; k <= Z.ONE.shiftLeft(n).min(Z.valueOf(m)).longValueExact(); ++k) {
      polys.add(RING.series(RING.one(), RING.oneMinusXToTheN(k), m));
    }
    final Polynomial<Q> p = ci.apply(polys, Z.valueOf(m));
    return p.coeff(m).toZ();
  }

  private int mN = -1;

  @Override
  public Z next() {
    return t(++mN, 4);
  }
}
#!queue	A006381	1	->	0	A006380	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006381 Number of n X 3 binary matrices under row and column permutations and column complementations.
 * @author Sean A. Irvine
 */
public class A006381 extends A006380 {

  private int mM = -1;

  @Override
  public Z next() {
    return t(3, ++mM);
  }
}
#!queue	A006382	1	->	0	A006380	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006382 Number of n X 4 binary matrices under row and column permutations and column complementations.
 * @author Sean A. Irvine
 */
public class A006382 extends A006380 {

  private int mM = -1;

  @Override
  public Z next() {
    return t(4, ++mM);
  }
}
#!queue	A006383	1	->	0	A006380	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006383 Number of equivalence classes of n X n binary matrices when one can permute rows, permute columns and complement columns.
 * @author Sean A. Irvine
 */
public class A006383 extends A006380 {

  private int mM = -1;

  @Override
  public Z next() {
    return t(++mM, mM);
  }
}
#!queue	A006386	0	->	2	A006387	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006386 Number of unrooted maps with n edges on the torus.
 * @author Sean A. Irvine
 */
public class A006386 extends A006387 {

  private int mN = 1;

  @Override
  public Z next() {
    count(1, ++mN, 1, mN + 1, false);
    return Z.valueOf(mSums[1]);
  }
}
#!queue	A006388	0	->	1	A006385	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006388 Number of planar maps with n edges and without faces of degree 1.
 * @author Sean A. Irvine
 */
public class A006388 extends A006385 {

  protected boolean isBracketPair(final int start, final int end) {
    return isPair(start, end, OPEN_BRACKET, CLOSE_BRACKET);
  }

  @Override
  protected boolean reject(final int e) {
    // Reject anything containing an adjacent pair of brackets
    for (int k = 2; k <= 2 * e; ++k) {
      if (mS[k - 1] == OPEN_BRACKET && mS[k] == CLOSE_BRACKET) {
        return true;
      }
    }
    return isBracketPair(1, 2 * e);
  }

  @Override
  public Z next() {
    planarCount(1, ++mN + 1, 1, mN + 2, mVerbose);
    return Z.valueOf(mTotalSensed);
  }
}
#!queue	A006389	0	->	1	A006388	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006389 Number of unsensed planar maps with n edges and without faces of degree 1.
 * @author Sean A. Irvine
 */
public class A006389 extends A006388 {

  private int mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(planarCount(2, ++mN, 1, mN + 1, mVerbose));
  }
}
#!queue	A006391	0	->	1	A006385	--------------------------------
package irvine.oeis.a006;

/**
 * A006391 Number of unsensed planar maps with n edges and without loops.
 * @author Sean A. Irvine
 */
public class A006391 extends A006385 {

  {
    next();
  }

  static boolean hasLoop(final int e, final int[] s) {
    for (int k = 1; k <= 2 * e; ++k) {
      if (s[k] == OPEN_BRACKET) {
        int bopen = 1;
        int popen = 0;
        for (int j = k + 1; j <= 2 * e; ++j) {
          if (s[j] == CLOSE_BRACKET && --bopen == 0) {
            if (popen == 0) {
              return true;
            } else {
              break;
            }
          } else if (s[j] == OPEN_PAREN) {
            ++popen;
          } else if (s[j] == OPEN_BRACKET) {
            ++bopen;
          } else if (s[j] == CLOSE_PAREN && --popen < 0) {
            break;
          }
        }
      }
    }
    return false;
  }
  @Override
  protected boolean reject(final int e) {
    return hasLoop(e, mS);
  }
}
#!queue	A006392	0	->	2	A006388	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006392 Number of planar maps with n edges and without faces of degree 1 or 2.
 * @author Sean A. Irvine
 */
public class A006392 extends A006388 {

  @Override
  protected boolean reject(final int e) {
    if (super.reject(e)) {
      return true;
    }
    if (mS[1] == OPEN_PAREN && isBracketPair(2, 2 * e)) {
      return true;
    }
    for (int k = 3; k <= 2 * e; ++k) {
      if (mS[k - 2] == OPEN_BRACKET && mS[k - 1] == CLOSE_PAREN && mS[k] == CLOSE_BRACKET) {
        return true;
      }
    }
    for (int k = 1; k < 2 * e; ++k) {
      if (mS[k] == OPEN_BRACKET && mS[k + 1] == OPEN_BRACKET) {
        for (int j = k + 3; j <= 2 * e; ++j) {
          if (isBracketPair(k, j) && isBracketPair(k + 1, j - 1)) {
            return true;
          }
        }
      }
    }
    return false;
  }

  private int mN = 1;

  @Override
  public Z next() {
    planarCount(1, ++mN, 1, mN + 1, mVerbose);
    return Z.valueOf(mTotalSensed);
  }
}
#!queue	A006393	0	->	2	A006392	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006393 Number of unsensed planar maps with n edges and without faces of degree 1 or 2.
 * @author Sean A. Irvine
 */
public class A006393 extends A006392 {

  private int mN = 1;

  @Override
  public Z next() {
    return Z.valueOf(planarCount(2, ++mN, 1, mN + 1, mVerbose));
  }
}
#!queue	A006394	0	->	1	A006395	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006394 Number of connected planar maps with n nodes and without loops or parallel edges.
 * @author Sean A. Irvine
 */
public class A006394 extends A006395 {

  @Override
  public Z next() {
    planarCount(1, ++mN, 1, mN + 1, mVerbose);
    return Z.valueOf(mTotalSensed);
  }
}
#!queue	A006395	0	->	1	A006385	--------------------------------
package irvine.oeis.a006;

import java.util.HashSet;

import irvine.util.Pair;

/**
 * A006395 Number of unsensed connected planar maps with n nodes and without loops or parallel edges.
 * @author Sean A. Irvine
 */
public class A006395 extends A006385 {

  /** Construct the sequence. */
  public A006395() {
    next();
  }

  private final HashSet<Pair<Integer, Integer>> mSeen = new HashSet<>();

  @Override
  protected boolean rejectDecode(final int e, final int[] vert) {
    mSeen.clear();
    for (int k = 1; k <= e; ++k) {
      final int j = 2 * e + 1 - k;
      final int vk = vert[k];
      final int vj = vert[j];
      if (vk == vj) {
        return true; // loop
      }
      if (!mSeen.add(new Pair<>(Math.min(vk, vj), Math.max(vk, vj)))) {
        return true; // parallel
      }
    }
    return false;
  }
}
#!queue	A006396	0	->	2	A006388	--------------------------------
package irvine.oeis.a006;

/**
 * A006396 Number of planar maps with n edges and without faces or vertices of degree 1.
 * @author Sean A. Irvine
 */
public class A006396 extends A006388 {

  /** Construct the sequence. */
  public A006396() {
    next();
  }

  protected boolean isParenthesisPair(final int start, final int end) {
    return isPair(start, end, OPEN_PAREN, CLOSE_PAREN);
  }

  @Override
  protected boolean reject(final int e) {
    // Reject anything containing an adjacent pair of brackets or parentheses
    for (int k = 1; k <= 2 * e; ++k) {
      if (mS[k - 1] == OPEN_BRACKET && mS[k] == CLOSE_BRACKET) {
        return true;
      }
      if (mS[k - 1] == OPEN_PAREN && mS[k] == CLOSE_PAREN) {
        return true;
      }
    }
    return isBracketPair(1, 2 * e) || isParenthesisPair(1, 2 * e);
  }
}
#!queue	A006397	0	->	2	A006396	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006397 Number of unsensed planar maps with n edges and without faces or vertices of degree 1.
 * @author Sean A. Irvine
 */
public class A006397 extends A006396 {

  @Override
  public Z next() {
    return Z.valueOf(planarCount(2, ++mN + 1, 1, mN + 1, mVerbose));
  }
}
#!queue	A006398	0	->	2	A006399	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006398 Number of planar maps with n edges and without loops or isthmuses.
 * @author Sean A. Irvine
 */
public class A006398 extends A006399 {

  @Override
  public Z next() {
    planarCount(1, ++mN, 1, mN, mVerbose);
    return Z.valueOf(mTotalSensed);
  }
}
#!queue	A006399	0	->	2	A006391	--------------------------------
package irvine.oeis.a006;

/**
 * A006399 Number of unsensed planar maps with n edges and without loops or isthmuses.
 * @author Sean A. Irvine
 */
public class A006399 extends A006391 {

  {
    next();
  }

  static boolean hasIsthmus(final int e, final int[] s) {
    for (int k = 1; k < 2 * e; ++k) {
      if (s[k] == OPEN_PAREN) {
        int popen = 1;
        int bopen = 0;
        for (int j = k + 1; j <= 2 * e; ++j) {
          if (s[j] == CLOSE_PAREN && --popen == 0) {
            if (bopen == 0) {
              return true;
            } else {
              break;
            }
          } else if (s[j] == OPEN_BRACKET) {
            ++bopen;
          } else if (s[j] == OPEN_PAREN) {
            ++popen;
          } else if (s[j] == CLOSE_BRACKET && --bopen < 0) {
            break;
          }
        }
      }
    }
    return false;
  }

  @Override
  protected boolean reject(final int e) {
    return super.reject(e) || hasIsthmus(e, mS);
  }

}
#!queue	A006400	0	->	3	A006394	--------------------------------
package irvine.oeis.a006;

/**
 * A006400 Number of connected planar maps without vertices of degree 1.
 * @author Sean A. Irvine
 */
public class A006400 extends A006394 {

  /** Construct the sequence. */
  public A006400() {
    next();
    next();
  }

  protected boolean isParenthesisPair(final int start, final int end) {
    return isPair(start, end, OPEN_PAREN, CLOSE_PAREN);
  }

  @Override
  protected boolean reject(final int e) {
    // Reject anything containing an adjacent pair of brackets or parentheses
    for (int k = 1; k <= 2 * e; ++k) {
      if (mS[k - 1] == OPEN_PAREN && mS[k] == CLOSE_PAREN) {
        return true;
      }
    }
    return isParenthesisPair(1, 2 * e);
  }
}
#!queue	A006401	0	->	3	A006400	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006401 Number of connected planar maps without vertices of degree 1.
 * @author Sean A. Irvine
 */
public class A006401 extends A006400 {

  @Override
  public Z next() {
    return Z.valueOf(planarCount(2, ++mN, 1, mN, mVerbose));
  }
}
#!queue	A006402	0	->	2	A000139	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000139;

/**
 * A006402 Number of sensed 2-connected (nonseparable) planar maps with n edges.
 * @author Sean A. Irvine
 */
public class A006402 extends A000139 {

  private final ArrayList<Z> mB = new ArrayList<>();
  {
    mB.add(null);
    mB.add(super.next());
  }

  @Override
  public Z next() {
    final int n = mB.size();
    mB.add(super.next());
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(n).divisors()) {
      final int d = dd.intValue();
      if (d != n) {
        sum = sum.add(mB.get(d).multiply(Euler.phiAsLong(n / d)).multiply(9L * d * d - 9L * d + 2L));
      }
    }
    sum = sum.add(mB.get(n).multiply2()).divide(n);
    sum = sum.add((n & 1) == 0 ? mB.get(n / 2).multiply(3 * n - 4).divide(4) : mB.get((n + 1) / 2).multiply(n + 1));
    return sum.divide(4);
  }
}
#!queue	A006403	0	->	1	A006385	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006403 Number of 2-connected planar maps with n edges.
 * @author Sean A. Irvine
 */
public class A006403 extends A006385 {

  static boolean hasCutVertex(final int e, final int[] s) {
    for (int k = 1; k <= 2 * e; ++k) {
      if (s[k] == OPEN_BRACKET || s[k] == OPEN_PAREN) {
        int bopen = s[k] == OPEN_BRACKET ? 1 : 0;
        int popen = 1 - bopen;
        for (int j = k + 1; j <= 2 * e; ++j) {
          if (popen < 0 || bopen < 0) {
            break;
          }
          if (popen == 0 && bopen == 0) {
            if (k != 1 || j != 2 * e) {
              return true;
            }
          }
          switch (s[j]) {
            case OPEN_BRACKET:
              ++bopen;
              break;
            case CLOSE_BRACKET:
              --bopen;
              break;
            case OPEN_PAREN:
              ++popen;
              break;
            case CLOSE_PAREN:
              --popen;
              break;
            default:
              throw new RuntimeException();
          }
        }
      }
    }
    return false;
  }

  @Override
  protected boolean reject(final int e) {
    // Check for a cut-vertex
    return hasCutVertex(e, mS);
  }

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ZERO;
    }
    return Z.valueOf(planarCount(2, mN, 2, mN, mVerbose));
  }
}
#!queue	A006404	0	->	3	A006392	--------------------------------
package irvine.oeis.a006;

/**
 * A006404 Number of 2-connected maps without faces of degree 2.
 * @author Sean A. Irvine
 */
public class A006404 extends A006392 {

  {
    next();
  }

  @Override
  protected boolean reject(final int e) {
    return super.reject(e) || A006403.hasCutVertex(e, mS);
  }
}
#!queue	A006405	0	->	3	A006393	--------------------------------
package irvine.oeis.a006;

/**
 * A006405 Number of unsensed 2-connected maps without faces of degree 2.
 * @author Sean A. Irvine
 */
public class A006405 extends A006393 {

  {
    next();
  }

  @Override
  protected boolean reject(final int e) {
    return super.reject(e) || A006403.hasCutVertex(e, mS);
  }
}
#!queue	A006406	0	->	3	A006394	--------------------------------
package irvine.oeis.a006;

/**
 * A006406 Number of 2-connected planar maps with n edges (see reference for precise definition).
 * @author Sean A. Irvine
 */
public class A006406 extends A006394 {

  {
    next();
    next();
  }

  @Override
  protected boolean reject(final int e) {
    return super.reject(e) || A006403.hasCutVertex(e, mS);
  }
}
#!queue	A006407	0	->	3	A006395	--------------------------------
package irvine.oeis.a006;

/**
 * A006407 Number of unsensed 2-connected planar maps with n edges.
 * @author Sean A. Irvine
 */
public class A006407 extends A006395 {

  {
    next();
    next();
  }

  @Override
  protected boolean reject(final int e) {
    return super.reject(e) || A006403.hasCutVertex(e, mS);
  }
}
#!queue	A006420	0	->	2	A006398	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006420 Number of rooted planar maps with 3 vertices and n faces and no isthmuses.
 * @author Sean A. Irvine
 */
public class A006420 extends A006398 {

  @Override
  protected boolean reject(final int e) {
    return hasIsthmus(e, mS);
  }

  @Override
  public Z next() {
    planarCount(0, ++mN + 1, 3, 3, mVerbose);
    return Z.valueOf(mTotal);
  }
}
#!queue	A006421	0	->	2	A006398	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006421 Number of rooted planar maps with 4 vertices and n faces and no isthmuses.
 * @author Sean A. Irvine
 */
public class A006421 extends A006398 {

  @Override
  protected boolean reject(final int e) {
    return hasIsthmus(e, mS);
  }

  @Override
  public Z next() {
    planarCount(0, ++mN + 2, 4, 4, mVerbose);
    return Z.valueOf(mTotal);
  }
}
#!queue	A006425	2	->	1	A343092	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a343.A343092;

/**
 * A006425 Number of rooted toroidal maps with 2 vertices and n faces and no isthmuses.
 * @author Sean A. Irvine
 */
public class A006425 extends A343092 {

  private int mN = 2;

  @Override
  public Z next() {
    return h(++mN, 1).coeff(mN - 3).toZ();
  }
}
#!queue	A006426	2	->	1	A343092	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a343.A343092;

/**
 * A006426 Number of rooted toroidal maps with 3 vertices and n faces and no isthmuses.
 * @author Sean A. Irvine
 */
public class A006426 extends A343092 {

  private int mN = 3;

  @Override
  public Z next() {
    return h(++mN, 1).coeff(mN - 4).toZ();
  }
}
#!queue	A006427	2	->	1	A343092	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a343.A343092;

/**
 * A006427 Number of rooted toroidal maps with 4 vertices and n faces and no isthmuses.
 * @author Sean A. Irvine
 */
public class A006427 extends A343092 {

  private int mN = 4;

  @Override
  public Z next() {
    return h(++mN, 1).coeff(mN - 5).toZ();
  }
}
#!queue	A006432	0	->	1	A342987	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a342.A342987;

/**
 * A006432 Number of tree-rooted planar maps with 3 vertices and n faces and no isthmuses.
 * @author Sean A. Irvine
 */
public class A006432 extends A342987 {

  private int mN = 1;

  @Override
  public Z next() {
    return h(++mN).coeff(mN - 2);
  }
}
#!queue	A006433	0	->	1	A342987	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a342.A342987;

/**
 * A006433 Number of tree-rooted planar maps with 4 vertices and n faces and no isthmuses.
 * @author Sean A. Irvine
 */
public class A006433 extends A342987 {

  private int mN = 2;

  @Override
  public Z next() {
    return h(++mN).coeff(mN - 3);
  }
}
#!queue	A006447	0	->	1	A170896	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a170.A170896;
import irvine.util.Pair;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A006447 Consider a 2-D cellular automaton generated by the Schrandt-Ulam rule of A170896, but confined to a semi-infinite strip of width n, starting with one ON cell at the top left corner; a(n) is the period of the resulting structure.
 * @author Sean A. Irvine
 */
public class A006447 extends A170896 {

  private int mN = 0;

  @Override
  protected boolean accept(final Pair<Integer, Integer> pt) {
    return pt.left() >= 0 && pt.right() >= 0 && pt.right() < mN;
  }

  @Override
  public Z next() {
    mN++;
    reset();
    // Might be better to convert each column of image into an integer and look for period of that sequence
    final LongDynamicBooleanArray[] plane = new LongDynamicBooleanArray[mN];
    for (int k = 0; k < mN; ++k) {
      plane[k] = new LongDynamicBooleanArray();
    }
    int iter = -1;
    for (int k = 0; k < 2 * mN; ++k) {
      // A little initial run up before we even begin looking
      stepAutomata(plane);
    }
    while (true) {
      ++iter;
      stepAutomata(plane);
      for (int period = 1; period < iter; ++period) {
        boolean ok = true;
        final int start = iter / 2;
        for (int i = 0; i < mN; ++i) {
          if (plane[i].isSet(start) != plane[i].isSet(start + period) || plane[i].isSet(start) != plane[i].isSet(start + 2 * period)) {
            ok = false;
            break;
          }
        }
        if (ok) {
          // Do a more careful check
          for (int s = start + 1; s < period; ++s) {
            for (int i = 0; i < mN; ++i) {
              if (plane[i].isSet(start) != plane[i].isSet(start + period)) {
                ok = false;
                break;
              }
            }
          }
          if (ok) {
            return Z.valueOf(period);
          }
        }
      }
    }
  }

  private void stepAutomata(final LongDynamicBooleanArray[] plane) {
    super.next();
    for (final Pair<Integer, Integer> pt : mNewlyOn) {
      plane[pt.right()].set(pt.left());
    }
  }
}
#!queue	A006468	0	->	1	A006398	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006468 Number of rooted planar maps with 4 faces and n vertices and no isthmuses.
 * @author Sean A. Irvine
 */
public class A006468 extends A006398 {

  @Override
  protected boolean reject(final int e) {
    return hasIsthmus(e, mS);
  }

  @Override
  public Z next() {
    ++mN;
    planarCount(0, mN + 1, mN - 1, mN - 1, mVerbose);
    return Z.valueOf(mTotal);
  }
}
#!queue	A006539	1	->	0	A006540	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;

/**
 * A006539 Numerators of worst case for Engel expansion.
 * @author Sean A. Irvine
 */
public class A006539 extends A006540 {

  @Override
  public Z next() {
    super.next();
    return Z.valueOf(mMinB.get(mN));
  }

}
#!queue	A006540	1	->	0	A006538	--------------------------------
package irvine.oeis.a006;

/**
 * A006540 Denominators of worst case for Engel expansion.
 * @author Sean A. Irvine
 */
public class A006540 extends A006538 {

  @Override
  protected long v(final long a, final long k) {
    return (k - a % k) % k;
  }
}
#!queue	A006572	1	->	0	A111999	--------------------------------
package irvine.oeis.a006;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a111.A111999;

/**
 * A006572 Numerators of an asymptotic expansion for the number of forests on n nodes (A001858).
 * @author Sean A. Irvine
 */
public class A006572 extends A111999 {

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = -1;

  protected Z select(final Q n) {
    return n.num();
  }

  @Override
  public Z next() {
    ++mN;
    Q sum = Q.ZERO;
    for (int k = 1; k <= mN / 2; ++k) {
      final Q v = new Q(get((long) mN, 2L * k - 1).abs(), mF.factorial(mN - k).shiftLeft(mN - k));
      sum = sum.signedAdd((k & 1) != 0, v);
      //System.out.println(mN + " k= " + k + " adding " + v + " sum now: " + sum);
    }
    return select(sum);
  }
}
#!queue	A006573	1	->	0	A006572	--------------------------------
package irvine.oeis.a006;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A006573 Denominators of an asymptotic expansion for the number of forests on n nodes (A001858).
 * @author Sean A. Irvine
 */
public class A006573 extends A006572 {

  @Override
  protected Z select(final Q n) {
    return n.den();
  }
}
#!queue	A006589	0	->	-1	A001792	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a001.A001792;

/**
 * A006589 a(n) = (n+3)*2^n - 1.
 * @author Sean A. Irvine
 */
public class A006589 extends A001792 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A006614	3	->	4	A006613	--------------------------------
package irvine.oeis.a006;

/**
 * A006614 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006614 extends A006613 {

  @Override
  protected int j() {
    return 4;
  }
}

#!queue	A006615	3	->	4	A006614	--------------------------------
package irvine.oeis.a006;

/**
 * A006615 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006615 extends A006614 {

  @Override
  protected boolean isZarankiewicz(final long[] matrix) {
    // Check exists a 3xj submatrix all ones
    for (int row1 = 0; row1 < matrix.length - 2; ++row1) {
      final long r1 = matrix[row1];
      if ((long) Long.bitCount(r1) >= j()) {
        for (int row2 = row1 + 1; row2 < matrix.length - 1; ++row2) {
          final long r2 = matrix[row2] & r1;
          if ((long) Long.bitCount(r2) >= j()) {
            for (int row3 = row2 + 1; row3 < matrix.length; ++row3) {
              final long r3 = matrix[row3] & r2;
              if ((long) Long.bitCount(r3) >= j()) {
                // Found 3 rows with at least j ones in same place, hence exist column selection
                return true;
              }
            }
          }
        }
      }
    }
    return false;
  }
}

#!queue	A006616	3	->	4	A006614	--------------------------------
package irvine.oeis.a006;

/**
 * A006616 Zarankiewicz's problem k_4(n).
 * @author Sean A. Irvine
 */
public class A006616 extends A006614 {

  @Override
  protected boolean isZarankiewicz(final long[] matrix) {
    // Check exists a 4xj submatrix all ones
    for (int row1 = 0; row1 < matrix.length - 3; ++row1) {
      final long r1 = matrix[row1];
      if ((long) Long.bitCount(r1) >= j()) {
        for (int row2 = row1 + 1; row2 < matrix.length - 2; ++row2) {
          final long r2 = matrix[row2] & r1;
          if ((long) Long.bitCount(r2) >= j()) {
            for (int row3 = row2 + 1; row3 < matrix.length - 1; ++row3) {
              final long r3 = matrix[row3] & r2;
              if ((long) Long.bitCount(r3) >= j()) {
                for (int row4 = row3 + 1; row4 < matrix.length; ++row4) {
                  final long r4 = matrix[row4] & r3;
                  if ((long) Long.bitCount(r4) >= j()) {
                    // Found 4 rows with at least j ones in same place, hence exist column selection
                    return true;
                  }
                }
              }
            }
          }
        }
      }
    }
    return false;
  }
}

#!queue	A006617	3	->	2	A006613	--------------------------------
package irvine.oeis.a006;

/**
 * A006617 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006617 extends A006613 {

  @Override
  protected int cols() {
    return mN + 1;
  }

  @Override
  protected int init() {
    return 1;
  }
}

#!queue	A006619	3	->	2	A006614	--------------------------------
package irvine.oeis.a006;

/**
 * A006619 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006619 extends A006614 {

  @Override
  protected int init() {
    return 1;
  }

  @Override
  protected int cols() {
    return mN + 2;
  }
}

#!queue	A006620	3	->	2	A006613	--------------------------------
package irvine.oeis.a006;

/**
 * A006620 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006620 extends A006613 {

  @Override
  protected int j() {
    return 2;
  }

  @Override
  protected int cols() {
    return mN + 1;
  }
}

#!queue	A006623	3	->	4	A006613	--------------------------------
package irvine.oeis.a006;

/**
 * A006623 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006623 extends A006613 {

  @Override
  protected int cols() {
    return mN - 1;
  }

  @Override
  protected int init() {
    return 3;
  }
}

#!queue	A006624	3	->	2	A006614	--------------------------------
package irvine.oeis.a006;

/**
 * A006624 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006624 extends A006614 {

  @Override
  protected int init() {
    return 1;
  }

  @Override
  protected int cols() {
    return mN + 3;
  }
}

#!queue	A006626	3	->	4	A006616	--------------------------------
package irvine.oeis.a006;

/**
 * A006626 Zarankiewicz's problem k_4(n,n+1).
 * @author Sean A. Irvine
 */
public class A006626 extends A006616 {

  @Override
  protected int cols() {
    return mN + 1;
  }
}

#!queue	A006647	1	->	4	A001430	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001430;
import irvine.oeis.a001.A001433;

/**
 * A006647 Number of graphs with n nodes, n-2 edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006647 extends A001430 {

  private Sequence mA = new A001433();
  {
    mA.next();
    mA.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A006648	1	->	2	A001433	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001433;
import irvine.oeis.a001.A001434;

/**
 * A006648 Number of graphs with n nodes, n-1 edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006648 extends A001433 {

  private Sequence mA = new A001434();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A006649	1	->	3	A001434	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001434;
import irvine.oeis.a048.A048179;

/**
 * A006649 Number of graphs with n nodes, n edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006649 extends A001434 {

  private int mN = 2;
  private Sequence mA = new A048179();
  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(++mN < 5 ? Z.ZERO : mA.next());
  }
}
#!queue	A006650	1	->	4	A048179	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a048.A048179;
import irvine.oeis.a048.A048180;

/**
 * A006650 Number of graphs with n nodes, n+1 edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006650 extends A048179 {

  private boolean mFirst = true;
  private Sequence mA = new A048180();

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return super.next();
    }
    return super.next().subtract(mA.next());
  }
}
#!queue	A006651	1	->	4	A001430	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001430;
import irvine.oeis.a048.A048180;

/**
 * A006651 Number of graphs with n nodes, n+2 edges and no isolated vertices.
 * @author Sean A. Irvine
 */
public class A006651 extends A001430 {

  private Sequence mA = new A048180();

  @Override
  public Z next() {
    return mA.next().subtract(numberLinearGraphs(++mN + 2, mN + 5));
  }
}
#!queue	A006657	0	->	2	A005316	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;
import java.util.Collections;

import irvine.math.z.Z;
import irvine.oeis.a005.A005316;
import irvine.util.Pair;

/**
 * A006657 Number of closed meanders with 2 components and 2n bridges.
 * @author Andrew Howroyd
 * @author Sean A. Irvine (Java port)
 */
public class A006657 extends A005316 {

  /**
   * Processing component to count meander systems or semi-meander systems by number of component.
   * A006657, A006658, A008828, A046721, A046726
   */
  public static class MeandersByComponents extends MeanderProblem implements StateMachine<Pair<Integer, Z>> {
    private final Z mLimit;
    private final Integer mMaxComponents;
    private final int mRemainingBridges;

    /**
     * Construct meanders by components.
     * @param remainingBridges remaining bridges
     * @param maxComponents maximum number of components
     */
    public MeandersByComponents(final int remainingBridges, final Integer maxComponents) {
      super(remainingBridges);
      mRemainingBridges = remainingBridges;
      mLimit = Z.ONE.shiftLeft(2 + (WORD_SHIFT * remainingBridges));
      mMaxComponents = remainingBridges == 0 || maxComponents == null ? null : maxComponents - 1;
    }

    /**
     * Initial states for semi-meander systems.
     * @param windingPredicate winding predicate
     * @return initial states
     */
    public Iterable<Pair<Integer, Z>> semiMeanderInitialStates(final Func<Integer, Boolean> windingPredicate) {
      final ArrayList<Pair<Integer, Z>> res = new ArrayList<>();
      Z bits = Z.ONE;
      Z state = pack(bits, bits);
      int winding = 0;
      while (state.compareTo(mLimit) < 0) {
        if ((winding & 1) == (mRemainingBridges & 1) && (windingPredicate == null || windingPredicate.f(winding))) {
          res.add(new Pair<>(0, state));
        }
        ++winding;
        bits = bits.shiftLeft(WORD_SHIFT).or(Z.ONE);
        state = pack(bits, bits);
      }
      return res;
    }

    @Override
    public Iterable<Pair<Integer, Z>> enumerate(final Pair<Integer, Z> state) {
      final int n = state.left();
      final ArrayList<Pair<Integer, Z>> res = new ArrayList<>();
      for (final Pair<Integer, Z> next : enumeratePossibilities(state.right(), (action, lower, upper) -> new Pair<>(action == Action.CLOSE_LOOP ? n + 1 : n, packSymmetrical(lower, upper)))) {
        if ((mLimit.signum() < 0 || next.right().compareTo(mLimit) < 0) && (mMaxComponents == null || state.left() <= mMaxComponents)) {
          res.add(next);
        }
      }
      return res;
    }
  }

  private int mN = components() * 2 - 2;

  protected Iterable<Pair<Integer, Z>> initialStates(final MeandersByComponents mbc) {
    // Initial states for closed meander systems.
    return Collections.singleton(new Pair<>(0, DEFAULT_INITIAL_STATE));
  }

  protected int components() {
    return 2;
  }

  @Override
  public Z next() {
    mN += 2;
    final SimpleProcessor<Pair<Integer, Z>> processor = new SimpleProcessor<Pair<Integer, Z>>() {
      @Override
      protected Z total(final Iterable<Pair<Pair<Integer, Z>, Z>> counts) {
        Z count = Z.ZERO;
        for (final Pair<Pair<Integer, Z>, Z> e : counts) {
          if (e.left().left() == components()) {
            count = count.add(e.right());
          }
        }
        return count;
      }
    };
    processor.setCreateStateMachine(k -> new MeandersByComponents(k, components()));
    return processor.process(mN, initialStates(new MeandersByComponents(mN, components())));
  }
}
#!queue	A006658	0	->	3	A006657	--------------------------------
package irvine.oeis.a006;

/**
 * A006658 Closed meanders with 3 components and 2n bridges.
 * @author Sean A. Irvine
 */
public class A006658 extends A006657 {

  @Override
  protected int components() {
    return 3;
  }
}
#!queue	A006760	0	->	1	A255487	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a038.A038119;
import irvine.oeis.a255.A255487;

/**
 * A006760 Number of one-sided 4-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006760 extends A255487 {

  private final A038119 mA = new A038119();

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A006761	0	->	1	A290305	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a068.A068870;
import irvine.oeis.a290.A290305;

/**
 * A006761 Number of one-sided 5-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006761 extends A290305 {

  private final A068870 mA = new A068870();

  {
    next(); // skip 0th term
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A006762	0	->	1	A001168	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a001.A001168;

/**
 * A006762 Number of strictly 2-dimensional fixed polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006762 extends A001168 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.ZERO.max(super.next().subtract(2));
  }
}
#!queue	A006765	0	->	1	A000105	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000105;

/**
 * A006765 Number of strictly 2-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006765 extends A000105 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A006767	0	->	1	A068870	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a038.A038119;
import irvine.oeis.a068.A068870;

/**
 * A006767 Number of 4-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006767 extends A068870 {

  {
    super.next();
  }

  private final A038119 mA = new A038119();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A006768	0	->	1	A290305	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a068.A068870;
import irvine.oeis.a290.A290305;

/**
 * A006768 Number of 5-dimensional polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A006768 extends A290305 {

  private final A068870 mA = new A068870();

  {
    next(); // skip 0th term
  }

  @Override
  public Z next() {
    final Z c = super.next();
    long sym = 0;
    for (final FiveDPackedPolyomino p : mPolysB) {
      if (p.isSymmetric()) {
        ++sym;
      }
    }
    return Z.ONE.max(c.add(sym).divide2()).subtract(mA.next());
  }
}
#!queue	A006802	0	->	1	A000055	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000055;

/**
 * A006802 Log of e.g.f. for trees A000055(n-1).
 * @author Sean A. Irvine
 */
public class A006802 extends A000055 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final ArrayList<Q> mA55 = new ArrayList<>();
  private Z mF = Z.ONE;

  private int mN = 0;

  {
    mA55.add(Q.ZERO);
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mA55.add(new Q(super.next(), mF));
    return RING.log1p(RING.create(mA55), mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A006827	0	->	1	A000041	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;
import irvine.oeis.a002.A002219;

/**
 * A006827 Number of partitions of 2n with all subsums different from n.
 * @author Sean A. Irvine
 */
public class A006827 extends A000041 {

  private final A002219 mA = new A002219();

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next().subtract(mA.next());
  }
}
#!queue	A006854	0	->	1	A006853	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A006854 Nonantipodal balanced colorings of n-cube.
 * @author Sean A. Irvine
 */
public class A006854 extends A006853 {

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN <= 2) {
      return Z.ONE;
    }
    Z sum = Z.ONE; // A_{n,0} = 1
    final ArrayList<Z> prev = new ArrayList<>();
    prev.add(Z.ONE);
    for (int k = 1; k <= (1L << mN) / 4; ++k) {
      Z t = bigN(mN, 2 * k);
      for (int i = 0; i < k; ++i) {
        t = t.subtract(Binomial.binomial((1L << (mN - 1)) - 2 * i, k - i).multiply(prev.get(i)));
      }
      prev.add(t);
      sum = sum.add(t);
    }
    return sum;
  }
}
#!queue	A006931	1	->	3	A002997	--------------------------------
package irvine.oeis.a006;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002997;
import irvine.util.array.DynamicArray;

/**
 * A006931 Least Carmichael number with n prime factors, or 0 if no such number exists.
 * @author Sean A. Irvine
 */
public class A006931 extends A002997 {

  private final DynamicArray<Z> mLeast = new DynamicArray<>();
  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    while (mLeast.get(mN) == null) {
      final Z n = super.next();
      final int o = Jaguar.factor(n).omega();
      if (mLeast.get(o) == null) {
        mLeast.set(o, n);
      }
    }
    return mLeast.get(mN);
  }
}
#!queue	A006967	1	->	0	A084894	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.a084.A084894;

/**
 * A006967 Number of graceful permutations of length n.
 * @author Sean A. Irvine
 */
public class A006967 extends A084894 {

  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mF = mF.multiply(mN);
    return mF.subtract(super.next());
  }
}
#!queue	A006978	0	->	1	A006977	--------------------------------
package irvine.oeis.a006;

/**
 * A006978 Successive states of the Rule 110 cellular automaton defined by 000, 001, 010, 011, ..., 111 -&gt; 0,1,1,1,0,1,1,0 when started with a single ON cell.
 * @author Sean A. Irvine
 */
public class A006978 extends A006977 {

  private static final boolean[] A = {false, true, true, true, false, true, true, false};

  @Override
  protected boolean isSet(final int v) {
    return A[v];
  }
}
#!queue	A007042	0	->	1	A000041	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A007042 Left diagonal of partition triangle A047812.
 * @author Sean A. Irvine
 */
public class A007042 extends A000041 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(2);
  }
}
#!queue	A007045	1	->	2	A047812	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a047.A047812;

/**
 * A007045 Second (lower) diagonal of partition triangle A047812.
 * @author Sean A. Irvine
 */
public class A007045 extends A047812 {

  private int mN = 1;

  @Override
  public Z next() {
    if (++mN == 2) {
      return Z.ZERO;
    }
    return get(mN).coeff((mN - 3) * (mN + 1));
  }
}
#!queue	A007049	1	->	3	A007048	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007049 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007049 extends A007048 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2L);
  }
}
#!queue	A007050	1	->	6	A007048	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007050 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007050 extends A007048 {

  private long mN = 5;

  @Override
  public Z next() {
    return get(++mN, 3L);
  }
}
#!queue	A007065	0	->	-1	A011804	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.a011.A011804;

/**
 * A007065 Number of M-sequences from multicomplexes on at most 5 variables with no monomial of degree greater than n.
 * @author Sean A. Irvine
 */
public class A007065 extends A011804 {

  @Override
  protected long start() {
    return -2;
  }

  @Override
  protected long variables() {
    return 5;
  }
}
#!queue	A007075	3	->	1	A007046	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007075 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007075 extends A007046 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 1L);
  }
}
#!queue	A007076	3	->	6	A007046	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007076 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007076 extends A007046 {

  private long mN = 5;

  @Override
  public Z next() {
    return get(++mN, 3L);
  }
}
#!queue	A007098	1	->	0	A228601	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a228.A228601;

/**
 * A007098 Number of unlabeled bisectable trees with 2n+1 nodes.
 * @author Sean A. Irvine
 */
public class A007098 extends A228601 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      sum = sum.add(Binomial.binomial(k + 1, 2).multiply(a(mN, k)));
    }
    return sum;
  }
}
#!queue	A007122	0	->	1	A005043	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a005.A005043;
import irvine.oeis.a005.A005213;

/**
 * A007122 Number of unlabeled identity connected unit interval graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A007122 extends A005043 {

  private final A005213 mA = new A005213();
  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(mA.next()).divide2();
  }
}
#!queue	A007150	0	->	1	A000568	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a000.A000568;

/**
 * A007150 2-part of number of tournaments on n nodes.
 * @author Sean A. Irvine
 */
public class A007150 extends A000568 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    t.makeOdd();
    return Z.valueOf(t.auxiliary());
  }
}
#!queue	A007161	1	->	0	A007165	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A007161 Number of blobs with vertical symmetry.
 * @author Sean A. Irvine
 */
public class A007161 extends A007165 {

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private Polynomial<Z> mH = RING.zero();
  private Polynomial<Z> mC = RING.x();
  private int mN = 0;

  protected Z select(final Polynomial<Z> c, final Polynomial<Z> d, final int n) {
    return c.coeff(2 * n - 1);
  }

  @Override
  public Z next() {
    ++mN;
    final int n = 2 * mN;
    mH = RING.add(mH, RING.monomial(super.next(), n));
    final Polynomial<Z> d = RING.add(RING.x(), RING.multiply(mH, mC, n));
    mC = RING.add(RING.x(), RING.series(RING.pow(d, 3, n), RING.subtract(RING.one(), RING.pow(d, 2, n)), n));
    return select(mC, d, mN);
  }
}
#!queue	A007162	1	->	0	A007161	--------------------------------
package irvine.oeis.a007;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A007162 Number of skeins with vertical symmetry.
 * @author Sean A. Irvine
 */
public class A007162 extends A007161 {

  @Override
  protected Z select(final Polynomial<Z> c, final Polynomial<Z> d, final int n) {
    return d.coeff(2 * n - 1);
  }
}
#!queue	A007168	0	->	1	A007166	--------------------------------
package irvine.oeis.a007;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A007168 P-graphs with 2n edges.
 * @author Sean A. Irvine
 */
public class A007168 extends A007166 {

  @Override
  protected Z select(final Polynomial<Z> s, final Polynomial<Z> b, final int n) {
    Polynomial<Z> a = RING.one();
    for (int i = 1; i < 2 * n; i += 2) {
      a = RING.multiply(a, RING.pow(RING.oneMinusXToTheN(i), s.coeff(i), 2 * n));
    }
    return RING.coeff(RING.one(), a, 2 * n);
  }
}
#!queue	A007169	0	->	1	A003168	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.CyclicGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a003.A003168;

/**
 * A007169 Number of Q-graphs rooted at a polygon.
 * @author Sean A. Irvine
 */
public class A007169 extends A003168 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private int mN = 0;
  private CycleIndex mCycleIndexSum = new CycleIndex("C");
  private Polynomial<Q> mB = RING.monomial(new Q(super.next()), 1);

  @Override
  public Z next() {
    mN += 2;
    mCycleIndexSum.add(new CyclicGroup(mN + 2).cycleIndex());
    mB = RING.add(mB, RING.monomial(new Q(super.next()), mN + 1));
    //System.out.println("u=" + u);
    final Polynomial<Q> u = mCycleIndexSum.apply(mB, mN + 1);
    return u.coeff(mN).toZ();
  }
}
#!queue	A007170	0	->	1	A007169	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a294.A294724;
import irvine.oeis.a294.A294728;

/**
 * A007170 Number of Q-graphs with 2n edges.
 * @author Sean A. Irvine
 */
public class A007170 extends A007169 {

  private final A294724 mV = new A294724();
  private final A294728 mW = new A294728();

  @Override
  public Z next() {
    return mV.next().subtract(mW.next()).divide2().add(super.next());
  }
}
#!queue	A007171	0	->	1	A007170	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a003.A003169;

/**
 * A007171 Number of Q-graphs with 2n edges.
 * @author Sean A. Irvine
 */
public class A007171 extends A007170 {

  private final A003169 mP = new A003169();
  private final A007165 mH = new A007165();
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      super.next();
      return Z.ONE;
    }
    return mP.next().add(mH.next()).divide2().add(super.next());
  }
}
#!queue	A007201	2	->	3	A007200	--------------------------------
package irvine.oeis.a007;

/**
 * A007201 Number of self-avoiding walks on hexagonal lattice.
 * @author Sean A. Irvine
 */
public class A007201 extends A007200 {

  /** Construct the sequence. */
  public A007201() {
    super(3);
  }
}
#!queue	A007219	0	->	1	A006718	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a006.A006718;

/**
 * A007219 Number of golygons of order 8n (or serial isogons of order 8n).
 * @author Sean A. Irvine
 */
public class A007219 extends A006718 {

  {
    super.next(); // skip 0th term
  }

  @Override
  public Z next() {
    return super.next().divide(4);
  }
}
#!queue	A007224	2	->	4	A007223	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007224 Number of distinct perforation patterns for deriving (v,b) = (n+3,n) punctured convolutional codes from (2,1).
 * @author Sean A. Irvine
 */
public class A007224 extends A007223 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2).coeff(mN + 3);
  }
}
#!queue	A007225	2	->	5	A007223	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007225 Number of distinct perforation patterns for deriving (v,b) = (n+4,n) punctured convolutional codes from (2,1).
 * @author Sean A. Irvine
 */
public class A007225 extends A007223 {

  private int mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2).coeff(mN + 4);
  }
}
#!queue	A007242	-1	->	0	A000521	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000521;

/**
 * A007242 McKay-Thompson series of class 2a for the Monster group.
 * @author Sean A. Irvine
 */
public class A007242 extends A000521 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final List<Q> mJ = new ArrayList<>();
  private int mN = -1;

  @Override
  public Z next() {
    final Z j = super.next();
    mJ.add(new Q(++mN == 1 ? j.subtract(1728) : j));
    return RING.sqrt(RING.create(mJ), mN).coeff(mN).toZ();
  }
}
#!queue	A007312	0	->	1	A000041	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A007312 Reversion of g.f. (with constant term omitted) for partition numbers.
 * @author Sean A. Irvine
 */
public class A007312 extends A000041 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final ArrayList<Z> mP = new ArrayList<>();
  private int mN = 0;
  {
    mP.add(Z.ZERO);
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    return RING.reversion(RING.create(mP), mN).coeff(mN);
  }
}

#!queue	A007313	0	->	1	A000364	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A007313 Reversion of g.f. for Euler (secant) numbers A000364.
 * @author Sean A. Irvine
 */
public class A007313 extends A000364 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final ArrayList<Z> mP = new ArrayList<>();
  private int mN = 0;
  {
    mP.add(Z.ZERO);
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    return RING.reversion(RING.create(mP), mN).coeff(mN);
  }
}

#!queue	A007315	0	->	1	A000055	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000055;

/**
 * A007315 Reversion of g.f. (beginning with constant term) for number of trees with n nodes.
 * @author Sean A. Irvine
 */
public class A007315 extends A000055 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final Polynomial<Z> mP = RING.empty();
  private int mN = 0;
  {
    mP.add(Z.ZERO);
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    return RING.reversion(mP, mN).coeff(mN);
  }
}

#!queue	A007316	0	->	1	A000111	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.a000.A000111;

/**
 * A007316 Reversion of g.f. for Euler numbers A000111(n-1).
 * @author Sean A. Irvine
 */
public class A007316 extends A000111 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final ArrayList<Z> mP = new ArrayList<>();
  private int mN = 0;
  {
    mP.add(Z.ZERO);
  }

  @Override
  public Z next() {
    ++mN;
    mP.add(super.next());
    return RING.reversion(RING.create(mP), mN).coeff(mN);
  }
}

#!queue	A007344	3	->	4	A007343	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007344 Number of homogeneous primitive partition identities of degree 6 with largest part n.
 * @author Sean A. Irvine
 */
public class A007344 extends A007343 {

  private int mN = 3;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    mA = mA.add(get(mN, 3));
    return mA;
  }
}
#!queue	A007360	0	->	1	A051424	--------------------------------
package irvine.oeis.a007;

import java.util.Collections;

import irvine.math.z.Z;
import irvine.oeis.a051.A051424;

/**
 * A007360 Number of partitions of n into distinct and pairwise relatively prime parts.
 * @author Sean A. Irvine
 */
public class A007360 extends A051424 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return b(mN, mN, Collections.emptySet())
      .subtract(b(mN - 2, mN - 2, Collections.emptySet()));
  }
}
#!queue	A007383	0	->	1	A000931	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A007383 Number of strict first-order maximal independent sets in path graph.
 * @author Sean A. Irvine
 */
public class A007383 extends A000931 {

  {
    for (int k = 0; k < 7; ++k) {
      next();
    }
  }

  private long mN = 1;
  private boolean mAlternate = true;

  @Override
  public Z next() {
    if (mAlternate) {
      ++mN;
    }
    mAlternate = !mAlternate;
    return super.next().subtract(mAlternate ? mN : 1);
  }
}
#!queue	A007384	0	->	1	A001687	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a001.A001687;

/**
 * A007384 Number of strict 3rd-order maximal independent sets in path graph.
 * @author Sean A. Irvine
 */
public class A007384 extends A001687 {

  {
    for (int k = 0; k < 7; ++k) {
      next();
    }
  }

  private long mN = 1;
  private boolean mAlternate = true;

  @Override
  public Z next() {
    if (mAlternate) {
      ++mN;
    }
    mAlternate = !mAlternate;
    return super.next().subtract(mAlternate ? mN : 1);
  }
}
#!queue	A007391	0	->	1	A001608	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a001.A001608;

/**
 * A007391 Number of strict first-order maximal independent sets in cycle graph.
 * @author Sean A. Irvine
 */
public class A007391 extends A001608 {

  {
    super.next();
  }

  private long mN = -2;
  private boolean mAlternate = false;

  @Override
  public Z next() {
    mAlternate = !mAlternate;
    if (mAlternate) {
      mN += mN == 0 ? 3 : 2;
    }
    return super.next().subtract(mAlternate ? mN : 2);
  }
}
#!queue	A007454	0	->	1	A003430	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a003.A003430;

/**
 * A007454 Number of unlabeled disconnected series-parallel posets with n nodes.
 * @author Sean A. Irvine
 */
public class A007454 extends A003430 {

  private final Sequence mConnected = new A007453();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.ONE.max(super.next().subtract(mConnected.next()));
  }
}

#!queue	A007536	0	->	1	A000384	--------------------------------
package irvine.oeis.a007;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A007536 Numbers that are not the sum of 3 hexagonal numbers (probably finite).
 * @author Sean A. Irvine
 */
public class A007536 extends A000384 {

  // This sequence is likely finite and this generates all the terms

  private long mN = 3;
  private long mR = 0;
  private final TreeSet<Long> mForbidden = new TreeSet<>();

  @Override
  public Z next() {
    while (true) {
      ++mN;
      while (mN >= mR) {
        mR = super.next().longValueExact();
        final A000384 a = new A000384();
        long s;
        while ((s = a.next().longValueExact()) <= mR) {
          final A000384 b = new A000384();
          long t;
          while ((t = b.next().longValueExact()) <= s) {
            mForbidden.add(mR + s + t);
          }
        }
      }
      if (!mForbidden.remove(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A007625	0	->	-1	A011804	--------------------------------
package irvine.oeis.a007;

import irvine.oeis.a011.A011804;

/**
 * A007625 Number of M-sequences from multicomplexes on at most 6 variables with no monomial of degree more than n-1.
 * @author Sean A. Irvine
 */
public class A007625 extends A011804 {

  @Override
  protected long start() {
    return -2;
  }

  @Override
  protected long variables() {
    return 6;
  }
}
#!queue	A007665	0	->	1	A056556	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a056.A056556;

/**
 * A007665 Tower of Hanoi with 5 pegs.
 * @author Sean A. Irvine
 */
public class A007665 extends A056556 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    final Z a = super.next();
    return Z.ONE
      .add(a.multiply(a.subtract(1)).divide2())
      .add(mN)
      .subtract(a.multiply(a.add(1)).multiply(a.add(2)).divide(6))
      .shiftLeft(a.longValueExact())
      .subtract(1);
  }
}
#!queue	A007704	0	->	1	A006277	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a006.A006277;

/**
 * A007704 a(n+2) = (a(n) - 1)*a(n+1) + 1.
 * @author Sean A. Irvine
 */
public class A007704 extends A006277 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A007717	1	->	0	A318951	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A007717 Number of symmetric polynomial functions of degree n of a symmetric matrix (of indefinitely large size) under joint row and column permutations. Also number of multigraphs with n edges (allowing loops) on an infinite set of nodes.
 * @author Sean A. Irvine
 */
public class A007717 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : rowSumMats(mN, 2 * mN, 2);
  }
}
#!queue	A007721	0	->	1	A004251	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a004.A004251;

/**
 * A007721 Number of distinct degree sequences among all connected graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A007721 extends A004251 {

  // Based on the Kai Wang paper

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    final int bigN = mN * (mN - 1);
    Z sum = Z.ZERO;
    for (int i = 2 * (mN - 1); i <= bigN; i += 2) {
      for (int j = 1; j <= Math.min(mN - 1, i - mN + 1); ++j) {
        sum = sum.add(mB.get(i - j - mN + 1, j - 1, mN - 1, mN - j - 1));
      }
    }
    return sum;
  }

}
#!queue	A007722	0	->	3	A004251	--------------------------------
package irvine.oeis.a007;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.a004.A004251;

/**
 * A007722 Number of graphical partitions of biconnected graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A007722 extends A004251 {

  // Based on the Kai Wang paper

  {
    super.next();
  }

  private int mN = 2;

  private Z s(final int n) {
    Z sum = Z.ZERO;
    for (int k = 2 * n - 2; k <= n * (n - 2); k += 2) {
      sum = sum.add(mB.get(k - 2 * n + 3, n - 3, n - 1, 1));
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    final Z d0 = super.next(); // D_0(n-2)
    final Z c = d0.add(s(mN));
    final Z d2 = d(mN).subtract(c);
    Z sum = Z.ZERO;
    for (int i = 4; i < mN; ++i) {
      final int k = (i + 1) / 2;
      for (int j = i & 1; j <= 2 * k - 4; j += 2) {
        sum = sum.add(IntegerPartition.partitions(j));
      }
    }
    return d2.subtract(sum);
  }
}
#!queue	A007752	0	->	1	A007750	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007752 Odd bisection of A007750.
 * @author Sean A. Irvine
 */
public class A007752 extends A007750 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A007822	0	->	1	A001415	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a001.A001415;

/**
 * A007822 Number of symmetric foldings of 2n+1 stamps.
 * @author Sean A. Irvine (Java port)
 */
public class A007822 extends A001415 {

  private int mN = 1;
  private long mCount = 0;

  private boolean isSymmetric(final int[] c, final int delta) {
    for (int k = 0; k < (c.length - 1) / 2; ++k) {
      if (c[(delta + k) % c.length] != c[(delta + c.length - 2 - k) % c.length]) {
        return false;
      }
    }
    return true;
  }

  @Override
  protected void process(final int[] a, final int[] b, final int n) {
    final int[] c = new int[a.length];
    int j = 0;
    for (int k = 0; k < b.length; k++) {
      c[k] = b[j] - j;
      j = b[j];
    }
    for (int k = 0; k < a.length; ++k) {
      if (isSymmetric(c, k)) {
        ++mCount;
      }
    }
  }

  @Override
  public Z next() {
    mN += 2;
    mCount = 0;
    foldings(new int[] {mN - 1}, true, 0, 0);
    return Z.valueOf((mCount + 1) / 2);
  }
}
#!queue	A007827	1	->	0	A000669	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000669;

/**
 * A007827 Number of homeomorphically irreducible (or series-reduced) trees with n pendant nodes, or continua with n non-cut points, or leaves.
 * @author Sean A. Irvine
 */
public class A007827 extends A000669 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private static final Polynomial<Z> X1 = Polynomial.create(1, 1);
  private Polynomial<Z> mB = RING.zero();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mB = RING.add(mB, RING.monomial(super.next(), mN));
    return RING.multiply(RING.subtract(X1, mB), mB, mN).coeff(mN);
  }
}
#!queue	A007857	0	->	1	A007226	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a000.A000108;

/**
 * A007857 Number of independent sets in rooted plane trees on n nodes.
 * @author Sean A. Irvine
 */
public class A007857 extends A007226 {

  private final A000108 mC = new A000108();

  @Override
  public Z next() {
    return super.next().subtract(mC.next());
  }
}
#!queue	A007952	1	->	0	A002491	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.a002.A002491;

/**
 * A007952 Generated by a sieve: keep first number, drop every 2nd, keep first, drop every 3rd, keep first, drop every 4th, etc.
 * @author Sean A. Irvine
 */
public class A007952 extends A002491 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A007969	0	->	1	A007968	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007969 Rectangular numbers.
 * @author Sean A. Irvine
 */
public class A007969 extends A007968 {

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A007970	0	->	1	A007968	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007970 Rhombic numbers.
 * @author Sean A. Irvine
 */
public class A007970 extends A007968 {

  @Override
  public Z next() {
    while (true) {
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A007973	4	->	2	A007975	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007973 Number of permutations that are n-2 "block reversals" away from 12...n.
 * @author Sean A. Irvine
 */
public class A007973 extends A007975 {

  @Override
  protected int start() {
    return 1;
  }

  @Override
  public Z next() {
    init();
    for (int k = 0; k < mN - 2; ++k) {
      step();
    }
    return Z.valueOf(mPrev.size());
  }
}
#!queue	A007974	4	->	3	A007975	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;

/**
 * A007974 Number of permutations that are n-3 "block reversals" away from 12...n.
 * @author Sean A. Irvine
 */
public class A007974 extends A007975 {

  @Override
  protected int start() {
    return 2;
  }

  @Override
  public Z next() {
    init();
    for (int k = 0; k < mN - 3; ++k) {
      step();
    }
    return Z.valueOf(mPrev.size());
  }
}
#!queue	A008282	0	->	1	A008281	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008282 Triangle of Euler-Bernoulli or Entringer numbers read by rows: T(n,k) is the number of down-up permutations of n+1 starting with k+1.
 * @author Sean A. Irvine
 */
public class A008282 extends A008281 {

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A008283	0	->	3	A008281	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008283 Read across rows of Euler-Bernoulli or Entringer triangle.
 * @author Sean A. Irvine
 */
public class A008283 extends A008281 {

  private long mN = 2;
  private long mM = 2;

  @Override
  public Z next() {
    if (++mM >= mN - 1) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A008291	0	->	2	A008290	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008291 Triangle of rencontres numbers.
 * @author Sean A. Irvine
 */
public class A008291 extends A008290 {

  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM >= mN - 1) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A008518	1	->	0	A008292	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008518 Triangle of Eulerian numbers with rows multiplied by 1 + x.
 * @author Sean A. Irvine
 */
public class A008518 extends A008292 {

  private long mN = 0;
  private long mM = 1;

  @Override
  public Z next() {
    if (++mM > mN) {
      mM = 1;
      if (++mN == 1) {
        return Z.ONE;
      }
    }
    return get(mN - 1, mM).add(get(mN - 1, mM - 1));
  }
}
#!queue	A008828	0	->	1	A006657	--------------------------------
package irvine.oeis.a008;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a006.A006657;
import irvine.util.Pair;

/**
 * A008828 Triangle read by rows: T(n,k) = number of closed meander systems of order n with k&lt;=n components.
 * @author Sean A. Irvine
 */
public class A008828 extends A006657 {

  private int mN = 0;
  private int mM = 0;
  private Z[] mTotals = null;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
      mTotals = new Z[mN + 2];
      Arrays.fill(mTotals, Z.ZERO);
      final SimpleProcessor<Pair<Integer, Z>> processor = new SimpleProcessor<Pair<Integer, Z>>() {
        @Override
        protected Z total(final Iterable<Pair<Pair<Integer, Z>, Z>> counts) {
          for (final Pair<Pair<Integer, Z>, Z> e : counts) {
            final int components = e.left().left();
            mTotals[components] = mTotals[components].add(e.right());
          }
          return null; // not used
        }
      };
      processor.setCreateStateMachine(k -> new MeandersByComponents(k, mN + 1));
      processor.process(2 * mN, initialStates(null));
    }
    return mTotals[mM];
  }
}
#!queue	A008844	1	->	0	A001653	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.a001.A001653;

/**
 * A008844 Squares of sequence A001653: y^2 such that x^2 - 2*y^2 = -1 for some x.
 * @author Sean A. Irvine
 */
public class A008844 extends A001653 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A008845	1	->	0	A008844	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;

/**
 * A008845 Numbers k such that k+1 and k/2+1 are squares.
 * @author Sean A. Irvine
 */
public class A008845 extends A008844 {

  @Override
  public Z next() {
    return super.next().subtract(1).multiply2();
  }
}
#!queue	A008912	2	->	1	A008867	--------------------------------
package irvine.oeis.a008;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A008912 Truncated triangular numbers (of form n*(n-3)/2 - k^2+k*n+1 for 1&lt;=k&lt;n).
 * @author Sean A. Irvine
 */
public class A008912 extends A008867 {

  private Z mPrev = Z.ZERO;
  private int mLookahead = 0; // Heuristic lookahead
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    ++mLookahead;
    while (mSet.size() < mLookahead) {
      final Z t = super.next();
      if (t.compareTo(mPrev) > 0) {
        mSet.add(t);
      }
    }
    mPrev = mSet.pollFirst();
    return mPrev;
  }
}

#!queue	A008965	0	->	1	A000031	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.a000.A000031;

/**
 * A008965 Number of necklaces of sets of beads containing a total of n beads.
 * @author Sean A. Irvine
 */
public class A008965 extends A000031 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A009561	1	->	2	A006987	--------------------------------
package irvine.oeis.a009;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a006.A006987;

/**
 * A009561 Index of central binomial coefficient C(2n,n) within A006987.
 * @author Sean A. Irvine
 */
public class A009561 extends A006987 {

  private long mN = 1;
  private long mC = 0;

  @Override
  public Z next() {
    ++mN;
    final Z target = Binomial.binomial(2 * mN, mN);
    Z v;
    do {
      v = super.next();
      ++mC;
    } while (!v.equals(target));
    return Z.valueOf(mC);
  }
}
#!queue	A010026	1	->	2	A211318	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.a211.A211318;

/**
 * A010026 Triangle read by rows: number of permutations of 1..n by length of longest run.
 * @author Sean A. Irvine
 */
public class A010026 extends A211318 {

  private int mN = 1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM >= mN - 1) {
      ++mN;
      mM = 0;
    }
    return a(mN, mN - mM);
  }
}
#!queue	A010372	0	->	1	A000602	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.a000.A000602;

/**
 * A010372 Number of unrooted quartic trees with n (unlabeled) nodes and possessing a centroid; number of n-carbon alkanes C(n)H(2n +2) with a centroid ignoring stereoisomers.
 * @author Sean A. Irvine
 */
public class A010372 extends A000602 {

  private final A010373 mA = new A010373();
  private boolean mOdd = false;

  {
    super.next();
  }

  @Override
  public Z next() {
    mOdd = !mOdd;
    return mOdd ? super.next() : super.next().subtract(mA.next());
  }
}
#!queue	A010373	0	->	1	A000598	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.a000.A000598;

/**
 * A010373 Number of unrooted quartic trees with 2n (unlabeled) nodes and possessing a bicentroid; number of 2n-carbon alkanes C(2n)H(4n+2) with a bicentroid, ignoring stereoisomers.
 * @author Sean A. Irvine
 */
public class A010373 extends A000598 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z b = super.next();
    return b.multiply(b.add(1)).divide2();
  }
}
#!queue	A010527	1	->	0	A002193	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.a002.A002193;

/**
 * A010527 Decimal expansion of sqrt(3)/2.
 * @author Sean A. Irvine
 */
public class A010527 extends A002193 {

  @Override
  protected Z n() {
    return Z.valueOf(75);
  }
}
#!queue	A010796	0	->	1	A010790	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;

/**
 * A010796 a(n) = n!*(n+1)!/2.
 * @author Sean A. Irvine
 */
public class A010796 extends A010790 {

  {
    next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A011787	0	->	1	A065128	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a065.A065128;

/**
 * A011787 Number of n X n matrices over Z_4 whose determinant is 1.
 * @author Sean A. Irvine
 */
public class A011787 extends A065128 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A011796	0	->	1	A051168	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a051.A051168;

/**
 * A011796 Number of irreducible alternating Euler sums of depth 6 and weight 6+2n.
 * @author Sean A. Irvine
 */
public class A011796 extends A051168 {

  protected long mN = 6;

  @Override
  public Z next() {
    return t(++mN, 6);
  }
}
#!queue	A011808	0	->	1	A011804	--------------------------------
package irvine.oeis.a011;

/**
 * A011808 M-sequences from multicomplexes on at most 11 variables with no monomial of degree more than n-1.
 * @author Sean A. Irvine
 */
public class A011808 extends A011804 {

  @Override
  protected long variables() {
    return 11;
  }
}
#!queue	A011821	0	->	1	A011804	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;

/**
 * A011821 Number of M-sequences m_0,...,m_5 with m_1 &lt; n.
 * @author Sean A. Irvine
 */
public class A011821 extends A011804 {

  private long mN = -1;

  @Override
  public Z next() {
    return m(++mN, 5);
  }
}
#!queue	A011822	0	->	1	A011804	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;

/**
 * A011822 M-sequences m_0,...,m_6 with m_1 &lt; n.
 * @author Sean A. Irvine
 */
public class A011822 extends A011804 {

  private long mN = -1;

  @Override
  public Z next() {
    return m(++mN, 6);
  }
}
#!queue	A011823	0	->	1	A011804	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;

/**
 * A011823 M-sequences m_0,...,m_7 with m_1 &lt; n.
 * @author Sean A. Irvine
 */
public class A011823 extends A011804 {

  private long mN = -1;

  @Override
  public Z next() {
    return m(++mN, 7);
  }
}
#!queue	A011824	0	->	1	A011804	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;

/**
 * A011824 M-sequences m_0,...,m_8 with m_1 &lt; n.
 * @author Sean A. Irvine
 */
public class A011824 extends A011804 {

  private long mN = -1;

  @Override
  public Z next() {
    return m(++mN, 8);
  }
}
#!queue	A011825	0	->	1	A011804	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;

/**
 * A011825 M-sequences m_0,...,m_9 with m_1 &lt; n.
 * @author Sean A. Irvine
 */
public class A011825 extends A011804 {

  private long mN = -1;

  @Override
  public Z next() {
    return m(++mN, 9);
  }
}
#!queue	A011827	0	->	1	A007695	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a007.A007695;

/**
 * A011827 f-vectors for simplicial complexes of dimension at most 2 on at most n-1 vertices.
 * @author Sean A. Irvine
 */
public class A011827 extends A007695 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, 3);
  }
}
#!queue	A011828	0	->	1	A007695	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a007.A007695;

/**
 * A011828 Number of f-vectors for simplicial complexes of dimension at most 3 on at most n-1 vertices.
 * @author Sean A. Irvine
 */
public class A011828 extends A007695 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, 4);
  }
}
#!queue	A011829	0	->	1	A007695	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a007.A007695;

/**
 * A011829 Number of f-vectors for simplicial complexes of dimension at most 4 on at most n-1 vertices.
 * @author Sean A. Irvine
 */
public class A011829 extends A007695 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, 5);
  }
}
#!queue	A011830	0	->	1	A007695	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a007.A007695;

/**
 * A011830 f-vectors for simplicial complexes of dimension at most 5 on at most n-1 vertices.
 * @author Sean A. Irvine
 */
public class A011830 extends A007695 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, 6);
  }
}
#!queue	A011831	0	->	1	A007695	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a007.A007695;

/**
 * A011831 f-vectors for simplicial complexes of dimension at most 6 on at most n-1 vertices.
 * @author Sean A. Irvine
 */
public class A011831 extends A007695 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, 7);
  }
}
#!queue	A011832	0	->	1	A007695	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a007.A007695;

/**
 * A011832 f-vectors for simplicial complexes of dimension at most 7 on at most n-1 vertices.
 * @author Sean A. Irvine
 */
public class A011832 extends A007695 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, 8);
  }
}
#!queue	A011833	0	->	1	A007695	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a007.A007695;

/**
 * A011833 Number of f-vectors for simplicial complexes of dimension at most 8 on at most n-1 vertices.
 * @author Sean A. Irvine
 */
public class A011833 extends A007695 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, 9);
  }
}
#!queue	A011918	0	->	1	A011916	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;

/**
 * A011918 a(n) = A011916(n) + A011922(n) - 1.
 * @author Sean A. Irvine
 */
public class A011918 extends A011916 {

  private final A011922 mA = new A011922();
  {
    next(); // skip 0th term
  }

  @Override
  public Z next() {
    return super.next().add(mA.next()).subtract(1);
  }
}
#!queue	A011957	0	->	1	A001037	--------------------------------
package irvine.oeis.a011;

import irvine.math.z.Z;
import irvine.oeis.a000.A000048;
import irvine.oeis.a001.A001037;
import irvine.oeis.a165.A165920;

/**
 * A011957 Number of ZnS polytypes that repeat after n layers.
 * @author Sean A. Irvine
 */
public class A011957 extends A001037 {

  // After Joerg Arndt

  private final A000048 mA48 = new A000048();
  private final A165920 mA165920 = new A165920();
  private long mN = 0;
  {
    super.next(); // skip 0th term
  }

  @Override
  public Z next() {
    if (++mN <= 2) {
      super.next(); // discard
      mA48.next(); // discard
      return Z.valueOf(mN - 1);
    }
    Z res = super.next();
    if ((mN & 1) == 0) {
      res = res.add(mA48.next().multiply(3));
    }
    if (mN % 3 == 0) {
      res = res.add(mA165920.next().multiply(4));
    }
    return res.divide(6);
  }
}
#!queue	A013583	0	->	1	A000119	--------------------------------
package irvine.oeis.a013;

import irvine.math.z.Z;
import irvine.oeis.a000.A000119;
import irvine.util.array.DynamicLongArray;

/**
 * A013583 Smallest positive number that can be written as sum of distinct Fibonacci numbers in n ways.
 * @author Sean A. Irvine
 */
public class A013583 extends A000119 {

  private long mM = -1;
  private int mN = 0;
  private final DynamicLongArray mFirst = new DynamicLongArray();

  @Override
  public Z next() {
    ++mN;
    while (mFirst.get(mN) == 0) {
      ++mM;
      final int v = super.next().intValueExact();
      if (mFirst.get(v) == 0) {
        mFirst.set(v, mM);
      }
    }
    return Z.valueOf(mFirst.get(mN));
  }
}
#!queue	A013925	4	->	5	A013924	--------------------------------
package irvine.oeis.a013;

import irvine.math.z.Z;

/**
 * A013925 Number of labeled connected graphs with n nodes and 3 cutpoints.
 * @author Sean A. Irvine
 */
public class A013925 extends A013924 {

  private int mN = 4;

  @Override
  public Z next() {
    return get(3, ++mN);
  }
}
#!queue	A014000	1	->	2	A003658	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a003.A003658;

/**
 * A014000 First coordinate of fundamental unit of real quadratic field with discriminant A003658(n), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A014000 extends A003658 {

  // Based on Keith Matthews
  // http://www.numbertheory.org/gnubc/unit
  // Looks to be almost the same as QuadraticFieldUtils.fundamentalUnit

  // Returns the fundamental unit and the norm
  protected Z[] fundamentalUnit(final Z bigD) {
    final Z d = bigD.mod(4) == 0 ? bigD.divide(4) : bigD;
    if (Z.FIVE.equals(d)) {
      return new Z[] {Z.ZERO, Z.ONE, Z.NEG_ONE};
    }
    final Z[] sqrt = d.sqrtAndRemainder();
    if (sqrt[0].isZero()) {
      // d is a perfect square, undefined
      return null;
    }
    final Z p = sqrt[0];
    final Z h = p.subtract(1).divide2();
    final Z t = h.multiply2().add(1);
    final long z = d.mod(4);
    Z b;
    Z c;
    if (z == 1) {
      b = t;
      c = Z.TWO;
    } else {
      b = p;
      c = Z.ONE;
    }
    if (d.equals(p.square().add(1))) {
      // period 1, exceptional case
      if (z == 1) {
        return new Z[] {p.subtract(1), Z.TWO, Z.NEG_ONE};
      } else {
        return new Z[] {p, Z.ONE, Z.NEG_ONE};
      }
    }
    if (d.equals(t.square().add(4))) {
      // period 1, exceptional case
      return new Z[] {h, Z.ONE, Z.NEG_ONE};
    }

    // Continued fraction expansion
    b = p.add(b).divide(c).multiply(c).subtract(b);
    c = d.subtract(b.square()).divide(c);
    Z u1 = Z.ONE;
    Z u2 = d.mod(4) == 1 ? h : p;
    Z v1 = Z.ZERO;
    Z v2 = Z.ONE;

    boolean even = true;
    while (true) {
      even = !even;
      final Z q = p.add(b).divide(c);
      final Z b0 = b;
      b = q.multiply(c).subtract(b);
      final Z c0 = c;
      c = d.subtract(b.square()).divide(c);
      final Z u0 = u1;
      final Z v0 = v1;
      final Z u = u2.multiply(q).add(u1);
      final Z v = v2.multiply(q).add(v1);
      u1 = u2;
      v1 = v2;
      u2 = u;
      v2 = v;
      // u/v is the ith convergent to sqrt(d) or (sqrt(d)-1)/2
      if (b.equals(b0)) {
        // Even period
        return new Z[] {v1.multiply(u.add(u0)).signedAdd(even, Z.ONE), v1.multiply(v.add(v0)), Z.ONE};
      }
      if (c.equals(c0)) {
        // Odd period
        return new Z[] {u.multiply(v).add(u1.multiply(v1)), v.square().add(v1.square()), Z.NEG_ONE};
      }
    }
  }

  protected Z select(final Z[] res) {
    return res[0];
  }

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    //System.out.println("Q:" + QuadraticFieldUtils.fundamentalUnitPair(n)[0] + "n=" + n);
    return select(fundamentalUnit(n));
  }
}
#!queue	A014046	1	->	2	A003658	--------------------------------
package irvine.oeis.a014;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a003.A003658;

/**
 * A014046 Second coordinate of fundamental unit of real quadratic field with discriminant A003658(n), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A014046 extends A003658 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[1];
  }
}
#!queue	A014077	1	->	2	A003658	--------------------------------
package irvine.oeis.a014;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a003.A003658;

/**
 * A014077 Norm of fundamental unit of real quadratic field with discriminant A003658(n), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A014077 extends A003658 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitNorm(super.next());
  }
}
#!queue	A014250	0	->	1	A002379	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.ComplementSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002379;

/**
 * A014250 a(n) = b(n) - c(n) where b(n) = [ (3/2)^n ] and c(n) is the n-th number not in sequence b.
 * @author Sean A. Irvine
 */
public class A014250 extends A002379 {

  private final Sequence mA = new ComplementSequence(new A002379(), Z.ONE);
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A014428	0	->	1	A007318	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a007.A007318;

/**
 * A014428 Even elements in Pascal's triangle.
 * @author Sean A. Irvine
 */
public class A014428 extends A007318 {

  @Override
  public Z next() {
    while (true) {
      final Z b = super.next();
      if (b.isEven()) {
        return b;
      }
    }
  }
}
#!queue	A014465	0	->	1	A063691	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a063.A063691;

/**
 * A014465 A063691 without zeros.
 * @author Sean A. Irvine
 */
public class A014465 extends A063691 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.signum() != 0) {
        return t;
      }
    }
  }
}
#!queue	A014531	0	->	1	A002426	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001006;
import irvine.oeis.a002.A002426;

/**
 * A014531 Form array in which n-th row is obtained by expanding (1+x+x^2)^n and taking the 2nd column from the center.
 * @author Sean A. Irvine
 */
public class A014531 extends A002426 {

  private final Sequence mA = new A001006().skip(2);

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A014537	0	->	1	A002387	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a002.A002387;

/**
 * A014537 Number of books required for n book-lengths of overhang in the harmonic book stacking problem. Sum_{i=1..a(n)} 1/i &gt;= 2n and Sum_{i=1..a(n)-1} 1/i &lt; 2n.
 * @author Sean A. Irvine
 */
public class A014537 extends A002387 {

  @Override
  public Z next() {
    if (Z.ONE.equals(super.next())) {
      super.next();
    }
    return super.next();
  }
}
#!queue	A014546	0	->	1	A000058	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a000.A000058;

/**
 * A014546 Primes in Sylvester's sequence A000058.
 * @author Sean A. Irvine
 */
public class A014546 extends A000058 {

  @Override
  public Z next() {
    while (true) {
      final Z s = super.next();
      if (s.isProbablePrime()) {
        return s;
      }
    }
  }
}
#!queue	A014547	0	->	1	A000364	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A014547 n-th Euler (secant, zig) number A000364(n) is prime.
 * @author Sean A. Irvine
 */
public class A014547 extends A000364 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z s = super.next();
      if (s.isProbablePrime()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A014578	1	->	0	A007949	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a007.A007949;

/**
 * A014578 Binary expansion of Thue constant (or Roth's constant).
 * @author Sean A. Irvine
 */
public class A014578 extends A007949 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return Z.ONE.subtract(super.next().mod(2));
  }
}
#!queue	A014600	1	->	0	A000003	--------------------------------
package irvine.oeis.a014;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.a000.A000003;

/**
 * A014600 Class numbers h(D) of imaginary quadratic orders with discriminant D == 0 or 1 mod 4, D&lt;0.
 * @author Sean A. Irvine
 */
public class A014600 extends A000003 {

  // Interleave A000003 and A014599

  private long mD = 0;
  private long mDelta = 3;

  @Override
  public Z next() {
    mD -= mDelta;
    mDelta = 4 - mDelta;
    return Z.valueOf(LongUtils.classNumber(mD));
  }
}
#!queue	A014736	1	->	0	A014493	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014736 Squares of odd triangular numbers.
 * @author Sean A. Irvine
 */
public class A014736 extends A014493 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014748	1	->	0	A014467	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014748 Squares of numbers in array formed from elements to the right of middle of rows of triangle of Eulerian numbers.
 * @author Sean A. Irvine
 */
public class A014748 extends A014467 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014760	1	->	0	A014475	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014760 Squares of numbers in array formed from odd elements to the right of middle of rows of Pascal triangle that are not 1.
 * @author Sean A. Irvine
 */
public class A014760 extends A014475 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isOdd() && !Z.ONE.equals(t)) {
        return t.square();
      }
    }
  }
}
#!queue	A014765	0	->	1	A014630	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014765 Squares of distinct elements in triangle of Eulerian numbers.
 * @author Sean A. Irvine
 */
public class A014765 extends A014630 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014771	0	->	1	A014634	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014771 Squares of odd hexagonal numbers.
 * @author Sean A. Irvine
 */
public class A014771 extends A014634 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014772	0	->	1	A014635	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014772 Squares of even hexagonal numbers.
 * @author Sean A. Irvine
 */
public class A014772 extends A014635 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014773	0	->	1	A014637	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014773 Squares of odd heptagonal numbers.
 * @author Sean A. Irvine
 */
public class A014773 extends A014637 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014798	1	->	0	A015222	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a015.A015222;

/**
 * A014798 Squares of even square pyramidal numbers.
 * @author Sean A. Irvine
 */
public class A014798 extends A015222 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014801	1	->	0	A015225	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a015.A015225;

/**
 * A014801 Squares of odd hexagonal pyramidal numbers.
 * @author Sean A. Irvine
 */
public class A014801 extends A015225 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A014822	0	->	1	A014824	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;

/**
 * A014822 Numbers k such that k divides s(k), where s(1)=1, s(j)=10*s(j-1)+j (A014824).
 * @author Sean A. Irvine
 */
public class A014822 extends A014824 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A014850	0	->	1	A000340	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.a000.A000340;

/**
 * A014850 Numbers k that divide s(k), where s(1)=1, s(j)=3*s(j-1)+j.
 * @author Sean A. Irvine
 */
public class A014850 extends A000340 {

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A014981	0	->	1	A001608	--------------------------------
package irvine.oeis.a014;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a001.A001608;

/**
 * A014981 a(n) = c(prime(n))/prime(n), where c = Perrin sequence A001608 (starting 0,2,3,...) and prime(n) is the n-th prime.
 * @author Sean A. Irvine
 */
public class A014981 extends A001608 {

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      if (mPrime.isPrime(++mN)) {
        return super.next().divide(mN);
      }
      super.next();
    }
  }
}
#!queue	A015627	1	->	2	A015622	--------------------------------
package irvine.oeis.a015;

/**
 * A015627 Quadruples of different integers from [ 2,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015627 extends A015622 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015628	1	->	2	A015623	--------------------------------
package irvine.oeis.a015;

/**
 * A015628 Quadruples of different integers from [ 2,n ] with no common factors between pairs.
 * @author Sean A. Irvine
 */
public class A015628 extends A015623 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015629	1	->	2	A015625	--------------------------------
package irvine.oeis.a015;

/**
 * A015629 Quadruples of different integers from [ 2,n ] with no common factors between triples.
 * @author Sean A. Irvine
 */
public class A015629 extends A015625 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015638	1	->	2	A015634	--------------------------------
package irvine.oeis.a015;

/**
 * A015638 Number of ordered quadruples of integers from [ 2,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015638 extends A015634 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015639	1	->	2	A015635	--------------------------------
package irvine.oeis.a015;

/**
 * A015639 Number of ordered quadruples of integers from [ 2,n ] with no common factors between triples.
 * @author Sean A. Irvine
 */
public class A015639 extends A015635 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015641	1	->	2	A015640	--------------------------------
package irvine.oeis.a015;

/**
 * A015641 Number of 5-tuples of different integers from [ 2,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015641 extends A015640 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015645	1	->	2	A015644	--------------------------------
package irvine.oeis.a015;

/**
 * A015645 Number of 5-tuples of different integers from [ 2,n ] with no common factors among quadruples.
 * @author Sean A. Irvine
 */
public class A015645 extends A015644 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015649	1	->	2	A015646	--------------------------------
package irvine.oeis.a015;

/**
 * A015649 Number of 5-tuples of different integers from [ 2,n ] with no common factors among triples.
 * @author Sean A. Irvine
 */
public class A015649 extends A015646 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015651	1	->	2	A015650	--------------------------------
package irvine.oeis.a015;

/**
 * A015651 Number of ordered 5-tuples of integers from [ 2,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015651 extends A015650 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015655	1	->	2	A015653	--------------------------------
package irvine.oeis.a015;

/**
 * A015655 Number of ordered 5-tuples of integers from [ 2,n ] with no common factors among quadruples.
 * @author Sean A. Irvine
 */
public class A015655 extends A015653 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015657	1	->	2	A015656	--------------------------------
package irvine.oeis.a015;

/**
 * A015657 Number of ordered 5-tuples of integers from [ 2,n ] with no common factors among triples.
 * @author Sean A. Irvine
 */
public class A015657 extends A015656 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015699	1	->	2	A015698	--------------------------------
package irvine.oeis.a015;

/**
 * A015699 Number of 5-tuples of different integers from [ 2,n ] with no common factors among pairs.
 * @author Sean A. Irvine
 */
public class A015699 extends A015698 {

  @Override
  protected long start() {
    return 2;
  }
}
#!queue	A015976	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015976 One iteration of Reverse and Add is needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015976 extends A015977 {

  @Override
  protected int iterations() {
    return 1;
  }
}
#!queue	A015982	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015982 Five iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015982 extends A015977 {

  @Override
  protected int iterations() {
    return 5;
  }
}
#!queue	A015990	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015990 Nine iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015990 extends A015977 {

  @Override
  protected int iterations() {
    return 9;
  }
}
#!queue	A015991	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015991 Numbers such that ten iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015991 extends A015977 {

  @Override
  protected int iterations() {
    return 10;
  }
}
#!queue	A015993	0	->	1	A015977	--------------------------------
package irvine.oeis.a015;

/**
 * A015993 Twelve iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015993 extends A015977 {

  @Override
  protected int iterations() {
    return 12;
  }
}
#!queue	A016018	1	->	0	A016017	--------------------------------
package irvine.oeis.a016;

/**
 * A016018 Least k such that (tau(k^3)+2)/3=n.
 * @author Sean A. Irvine
 */
public class A016018 extends A016017 {

  @Override
  protected int v() {
    return 3;
  }
}
#!queue	A016020	1	->	0	A016017	--------------------------------
package irvine.oeis.a016;

/**
 * A016020 Least k such that (tau(k^4)+3)/4=n.
 * @author Sean A. Irvine
 */
public class A016020 extends A016017 {

  @Override
  protected int v() {
    return 4;
  }
}
#!queue	A016031	0	->	1	A000295	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;
import irvine.oeis.a000.A000295;

/**
 * A016031 De Bruijn's sequence: 2^(2^(n-1) - n): number of ways of arranging 2^n bits in circle so all 2^n consecutive strings of length n are distinct.
 * @author Sean A. Irvine
 */
public class A016031 extends A000295 {

  @Override
  public Z next() {
    return Z.ONE.shiftLeft(super.next().longValueExact());
  }
}
#!queue	A016048	1	->	2	A016047	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;

/**
 * A016048 Least k such that (2*p_n)*k + 1 | Mersenne(p_n), p_n = n-th prime, n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A016048 extends A016047 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2().divide(mP);
  }
}
#!queue	A016058	1	->	2	A016057	--------------------------------
package irvine.oeis.a016;

import java.util.ArrayList;

import irvine.math.z.Z;

/**
 * A016058 Primitive pseudo-powers to base 3.
 * @author Sean A. Irvine
 */
public class A016058 extends A016057 {

  // Somewhat conjectural ... seems to match entries

  private final ArrayList<Z> mPrimitive = new ArrayList<>();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      boolean ok = true;
      for (final Z p : mPrimitive) {
        final Z[] qr = t.divideAndRemainder(p);
        if (qr[1].isZero()) {
          final Z base = qr[0].isPower();
          if (Z.THREE.equals(qr[0]) || Z.THREE.equals(base)) {
            ok = false;
            break;
          }
        }
      }
      if (ok) {
        mPrimitive.add(t);
        return t;
      }
    }
  }
}
#!queue	A016059	1	->	2	A006521	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;
import irvine.oeis.a006.A006521;

/**
 * A016059 (s(n)+s(n+1))/6, where s()=A006521.
 * @author Sean A. Irvine
 */
public class A016059 extends A006521 {

  private Z mPrev = super.next();

  {
    next();
  }

  @Override
  public Z next() {
    final Z t = mPrev;
    mPrev = super.next();
    return t.add(mPrev).divide(6);
  }
}
#!queue	A016060	1	->	3	A006521	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;
import irvine.oeis.a006.A006521;

/**
 * A016060 (s(n)+s(n+1))/18, where s()=A006521.
 * @author Sean A. Irvine
 */
public class A016060 extends A006521 {

  private Z mPrev = super.next();

  {
    next();
    next();
  }

  @Override
  public Z next() {
    final Z t = mPrev;
    mPrev = super.next();
    return t.add(mPrev).divide(18);
  }
}
#!queue	A018192	0	->	1	A081054	--------------------------------
package irvine.oeis.a018;

import irvine.factor.factor.Jaguar;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Binomial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a081.A081054;

/**
 * A018192 Number of chord diagrams of degree n with an isolated chord.
 * @author Sean A. Irvine
 */
public class A018192 extends A081054 {

  // After Alexander Stoimenow

  protected Z gamma(final int d, final int c) {
    if ((c & 1) == 0) {
      Z sum = Z.ZERO;
      Z zc = Z.ONE;
      for (int i = 0; i <= d / 2; ++i) {
        if (i > 0) {
          zc = zc.multiply(c);
        }
        sum = sum.add(Binomial.binomial(d, 2 * i).multiply(zc).multiply(mF.doubleFactorial(2 * i - 1)));
      }
      return sum;
    } else if ((d & 1) == 0) {
      return Z.valueOf(c).pow(d / 2).multiply(mF.doubleFactorial(d - 1));
    } else {
      return Z.ZERO;
    }
  }

  protected Z lambda(final int e, final int d, final int c) {
    return Binomial.binomial(e + d - 1, e).multiply(gamma(e, c));
  }

  protected Polynomial<Z> lambdaStarSeries(final int c, final int k, final int n) {
    final Z[] series = new Z[n + 1];
    for (int d = 0; d <= n; ++d) {
      series[d] = lambda(d, k, c);
    }
    return Polynomial.create(series);
  }

  private Polynomial<Z> xiSeries(final int c, final int k, final int n) {
    final Z[] t = new Z[n + 1];
    for (int d = 0; d <= n; ++d) {
      t[d] = xi(c, d, k);
    }
    return Polynomial.create(t);
  }

  protected Z xiBar(final int c, final int d, final int k) {
    final int n = d - 2;
    return RING.multiply(RING.diff(psiBarSeries(n).substitutePower(2, n).shift(1)), xiSeries(c, k - 1, n), n).coeff(n);
  }

  protected Z xi(final int c, final int d, final int k) {
    final int n = d - 2 * k;
    if (n < 0 || k < 0) {
      return Z.ZERO;
    }
    return RING.multiply(RING.pow(psiBarSeries(n).substitutePower(2, n), k, n), lambdaStarSeries(c, k + 1, n), n).coeff(n);
  }

  protected Z zeta(final int c, final int d, final int k) {
    return xi(c, d, k).add(xiBar(c, d, k));
  }

  protected Z eta(final int c, final int d) {
    Z sum = Z.ZERO;
    for (int k = 1; k <= d / 2; ++k) {
      sum = sum.signedAdd((k & 1) == 1, zeta(c, d, k));
    }
    return sum;
  }

  protected Z lambda(final int n) {
    return mF.doubleFactorial(2 * n - 1);
  }

  private Z psi(final int n) {
    return lambda(n).subtract(psiBarSeries(n).coeff(n));
  }

  private Z psiBar2(final int n, final int i) {
    return RING.multiply(RING.pow(psiBarSeries(n - 1), i), lambda2Series(i + 1, n), n).coeff(n - i);
  }

  protected Polynomial<Z> lambda2Series(final int i, final int n) {
    final Z[] series = new Z[n + 1];
    for (int d = 0; d <= n; ++d) {
      series[d] = lambda(d, i);
    }
    return Polynomial.create(series);
  }

  private Z psiBar(final int n) {
    Z sum = Z.ZERO;
    for (int i = 0; i <= n; ++i) {
      sum = sum.signedAdd((i & 1) == 0, psiBar2(n, i));
    }
    return sum;
  }

  protected Z gammaTilde(final int d, final int c) {
    if (c == 1) {
      return (d & 1) == 0 ? psi(d / 2) : Z.ZERO;
    }
    if (c == 2) {
      return eta(2, d).add((d & 1) == 1 ? psiBar((d - 1) / 2).multiply(d) : Z.ZERO);
    } else {
      assert c > 2;
      return eta(c, d);
    }
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final int n2 = 2 * mN;
    for (final Z dd : Jaguar.factor(n2).divisors()) {
      final int d = dd.intValue();
      final int c = n2 / d;
      sum = sum.add(gammaTilde(d, c).multiply(Euler.phiAsLong(c)));
    }
    return sum.divide(n2);
  }
}

#!queue	A018193	0	->	1	A018192	--------------------------------
package irvine.oeis.a018;

import irvine.math.z.Z;

/**
 * A018193 Number of chord diagrams of degree n with an isolated chord of length 1.
 * @author Sean A. Irvine
 */
public class A018193 extends A018192 {

  // After Alexander Stoimenow

  protected Z psiTildeBar(final int d) {
    if (d == 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k <= d; ++k) {
      sum = sum.signedAdd((k & 1) == 0, lambda(d - k, k + 1).add(lambda(d - k, k)));
    }
    return sum;
  }

  @Override
  protected Z xi(final int c, final int d, final int k) {
    if (2 * k > d || k < 0) {
      return Z.ZERO;
    }
    return lambda(d - 2 * k, k + 1, c);
  }

  @Override
  protected Z xiBar(final int c, final int d, final int k) {
    return xi(c, d - 2, k - 1);
  }

  protected Z psiTilde(final int d) {
    return lambda(d).subtract(psiTildeBar(d));
  }

  @Override
  protected Z gammaTilde(final int d, final int c) {
    if (c == 1) {
      return (d & 1) == 0 ? psiTilde(d / 2) : Z.ZERO;
    }
    if (c == 2) {
      return eta(2, d).add(d == 1 ? 1 : 0);
    } else {
      return eta(c, d);
    }
  }
}

#!queue	A018225	0	->	1	A317184	--------------------------------
package irvine.oeis.a018;

import irvine.math.z.Z;
import irvine.oeis.a007.A007769;
import irvine.oeis.a317.A317184;

/**
 * A018225 Number of connected chord diagrams of degree n.
 * @author Sean A. Irvine
 */
public class A018225 extends A317184 {

  private A007769 mA = new A007769();
  {
    mA.next(); // skip 0th
  }

  @Override
  public Z next() {
    return mA.next().subtract(super.next());
  }
}

#!queue	A018886	0	->	1	A002379	--------------------------------
package irvine.oeis.a018;

import irvine.math.z.Z;
import irvine.oeis.a002.A002379;

/**
 * A018886 Waring's problem: least positive integer requiring maximum number of terms when expressed as a sum of positive n-th powers.
 * @author Sean A. Irvine
 */
public class A018886 extends A002379 {

  {
    super.next(); // skip 0th
  }

  @Override
  public Z next() {
    return super.next().shiftLeft(mN).subtract(1);
  }
}
#!queue	A018899	1	->	0	A003586	--------------------------------
package irvine.oeis.a018;

import irvine.math.z.Z;
import irvine.oeis.a003.A003586;
import irvine.util.array.DynamicLongArray;
import irvine.util.array.LongDynamicBooleanArray;
import irvine.util.string.StringUtils;

/**
 * A018899 Smallest positive integer not representable as the sum of at most n distinct numbers of form 2^a*3^b.
 * @author Sean A. Irvine
 */
public class A018899 extends A003586 {

  // After Jack Brennan

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private LongDynamicBooleanArray mA = new LongDynamicBooleanArray();
  private final DynamicLongArray mL = new DynamicLongArray();
  private long mLimit = 1L << 16;
  private int mTerms;
  {
    // Precompute 2^a * 3^b list
    final A003586 mSeq = new A003586();
    final Z lim = Z.valueOf(Long.MAX_VALUE);
    Z t;
    while ((t = mSeq.next()).compareTo(lim) < 0) {
      mL.set(mL.length(), t.longValueExact());
    }
  }

  private long getN() {
    long n = mLimit;
    while (n != 0) {
      if (mA.isSet(--n)) {
        for (int j = 0; j < mL.length() && n + mL.get(j) < mLimit; ++j) {
          mA.set(n + mL.get(j));
        }
      }
    }
    n = 0;
    while (mA.isSet(n) && ++n < mLimit) {
    }
    return n;
  }

  @Override
  public Z next() {
    if (!mA.isSet(0)) {
      mA.set(0);
      return Z.ONE;
    }
    while (true) {
      final long n = getN();
      if (n != mLimit) {
        ++mTerms;
        return Z.valueOf(n);
      }
      mLimit <<= 6; // Expand search region by factor of 64
      if (mLimit <= 0) {
        throw new UnsupportedOperationException();
      }
      mA = new LongDynamicBooleanArray();
      mA.set(0);
      // Run up, skip over already produced terms
      for (int k = 0; k < mTerms; ++k) {
        getN();
      }
      if (mVerbose) {
        StringUtils.message("Limit increased to " + mLimit);
      }
    }
  }
}

#!queue	A019269	0	->	1	A019268	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;

/**
 * A019269 Let Dedekind's psi(m) = product of (p+1)p^(e-1) for primes p, where p^e is a factor of m. Iterating psi(m) eventually results in a number of form 2^a*3^b. a(n) is the number of steps to reach such a number.
 * @author Sean A. Irvine
 */
public class A019269 extends A019268 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(count(++mN));
  }
}
#!queue	A019304	1	->	0	A009475	--------------------------------
package irvine.oeis.a019;

import irvine.oeis.a009.A009475;

/**
 * A019304 "Pascal sweep" for k=3: draw a horizontal line through the 1 at C(k,0) in Pascal's triangle; rotate this line and record the sum of the numbers on it (excluding the initial 1).
 * @author Sean A. Irvine
 */
public class A019304 extends A009475 {

  @Override
  protected long row() {
    return 3;
  }
}
#!queue	A019305	1	->	0	A009475	--------------------------------
package irvine.oeis.a019;

import irvine.oeis.a009.A009475;

/**
 * A019305 "Pascal sweep" for k=4: draw a horizontal line through the 1 at binomial(k,0) in Pascal's triangle; rotate this line and record the sum of the numbers on it (excluding the initial 1).
 * @author Sean A. Irvine
 */
public class A019305 extends A009475 {

  @Override
  protected long row() {
    return 4;
  }
}
#!queue	A019306	1	->	0	A009475	--------------------------------
package irvine.oeis.a019;

import irvine.oeis.a009.A009475;

/**
 * A019306 "Pascal sweep" for k=5: draw a horizontal line through the 1 at C(k,0) in Pascal's triangle; rotate this line and record the sum of the numbers on it (excluding the initial 1).
 * @author Sean A. Irvine
 */
public class A019306 extends A009475 {

  @Override
  protected long row() {
    return 5;
  }
}
#!queue	A019444	0	->	1	A002251	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;
import irvine.oeis.a002.A002251;

/**
 * A019444 a_1, a_2, ..., is a permutation of the positive integers such that the average of each initial segment is an integer, using the greedy algorithm to define a_n.
 * @author Sean A. Irvine
 */
public class A019444 extends A002251 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A019578	1	->	3	A019575	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;

/**
 * A019578 Place n distinguishable balls in n boxes (in n^n ways); let f(n,k) = number of ways that max in any box is k, for 1&lt;=k&lt;=n; sequence gives f(n,3)/n.
 * @author Sean A. Irvine
 */
public class A019578 extends A019575 {

  private int mN = 2;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    mF = mF.multiply(mN++);
    return get(mN, mN, 3).subtract(get(mN, mN, 2)).multiply(mF).toZ();
  }
}
#!queue	A019579	1	->	3	A019575	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;

/**
 * A019579 Place n distinguishable balls in n boxes (in n^n ways); let f(n,k) = number of ways that max in any box is k, for 1 &lt;= k &lt;= n; sequence gives f(n,n-2)/n.
 * @author Sean A. Irvine
 */
public class A019579 extends A019575 {

  private int mN = 2;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    mF = mF.multiply(mN++);
    return get(mN, mN, mN - 2).subtract(get(mN, mN, mN - 3)).multiply(mF).toZ();
  }
}
#!queue	A019580	1	->	4	A019575	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;

/**
 * A019580 Place n distinguishable balls in n boxes (in n^n ways); let f(n,k) = number of ways that max in any box is k, for 1&lt;=k&lt;=n; sequence gives f(n,4)/n.
 * @author Sean A. Irvine
 */
public class A019580 extends A019575 {

  private int mN = 3;
  private Z mF = Z.TWO;

  @Override
  public Z next() {
    mF = mF.multiply(mN++);
    return get(mN, mN, 4).subtract(get(mN, mN, 3)).multiply(mF).toZ();
  }
}
#!queue	A020479	1	->	2	A000252	--------------------------------
package irvine.oeis.a020;

import irvine.math.z.Z;
import irvine.oeis.a000.A000252;

/**
 * A020479 Number of noninvertible 2 X 2 matrices over Z/nZ (determinant is a divisor of 0).
 * @author Sean A. Irvine
 */
public class A020479 extends A000252 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z a = super.next();
    return Z.valueOf(mN).pow(4).subtract(a);
  }
}
#!queue	A020942	2	->	1	A064105	--------------------------------
package irvine.oeis.a020;

import irvine.oeis.a000.A000930;
import irvine.oeis.a064.A064105;

/**
 * A020942 First column of 3rd-order Zeckendorf array.
 * @author Sean A. Irvine
 */
public class A020942 extends A064105 {

  /** Construct the sequence. */
  public A020942() {
    super(new A000930().skip(2), 3);
  }
}
#!queue	A020950	0	->	1	A020946	--------------------------------
package irvine.oeis.a020;

import irvine.math.z.Z;

/**
 * A020950 a(n) = k-1, where k is smallest number such that A002487(k) = n.
 * @author Sean A. Irvine
 */
public class A020950 extends A020946 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A020999	1	->	0	A014097	--------------------------------
package irvine.oeis.a020;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.oeis.a014.A014097;
import irvine.util.array.LongDynamicArray;

/**
 * A020999 Conjectured number of irreducible multiple zeta values of depth n and weight 3n (confirmed up to n=7).
 * @author Sean A. Irvine
 */
public class A020999 extends A014097 {

  private final LongDynamicArray<Z> mA = new LongDynamicArray<>();
  private long mN = 0;
  {
    mA.set(0, Z.ZERO);
  }

  private Z get(final long d) {
    while (d >= mA.length()) {
      mA.set(mA.length(), super.next());
    }
    return mA.get(d);
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(mN).divisors()) {
      final long d = dd.longValue();
      sum = sum.add(get(d).multiply(Mobius.mobius(mN / d)));
    }
    return sum.divide(mN);
  }
}
#!queue	A022155	0	->	1	A020985	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.a020.A020985;

/**
 * A022155 Values of n at which Golay-Rudin-Shapiro sequence A020985 is negative.
 * @author Sean A. Irvine
 */
public class A022155 extends A020985 {

  @Override
  public Z next() {
    while (true) {
      if (super.next().signum() < 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A022292	1	->	0	A000002	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.a000.A000002;

/**
 * A022292 Exactly half of first a(n) terms of Kolakoski sequence A000002 are 1's (not known to be infinite).
 * @author Sean A. Irvine
 */
public class A022292 extends A000002 {

  private long mA = -1; // Counts 2 * the number of 1s

  @Override
  public Z next() {
    if (mA < 0) {
      ++mA;
      return Z.ZERO;
    }
    while (true) {
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (mA == mN + 1) {
        return Z.valueOf(mA);
      }
    }
  }
}
#!queue	A022293	1	->	0	A000002	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.a000.A000002;

/**
 * A022293 Sequence A022292 divided by 2.
 * @author Sean A. Irvine
 */
public class A022293 extends A000002 {

  private long mA = 0; // Counts 2 * the number of 1s

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (mA == mN + 1) {
        return Z.valueOf(mA / 2);
      }
    }
  }
}
#!queue	A022298	1	->	0	A006928	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.a006.A006928;

/**
 * A022298 Exactly half of first n terms of A006928 are 1's (not known to be infinite).
 * @author Sean A. Irvine
 */
public class A022298 extends A006928 {

  private long mA = 0; // Counts 2 * the number of 1s
  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      mN += 2;
      if (mA == mN) {
        return Z.valueOf(mA);
      }
    }
  }
}
#!queue	A022299	1	->	0	A022298	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022299 Sequence A022298 divided by 2.
 * @author Sean A. Irvine
 */
public class A022299 extends A022298 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A022301	1	->	0	A022300	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022301 Index of n-th 1 in A022300.
 * @author Sean A. Irvine
 */
public class A022301 extends A022300 {

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN + 1);
      }
    }
  }
}
#!queue	A022302	1	->	0	A022300	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022302 Least k such that first k terms of A022300 contain n more 1's than 2's.
 * @author Sean A. Irvine
 */
public class A022302 extends A022300 {

  private long mExcess = 0;
  private long mOnes = 0;

  @Override
  public Z next() {
    ++mExcess;
    while (true) {
      if (Z.ONE.equals(super.next())) {
        ++mOnes;
      }
      final long twos = mN + 1 - mOnes;
      if (mOnes >= twos + mExcess) {
        return Z.valueOf(mN + 1);
      }
    }
  }
}
#!queue	A022304	1	->	0	A022303	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022304 Index of n-th 1 in A022303.
 * @author Sean A. Irvine
 */
public class A022304 extends A022303 {

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN + 1);
      }
    }
  }
}
#!queue	A022305	1	->	0	A022303	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022305 Exactly half the first a(n) terms of A022303 are 1's.
 * @author Sean A. Irvine
 */
public class A022305 extends A022303 {

  private long mA = 0; // Counts 2 * the number of 1s

  @Override
  public Z next() {
    while (true) {
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (Z.ONE.equals(super.next())) {
        mA += 2;
      }
      if (mA == mN + 1) {
        return Z.valueOf(mA);
      }
    }
  }
}
#!queue	A022306	1	->	0	A022305	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022306 Sequence A022305 divided by 2.
 * @author Sean A. Irvine
 */
public class A022306 extends A022305 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A022440	0	->	1	A022427	--------------------------------
package irvine.oeis.a022;

/**
 * A022440 a(n) = c(n-1) + c(n-3) where c is the sequence of positive numbers not in a.
 * @author Sean A. Irvine
 */
public class A022440 extends A022427 {

  /** Construct the sequence. */
  public A022440() {
    super(3, 4, 5);
  }
}
#!queue	A022494	1	->	0	A137251	--------------------------------
package irvine.oeis.a022;

import java.util.Arrays;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a137.A137251;

/**
 * A022494 Number of connected regular linearized chord diagrams of degree n.
 * @author Sean A. Irvine
 */
public class A022494 extends A137251 {

  // After Gheorghe Coserea

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final PolynomialRingField<Polynomial<Z>> RING2 = new PolynomialRingField<>("t", RING);
  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    final Polynomial<Polynomial<Z>> r = new Polynomial<>("t", RING.zero(), RING.one());
    r.add(RING.zero());
    r.add(RING.one());
    for (int n = 2; n <= mN; ++n) {
      final Polynomial<Z> c = new Polynomial<>("x", Z.ZERO, Z.ONE);
      c.add(Z.ZERO);
      for (int k = 0; k <= mN; ++k) {
        c.add(RING.create(Arrays.asList(get(k, 0, 0))).shift(2).coeff(n));
      }
      r.add(c);
    }
    return RING2.eval(RING2.series(RING2.x(), RING2.reversion(r, mN), mN), RING.one()).coeff(mN - 1);
  }
}
#!queue	A022818	0	->	1	A022811	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022818 Square array read by antidiagonals: A(n,k) = number of terms in the n-th derivative of a function composed with itself k times (n, k &gt;= 1).
 * @author Sean A. Irvine
 */
public class A022818 extends A022811 {

  private long mD = 1;
  private long mN = 1;

  @Override
  public Z next() {
    if (++mN >= mD) {
      ++mD;
      mN = 1;
    }
    return get(mN, mD - mN);
  }
}
#!queue	A022895	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022895 Number of solutions to c(1)*prime(1) + ... + c(n)*prime(n) = 1, where c(i) = +-1 for i &gt; 1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022895 extends A022894 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(1L, ++mN);
  }
}
#!queue	A022896	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022896 Number of solutions to c(1)*prime(1) + ... + c(n)*prime(n) = 2, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022896 extends A022894 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(0L, ++mN);
  }
}
#!queue	A022897	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022897 Number of solutions to c(1)*prime(2) +...+ c(n)*prime(n+1) = 0, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022897 extends A022894 {

  private long mN = 0;

  @Override
  protected long start() {
    return 2;
  }

  @Override
  public Z next() {
    return get(3L, ++mN);
  }
}
#!queue	A022898	0	->	1	A022897	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022898 Number of solutions to c(1)*prime(2)+...+c(n)*prime(n+1) = 1, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022898 extends A022897 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2L, ++mN);
  }
}
#!queue	A022899	0	->	1	A022897	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022899 Number of solutions to c(1)*prime(2) + ... + c(n)*prime(n+1) = 2, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022899 extends A022897 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(1L, ++mN);
  }
}
#!queue	A022900	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022900 Number of solutions to c(1)*prime(3) + ... + c(n)*prime(n+2) = 0, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022900 extends A022894 {

  private long mN = 0;

  @Override
  protected long start() {
    return 4;
  }

  @Override
  public Z next() {
    return get(5L, ++mN);
  }
}
#!queue	A022901	0	->	1	A022900	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022901 Number of solutions to c(1)*prime(3)+...+c(n)*prime(n+2) = 1, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022901 extends A022900 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(4L, ++mN);
  }
}
#!queue	A022902	0	->	1	A022900	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022902 Number of solutions to c(1)*prime(3)+...+c(n)*prime(n+2) = 2, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022902 extends A022900 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(3L, ++mN);
  }
}
#!queue	A022903	0	->	1	A022894	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022903 Number of solutions to c(1)*prime(4) + ... + c(n)*prime(n+3) = 0, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022903 extends A022894 {

  private long mN = 0;

  @Override
  protected long start() {
    return 6;
  }

  @Override
  public Z next() {
    return get(7L, ++mN);
  }
}
#!queue	A022904	0	->	1	A022903	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022904 Number of solutions to c(1)*prime(4) + ... + c(n)*prime(n+3) = 1, where c(i) = +-1 for i&gt;1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022904 extends A022903 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(6L, ++mN);
  }
}
#!queue	A022907	0	->	1	A000123	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.a000.A000123;

/**
 * A022907 The sequence m(n) in A022905.
 * @author Sean A. Irvine
 */
public class A022907 extends A000123 {

  @Override
  public Z next() {
    return super.next().multiply(3).divide2().subtract(1);
  }
}
#!queue	A022908	0	->	1	A022907	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022908 The sequence M(n) in A022905.
 * @author Sean A. Irvine
 */
public class A022908 extends A022907 {

  private long mN = 0;
  private Z mS = Z.ZERO;

  @Override
  public Z next() {
    if (++mN > 1) {
      mS = mS.add(super.next());
    }
    return mS.add(mN == 1 ? 0 : mN);
  }
}
#!queue	A022920	0	->	1	A022903	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;

/**
 * A022920 Number of solutions to c(1)*prime(4) + ... + c(n)*prime(n+3) = 2, where c(i) = +-1 for i &gt; 1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022920 extends A022903 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(5L, ++mN);
  }
}
#!queue	A023025	4	->	5	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023025 Number of partitions of n into 5 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023025 extends A023024 {

  @Override
  protected int parts() {
    return 5;
  }
}
#!queue	A023026	4	->	6	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023026 Number of partitions of n into 6 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023026 extends A023024 {

  @Override
  protected int parts() {
    return 6;
  }
}
#!queue	A023027	4	->	7	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023027 Number of partitions of n into 7 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023027 extends A023024 {

  @Override
  protected int parts() {
    return 7;
  }
}
#!queue	A023028	4	->	8	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023028 Number of partitions of n into 8 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023028 extends A023024 {

  @Override
  protected int parts() {
    return 8;
  }
}
#!queue	A023029	4	->	9	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023029 Number of partitions of n into 9 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023029 extends A023024 {

  @Override
  protected int parts() {
    return 9;
  }
}
#!queue	A023030	4	->	10	A023024	--------------------------------
package irvine.oeis.a023;

/**
 * A023030 Number of partitions of n into 10 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023030 extends A023024 {

  @Override
  protected int parts() {
    return 10;
  }
}
#!queue	A023031	1	->	6	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023031 Number of compositions of n into 6 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023031 extends A000741 {

  {
    for (int k = 0; k < 5; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 5);
  }
}
#!queue	A023032	1	->	7	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023032 Number of compositions of n into 7 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023032 extends A000741 {

  {
    for (int k = 0; k < 6; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 6);
  }
}
#!queue	A023033	1	->	8	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023033 Number of compositions of n into 8 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023033 extends A000741 {

  {
    for (int k = 0; k < 7; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 7);
  }
}
#!queue	A023034	1	->	9	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023034 Number of compositions of n into 9 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023034 extends A000741 {

  {
    for (int k = 0; k < 8; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 8);
  }
}
#!queue	A023035	1	->	10	A000741	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000741;

/**
 * A023035 Number of compositions of n into 10 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023035 extends A000741 {

  {
    for (int k = 0; k < 9; ++k) {
      super.next();
    }
  }

  @Override
  protected Z p(final Z n) {
    return Binomial.binomial(n.longValue() - 1, 9);
  }
}
#!queue	A023095	3	->	4	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023095 a(n) is the least k &gt; 0 such that k and 3k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023095 extends A023094 {

  @Override
  protected int multiple() {
    return 3;
  }
}
#!queue	A023096	3	->	5	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023096 Least k such that k and 4k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023096 extends A023094 {

  @Override
  protected int multiple() {
    return 4;
  }
}
#!queue	A023097	3	->	6	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023097 a(n) is least k such that k and 5k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023097 extends A023094 {

  @Override
  protected int multiple() {
    return 5;
  }
}
#!queue	A023098	3	->	7	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023098 a(n) is least k such that k and 6k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023098 extends A023094 {

  @Override
  protected int multiple() {
    return 6;
  }
}
#!queue	A023099	3	->	8	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023099 a(n) is least k such that k and 7k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023099 extends A023094 {

  @Override
  protected int multiple() {
    return 7;
  }
}
#!queue	A023100	3	->	9	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023100 a(n) is least k such that k and 8k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023100 extends A023094 {

  @Override
  protected int multiple() {
    return 8;
  }
}
#!queue	A023101	3	->	10	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023101 a(n) is least k such that k and 9k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023101 extends A023094 {

  @Override
  protected int multiple() {
    return 9;
  }
}
#!queue	A023102	3	->	11	A023094	--------------------------------
package irvine.oeis.a023;

/**
 * A023102 a(n) is least k such that k and 10k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023102 extends A023094 {

  @Override
  protected int multiple() {
    return 10;
  }
}
#!queue	A023487	1	->	0	A000204	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000204;
import irvine.oeis.a001.A001690;

/**
 * A023487 a(n) = b(n) + d(n), where b(n) = (n-th Lucas number &gt; 3) and d(n) = (n-th non-Fibonacci number).
 * @author Sean A. Irvine
 */
public class A023487 extends A000204 {

  final Sequence mA = new A001690();
  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().add(mA.next());
  }
}
#!queue	A023495	1	->	0	A000204	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000204;
import irvine.oeis.a090.A090946;

/**
 * A023495 a(n) = b(n) + d(n), where b(n) = (n-th Lucas number &gt; 3) and d(n) = (n-th non-Lucas number).
 * @author Sean A. Irvine
 */
public class A023495 extends A000204 {

  final Sequence mA = new A090946();
  {
    super.next();
    next();
  }

  @Override
  public Z next() {
    return super.next().add(mA.next());
  }
}
#!queue	A023638	11	->	6	A023637	--------------------------------
package irvine.oeis.a023;

/**
 * A023638 Vertex-transitive graphs of valency 11 with 2n nodes.
 * @author Sean A. Irvine
 */
public class A023638 extends A023637 {

  /** Construct the sequence. */
  public A023638() {
    super(11);
  }
}
#!queue	A023640	5	->	3	A023637	--------------------------------
package irvine.oeis.a023;

/**
 * A023640 Number of vertex-transitive graphs of valency 5 with 2n nodes.
 * @author Sean A. Irvine
 */
public class A023640 extends A023637 {

  /** Construct the sequence. */
  public A023640() {
    super(5);
  }
}
#!queue	A023642	7	->	4	A023637	--------------------------------
package irvine.oeis.a023;

/**
 * A023642 Vertex-transitive graphs of valency 7 with 2n nodes.
 * @author Sean A. Irvine
 */
public class A023642 extends A023637 {

  /** Construct the sequence. */
  public A023642() {
    super(7);
  }
}
#!queue	A023644	9	->	5	A023637	--------------------------------
package irvine.oeis.a023;

/**
 * A023644 Vertex-transitive graphs of valency 9 with 2n nodes.
 * @author Sean A. Irvine
 */
public class A023644 extends A023637 {

  /** Construct the sequence. */
  public A023644() {
    super(9);
  }
}
#!queue	A023646	3	->	2	A023637	--------------------------------
package irvine.oeis.a023;

/**
 * A023646 Number of vertex-transitive graphs of valency 3 with 2n nodes.
 * @author Sean A. Irvine
 */
public class A023646 extends A023637 {

  /** Construct the sequence. */
  public A023646() {
    super(3);
  }
}
#!queue	A023892	0	->	1	A007360	--------------------------------
package irvine.oeis.a023;

import java.util.Collections;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a007.A007360;

/**
 * A023892 Derivative of log of A007360.
 * @author Sean A. Irvine
 */
public class A023892 extends A007360 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mG = RING.create(Collections.singletonList(new Q(super.next())));
  private int mN = 0;

  @Override
  public Z next() {
    mG.add(new Q(super.next()));
    return RING.diff(RING.log(mG, ++mN)).coeff(mN - 1).toZ();
  }
}

#!queue	A023896	2	->	1	A023022	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;

/**
 * A023896 Sum of positive integers in smallest positive reduced residue system modulo n. a(1) = 1 by convention.
 * @author Sean A. Irvine
 */
public class A023896 extends A023022 {

  private long mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    return ++mN <= 2 ? Z.ONE : super.next().multiply(mN);
  }
}

#!queue	A023901	0	->	1	A002126	--------------------------------
package irvine.oeis.a023;

import java.util.Collections;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a002.A002126;

/**
 * A023901 Derivative of log of A002126.
 * @author Sean A. Irvine
 */
public class A023901 extends A002126 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mG = RING.create(Collections.singletonList(new Q(super.next())));
  private int mN = 0;

  @Override
  public Z next() {
    mG.add(new Q(super.next()));
    return RING.diff(RING.log(mG, ++mN)).coeff(mN - 1).toZ();
  }
}

#!queue	A023986	0	->	1	A023847	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;

/**
 * A023986 Sum of exponents of primes in C(4n,2n)/C(2n,n).
 * @author Sean A. Irvine
 */
public class A023986 extends A023847 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(binomialOmega(4 * ++mN, 2 * mN) - binomialOmega(2 * mN, mN));
  }
}

#!queue	A023987	0	->	1	A023847	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;

/**
 * A023987 Sum of exponents of primes in C(5n,3n)/C(3n,2n).
 * @author Sean A. Irvine
 */
public class A023987 extends A023847 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(binomialOmega(5 * ++mN, 3 * mN) - binomialOmega(3 * mN, 2 * mN));
  }
}

#!queue	A024222	0	->	1	A002326	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a002.A002326;

/**
 * A024222 Number of shuffles (perfect faro shuffles with cut) required to return a deck of size n to original order.
 * @author Sean A. Irvine
 */
public class A024222 extends A002326 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    if (mA == null) {
      mA = super.next();
      if (!Z.ONE.equals(mA)) {
        return mA;
      }
    }
    final Z t = mA;
    mA = null;
    return t;
  }
}

#!queue	A024311	0	->	1	A002212	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a055.A055879;

/**
 * A024311 Catacondensed simply-connected monopentapolyhexes.
 * @author Sean A. Irvine
 */
public class A024311 extends A002212 {

  private Z mU = super.next().subtract(1);
  private final Sequence mVSeq = new A055879();

  @Override
  public Z next() {
    final Z uPrev = mU;
    mU = super.next();
    return mU.subtract(uPrev.multiply2()).subtract(mVSeq.next()).divide2();
  }
}
#!queue	A024482	1	->	2	A051924	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a051.A051924;

/**
 * A024482 a(n) = (1/2)*(binomial(2n, n) - binomial(2n-2, n-1)).
 * @author Sean A. Irvine
 */
public class A024482 extends A051924 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A024512	1	->	2	A004431	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a004.A004431;

/**
 * A024512 Position of 1 + n^2 in A004431 (sums of 2 distinct nonzero squares).
 * @author Sean A. Irvine
 */
public class A024512 extends A004431 {

  private long mN = 0;
  private long mM = 1;

  @Override
  public Z next() {
    final Z t = Z.valueOf(++mM).square().add(1);
    while (true) {
      ++mN;
      if (super.next().equals(t)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A024528	1	->	0	A008578	--------------------------------
package irvine.oeis.a024;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002110;
import irvine.oeis.a008.A008578;

/**
 * A024528 a(n) = n-th elementary symmetric function of {1, prime(1), prime(2), ..., prime(n)}.
 * @author Sean A. Irvine
 */
public class A024528 extends A008578 {

  private Q mSum = Q.ZERO;
  private Sequence mA2110 = new A002110();

  @Override
  public Z next() {
    mSum = mSum.add(new Q(Z.ONE, super.next()));
    return mSum.multiply(mA2110.next()).num();
  }
}
#!queue	A024610	1	->	0	A003136	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a003.A003136;

/**
 * A024610 Position of n^2 in A003136.
 * @author Sean A. Irvine
 */
public class A024610 extends A003136 {

  private long mN = 0;
  private long mM = -1;

  @Override
  public Z next() {
    final Z m2 = Z.valueOf(++mM).square();
    while (true) {
      ++mN;
      if (super.next().equals(m2)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024673	1	->	2	A024670	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;

/**
 * A024673 Position of 1 + n^3 in A024670 (distinct sums of cubes of distinct positive integers).
 * @author Sean A. Irvine
 */
public class A024673 extends A024670 {

  private long mN = 0;
  private long mM = 1;

  @Override
  public Z next() {
    final Z t = Z.valueOf(++mM).pow(3).add(1);
    while (true) {
      ++mN;
      if (t.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024808	1	->	3	A004432	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a004.A004432;

/**
 * A024808 a(n) = position of 5 + n^2 in A004432.
 * @author Sean A. Irvine
 */
public class A024808 extends A004432 {

  private long mN = 0;
  private long mM = 2;

  @Override
  public Z next() {
    final Z t = Z.valueOf(++mM).square().add(5);
    while (true) {
      ++mN;
      if (t.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024818	0	->	1	A024814	--------------------------------
package irvine.oeis.a024;

import irvine.math.cr.CR;
import irvine.math.cr.ComputableReals;
import irvine.math.z.Z;

/**
 * A024818 a(n) = floor(tan m), where m is the least positive integer such that floor(tan m) &gt; floor(tan k) for k = 0,1,...,m-1.
 * @author Sean A. Irvine
 */
public class A024818 extends A024814 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return ComputableReals.SINGLETON.tan(CR.valueOf(super.next())).floor();
  }
}
#!queue	A024943	0	->	1	A024941	--------------------------------
package irvine.oeis.a024;

import irvine.oeis.Sequence;
import irvine.oeis.a002.A002476;

/**
 * A024943 Number of partitions of n into distinct 6k+1 primes.
 * @author Sean A. Irvine
 */
public class A024943 extends A024941 {

  @Override
  protected Sequence seq() {
    return new A002476();
  }

  {
    next();
  }
}
#!queue	A024944	0	->	1	A024941	--------------------------------
package irvine.oeis.a024;

import irvine.oeis.Sequence;
import irvine.oeis.a007.A007528;

/**
 * A024944 Number of partitions of n into distinct 6k-1 primes.
 * @author Sean A. Irvine
 */
public class A024944 extends A024941 {

  @Override
  protected Sequence seq() {
    return new A007528();
  }

  {
    next();
  }
}
#!queue	A024979	1	->	3	A024975	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;

/**
 * A024979 Position of n^3 + 9 in A024975.
 * @author Sean A. Irvine
 */
public class A024979 extends A024975 {

  private long mM = 2;
  private long mN = 0;

  @Override
  public Z next() {
    final Z t = Z.valueOf(++mM).pow(3).add(9);
    while (true) {
      ++mN;
      if (super.next().equals(t)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024997	2	->	3	A025179	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.a025.A025179;

/**
 * A024997 a(n) = number of (s(0), s(1), ..., s(n)) such that every s(i) is an integer, s(0) = 0 = s(n), |s(i) - s(i-1)| = 1 for i = 1,2; |s(i) - s(i-1)| &lt;= 1 for i &gt;= 3. Also a(n) = T(n,n), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A024997 extends A025179 {

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A025047	1	->	0	A059882	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a059.A059882;

/**
 * A025047 Alternating compositions, i.e., compositions with alternating increases and decreases, starting with either an increase or a decrease.
 * @author Sean A. Irvine
 */
public class A025047 extends A059882 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.NEG_ONE;
    for (long k = 1; k <= mN; ++k) {
      sum = sum.add(mS.get(mN, k).add(mT.get(mN, k)));
    }
    return sum;
  }
}
#!queue	A025048	1	->	0	A059882	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a059.A059882;

/**
 * A025048 Number of up/down (initially ascending) compositions of n.
 * @author Sean A. Irvine
 */
public class A025048 extends A059882 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= mN; ++k) {
      sum = sum.add(mT.get(mN, k));
    }
    return sum;
  }
}
#!queue	A025049	1	->	0	A059882	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a059.A059882;

/**
 * A025049 Number of down/up (initially descending) compositions of n.
 * @author Sean A. Irvine
 */
public class A025049 extends A059882 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= mN; ++k) {
      sum = sum.add(mS.get(mN, k));
    }
    return sum;
  }
}
#!queue	A025135	0	->	1	A025134	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025135 (n-1)st elementary symmetric function of binomial(n,0), binomial(n,1), ..., binomial(n,n).
 * @author Sean A. Irvine
 */
public class A025135 extends A025134 {

  private long mN = 0;

  @Override
  public Z next() {
    return sym(Z.ONE, 0, ++mN, mN, mN - 1);
  }
}
#!queue	A025141	0	->	2	A025134	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025141 a(n) = (k-1)st elementary symmetric function of C(n,0), C(n,1), ..., C(n,k), where k = floor( n/2 ).
 * @author Sean A. Irvine
 */
public class A025141 extends A025134 {

  private long mN = 1;

  @Override
  public Z next() {
    return sym(Z.ONE, 0, ++mN / 2, mN, mN / 2 - 1);
  }
}
#!queue	A025158	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025158 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 4.
 * @author Sean A. Irvine
 */
public class A025158 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 4);
  }
}
#!queue	A025159	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025159 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 5.
 * @author Sean A. Irvine
 */
public class A025159 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 5);
  }
}
#!queue	A025160	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025160 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 6.
 * @author Sean A. Irvine
 */
public class A025160 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 6);
  }
}
#!queue	A025161	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025161 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 7.
 * @author Sean A. Irvine
 */
public class A025161 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 7);
  }
}
#!queue	A025162	0	->	1	A194543	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a194.A194543;

/**
 * A025162 Number of partitions of n with distinct parts p(i) such that if i != j, then |p(i) - p(j)| &gt;= 8.
 * @author Sean A. Irvine
 */
public class A025162 extends A194543 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 8);
  }
}
#!queue	A025183	0	->	1	A025177	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025183 a(n) = T(2n-1,n), where T is the array defined in A025177.
 * @author Sean A. Irvine
 */
public class A025183 extends A025177 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN);
  }
}
#!queue	A025187	0	->	1	A025177	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025187 a(n) = T(2n,n-1), where T is the array defined in A025177.
 * @author Sean A. Irvine
 */
public class A025187 extends A025177 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A025188	0	->	1	A025177	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025188 a(n) = T(2n,n+1), where T is the array defined in A025177.
 * @author Sean A. Irvine
 */
public class A025188 extends A025177 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A025200	3	->	2	A025194	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A025200 a(n) = floor(floor(S3)/floor(S1)), where S3 and S1 are, respectively, the 3rd and first elementary symmetric functions of {sqrt(k), k = 1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A025200 extends A025194 {

  private final Sequence mS1 = new A025224().skip(3);

  @Override
  public Z next() {
    return super.next().divide(mS1.next());
  }
}
#!queue	A025213	2	->	3	A025212	--------------------------------
package irvine.oeis.a025;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A025213 a(n) = floor(3rd elementary symmetric function of Sum_{j=1..k} 1/j, k = 1,2,...,n).
 * @author Sean A. Irvine
 */
public class A025213 extends A025212 {

  private int mN = 2;
  private Q mSum = Q.ZERO;

  @Override
  public Z next() {
    final Q si = h(++mN);
    for (int j = 2; j < mN; ++j) {
      final Q sj = si.multiply(h(j));
      for (int k = 1; k < j; ++k) {
        mSum = mSum.add(sj.multiply(h(k)));
      }
    }
    return mSum.floor();
  }
}
#!queue	A025214	2	->	4	A025212	--------------------------------
package irvine.oeis.a025;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A025214 a(n) = floor(4th elementary symmetric function of Sum_{j=1..k} 1/j, k = 1,2,...,n).
 * @author Sean A. Irvine
 */
public class A025214 extends A025212 {

  private int mN = 3;
  private Q mSum = Q.ZERO;

  @Override
  public Z next() {
    final Q sl = h(++mN);
    for (int i = 3; i < mN; ++i) {
      final Q si = sl.multiply(h(i));
      for (int j = 2; j < i; ++j) {
        final Q sj = si.multiply(h(j));
        for (int k = 1; k < j; ++k) {
          mSum = mSum.add(sj.multiply(h(k)));
        }
      }
    }
    return mSum.floor();
  }
}
#!queue	A025215	2	->	1	A025212	--------------------------------
package irvine.oeis.a025;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A025215 a(n) = [ Sum of squares of 1 + 1/2 + ... + 1/k ], k = 1,2,...,n.
 * @author Sean A. Irvine
 */
public class A025215 extends A025212 {

  private int mN = 0;
  private Q mSum = Q.ZERO;

  @Override
  public Z next() {
    mSum = mSum.add(h(++mN).square());
    return mSum.floor();
  }
}
#!queue	A025480	1	->	0	A000265	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a000.A000265;

/**
 * A025480 a(2n) = n, a(2n+1) = a(n).
 * @author Sean A. Irvine
 */
public class A025480 extends A000265 {

  @Override
  public Z next() {
    return super.next().subtract(1).divide2();
  }
}

#!queue	A025488	1	->	0	A025487	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025488 Number of distinct prime signatures of the positive integers up to 2^n.
 * @author Sean A. Irvine
 */
public class A025488 extends A025487 {

  private long mSignatures = 0;
  private Z mLimit = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mSignatures;
    } while (super.next().compareTo(mLimit) < 0);
    mLimit = mLimit.multiply2();
    return Z.valueOf(mSignatures);
  }
}

#!queue	A025506	1	->	0	A006928	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a006.A006928;

/**
 * A025506 Least k such that first k terms of A006928 contain n more 1's than 2's.
 * @author Sean A. Irvine
 */
public class A025506 extends A006928 {

  private long mRunningDelta = 0;
  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.TWO;
    }
    while (mRunningDelta != mN) {
      mRunningDelta -= super.next().longValue() * 2 - 3;
      ++mM;
    }
    return Z.valueOf(mM);
  }
}
#!queue	A025537	1	->	0	A002944	--------------------------------
package irvine.oeis.a025;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002944;
import irvine.oeis.a003.A003418;

/**
 * A025537 a(n) = (1/s(1) + 1/s(2) + ... + 1/s(n+1)) * LCM{1, 2, ..., n}, where s(k) = LCM{1,2,...,k}/k = A002944(k).
 * @author Sean A. Irvine
 */
public class A025537 extends A002944 {

  private Sequence mA = new A003418();
  private Q mSum = Q.ZERO;

  @Override
  public Z next() {
    mSum = mSum.add(new Q(Z.ONE, super.next()));
    return mSum.multiply(mA.next()).toZ();
  }
}
#!queue	A025538	1	->	0	A002944	--------------------------------
package irvine.oeis.a025;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002944;
import irvine.oeis.a003.A003418;

/**
 * A025538 a(n) = (1/s(1) - 1/s(2) + ... + d/s(n+1)) * LCM{1, 2, ..., n}, where d = (-1)^n, s = A002944, i.e., s(k) = LCM of row k of Pascal's triangle.
 * @author Sean A. Irvine
 */
public class A025538 extends A002944 {

  private Sequence mA = new A003418();
  private Q mSum = Q.ZERO;
  private boolean mSign = false;

  @Override
  public Z next() {
    mSign = !mSign;
    mSum = mSum.signedAdd(mSign, new Q(Z.ONE, super.next()));
    return mSum.multiply(mA.next()).toZ();
  }
}
#!queue	A025543	1	->	0	A018252	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a018.A018252;

/**
 * A025543 Least common multiple of the first n composite numbers.
 * @author Sean A. Irvine
 */
public class A025543 extends A018252 {

  private Z mL = Z.ONE;

  @Override
  public Z next() {
    mL = mL.lcm(super.next());
    return mL;
  }
}
#!queue	A025547	0	->	1	A005408	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a005.A005408;

/**
 * A025547 Least common multiple of {1,3,5,...,2n-1}.
 * @author Sean A. Irvine
 */
public class A025547 extends A005408 {

  private Z mL = Z.ONE;

  @Override
  public Z next() {
    mL = mL.lcm(super.next());
    return mL;
  }
}
#!queue	A025548	0	->	1	A025547	--------------------------------
package irvine.oeis.a025;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;

/**
 * A025548 a(n) = sum of the exponents in the prime factorization of the least common multiple of {1,3,5,...,2n-1}.
 * @author Sean A. Irvine
 */
public class A025548 extends A025547 {

  private final PrimeDivision mFactor = new PrimeDivision();

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).bigOmega());
  }
}
#!queue	A025549	0	->	1	A025547	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001147;

/**
 * A025549 a(n) = (2n-1)!!/lcm{1,3,5,...,2n-1}.
 * @author Sean A. Irvine
 */
public class A025549 extends A025547 {

  private final Sequence mDF = new A001147().skip(1);

  @Override
  public Z next() {
    return mDF.next().divide(super.next());
  }
}
#!queue	A025565	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025565 a(n) = T(n,n-1), where T is array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025565 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A025567	0	->	1	A014531	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a014.A014531;

/**
 * A025567 a(n) = T(n,n+1), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025567 extends A014531 {

  private Z mS = Z.ZERO;

  @Override
  public Z next() {
    final Z t = mS;
    mS = super.next();
    return mS.add(t);
  }
}
#!queue	A025569	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025569 T(2n-1,n), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025569 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(2 * mN, mN + 1);
  }
}
#!queue	A025570	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025570 a(n) = T(2n,n), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025570 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(2 * mN - 1, mN);
  }
}
#!queue	A025571	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025571 a(n) = T(3n,n), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025571 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(3 * mN - 1, mN);
  }
}
#!queue	A025572	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025572 a(n) = T(4n,n), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025572 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(4 * mN - 1, mN);
  }
}
#!queue	A025573	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025573 a(n) = T(2n,n-1), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025573 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(2 * mN + 1, mN);
  }
}
#!queue	A025574	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025574 T(2n,n+1), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025574 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return get(2 * mN + 1, mN + 2);
  }
}
#!queue	A025575	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025575 a(n) = T(n,[ n/2 ]), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025575 extends A025564 {

  private long mN = -2;

  @Override
  public Z next() {
    if (++mN == -1) {
      return Z.ONE;
    }
    return get(mN, (mN + 1) / 2);
  }
}
#!queue	A025576	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025576 a(n) = T(n,[ n/2 ]+1), where T is the array defined in A025564.
 * @author Sean A. Irvine
 */
public class A025576 extends A025564 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, (mN + 1) / 2 + 1);
  }
}
#!queue	A025578	0	->	1	A025564	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025578 a(n) = Sum{T(n,k-1), k = 1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A025578 extends A025564 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A025692	1	->	0	A025610	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025692 Index of 2^n within sequence of numbers of form 2^i*6^j.
 * @author Sean A. Irvine
 */
public class A025692 extends A025610 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply2();
    return Z.valueOf(mN);
  }
}
#!queue	A025693	1	->	0	A003591	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a003.A003591;

/**
 * A025693 Index of 2^n within sequence of numbers of form 2^i*7^j.
 * @author Sean A. Irvine
 */
public class A025693 extends A003591 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply2();
    return Z.valueOf(mN);
  }
}
#!queue	A025694	1	->	0	A025611	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025694 Index of 2^n within sequence of numbers of form 2^i * 9^j.
 * @author Sean A. Irvine
 */
public class A025694 extends A025611 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply2();
    return Z.valueOf(mN);
  }
}
#!queue	A025700	1	->	0	A025616	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025700 Index of 3^n within sequence of numbers of form 3^i * 10^j.
 * @author Sean A. Irvine
 */
public class A025700 extends A025616 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(3);
    return Z.valueOf(mN);
  }
}
#!queue	A025702	1	->	0	A025617	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025702 Index of 4^n within sequence of numbers of form 4^i*5^j.
 * @author Sean A. Irvine
 */
public class A025702 extends A025617 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.shiftLeft(2);
    return Z.valueOf(mN);
  }
}
#!queue	A025703	1	->	0	A025618	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025703 Index of 4^n within sequence of numbers of form 4^i*6^j.
 * @author Sean A. Irvine
 */
public class A025703 extends A025618 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.shiftLeft(2);
    return Z.valueOf(mN);
  }
}
#!queue	A025706	1	->	0	A025617	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025706 Index of 5^n within sequence of numbers of form 4^i*5^j.
 * @author Sean A. Irvine
 */
public class A025706 extends A025617 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(5);
    return Z.valueOf(mN);
  }
}
#!queue	A025707	1	->	0	A025622	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025707 Index of 5^n within sequence of numbers of form 5^i*6^j.
 * @author Sean A. Irvine
 */
public class A025707 extends A025622 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(5);
    return Z.valueOf(mN);
  }
}
#!queue	A025708	1	->	0	A003595	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a003.A003595;

/**
 * A025708 Index of 5^n within sequence of numbers of form 5^i*7^j.
 * @author Sean A. Irvine
 */
public class A025708 extends A003595 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(5);
    return Z.valueOf(mN);
  }
}
#!queue	A025715	1	->	0	A025622	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025715 Index of 6^n in A025622 (numbers of form 5^i*6^j).
 * @author Sean A. Irvine
 */
public class A025715 extends A025622 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(6);
    return Z.valueOf(mN);
  }
}
#!queue	A025723	1	->	0	A003595	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;
import irvine.oeis.a003.A003595;

/**
 * A025723 Index of 7^n within sequence of numbers of form 5^i*7^j.
 * @author Sean A. Irvine
 */
public class A025723 extends A003595 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(7);
    return Z.valueOf(mN);
  }
}
#!queue	A025742	1	->	0	A025621	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025742 a(n) is the index of 10^n within sequence of numbers of form 4^i*10^j.
 * @author Sean A. Irvine
 */
public class A025742 extends A025621 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(10);
    return Z.valueOf(mN);
  }
}
#!queue	A025747	1	->	0	A025635	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Z;

/**
 * A025747 Index of 10^n within sequence of numbers of form 9^i*10^j.
 * @author Sean A. Irvine
 */
public class A025747 extends A025635 {

  private long mN = 0;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!mA.equals(super.next()));
    mA = mA.multiply(10);
    return Z.valueOf(mN);
  }
}
#!queue	A026002	0	->	1	A008288	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A026002 a(n) = T(n,n+2), where T = Delannoy triangle (A008288).
 * @author Sean A. Irvine
 */
public class A026002 extends A008288 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN + 2);
  }
}
#!queue	A026052	0	->	2	A008778	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.recur.PeriodicSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a008.A008778;

/**
 * A026052 (d(n)-r(n))/2, where d = A008778 and r is the periodic sequence with fundamental period (1,1,0,1).
 * @author Sean A. Irvine
 */
public class A026052 extends A008778 {

  private final Sequence mS = new PeriodicSequence(1, 1, 0, 1);
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mS.next()).divide2();
  }
}

#!queue	A026053	0	->	2	A008778	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.recur.PeriodicSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a008.A008778;

/**
 * A026053 (d(n)-r(n))/5, where d = A008778 and r is the periodic sequence with fundamental period (0,3,1,0,1).
 * @author Sean A. Irvine
 */
public class A026053 extends A008778 {

  private final Sequence mS = new PeriodicSequence(0, 3, 1, 0, 1);
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mS.next()).divide(5);
  }
}

#!queue	A026059	0	->	4	A026057	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.recur.PeriodicSequence;
import irvine.oeis.Sequence;

/**
 * A026059 a(n) = (d(n)-r(n))/5, where d = A026057 and r is the periodic sequence with fundamental period (1,0,3,1,0).
 * @author Sean A. Irvine
 */
public class A026059 extends A026057 {

  private final Sequence mS = new PeriodicSequence(1, 0, 3, 1, 0);
  {
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mS.next()).divide(5);
  }
}

#!queue	A026072	0	->	1	A024996	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a024.A024996;

/**
 * A026072 a(n) = T(2n-1,n), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A026072 extends A024996 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN).max(Z.ONE);
  }
}

#!queue	A026076	0	->	1	A024996	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a024.A024996;

/**
 * A026076 a(n) = T(2n,n-1), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A026076 extends A024996 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}

#!queue	A026077	0	->	1	A024996	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a024.A024996;

/**
 * A026077 a(n) = T(2n,n+1), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A026077 extends A024996 {

  private long mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return get(2 * mN, mN + 1);
  }
}

#!queue	A026079	2	->	1	A025179	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a025.A025179;

/**
 * A026079 a(n) = Sum_{k = 1..n} T(k,k-1), where T is the array defined in A024996.
 * @author Sean A. Irvine
 */
public class A026079 extends A025179 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().add(2);
  }
}

#!queue	A026089	1	->	0	A026082	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026089 a(n) = T(2n,n), where T is the array defined in A026082.
 * @author Sean A. Irvine
 */
public class A026089 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}

#!queue	A026090	1	->	0	A026082	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026090 a(n) = T(3n,n), where T is the array defined in A026082.
 * @author Sean A. Irvine
 */
public class A026090 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(3 * ++mN, mN);
  }
}

#!queue	A026091	1	->	0	A026082	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026091 a(n) = T(4n,n), where T is the array defined in A026082.
 * @author Sean A. Irvine
 */
public class A026091 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(4 * ++mN, mN);
  }
}

#!queue	A026094	1	->	0	A026082	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026094 a(n) = T(n,[ n/2 ]), where T is the array defined in A026082.
 * @author Sean A. Irvine
 */
public class A026094 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}

#!queue	A026106	0	->	5	A002212	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a007.A007317;

/**
 * A026106 Number of polyhexes of class PF2 (with one catafusene annealated to pyrene).
 * @author Sean A. Irvine
 */
public class A026106 extends A002212 {

  private final Sequence mB = new A007317();
  private Z mA = null;
  private boolean mEven = false;
  {
    super.next();
  }

  @Override
  public Z next() {
    mEven = !mEven;
    if (mEven) {
      mA = mB.next();
    }
    return super.next().multiply(3).add(mA).divide2();
  }
}
#!queue	A026111	0	->	2	A026105	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026111 a(n) = T(2n-1,n), where T is the array defined in A026105.
 * @author Sean A. Irvine
 */
public class A026111 extends A026105 {

  private long mN = 1;

  @Override
  public Z next() {
    return m(2 * ++mN - 1, mN);
  }
}
#!queue	A026115	0	->	1	A026105	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026115 a(n) = T(2n,n-1), where T is the array defined in A026105.
 * @author Sean A. Irvine
 */
public class A026115 extends A026105 {

  private long mN = 0;

  @Override
  public Z next() {
    return m(2 * ++mN, mN - 1);
  }
}
#!queue	A026116	0	->	1	A026105	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026116 T(2n,n+1), where T is the array defined in A026105.
 * @author Sean A. Irvine
 */
public class A026116 extends A026105 {

  private long mN = 0;

  @Override
  public Z next() {
    return m(2 * ++mN, mN + 1);
  }
}
#!queue	A026118	1	->	6	A039658	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a039.A039658;

/**
 * A026118 Number of polyhexes of class PF2 (with two catafusenes annealated to pyrene).
 * @author Sean A. Irvine
 */
public class A026118 extends A039658 {

  private final MemorySequence mA = MemorySequence.cachedSequence(new A002212());
  private int mN = 1;
  {
    super.next(); // skip n == 1 in A039658
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k < mN; ++k) {
      sum = sum.add(mA.a(k).multiply(mA.a(mN - k)));
    }
    sum = sum.multiply(13).add(super.next());
    if ((mN & 1) == 0) {
      sum = sum.add(mA.a(mN / 2).multiply(6));
    }
    return sum.divide(4);
  }
}
#!queue	A026120	0	->	-1	A026105	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026120 Triangle T by rows: second differences of Motzkin triangle (A026300), (i &gt;= -1, -1&lt;=j&lt;=i).
 * @author Sean A. Irvine
 */
public class A026120 extends A026105 {

  private long mN = -2;
  private long mM = 0;

  protected Z u(final long n, final long m) {
    if (n == 1 && m == 0) {
      return Z.ONE;
    }
    if (m == -1) {
      return Z.ONE;
    }
    return m(n + 1, m + 1).subtract(m(n, m));

  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = -1;
    }
    return u(mN, mM);
  }
}
#!queue	A026127	0	->	1	A026120	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026127 a(n) = T(2n-1,n-1), where T is the array in A026120.
 * @author Sean A. Irvine
 */
public class A026127 extends A026120 {

  private long mN = 0;

  @Override
  public Z next() {
    return u(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026131	0	->	1	A026120	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026131 a(n) = T(2n,n-2), where T is the array in A026120.
 * @author Sean A. Irvine
 */
public class A026131 extends A026120 {

  private long mN = 0;

  @Override
  public Z next() {
    return u(2 * ++mN, mN - 2);
  }
}
#!queue	A026132	0	->	1	A026120	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026132 a(n) = T(2n,n), where T is the array in A026120.
 * @author Sean A. Irvine
 */
public class A026132 extends A026120 {

  private long mN = 0;

  @Override
  public Z next() {
    return u(2 * ++mN, mN);
  }
}
#!queue	A026141	1	->	2	A026139	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026141 a(n) = (s(n)-s(n-1))/2, where s = A026139.
 * @author Sean A. Irvine
 */
public class A026141 extends A026139 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.subtract(t).abs().divide2();
  }
}
#!queue	A026146	1	->	3	A026145	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026146 a(n) = (1/2)*|s(n) - s(n-1)|, where s = A026145.
 * @author Sean A. Irvine
 */
public class A026146 extends A026145 {

  {
    super.next();
  }

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.subtract(t).abs().divide2();
  }
}
#!queue	A026147	0	->	1	A001285	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a001.A001285;

/**
 * A026147 a(n) = position of n-th 1 in A001285 or A010059 (Thue-Morse sequence).
 * @author Sean A. Irvine
 */
public class A026147 extends A001285 {

  private long mN = 0;

  @Override
  public Z next() {
    do {
      ++mN;
    } while (!Z.ONE.equals(super.next()));
    return Z.valueOf(mN);
  }
}
#!queue	A026152	1	->	2	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026152 a(n) = T(n,n-1), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026152 extends A026148 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A026153	1	->	2	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026153 T(n,n-2), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026153 extends A026148 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026154	1	->	3	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026154 a(n) = T(n,n-3), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026154 extends A026148 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026155	1	->	4	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026155 T(n,n-4), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026155 extends A026148 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026157	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026157 a(n) = T(2n,n), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026157 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026158	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026158 a(n) = T(3n,n), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026158 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(3 * ++mN, mN);
  }
}
#!queue	A026159	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026159 T(4n,n), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026159 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(4 * ++mN, mN);
  }
}
#!queue	A026162	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026162 a(n) = T(n,[ n/2 ]), where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026162 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026164	1	->	0	A026148	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026164 a(n) = Sum{T(n,k)}, k = 0,1,...,n, where T is the array in A026148.
 * @author Sean A. Irvine
 */
public class A026164 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026181	1	->	3	A026180	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026181 a(n) = (1/2)*(s(n) - s(n-1)), where s = A026180.
 * @author Sean A. Irvine
 */
public class A026181 extends A026180 {

  {
    super.next();
  }

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.subtract(t).divide2();
  }
}
#!queue	A026243	0	->	1	A000522	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a000.A000522;

/**
 * A026243 a(n) = A000522(n) - 2.
 * @author Sean A. Irvine
 */
public class A026243 extends A000522 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(2);
  }
}
#!queue	A026245	0	->	1	A002251	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a002.A002251;

/**
 * A026245 a(n) = (1/2)*(s(n) + 1), where s(n) is the n-th odd number in A002251.
 * @author Sean A. Irvine
 */
public class A026245 extends A002251 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isEven());
    return t.add(1).divide2();
  }
}
#!queue	A026247	0	->	1	A002251	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a002.A002251;

/**
 * A026247 a(n) = (1/2)*s(n), where s(n) is n-th even number in A002251.
 * @author Sean A. Irvine
 */
public class A026247 extends A002251 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isOdd());
    return t.divide2();
  }
}
#!queue	A026291	0	->	2	A026268	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026291 a(n) = T(2n-1,n), where T is the array in A026268.
 * @author Sean A. Irvine
 */
public class A026291 extends A026268 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN);
  }
}
#!queue	A026295	0	->	1	A026268	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026295 a(n) = T(2n,n-1), where T is the array in A026268.
 * @author Sean A. Irvine
 */
public class A026295 extends A026268 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026296	0	->	1	A026268	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026296 a(n) = T(2n,n+1), where T is the array in A026268.
 * @author Sean A. Irvine
 */
public class A026296 extends A026268 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026298	0	->	7	A039919	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a039.A039919;

/**
 * A026298 Number of polyhexes of class PF2.
 * @author Sean A. Irvine
 */
public class A026298 extends A039919 {

  private final Sequence mS = new A002212();
  {
    super.next();
    mS.next();
    mS.next();
    mS.next();
  }

  private Z mB = mS.next();
  private Z mC = mS.next();
  private Z mT = null;

  @Override
  public Z next() {
    final Z a = mB;
    mB = mC;
    mC = mS.next();
    final Z m;
    if (mT != null) {
      m = mT;
      mT = null;
    } else {
      mT = super.next();
      m = mT;
    }
    //System.out.println(mA + " " + mB + " " + mC + " " + m);
    return mC.subtract(mB.multiply(6)).add(a.multiply(8)).multiply(3).add(m);
  }
}
#!queue	A026305	0	->	1	A026300	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026305 a(n) = T(2n,n-1), where T is the array in A026300.
 * @author Sean A. Irvine
 */
public class A026305 extends A026300 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 1);
  }
}
#!queue	A026330	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026330 a(n) = number of (s(0), s(1), ..., s(n)) such that s(i) is a nonnegative integer and |s(i) - s(i-1)| &lt;= 1 for i = 1,2,...,n, s(0) = 2, s(2n) = n+1. Also a(n) = T(2n,n+1), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026330 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026332	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026332 a(n) = T(2n,n), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026332 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026333	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026333 a(n) = T(3n,n), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026333 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(3 * ++mN, mN);
  }
}
#!queue	A026334	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026334 T(4n,n), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026334 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(4 * ++mN, mN);
  }
}
#!queue	A026336	1	->	0	A026323	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026336 a(n) = T(n,[ n/2 ]), where T is the array in A026323.
 * @author Sean A. Irvine
 */
public class A026336 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026376	0	->	1	A002212	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a002.A002212;

/**
 * A026376 a(n) is the number of integer strings s(0),...,s(n) counted by array T in A026374 that have s(n)=2; also a(n) = T(2n,n-1).
 * @author Sean A. Irvine
 */
public class A026376 extends A002212 {

  private long mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}
#!queue	A026388	0	->	1	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026388 a(n) is the number of integer strings s(0),...,s(n) counted by array T in A026386 that have s(n)=2; also a(n) = T(2n,n-1).
 * @author Sean A. Irvine
 */
public class A026388 extends A026386 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026389	0	->	2	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026389 a(n) = number of integer strings s(0),...,s(n) counted by array T in A026386 that have s(n)=4; also a(n) = T(2n,n-2).
 * @author Sean A. Irvine
 */
public class A026389 extends A026386 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026392	0	->	1	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026392 T(n,[ n/2 ]), where T is the array in A026386.
 * @author Sean A. Irvine
 */
public class A026392 extends A026386 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026402	1	->	2	A026400	--------------------------------
package irvine.oeis.a026;

import java.util.TreeMap;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A026402 Position of the second n in A026400.
 * @author Sean A. Irvine
 */
public class A026402 extends A026400 {

  private final TreeSet<Long> mSeenFirst = new TreeSet<>();
  private final TreeMap<Long, Long> mMap = new TreeMap<>();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    while (!mMap.containsKey(mN)) {
      final long s = super.next().longValueExact();
      ++mM;
      if (s >= mN && !mMap.containsKey(s) && !mSeenFirst.add(s)) {
        mMap.put(s, mM);
      }
    }
    mSeenFirst.remove(mN);
    return Z.valueOf(mMap.remove(mN));
  }
}
#!queue	A026404	1	->	2	A026400	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicLongArray;

/**
 * A026404 a(n) = greatest number of numbers between consecutive appearances of n in A026400.
 * @author Sean A. Irvine
 */
public class A026404 extends A026400 {

  private final LongDynamicLongArray mPrev = new LongDynamicLongArray();
  private final LongDynamicLongArray mMax = new LongDynamicLongArray();
  private final LongDynamicLongArray mCount = new LongDynamicLongArray();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    while (mCount.get(mN) != mN) {
      ++mM;
      final long s = super.next().longValueExact();
      if (mPrev.get(s) != 0) {
        mMax.set(s, Math.max(mMax.get(s), mM - mPrev.get(s) - 1));
      }
      mPrev.set(s, mM);
      mCount.set(s, mCount.get(s) + 1);
    }
    return Z.valueOf(mMax.get(mN));
  }
}
#!queue	A026411	1	->	2	A026409	--------------------------------
package irvine.oeis.a026;

import java.util.TreeMap;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A026411 Position of the second n in A026409.
 * @author Sean A. Irvine
 */
public class A026411 extends A026409 {

  private final TreeSet<Long> mSeenFirst = new TreeSet<>();
  private final TreeMap<Long, Long> mMap = new TreeMap<>();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    while (!mMap.containsKey(mN)) {
      final long s = super.next().longValueExact();
      ++mM;
      if (s >= mN && !mMap.containsKey(s) && !mSeenFirst.add(s)) {
        mMap.put(s, mM);
      }
    }
    mSeenFirst.remove(mN);
    return Z.valueOf(mMap.remove(mN));
  }
}
#!queue	A026413	1	->	2	A026409	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicLongArray;

/**
 * A026413 a(n) = greatest number of numbers between consecutive appearances of n in A026409.
 * @author Sean A. Irvine
 */
public class A026413 extends A026409 {

  private final LongDynamicLongArray mPrev = new LongDynamicLongArray();
  private final LongDynamicLongArray mMax = new LongDynamicLongArray();
  private final LongDynamicLongArray mCount = new LongDynamicLongArray();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    while (mCount.get(mN) != mN) {
      ++mM;
      final long s = super.next().longValueExact();
      if (mPrev.get(s) != 0) {
        mMax.set(s, Math.max(mMax.get(s), mM - mPrev.get(s) - 1));
      }
      mPrev.set(s, mM);
      mCount.set(s, mCount.get(s) + 1);
    }
    return Z.valueOf(mMax.get(mN));
  }
}
#!queue	A026414	1	->	2	A026409	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicLongArray;

/**
 * A026414 a(n) = greatest integer not found after first n in A026409.
 * @author Sean A. Irvine
 */
public class A026414 extends A026409 {

  private final LongDynamicLongArray mCount = new LongDynamicLongArray();
  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    while (mCount.get(mN) == 0) {
      final long s = super.next().longValueExact();
      mCount.set(s, mCount.get(s) + 1);
    }
    long k = mN;
    while (mCount.get(k) != k) {
      --k;
    }
    return Z.valueOf(k);
  }
}
#!queue	A026521	0	->	1	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026521 a(n) = T(n, n-1), T given by A026519. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 1.
 * @author Sean A. Irvine
 */
public class A026521 extends A026519 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A026522	0	->	2	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026522 a(n) = T(n, n-2), where T is given by A026519. Also number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 2.
 * @author Sean A. Irvine
 */
public class A026522 extends A026519 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026523	0	->	3	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026523 a(n) = T(n, n-3), T given by A026519. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 3.
 * @author Sean A. Irvine
 */
public class A026523 extends A026519 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026524	0	->	4	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026524 a(n) = T(n, n-4), T given by A026519. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 4.
 * @author Sean A. Irvine
 */
public class A026524 extends A026519 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026526	0	->	1	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026526 a(n) = T(2n,n-1), T given by A026519.
 * @author Sean A. Irvine
 */
public class A026526 extends A026519 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026527	0	->	2	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026527 a(n) = T(2*n, n-2), where T is given by A026519.
 * @author Sean A. Irvine
 */
public class A026527 extends A026519 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026528	0	->	1	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026528 a(n) = T(2*n-1, n-1), T given by A026519.
 * @author Sean A. Irvine
 */
public class A026528 extends A026519 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026529	0	->	2	A026519	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026529 a(n) = T(2*n-1, n-2), where T is given by A026519.
 * @author Sean A. Irvine
 */
public class A026529 extends A026519 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026538	0	->	1	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026538 a(n) = T(n,n-1), T given by A026536. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 1.
 * @author Sean A. Irvine
 */
public class A026538 extends A026536 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A026539	0	->	2	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026539 a(n) = T(n,n-2), T given by A026536. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 2.
 * @author Sean A. Irvine
 */
public class A026539 extends A026536 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026540	0	->	3	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026540 a(n) = T(n,n-3), T given by A026536. Also number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 3.
 * @author Sean A. Irvine
 */
public class A026540 extends A026536 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026541	0	->	4	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026541 a(n) = T(n,n-4), T given by A026536. Also a(n) = number of integer strings s(0), ..., s(n), counted by T, such that s(n) = 4.
 * @author Sean A. Irvine
 */
public class A026541 extends A026536 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026545	0	->	1	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026545 a(n) = T(2n-1, n-1), T given by A026536.
 * @author Sean A. Irvine
 */
public class A026545 extends A026536 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026546	0	->	2	A026536	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026546 a(n) = T(2n-1,n-2), T given by A026536.
 * @author Sean A. Irvine
 */
public class A026546 extends A026536 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026554	0	->	1	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026554 a(n) = T(n,n-1), T given by A026552. Also a(n) is the number of integer strings s(0),...,s(n) counted by T, such that s(n)=1.
 * @author Sean A. Irvine
 */
public class A026554 extends A026552 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A026555	0	->	2	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026555 a(n) = T(n, n-2), T given by A026552. Also a(n) = number of integer strings s(0), ..., s(n) counted by T, such that s(n) = 2.
 * @author Sean A. Irvine
 */
public class A026555 extends A026552 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026556	0	->	3	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026556 a(n) = T(n, n-3), T given by A026552. Also a(n) = number of integer strings s(0), ..., s(n) counted by T, such that s(n) = 3.
 * @author Sean A. Irvine
 */
public class A026556 extends A026552 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026557	0	->	4	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026557 a(n) = T(n, n-4), T given by A026552. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=4.
 * @author Sean A. Irvine
 */
public class A026557 extends A026552 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026559	0	->	1	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026559 a(n) = T(2*n, n-1), where T is given by A026552.
 * @author Sean A. Irvine
 */
public class A026559 extends A026552 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026560	0	->	2	A026552	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026560 a(n) = T(2*n, n-2), where T is given by A026552.
 * @author Sean A. Irvine
 */
public class A026560 extends A026552 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026569	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026569 a(n) = T(n,n), T given by A026568. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=0.
 * @author Sean A. Irvine
 */
public class A026569 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A026571	1	->	2	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026571 a(n)=T(n,n-2), T given by A026568. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=2.
 * @author Sean A. Irvine
 */
public class A026571 extends A026568 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026572	1	->	3	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026572 a(n) = T(n,n-3), T given by A026568. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=3.
 * @author Sean A. Irvine
 */
public class A026572 extends A026568 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A026573	1	->	4	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026573 a(n)=T(n,n-4), T given by A026568. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=4.
 * @author Sean A. Irvine
 */
public class A026573 extends A026568 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026574	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026574 T(2n,n), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026574 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026576	1	->	2	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026576 T(2n,n-2), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026576 extends A026568 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026578	1	->	2	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026578 T(2n-1,n-2), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026578 extends A026568 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026579	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026579 T(n,[ n/2 ]), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026579 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026580	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026580 T(n,0) + T(n,1) + ... + T(n,n), T given by A026568.
 * @author Sean A. Irvine
 */
public class A026580 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026583	1	->	0	A026568	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026583 a(n) = Sum{T(i,j)}, 0&lt;=j&lt;=i, 0&lt;=i&lt;=2n, T given by A026568.
 * @author Sean A. Irvine
 */
public class A026583 extends A026568 {

  private long mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k <= 2 * mN; ++k) {
      mSum = mSum.add(get(mN, k));
    }
    return mSum;
  }
}
#!queue	A026585	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026585 a(n) = T(n,n), T given by A026584. Also a(n) is the number of integer strings s(0), ..., s(n) counted by T, such that s(n)=0.
 * @author Sean A. Irvine
 */
public class A026585 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A026587	1	->	2	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026587 a(n) = T(n, n-2), T given by A026584. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=2.
 * @author Sean A. Irvine
 */
public class A026587 extends A026584 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A026589	1	->	4	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026589 a(n) = T(n,n-4), T given by A026584. Also a(n) = number of integer strings s(0),...,s(n) counted by T, such that s(n)=4.
 * @author Sean A. Irvine
 */
public class A026589 extends A026584 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN - 4);
  }
}
#!queue	A026590	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026590 a(n) = T(2*n, n), where T is given by A026584.
 * @author Sean A. Irvine
 */
public class A026590 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026592	1	->	2	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026592 a(n) = T(2*n, n-2), where T is given by A026584.
 * @author Sean A. Irvine
 */
public class A026592 extends A026584 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026594	1	->	2	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026594 a(n) = T(2*n-1, n-2), where T is given by A026584.
 * @author Sean A. Irvine
 */
public class A026594 extends A026584 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026595	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026595 a(n) = T(n, floor(n/2)), where T is given by A026584.
 * @author Sean A. Irvine
 */
public class A026595 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026596	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026596 Row sums of A026584.
 * @author Sean A. Irvine
 */
public class A026596 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026599	1	->	0	A026584	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026599 a(n) = Sum_{j=0..2*i, i=0..n} A026584(i,j).
 * @author Sean A. Irvine
 */
public class A026599 extends A026584 {

  private long mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k <= 2 * mN; ++k) {
      mSum = mSum.add(get(mN, k));
    }
    return mSum;
  }
}
#!queue	A026616	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026616 T(2n,n), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026616 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026620	1	->	2	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026620 T(2n-1,n-2), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026620 extends A026615 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026621	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026621 T(n,[ n/2 ]), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026621 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026622	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026622 a(n) = T(n,0) + T(n,1) + ... + T(n,n), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026622 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026623	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026623 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026615.
 * @author Sean A. Irvine
 */
public class A026623 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026627	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026627 T(2n,n), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026627 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026629	1	->	2	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026629 T(2n,n-2), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026629 extends A026626 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026631	1	->	2	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026631 T(2n-1,n-2), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026631 extends A026626 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026632	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026632 T(n,[ n/2 ]), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026632 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026634	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026634 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026626.
 * @author Sean A. Irvine
 */
public class A026634 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026639	0	->	1	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026639 T(2n,n-1), T given by A026637.
 * @author Sean A. Irvine
 */
public class A026639 extends A026637 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026640	0	->	2	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026640 T(2n,n-2), T given by A026637.
 * @author Sean A. Irvine
 */
public class A026640 extends A026637 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026642	0	->	2	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026642 a(n) = T(2n-1,n-2), T given by A026637.
 * @author Sean A. Irvine
 */
public class A026642 extends A026637 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026649	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026649 a(n) = T(2n,n), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026649 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026651	1	->	2	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026651 a(n) = T(2n,n-2), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026651 extends A026648 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026653	1	->	2	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026653 a(n) = T(2n-1,n-2), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026653 extends A026648 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026654	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026654 a(n) = T(n,[ n/2 ]), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026654 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026656	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026656 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026648.
 * @author Sean A. Irvine
 */
public class A026656 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026660	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026660 T(2n,n), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026660 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026662	1	->	2	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026662 T(2n,n-2), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026662 extends A026659 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026664	1	->	2	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026664 T(2n-1,n-2), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026664 extends A026659 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026665	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026665 T(n,[ n/2 ]), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026665 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026666	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026666 T(n,0) + T(n,1) + ... + T(n,n), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026666 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026667	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026667 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026659.
 * @author Sean A. Irvine
 */
public class A026667 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026669	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026669 Sum{T(n-k,k)}, 0&lt;=k&lt;=[ n/2 ], T given by A026659.
 * @author Sean A. Irvine
 */
public class A026669 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026672	0	->	2	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026672 a(n) = T(2n,n-1), T given by A026670. Also T(2n,n-1)=T(2n+1,n+2), T given by A026725; and T(2n,n-1), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026672 extends A026670 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026673	0	->	2	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026673 a(n) = T(2n,n-2), T given by A026670.
 * @author Sean A. Irvine
 */
public class A026673 extends A026670 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026674	0	->	1	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026674 a(n) = T(2n-1,n-1) = T(2n,n+1), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026674 extends A026670 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026675	0	->	2	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026675 a(n) = T(2n-1,n-2), T given by A026670. Also T(2n-1,n-2) = T(2n,n+2), T given by A026725 and T(2n,n-2), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026675 extends A026670 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026682	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026682 a(n) = A026681(2n,n).
 * @author Sean A. Irvine
 */
public class A026682 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026684	1	->	2	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026684 T(2n,n-2), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026684 extends A026681 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026686	1	->	2	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026686 T(2n-1,n-2), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026686 extends A026681 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026687	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026687 T(n,[ n/2 ]), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026687 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026688	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026688 T(n,0) + T(n,1) + ... + T(n,n), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026688 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026689	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026689 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026681.
 * @author Sean A. Irvine
 */
public class A026689 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026691	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026691 Sum{T(n-k,k)}, 0&lt;=k&lt;=[ n/2 ], T given by A026681.
 * @author Sean A. Irvine
 */
public class A026691 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026693	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026693 T(2n,n), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026693 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026695	1	->	2	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026695 T(2n,n-2), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026695 extends A026692 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026697	1	->	2	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026697 T(2n-1,n-2), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026697 extends A026692 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026698	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026698 T(n,[ n/2 ]), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026698 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026699	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026699 T(n,0) + T(n,1) + ... + T(n,n), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026699 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026700	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026700 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026700 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026702	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026702 a(n) = Sum_{k=0..floor(n/2)} T(n-k, k), T given by A026692.
 * @author Sean A. Irvine
 */
public class A026702 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026704	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026704 T(2n,n), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026704 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026706	1	->	2	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026706 T(2n,n-2), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026706 extends A026703 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026708	1	->	2	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026708 T(2n-1,n-2), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026708 extends A026703 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026709	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026709 T(n,[ n/2 ]), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026709 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026710	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026710 T(n,0) + T(n,1) + ... + T(n,n), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026710 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026711	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026711 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026703.
 * @author Sean A. Irvine
 */
public class A026711 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026713	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026713 Sum{T(n-k,k)}, 0&lt;=k&lt;=[ n/2 ], T given by A026703.
 * @author Sean A. Irvine
 */
public class A026713 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026715	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026715 T(2n,n), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026715 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A026717	1	->	2	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026717 T(2n,n-2), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026717 extends A026714 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026719	1	->	2	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026719 T(2n-1,n-2), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026719 extends A026714 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026720	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026720 T(n,[ n/2 ]), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026720 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A026721	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026721 T(n,0) + T(n,1) + ... + T(n,n), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026721 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026722	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026722 a(n) = T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A026714.
 * @author Sean A. Irvine
 */
public class A026722 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026724	1	->	0	A026714	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026724 Sum{T(n-k,k)}, 0&lt;=k&lt;=[ n/2 ], T given by A026714.
 * @author Sean A. Irvine
 */
public class A026724 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A026749	0	->	1	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026749 a(n) = T(2n,n-1), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026749 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026750	0	->	2	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026750 a(n) = T(2n,n-2), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026750 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026751	0	->	1	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026751 a(n) = T(2n-1,n-1), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026751 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026752	0	->	2	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026752 a(n) = T(2n-1,n-2), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026752 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026760	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026760 a(n) = T(2n, n-1), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026760 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026761	0	->	2	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026761 a(n) = T(2n, n-2), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026761 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026762	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026762 a(n) = T(2n-1,n-1), T given by A026758. Also T(2n+1,n+1), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026762 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026763	0	->	2	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026763 a(n) = T(2n-1,n-2), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026763 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026771	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026771 a(n) = T(2n,n-1), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026771 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026772	0	->	2	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026772 a(n) = T(2n, n-2), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026772 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026773	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026773 a(n) = T(2n-1,n-1), T given by A026769. Also T(2n+1,n+1), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026773 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026774	0	->	2	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026774 a(n) = T(2n-1,n-2), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026774 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026782	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026782 a(n) = T(2n,n-1), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026782 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 1);
  }
}
#!queue	A026783	0	->	2	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026783 a(n) = T(2n, n-2), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026783 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A026784	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026784 a(n) = T(2n-1, n-1), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026784 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026785	0	->	2	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026785 a(n) = T(2n-1, n-2), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026785 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026840	0	->	1	A079126	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a079.A079126;

/**
 * A026840 Triangular array T read by rows: T(n,k) = number of partitions of n into distinct parts &lt;= k, for k=1,2,...n.
 * @author Sean A. Irvine
 */
public class A026840 extends A079126 {

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}
#!queue	A026841	0	->	4	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026841 a(n) = T(2n,n-4), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026841 extends A026725 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026842	0	->	3	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026842 a(n) = T(2n,n-3), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026842 extends A026725 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026843	0	->	3	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026843 a(n) = T(2n,n+3), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026843 extends A026725 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026844	0	->	4	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026844 a(n) = T(2n,n+4), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026844 extends A026725 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026846	0	->	3	A026725	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026846 a(n) = T(2n+1,n+4), T given by A026725.
 * @author Sean A. Irvine
 */
public class A026846 extends A026725 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026848	0	->	4	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026848 a(n) = T(2n,n-4), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026848 extends A026736 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026849	0	->	3	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026849 a(n) = T(2n,n-3), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026849 extends A026736 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026850	0	->	1	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026850 a(n) = T(2n,n+1), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026850 extends A026736 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026851	0	->	2	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026851 a(n) = T(2n,n+2), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026851 extends A026736 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026852	0	->	3	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026852 a(n) = T(2n,n+3), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026852 extends A026736 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026853	0	->	4	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026853 a(n) = T(2n,n+4), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026853 extends A026736 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026855	0	->	1	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026855 a(n) = T(2n+1,n+2), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026855 extends A026736 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026856	0	->	2	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026856 a(n) = T(2n+1,n+3), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026856 extends A026736 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026857	0	->	3	A026736	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026857 a(n) = T(2n+1,n+4), T given by A026736.
 * @author Sean A. Irvine
 */
public class A026857 extends A026736 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026859	0	->	4	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026859 T(2n,n-4), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026859 extends A026747 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026860	0	->	3	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026860 T(2n,n-3), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026860 extends A026747 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026861	0	->	1	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026861 T(2n,n+1), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026861 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026862	0	->	2	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026862 T(2n,n+2), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026862 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026863	0	->	3	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026863 T(2n,n+3), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026863 extends A026747 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026864	0	->	4	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026864 T(2n,n+4), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026864 extends A026747 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026866	0	->	1	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026866 T(2n+1,n+2), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026866 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026867	0	->	2	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026867 T(2n+1,n+3), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026867 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026868	0	->	3	A026747	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026868 T(2n+1,n+4), T given by A026747.
 * @author Sean A. Irvine
 */
public class A026868 extends A026747 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026870	0	->	4	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026870 T(2n,n-4), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026870 extends A026758 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026871	0	->	3	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026871 T(2n,n-3), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026871 extends A026758 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026872	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026872 T(2n,n+1), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026872 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026873	0	->	2	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026873 T(2n,n+2), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026873 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026874	0	->	3	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026874 T(2n,n+3), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026874 extends A026758 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026875	0	->	4	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026875 T(2n,n+4), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026875 extends A026758 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026877	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026877 T(2n+1,n+2), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026877 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026878	0	->	2	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026878 a(n) = T(2n+1,n+3), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026878 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026879	0	->	3	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026879 T(2n+1,n+4), T given by A026758.
 * @author Sean A. Irvine
 */
public class A026879 extends A026758 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026880	0	->	1	A026758	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026880 a(n) = T(n,m) + T(n,m+1) + ... + T(n,n), m=[ (n+1)/2 ], T given by A026758.
 * @author Sean A. Irvine
 */
public class A026880 extends A026758 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = (mN + 1) / 2; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026881	0	->	4	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026881 T(2n,n-4), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026881 extends A026769 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026882	0	->	3	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026882 T(2n,n-3), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026882 extends A026769 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026883	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026883 T(2n,n+1), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026883 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026884	0	->	2	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026884 T(2n,n+2), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026884 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026885	0	->	3	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026885 T(2n,n+3), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026885 extends A026769 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026886	0	->	4	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026886 T(2n,n+4), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026886 extends A026769 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026888	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026888 T(2n+1,n+2), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026888 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026889	0	->	2	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026889 T(2n+1,n+3), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026889 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026890	0	->	3	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026890 T(2n+1,n+4), T given by A026769.
 * @author Sean A. Irvine
 */
public class A026890 extends A026769 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026891	0	->	1	A026769	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026891 a(n) = T(n,m) + T(n,m+1) + ... + T(n,n), m=[ (n+1)/2 ], T given by A026769.
 * @author Sean A. Irvine
 */
public class A026891 extends A026769 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = (mN + 1) / 2; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026892	0	->	4	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026892 T(2n,n-4), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026892 extends A026780 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 4);
  }
}
#!queue	A026893	0	->	3	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026893 T(2n,n-3), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026893 extends A026780 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 3);
  }
}
#!queue	A026894	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026894 T(2n,n+1), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026894 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A026895	0	->	2	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026895 T(2n,n+2), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026895 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 2);
  }
}
#!queue	A026896	0	->	3	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026896 T(2n,n+3), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026896 extends A026780 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 3);
  }
}
#!queue	A026897	0	->	4	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026897 T(2n,n+4), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026897 extends A026780 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 4);
  }
}
#!queue	A026899	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026899 T(2n+1,n+2), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026899 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A026900	0	->	2	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026900 T(2n+1,n+3), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026900 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 3);
  }
}
#!queue	A026901	0	->	3	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026901 T(2n+1,n+4), T given by A026780.
 * @author Sean A. Irvine
 */
public class A026901 extends A026780 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 4);
  }
}
#!queue	A026902	0	->	1	A026780	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026902 a(n) = T(n,m) + T(n,m+1) + ... + T(n,n), m=[ (n+1)/2 ], T given by A026780.
 * @author Sean A. Irvine
 */
public class A026902 extends A026780 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = (mN + 1) / 2; k <= mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A026909	0	->	1	A026908	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026909 (1/2)*T(2n,n), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026909 extends A026908 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A026910	0	->	1	A026907	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026910 T(2n,n-1), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026910 extends A026907 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 1);
  }
}
#!queue	A026911	0	->	2	A026907	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026911 T(2n,n-2), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026911 extends A026907 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 2);
  }
}
#!queue	A026912	0	->	1	A026907	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026912 T(2n-1,n-1), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026912 extends A026907 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A026913	0	->	2	A026907	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026913 T(2n-1,n-2), T given by A026907.
 * @author Sean A. Irvine
 */
public class A026913 extends A026907 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A026919	0	->	1	A026907	--------------------------------
package irvine.oeis.a026;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A026919 Uniquification of A026907.
 * @author Sean A. Irvine
 */
public class A026919 extends A026907 {

  private long mRow = 0;
  private Z mLeading = t(mRow, 0);
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    if (mSet.isEmpty() || mSet.first().compareTo(mLeading) > 0) {
      // Need to run through another row
      for (long k = 0; k <= mRow; ++k) {
        mSet.add(t(mRow, k));
      }
      mLeading = t(++mRow, 0);
    }
    return mSet.pollFirst();
  }
}
#!queue	A026934	0	->	1	A008288	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A026934 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A008288.
 * @author Sean A. Irvine
 */
public class A026934 extends A008288 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN - k , k).multiply(get(mN - k - 1, k + 1)));
    }
    return sum;
  }
}
#!queue	A026935	0	->	2	A008288	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A026935 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A008288.
 * @author Sean A. Irvine
 */
public class A026935 extends A008288 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN - k , k).multiply(get(mN - k - 2, k + 2)));
    }
    return sum;
  }
}
#!queue	A026936	0	->	3	A008288	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A026936 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A008288.
 * @author Sean A. Irvine
 */
public class A026936 extends A008288 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN - k , k).multiply(get(mN - k - 3, k + 3)));
    }
    return sum;
  }
}
#!queue	A026940	0	->	1	A026300	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026940 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026300.
 * @author Sean A. Irvine
 */
public class A026940 extends A026300 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A026941	0	->	2	A026300	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026941 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026300.
 * @author Sean A. Irvine
 */
public class A026941 extends A026300 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A026942	0	->	3	A026300	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026942 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026300.
 * @author Sean A. Irvine
 */
public class A026942 extends A026300 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A026947	0	->	1	A026374	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026947 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026374.
 * @author Sean A. Irvine
 */
public class A026947 extends A026374 {

  {
    nextRow();
  }

  @Override
  public Z next() {
    nextRow();
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.add(mGfRow.coeff(k).multiply(mGfRow.coeff(mN - k - 1)));
    }
    return sum;
  }
}
#!queue	A026948	0	->	2	A026374	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026948 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026374.
 * @author Sean A. Irvine
 */
public class A026948 extends A026374 {
  
  {
    nextRow();
    nextRow();
  }

  @Override
  public Z next() {
    nextRow();
    Z sum = Z.ZERO;
    for (int k = 0; k < mN - 1; ++k) {
      sum = sum.add(mGfRow.coeff(k).multiply(mGfRow.coeff(mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026949	0	->	3	A026374	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026949 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026374.
 * @author Sean A. Irvine
 */
public class A026949 extends A026374 {
  
  {
    nextRow();
    nextRow();
    nextRow();
  }

  @Override
  public Z next() {
    nextRow();
    Z sum = Z.ZERO;
    for (int k = 0; k < mN - 2; ++k) {
      sum = sum.add(mGfRow.coeff(k).multiply(mGfRow.coeff(mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026952	0	->	1	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026952 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026386.
 * @author Sean A. Irvine
 */
public class A026952 extends A026386 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 1)));
    }
    return sum;
  }
}
#!queue	A026953	0	->	2	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026953 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026386.
 * @author Sean A. Irvine
 */
public class A026953 extends A026386 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026954	0	->	3	A026386	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026954 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026386.
 * @author Sean A. Irvine
 */
public class A026954 extends A026386 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026956	1	->	0	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026956 a(n) = self-convolution of array T given by A026615.
 * @author Sean A. Irvine
 */
public class A026956 extends A026615 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026958	1	->	2	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026958 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026615.
 * @author Sean A. Irvine
 */
public class A026958 extends A026615 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026959	1	->	3	A026615	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026959 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026615.
 * @author Sean A. Irvine
 */
public class A026959 extends A026615 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026961	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026961 a(n) = self-convolution of array T given by A026626.
 * @author Sean A. Irvine
 */
public class A026961 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026963	1	->	2	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026963 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026626.
 * @author Sean A. Irvine
 */
public class A026963 extends A026626 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026964	1	->	3	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026964 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026626.
 * @author Sean A. Irvine
 */
public class A026964 extends A026626 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026965	1	->	0	A026626	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026965 a(n) = Sum_{k=0..n} (k+1) * A026626(n,k).
 * @author Sean A. Irvine
 */
public class A026965 extends A026626 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026967	0	->	1	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026967 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026637.
 * @author Sean A. Irvine
 */
public class A026967 extends A026637 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 1)));
    }
    return sum;
  }
}
#!queue	A026968	0	->	2	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026968 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026637.
 * @author Sean A. Irvine
 */
public class A026968 extends A026637 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026969	0	->	3	A026637	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026969 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026637.
 * @author Sean A. Irvine
 */
public class A026969 extends A026637 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026971	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026971 a(n) = self-convolution of array T given by A026648.
 * @author Sean A. Irvine
 */
public class A026971 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026973	1	->	2	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026973 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026648.
 * @author Sean A. Irvine
 */
public class A026973 extends A026648 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026974	1	->	3	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026974 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026648.
 * @author Sean A. Irvine
 */
public class A026974 extends A026648 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026975	1	->	0	A026648	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026975 a(n) = Sum_{k=0..n} (k+1) * A026648(n,k).
 * @author Sean A. Irvine
 */
public class A026975 extends A026648 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026976	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026976 Self-convolution of array T given by A026659.
 * @author Sean A. Irvine
 */
public class A026976 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026978	1	->	2	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026978 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026659.
 * @author Sean A. Irvine
 */
public class A026978 extends A026659 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026979	1	->	3	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026979 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026659.
 * @author Sean A. Irvine
 */
public class A026979 extends A026659 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026980	1	->	0	A026659	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026980 a(n) = Sum_{k=0..n} (k+1) * A026659(n,k).
 * @author Sean A. Irvine
 */
public class A026980 extends A026659 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026982	0	->	1	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026982 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026670.
 * @author Sean A. Irvine
 */
public class A026982 extends A026670 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 1)));
    }
    return sum;
  }
}
#!queue	A026983	0	->	2	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026983 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026670.
 * @author Sean A. Irvine
 */
public class A026983 extends A026670 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026984	0	->	3	A026670	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026984 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026670.
 * @author Sean A. Irvine
 */
public class A026984 extends A026670 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026986	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026986 Self-convolution of array T given by A026681.
 * @author Sean A. Irvine
 */
public class A026986 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026988	1	->	2	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026988 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026681.
 * @author Sean A. Irvine
 */
public class A026988 extends A026681 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026989	1	->	3	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026989 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026681.
 * @author Sean A. Irvine
 */
public class A026989 extends A026681 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026990	1	->	0	A026681	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026990 a(n) = Sum_{k=0..n} (k+1) * A026681(n, k).
 * @author Sean A. Irvine
 */
public class A026990 extends A026681 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026991	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026991 Self-convolution of array T given by A026692.
 * @author Sean A. Irvine
 */
public class A026991 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026993	1	->	2	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026993 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026692.
 * @author Sean A. Irvine
 */
public class A026993 extends A026692 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A026994	1	->	3	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026994 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026692.
 * @author Sean A. Irvine
 */
public class A026994 extends A026692 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A026995	1	->	0	A026692	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026995 a(n) = Sum_{k=0..n} (k+1) * A026692(n, k).
 * @author Sean A. Irvine
 */
public class A026995 extends A026692 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A026996	1	->	0	A026703	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;

/**
 * A026996 Self-convolution of array T given by A026703.
 * @author Sean A. Irvine
 */
public class A026996 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A026999	0	->	1	A026998	--------------------------------
package irvine.oeis.a026;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A026999 Uniquification of A026998.
 * @author Sean A. Irvine
 */
public class A026999 extends A026998 {

  private long mRow = 1;
  private Z mLast = Z.ZERO;
  private Z mLeading = get(mRow, 2 * mRow - 2);
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    while (mSet.isEmpty() || mSet.first().compareTo(mLeading) > 0) {
      // Need to run through another row
      for (long k = 0; k <= mRow; ++k) {
        final Z t = get(mRow, 2 * k);
        if (t.compareTo(mLast) > 0) {
          mSet.add(t);
        }
      }
      mLeading = get(++mRow, 2 * mRow - 2);
    }
    mLast = mSet.pollFirst();
    return mLast;
  }
}
#!queue	A027003	0	->	4	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027003 a(n) = A026998(2n, n+4).
 * @author Sean A. Irvine
 */
public class A027003 extends A027960 {

  private long mN = 6;

  @Override
  public Z next() {
    mN += 2;
    return get(mN, mN + 8);
  }
}
#!queue	A027007	0	->	3	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027007 a(n) = A026998(2n+1, n+4).
 * @author Sean A. Irvine
 */
public class A027007 extends A027960 {

  private long mN = 5;

  @Override
  public Z next() {
    mN += 2;
    return get(mN, mN + 7);
  }
}
#!queue	A027008	0	->	1	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027008 a(n) = greatest number in row n of array T given by A026998.
 * @author Sean A. Irvine
 */
public class A027008 extends A027960 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z max = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      max = max.max(get(mN, 2 * k));
    }
    return max;
  }
}
#!queue	A027011	0	->	1	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027011 Triangular array T read by rows: T(n,k) = t(n, 2k+1) for 0 &lt;= k &lt;= floor((2n-1)/2), t given by A027960, n &gt;= 0.
 * @author Sean A. Irvine
 */
public class A027011 extends A027960 {

  private long mN = 0;
  private long mM = 0;

  protected Z t(final long n, final long m) {
    return get(n, 2 * m + 1);
  }

  @Override
  public Z next() {
    if (++mM > (2 * mN - 1) / 2) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A027015	0	->	4	A027011	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027015 a(n) = A027011(2n, n+4).
 * @author Sean A. Irvine
 */
public class A027015 extends A027011 {

  private long mN = 3;

  @Override
  public Z next() {
    return ++mN == 4 ? Z.ONE : t(2 * mN, mN + 4);
  }
}
#!queue	A027019	0	->	3	A027011	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027019 a(n) = A027011(2n+1, n+4).
 * @author Sean A. Irvine
 */
public class A027019 extends A027011 {

  private long mN = 2;

  @Override
  public Z next() {
    return ++mN == 3 ? Z.ONE : t(2 * mN + 1, mN + 4);
  }
}
#!queue	A027020	0	->	1	A027011	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027020 a(n) = greatest number in row n of array T given by A027011.
 * @author Sean A. Irvine
 */
public class A027020 extends A027011 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z max = Z.ZERO;
    for (long k = 0; k <= (2 * mN - 1) / 2; ++k) {
      max = max.max(t(mN, k));
    }
    return max;
  }
}
#!queue	A027027	0	->	2	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027027 a(n) = T(n, 2n-3), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027027 extends A027023 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 3);
  }
}
#!queue	A027028	0	->	2	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027028 a(n) = T(n,2n-4), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027028 extends A027023 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 4);
  }
}
#!queue	A027029	0	->	3	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027029 a(n) = T(n,2n-5), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027029 extends A027023 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 5);
  }
}
#!queue	A027030	0	->	3	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027030 a(n) = T(n,2n-6), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027030 extends A027023 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 6);
  }
}
#!queue	A027031	0	->	4	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027031 a(n) = T(n,2n-7), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027031 extends A027023 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 7);
  }
}
#!queue	A027032	0	->	4	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027032 a(n) = T(n,2n-8), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027032 extends A027023 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 8);
  }
}
#!queue	A027033	0	->	5	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027033 a(n) = T(n,2n-9), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027033 extends A027023 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 9);
  }
}
#!queue	A027034	0	->	5	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027034 a(n) = T(n,2n-10), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027034 extends A027023 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 10);
  }
}
#!queue	A027042	0	->	1	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027042 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,2n-k), with T given by A027023.
 * @author Sean A. Irvine
 */
public class A027042 extends A027023 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027045	0	->	1	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027045 a(n) = Sum_{k=n+1..2*n} T(n, k), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027045 extends A027023 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = mN + 1; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027047	0	->	1	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027047 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A027023.
 * @author Sean A. Irvine
 */
public class A027047 extends A027023 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027048	0	->	2	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027048 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A027023.
 * @author Sean A. Irvine
 */
public class A027048 extends A027023 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027049	0	->	3	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027049 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A027023.
 * @author Sean A. Irvine
 */
public class A027049 extends A027023 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027050	0	->	1	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027050 a(n) = T(n,2n-1), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027050 extends A027023 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 1);
  }
}
#!queue	A027051	0	->	2	A027023	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027051 a(n) = T(n,2n-2), T given by A027023.
 * @author Sean A. Irvine
 */
public class A027051 extends A027023 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 2);
  }
}
#!queue	A027056	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027056 a(n) = A027052(n, 2n-1).
 * @author Sean A. Irvine
 */
public class A027056 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 1);
  }
}
#!queue	A027057	0	->	2	A027056	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027057 a(n) = (1/2) * A027052(n, 2n-1).
 * @author Sean A. Irvine
 */
public class A027057 extends A027056 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A027058	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027058 a(n) = A027052(n, 2n-2).
 * @author Sean A. Irvine
 */
public class A027058 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 2);
  }
}
#!queue	A027059	0	->	2	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027059 a(n) = A027052(n, 2n-3).
 * @author Sean A. Irvine
 */
public class A027059 extends A027052 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 3);
  }
}
#!queue	A027060	0	->	2	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027060 a(n) = T(n,2n-4), T given by A027052.
 * @author Sean A. Irvine
 */
public class A027060 extends A027052 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 4);
  }
}
#!queue	A027061	0	->	3	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027061 a(n) = A027052(n, 2n-5).
 * @author Sean A. Irvine
 */
public class A027061 extends A027052 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 5);
  }
}
#!queue	A027062	0	->	3	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027062 a(n) = A027052(n, 2n-6).
 * @author Sean A. Irvine
 */
public class A027062 extends A027052 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 6);
  }
}
#!queue	A027063	0	->	4	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027063 a(n) = A027052(n, 2n-7).
 * @author Sean A. Irvine
 */
public class A027063 extends A027052 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 7);
  }
}
#!queue	A027064	0	->	4	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027064 a(n) = A027052(n, 2n-8).
 * @author Sean A. Irvine
 */
public class A027064 extends A027052 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 8);
  }
}
#!queue	A027065	0	->	5	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027065 a(n) = A027052(n, 2n-9).
 * @author Sean A. Irvine
 */
public class A027065 extends A027052 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 9);
  }
}
#!queue	A027066	0	->	5	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027066 a(n) = A027052(n, 2n-10).
 * @author Sean A. Irvine
 */
public class A027066 extends A027052 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 10);
  }
}
#!queue	A027074	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027074 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,2n-k), with T given by A027052.
 * @author Sean A. Irvine
 */
public class A027074 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027077	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027077 a(n) = Sum_{k=n+1..2*n} T(n,k), T given by A027052.
 * @author Sean A. Irvine
 */
public class A027077 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = mN + 1; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027079	0	->	1	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027079 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A027052.
 * @author Sean A. Irvine
 */
public class A027079 extends A027052 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027080	0	->	2	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027080 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A027052.
 * @author Sean A. Irvine
 */
public class A027080 extends A027052 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027081	0	->	3	A027052	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027081 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A027052.
 * @author Sean A. Irvine
 */
public class A027081 extends A027052 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027088	0	->	1	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027088 a(n) = A027082(n, 2n-1).
 * @author Sean A. Irvine
 */
public class A027088 extends A027082 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 1);
  }
}
#!queue	A027089	0	->	2	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027089 a(n) = A027082(n, 2n-2).
 * @author Sean A. Irvine
 */
public class A027089 extends A027082 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 2);
  }
}
#!queue	A027090	0	->	2	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027090 a(n) = A027082(n, 2n-3).
 * @author Sean A. Irvine
 */
public class A027090 extends A027082 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 3);
  }
}
#!queue	A027091	0	->	2	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027091 a(n) = A027082(n, 2n-4).
 * @author Sean A. Irvine
 */
public class A027091 extends A027082 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 4);
  }
}
#!queue	A027092	0	->	3	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027092 a(n) = A027082(n, 2n-5).
 * @author Sean A. Irvine
 */
public class A027092 extends A027082 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 5);
  }
}
#!queue	A027093	0	->	3	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027093 a(n) = A027082(n, 2n-6).
 * @author Sean A. Irvine
 */
public class A027093 extends A027082 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 6);
  }
}
#!queue	A027094	0	->	4	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027094 a(n) = A027082(n, 2n-7).
 * @author Sean A. Irvine
 */
public class A027094 extends A027082 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 7);
  }
}
#!queue	A027095	0	->	4	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027095 a(n) = A027082(n, 2n-8).
 * @author Sean A. Irvine
 */
public class A027095 extends A027082 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 8);
  }
}
#!queue	A027096	0	->	5	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027096 a(n) = A027082(n, 2n-9).
 * @author Sean A. Irvine
 */
public class A027096 extends A027082 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 9);
  }
}
#!queue	A027097	0	->	5	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027097 a(n) = A027082(n, 2n-10).
 * @author Sean A. Irvine
 */
public class A027097 extends A027082 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 10);
  }
}
#!queue	A027105	0	->	1	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027105 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,2n-k), with T given by A027082.
 * @author Sean A. Irvine
 */
public class A027105 extends A027082 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027110	0	->	1	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027110 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A027082.
 * @author Sean A. Irvine
 */
public class A027110 extends A027082 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027111	0	->	2	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027111 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A027082.
 * @author Sean A. Irvine
 */
public class A027111 extends A027082 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027112	0	->	3	A027082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027112 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A027082.
 * @author Sean A. Irvine
 */
public class A027112 extends A027082 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027115	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027115 a(n) = T(n,0) + T(n,1) + ... + T(n,2n), T given by A027113.
 * @author Sean A. Irvine
 */
public class A027115 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027116	1	->	3	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027116 a(n) = A027113(n, n+3).
 * @author Sean A. Irvine
 */
public class A027116 extends A027113 {

  private long mN = 2;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, mN + 3);
  }
}
#!queue	A027117	1	->	4	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027117 a(n) = A027113(n, n+4).
 * @author Sean A. Irvine
 */
public class A027117 extends A027113 {

  private long mN = 3;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, mN + 4);
  }
}
#!queue	A027118	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027118 a(n) = A027113(n, 2n).
 * @author Sean A. Irvine
 */
public class A027118 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN);
  }
}
#!queue	A027120	1	->	2	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027120 a(n) = A027113(n, 2n-2).
 * @author Sean A. Irvine
 */
public class A027120 extends A027113 {

  private long mN = 1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 2);
  }
}
#!queue	A027121	1	->	2	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027121 a(n) = A027113(n, 2n-3).
 * @author Sean A. Irvine
 */
public class A027121 extends A027113 {

  private long mN = 1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 3);
  }
}
#!queue	A027122	1	->	2	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027122 a(n) = A027113(n, 2n-4).
 * @author Sean A. Irvine
 */
public class A027122 extends A027113 {

  private long mN = 1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 4);
  }
}
#!queue	A027123	1	->	3	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027123 a(n) = A027113(n, 2n-5).
 * @author Sean A. Irvine
 */
public class A027123 extends A027113 {

  private long mN = 2;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 5);
  }
}
#!queue	A027124	1	->	3	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027124 a(n) = A027113(n, 2n-6).
 * @author Sean A. Irvine
 */
public class A027124 extends A027113 {

  private long mN = 2;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 6);
  }
}
#!queue	A027125	1	->	4	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027125 a(n) = A027113(n, 2n-7).
 * @author Sean A. Irvine
 */
public class A027125 extends A027113 {

  private long mN = 3;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 7);
  }
}
#!queue	A027126	1	->	4	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027126 a(n) = A027113(n, 2n-8).
 * @author Sean A. Irvine
 */
public class A027126 extends A027113 {

  private long mN = 3;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 8);
  }
}
#!queue	A027127	1	->	5	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027127 a(n) = A027113(n, 2n-9).
 * @author Sean A. Irvine
 */
public class A027127 extends A027113 {

  private long mN = 4;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 9);
  }
}
#!queue	A027128	1	->	5	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027128 a(n) = A027113(n, 2n-10).
 * @author Sean A. Irvine
 */
public class A027128 extends A027113 {

  private long mN = 4;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    return get(++mN, 2 * mN - 10);
  }
}
#!queue	A027129	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027129 a(n) = T(n,n) + T(n,n+1) + ... + T(n,2n), T given by A027113.
 * @author Sean A. Irvine
 */
public class A027129 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 2 * mN; k >= mN; --k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027131	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027131 a(n) = diagonal sum of left justified array T given by A027113.
 * @author Sean A. Irvine
 */
public class A027131 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A027132	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027132 a(n) = diagonal sum of right justified array T given by A027113.
 * @author Sean A. Irvine
 */
public class A027132 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN - k, 2 * mN - 3 * k));
    }
    return sum;
  }
}
#!queue	A027133	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027133 Greatest number in row n of array T given by A027113.
 * @author Sean A. Irvine
 */
public class A027133 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z max = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      max = max.max(get(mN, k));
    }
    return max;
  }
}
#!queue	A027134	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027134 a(n) = self-convolution of row n of array T given by A027113.
 * @author Sean A. Irvine
 */
public class A027134 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027135	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027135 a(n) = Sum_{k=0..n} T(n,k) * T(n,2n-k), with T given by A027113.
 * @author Sean A. Irvine
 */
public class A027135 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027137	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027137 a(n) = Sum_{k=0..2n} (k+1) * A027113(n, k).
 * @author Sean A. Irvine
 */
public class A027137 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027139	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027139 T(n,n+1) + T(n,n+2) + ... + T(n,2n), T given by A027113.
 * @author Sean A. Irvine
 */
public class A027139 extends A027113 {

  private long mN = 0;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = mN + 1; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027140	1	->	0	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027140 a(n) = Sum_{k=0..n} T(n,k) * T(n,n+k), with T given by A027113.
 * @author Sean A. Irvine
 */
public class A027140 extends A027113 {

  private long mN = -1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN + k)));
    }
    return sum;
  }
}
#!queue	A027142	1	->	2	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027142 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A027113.
 * @author Sean A. Irvine
 */
public class A027142 extends A027113 {

  private long mN = 1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027143	1	->	3	A027113	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027143 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A027113.
 * @author Sean A. Irvine
 */
public class A027143 extends A027113 {

  private long mN = 2;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET));
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027145	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027145 a(n) = A027144(2n, n).
 * @author Sean A. Irvine
 */
public class A027145 extends A027144 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A027147	1	->	2	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027147 a(n) = A027144(2n, n-2).
 * @author Sean A. Irvine
 */
public class A027147 extends A027144 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN - 2);
  }
}
#!queue	A027149	1	->	2	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027149 a(n) = A027144(2n-1, n-2).
 * @author Sean A. Irvine
 */
public class A027149 extends A027144 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A027150	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027150 a(n) = A027144(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A027150 extends A027144 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN / 2);
  }
}
#!queue	A027152	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027152 T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A027144.
 * @author Sean A. Irvine
 */
public class A027152 extends A027144 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN, k));
    }
    return sum;
  }
}
#!queue	A027154	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027154 a(n) = Sum_{k=0..floor(n/2)} A027144(n-k, k).
 * @author Sean A. Irvine
 */
public class A027154 extends A027144 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(get(mN - k, k));
    }
    return sum;
  }
}
#!queue	A027155	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027155 Greatest number in row n of array T given by A027144.
 * @author Sean A. Irvine
 */
public class A027155 extends A027144 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z max = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      max = max.max(get(mN, k));
    }
    return max;
  }
}
#!queue	A027156	1	->	0	A027144	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027156 a(n) = self-convolution of array T given by A027144.
 * @author Sean A. Irvine
 */
public class A027156 extends A027144 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A027158	1	->	0	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027158 a(n) = T(2n,n), T given by A027157.
 * @author Sean A. Irvine
 */
public class A027158 extends A027157 {

  private long mN = -1;

  @Override
  public Z next() {
    return t(2 * ++mN, mN);
  }
}
#!queue	A027160	1	->	2	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027160 a(n) = T(2n,n-2), T given by A027157.
 * @author Sean A. Irvine
 */
public class A027160 extends A027157 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 2);
  }
}
#!queue	A027162	1	->	2	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027162 a(n) = T(2n-1,n-2), T given by A027157.
 * @author Sean A. Irvine
 */
public class A027162 extends A027157 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A027163	1	->	0	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027163 a(n) = T(n,[ n/2 ]), T given by A027157.
 * @author Sean A. Irvine
 */
public class A027163 extends A027157 {

  private long mN = -1;

  @Override
  public Z next() {
    return t(++mN, mN / 2);
  }
}
#!queue	A027164	1	->	0	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027164 a(n) = T(n,0) + T(n,1) + ... + T(n,n), T given by A027157.
 * @author Sean A. Irvine
 */
public class A027164 extends A027157 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(t(mN, k));
    }
    return sum;
  }
}
#!queue	A027165	1	->	0	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027165 T(n,0) + T(n,1) + ... + T(n,[ n/2 ]), T given by A027157.
 * @author Sean A. Irvine
 */
public class A027165 extends A027157 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(t(mN, k));
    }
    return sum;
  }
}
#!queue	A027167	1	->	0	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027167 a(n) = Sum_{k=0..floor(n/2)} A027157(n-k, k).
 * @author Sean A. Irvine
 */
public class A027167 extends A027157 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(t(mN - k, k));
    }
    return sum;
  }
}
#!queue	A027168	1	->	0	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027168 Greatest number in row n of array T given by A027157.
 * @author Sean A. Irvine
 */
public class A027168 extends A027157 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z max = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      max = max.max(t(mN, k));
    }
    return max;
  }
}
#!queue	A027169	1	->	0	A027157	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027169 a(n) = self-convolution of row n of array T given by A027157.
 * @author Sean A. Irvine
 */
public class A027169 extends A027157 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A027172	0	->	1	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027172 a(n) = (1/2) * A027170(2n, n).
 * @author Sean A. Irvine
 */
public class A027172 extends A027170 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN, mN).divide2();
  }
}
#!queue	A027173	0	->	1	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027173 a(n) = A027170(2n, n-1).
 * @author Sean A. Irvine
 */
public class A027173 extends A027170 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 1);
  }
}
#!queue	A027174	0	->	2	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027174 a(n) = A027170(2n, n-2).
 * @author Sean A. Irvine
 */
public class A027174 extends A027170 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN, mN - 2);
  }
}
#!queue	A027175	0	->	1	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027175 a(n) = A027170(2n-1, n-1).
 * @author Sean A. Irvine
 */
public class A027175 extends A027170 {

  private long mN = 0;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 1);
  }
}
#!queue	A027176	0	->	2	A027170	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027176 a(n) = A027170(2n-1, n-2).
 * @author Sean A. Irvine
 */
public class A027176 extends A027170 {

  private long mN = 1;

  @Override
  public Z next() {
    return t(2 * ++mN - 1, mN - 2);
  }
}
#!queue	A027183	0	->	1	A027170	--------------------------------
package irvine.oeis.a027;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A027183 a(n) = n-th largest even number in array T given by A027170.
 * @author Sean A. Irvine
 */
public class A027183 extends A027170 {

  private long mRow = 2;
  private Z mLast = Z.ZERO;
  private Z mLeading = t(mRow, 1);
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    while (mSet.isEmpty() || mSet.first().compareTo(mLeading) > 0) {
      for (long k = 0; k <= mRow / 2; ++k) {
        final Z t = t(mRow, k);
        if (t.isEven() && t.compareTo(mLast) > 0) {
          mSet.add(t);
        }
      }
      mLeading = t(++mRow, 1);
    }
    mLast = mSet.pollFirst();
    return mLast;
  }
}
#!queue	A027184	0	->	1	A027183	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027184 a(n) = (1/2)*(n-th largest even number in array T given by A027170).
 * @author Sean A. Irvine
 */
public class A027184 extends A027183 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A027189	0	->	1	A027188	--------------------------------
package irvine.oeis.a027;

/**
 * A027189 Number of partitions of n into an odd number of parts, the least being 3; also, a(n+3) = number of partitions of n into an even number of parts, each &gt;=3.
 * @author Sean A. Irvine
 */
public class A027189 extends A027188 {

  @Override
  protected int leastPart() {
    return 3;
  }
}
#!queue	A027190	0	->	1	A027188	--------------------------------
package irvine.oeis.a027;

/**
 * A027190 Number of partitions of n into an odd number of parts, the least being 4; also, a(n+4) = number of partitions of n into an even number of parts, each &gt;=4.
 * @author Sean A. Irvine
 */
public class A027190 extends A027188 {

  @Override
  protected int start() {
    return -4;
  }

  @Override
  protected int leastPart() {
    return 4;
  }
}
#!queue	A027191	0	->	1	A027188	--------------------------------
package irvine.oeis.a027;

/**
 * A027191 Number of partitions of n into an odd number of parts, the least being 5; also, a(n+5) = number of partitions of n into an even number of parts, each &gt;=5.
 * @author Sean A. Irvine
 */
public class A027191 extends A027188 {

  @Override
  protected int start() {
    return -5;
  }

  @Override
  protected int leastPart() {
    return 5;
  }
}
#!queue	A027192	0	->	1	A027188	--------------------------------
package irvine.oeis.a027;

/**
 * A027192 Number of partitions of n into an odd number of parts, the least being 6; also, a(n+6) = number of partitions of n into an even number of parts, each &gt;=6.
 * @author Sean A. Irvine
 */
public class A027192 extends A027188 {

  @Override
  protected int start() {
    return -6;
  }

  @Override
  protected int leastPart() {
    return 6;
  }
}
#!queue	A027201	1	->	0	A026714	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026714;

/**
 * A027201 a(n) = self-convolution of row n of array T given by A026714.
 * @author Sean A. Irvine
 */
public class A027201 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k)));
    }
    return sum;
  }
}
#!queue	A027203	1	->	2	A026714	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026714;

/**
 * A027203 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026714.
 * @author Sean A. Irvine
 */
public class A027203 extends A026714 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A027204	1	->	3	A026714	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026714;

/**
 * A027204 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026714.
 * @author Sean A. Irvine
 */
public class A027204 extends A026714 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A027205	1	->	0	A026714	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026714;

/**
 * A027205 a(n) = Sum_{k=0..n} (k+1) * A026714(n, k).
 * @author Sean A. Irvine
 */
public class A027205 extends A026714 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027208	0	->	1	A026725	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026725;

/**
 * A027208 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026725.
 * @author Sean A. Irvine
 */
public class A027208 extends A026725 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027209	0	->	2	A026725	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026725;

/**
 * A027209 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026725.
 * @author Sean A. Irvine
 */
public class A027209 extends A026725 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027210	0	->	3	A026725	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026725;

/**
 * A027210 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026725.
 * @author Sean A. Irvine
 */
public class A027210 extends A026725 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027216	0	->	1	A026736	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026736;

/**
 * A027216 a(n) = Sum_{k=0..n-1} T(n,k)*T(n,k+1), T given by A026736.
 * @author Sean A. Irvine
 */
public class A027216 extends A026736 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027217	0	->	2	A026736	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026736;

/**
 * A027217 a(n) = Sum_{k=0..n-2} T(n,k)*T(n,k+2), T given by A026736.
 * @author Sean A. Irvine
 */
public class A027217 extends A026736 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027218	0	->	3	A026736	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026736;

/**
 * A027218 a(n) = Sum_{k=0..n-3} T(n,k)*T(n,k+3), T given by A026736.
 * @author Sean A. Irvine
 */
public class A027218 extends A026736 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027224	0	->	1	A026747	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026747;

/**
 * A027224 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026747.
 * @author Sean A. Irvine
 */
public class A027224 extends A026747 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027225	0	->	2	A026747	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026747;

/**
 * A027225 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026747.
 * @author Sean A. Irvine
 */
public class A027225 extends A026747 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027226	0	->	3	A026747	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026747;

/**
 * A027226 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026747.
 * @author Sean A. Irvine
 */
public class A027226 extends A026747 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027232	0	->	1	A026758	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026758;

/**
 * A027232 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026758.
 * @author Sean A. Irvine
 */
public class A027232 extends A026758 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027233	0	->	2	A026758	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026758;

/**
 * A027233 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026758.
 * @author Sean A. Irvine
 */
public class A027233 extends A026758 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027234	0	->	3	A026758	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026758;

/**
 * A027234 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026758.
 * @author Sean A. Irvine
 */
public class A027234 extends A026758 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027240	0	->	1	A026769	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026769;

/**
 * A027240 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026769.
 * @author Sean A. Irvine
 */
public class A027240 extends A026769 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027241	0	->	2	A026769	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026769;

/**
 * A027241 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026769.
 * @author Sean A. Irvine
 */
public class A027241 extends A026769 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027242	0	->	3	A026769	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026769;

/**
 * A027242 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026769.
 * @author Sean A. Irvine
 */
public class A027242 extends A026769 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027248	0	->	1	A026780	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026780;

/**
 * A027248 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+1), with T given by A026780.
 * @author Sean A. Irvine
 */
public class A027248 extends A026780 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027249	0	->	2	A026780	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026780;

/**
 * A027249 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026780.
 * @author Sean A. Irvine
 */
public class A027249 extends A026780 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027250	0	->	3	A026780	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026780;

/**
 * A027250 a(n) = Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026780.
 * @author Sean A. Irvine
 */
public class A027250 extends A026780 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027254	1	->	2	A026703	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026703;

/**
 * A027254 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+2), with T given by A026703.
 * @author Sean A. Irvine
 */
public class A027254 extends A026703 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027255	1	->	3	A026703	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026703;

/**
 * A027255 Sum_{k=0..n-3} T(n,k) * T(n,k+3), with T given by A026703.
 * @author Sean A. Irvine
 */
public class A027255 extends A026703 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027256	1	->	0	A026703	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026703;

/**
 * A027256 a(n) = Sum_{k=0..n} (k+1) * A026703(n, k).
 * @author Sean A. Irvine
 */
public class A027256 extends A026703 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027258	0	->	1	A025177	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a025.A025177;

/**
 * A027258 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A025177.
 * @author Sean A. Irvine
 */
public class A027258 extends A025177 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027259	0	->	2	A025177	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a025.A025177;

/**
 * A027259 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A025177.
 * @author Sean A. Irvine
 */
public class A027259 extends A025177 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027260	0	->	3	A025177	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a025.A025177;

/**
 * A027260 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A025177.
 * @author Sean A. Irvine
 */
public class A027260 extends A025177 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027263	0	->	1	A026519	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026519;

/**
 * A027263 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A026519.
 * @author Sean A. Irvine
 */
public class A027263 extends A026519 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027264	0	->	2	A026519	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026519;

/**
 * A027264 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A026519.
 * @author Sean A. Irvine
 */
public class A027264 extends A026519 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027265	0	->	3	A026519	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026519;

/**
 * A027265 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A026519.
 * @author Sean A. Irvine
 */
public class A027265 extends A026519 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027268	0	->	1	A026536	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026536;

/**
 * A027268 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A026536.
 * @author Sean A. Irvine
 */
public class A027268 extends A026536 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027269	0	->	1	A026536	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026536;

/**
 * A027269 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A026536.
 * @author Sean A. Irvine
 */
public class A027269 extends A026536 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027270	0	->	2	A026536	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026536;

/**
 * A027270 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A026536.
 * @author Sean A. Irvine
 */
public class A027270 extends A026536 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027273	0	->	1	A026552	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026552;

/**
 * A027273 a(n) = Sum_{k=0..2n-1} T(n,k) * T(n,k+1), with T given by A026552.
 * @author Sean A. Irvine
 */
public class A027273 extends A026552 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027274	0	->	2	A026552	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026552;

/**
 * A027274 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A026552.
 * @author Sean A. Irvine
 */
public class A027274 extends A026552 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027275	0	->	3	A026552	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026552;

/**
 * A027275 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A026552.
 * @author Sean A. Irvine
 */
public class A027275 extends A026552 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027277	1	->	0	A026568	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026568;

/**
 * A027277 a(n) = Sum_{k=0..n} binomial(2*k,k)*binomial(2*n-k,k).
 * @author Sean A. Irvine
 */
public class A027277 extends A026568 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027279	1	->	2	A026568	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026568;

/**
 * A027279 a(n) = Sum_{k=0..2n-2} T(n,k) * T(n,k+2), with T given by A026568.
 * @author Sean A. Irvine
 */
public class A027279 extends A026568 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027280	1	->	3	A026568	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026568;

/**
 * A027280 a(n) = Sum_{k=0..2n-3} T(n,k) * T(n,k+3), with T given by A026568.
 * @author Sean A. Irvine
 */
public class A027280 extends A026568 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027282	1	->	0	A026584	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026584;

/**
 * A027282 a(n) = self-convolution of row n of array T given by A026584.
 * @author Sean A. Irvine
 */
public class A027282 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k)));
    }
    return sum;
  }
}
#!queue	A027284	1	->	2	A026584	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026584;

/**
 * A027284 a(n) = Sum_{k=0..2*n-2} T(n,k) * T(n,k+2), with T given by A026584.
 * @author Sean A. Irvine
 */
public class A027284 extends A026584 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k - 2)));
    }
    return sum;
  }
}
#!queue	A027285	1	->	3	A026584	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026584;

/**
 * A027285 a(n) = Sum_{k=0..2*n-3} T(n,k) * T(n,k+3), with T given by A026584.
 * @author Sean A. Irvine
 */
public class A027285 extends A026584 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, 2 * mN - k - 3)));
    }
    return sum;
  }
}
#!queue	A027286	1	->	0	A026584	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026584;

/**
 * A027286 a(n) = Sum_{k=0..2n} (k+1) * A026584(n, k).
 * @author Sean A. Irvine
 */
public class A027286 extends A026584 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027289	0	->	2	A026009	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026009;

/**
 * A027289 a(n) = Sum_{k=0..floor(n/2)-1} T(n,k) * T(n,k+2), with T given by A026009.
 * @author Sean A. Irvine
 */
public class A027289 extends A026009 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN / 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027290	0	->	4	A026009	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026009;

/**
 * A027290 a(n) = Sum_{k=0..floor(n/2)-2} T(n,k) * T(n,k+3), with T given by A026009.
 * @author Sean A. Irvine
 */
public class A027290 extends A026009 {

  private long mN = 3;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN / 2 - 1; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027294	1	->	0	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027294 Self-convolution of row n of array T given by A026022.
 * @author Sean A. Irvine
 */
public class A027294 extends A026022 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN >= 3 ? (mN + 1) / 2 + 1 : mN;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, lim - k)));
    }
    return sum;
  }
}
#!queue	A027296	1	->	2	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027296 a(n) = Sum_{k=0..floor((n-1)/2)} T(n,k) * T(n,k+2), with T given by A026022.
 * @author Sean A. Irvine
 */
public class A027296 extends A026022 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = (mN - 1) / 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027297	1	->	3	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027297 a(n) = Sum_{k=0..floor((n-3)/2)} T(n,k) * T(n,k+3), with T given by A026022.
 * @author Sean A. Irvine
 */
public class A027297 extends A026022 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = (mN - 3) / 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027298	1	->	0	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027298 a(n) = Sum_{k=0..m} (k+1) * A026022(n, k), where m=n for n=0,1 and m = floor((n+3)/2) for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027298 extends A026022 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN >= 3 ? (mN + 1) / 2 + 1 : mN;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027299	1	->	0	A026022	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026022;

/**
 * A027299 a(n) = Sum_{k=0..m} (k+1) * A026022(n, m-k), where m=n for n=0,1 and m = floor((n+3)/2) for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027299 extends A026022 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN >= 3 ? (mN + 1) / 2 + 1 : mN;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(t(mN, lim - k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027302	0	->	1	A008315	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a008.A008315;

/**
 * A027302 a(n) = Sum_{k=0..floor((n-1)/2)} T(n,k) * T(n,k+1), with T given by A008315.
 * @author Sean A. Irvine
 */
public class A027302 extends A008315 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN / 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027303	0	->	3	A008315	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a008.A008315;

/**
 * A027303 a(n) = Sum_{k=0..floor((n-3)/2)} T(n,k) * T(n,k+2)}, with T given by A008315.
 * @author Sean A. Irvine
 */
public class A027303 extends A008315 {

  private long mN = 3;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= (mN - 3) / 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027304	0	->	5	A008315	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a008.A008315;

/**
 * A027304 a(n) = Sum_{k=0..floor((n-5)/2)} T(n,k) * T(n,k+1)}, with T given by A008315.
 * @author Sean A. Irvine
 */
public class A027304 extends A008315 {

  private long mN = 5;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= (mN - 5) / 2; ++k) {
      sum = sum.add(t(mN, k).multiply(t(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027311	1	->	2	A026323	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026323;

/**
 * A027311 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+3), with T given by A026323.
 * @author Sean A. Irvine
 */
public class A027311 extends A026323 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027312	1	->	0	A026323	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026323;

/**
 * A027312 a(n) = Sum_{k=0..n+2} (k+1) * A026323(n, k).
 * @author Sean A. Irvine
 */
public class A027312 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN + 2; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027314	1	->	0	A026323	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026323;

/**
 * A027314 a(n) is the sum of squares of numbers in row n of array T given by A026323.
 * @author Sean A. Irvine
 */
public class A027314 extends A026323 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN + 2; ++k) {
      sum = sum.add(get(mN, k).square());
    }
    return sum;
  }
}
#!queue	A027315	1	->	0	A026082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026082;

/**
 * A027315 Self-convolution of array T given by A026082.
 * @author Sean A. Irvine
 */
public class A027315 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).square());
    }
    return sum;
  }
}
#!queue	A027317	1	->	2	A026082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026082;

/**
 * A027317 a(n) = Sum_{k=0..m-2} T(n,k) * T(n,k+2), where m=n for n=0,1,2,3; m=2n for n &gt;= 4; and T is given by A026082.
 * @author Sean A. Irvine
 */
public class A027317 extends A026082 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 1; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027318	1	->	3	A026082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026082;

/**
 * A027318 a(n) = Sum_{k=0..m-3} T(n,k) * T(n,k+2), where m=n for n=0,1,2,3; m=2n for n &gt;= 4; and T is given by A026082.
 * @author Sean A. Irvine
 */
public class A027318 extends A026082 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < 2 * mN - 2; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027319	1	->	0	A026082	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026082;

/**
 * A027319 a(n) = Sum_{k=0..m} (k+1) * A026082(n, k), where 0 &lt;= k &lt;= m, m=n for n=0,1,2,3; m=2n for n &gt;= 4.
 * @author Sean A. Irvine
 */
public class A027319 extends A026082 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= 2 * mN; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027323	0	->	1	A026120	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026120;

/**
 * A027323 a(n) = Sum_{k=0..m} T(n,k) * T(n,k+1), where m=0 for n=1; m=n for n &gt;= 2; and T is given by A026120.
 * @author Sean A. Irvine
 */
public class A027323 extends A026120 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = -1; k < mN; ++k) {
      sum = sum.add(u(mN, k).multiply(u(mN, k + 1)));
    }
    return sum;
  }
}
#!queue	A027324	0	->	2	A026120	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026120;

/**
 * A027324 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+2), with T given by A026120.
 * @author Sean A. Irvine
 */
public class A027324 extends A026120 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = -1; k < mN - 1; ++k) {
      sum = sum.add(u(mN, k).multiply(u(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027325	0	->	3	A026120	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026120;

/**
 * A027325 a(n) = Sum_{k=0..n-2} T(n,k) * T(n,k+3), with T given by A026120.
 * @author Sean A. Irvine
 */
public class A027325 extends A026120 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = -1; k < mN - 2; ++k) {
      sum = sum.add(u(mN, k).multiply(u(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027329	1	->	0	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027329 a(n) = self-convolution of row n of array T given by A026148.
 * @author Sean A. Irvine
 */
public class A027329 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN < 2 ? mN : mN + 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, lim - k)));
    }
    return sum;
  }
}
#!queue	A027331	1	->	2	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027331 a(n) = Sum_{k=0..m} T(n,k) * T(n,k+2), where m=2 for n=2 and m=n+1 for n &gt;= 3; and T is given by A026148.
 * @author Sean A. Irvine
 */
public class A027331 extends A026148 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 2)));
    }
    return sum;
  }
}
#!queue	A027332	1	->	3	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027332 a(n) = Sum_{k=0..n-1} T(n,k) * T(n,k+3), with T given by A026148.
 * @author Sean A. Irvine
 */
public class A027332 extends A026148 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(get(mN, k).multiply(get(mN, k + 3)));
    }
    return sum;
  }
}
#!queue	A027333	1	->	0	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027333 a(n) = Sum_{k=0..m} (k+1) * A026148(n, k), where m=0 for n=1; m=n+1 for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027333 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN < 2 ? mN : mN + 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(get(mN, k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027334	1	->	0	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027334 a(n) = Sum_{k=0..m} (k+1) * A026148(n, m-k), where m=0 for n=1; m=n+1 for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027334 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN < 2 ? mN : mN + 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(get(mN, lim - k).multiply(k + 1));
    }
    return sum;
  }
}
#!queue	A027335	1	->	0	A026148	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a026.A026148;

/**
 * A027335 a(n) is the sum of squares of the numbers in row n of array T given by A026148.
 * @author Sean A. Irvine
 */
public class A027335 extends A026148 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    final long lim = mN < 2 ? mN : mN + 2;
    for (long k = 0; k <= lim; ++k) {
      sum = sum.add(get(mN, k).square());
    }
    return sum;
  }
}
#!queue	A027419	0	->	1	A027384	--------------------------------
package irvine.oeis.a027;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;

/**
 * A027419 Number of distinct products ij with 0 &lt;= i, j &lt;= n-th prime.
 * @author Sean A. Irvine
 */
public class A027419 extends A027384 {

  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (mPrime.isPrime(mN)) {
        return t;
      }
    }
  }
}
#!queue	A027449	1	->	2	A027446	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027449 Second diagonal of A027446.
 * @author Sean A. Irvine
 */
public class A027449 extends A027446 {

  private long mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027450	1	->	3	A027446	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027450 Third diagonal of A027446.
 * @author Sean A. Irvine
 */
public class A027450 extends A027446 {

  private long mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027452	1	->	2	A027447	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027452 Second diagonal of A027447.
 * @author Sean A. Irvine
 */
public class A027452 extends A027447 {

  private long mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027453	1	->	3	A027447	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027453 Third diagonal of A027447.
 * @author Sean A. Irvine
 */
public class A027453 extends A027447 {

  private long mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027455	1	->	2	A027448	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027455 Second diagonal of A027448.
 * @author Sean A. Irvine
 */
public class A027455 extends A027448 {

  private long mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027456	1	->	3	A027448	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027456 Third diagonal of A027448.
 * @author Sean A. Irvine
 */
public class A027456 extends A027448 {

  private long mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027458	1	->	3	A027446	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027458 Third column of A027446.
 * @author Sean A. Irvine
 */
public class A027458 extends A027446 {

  private long mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027460	1	->	2	A027447	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027460 Second column of A027447.
 * @author Sean A. Irvine
 */
public class A027460 extends A027447 {

  private long mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027461	1	->	3	A027447	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027461 Third column of A027447.
 * @author Sean A. Irvine
 */
public class A027461 extends A027447 {

  private long mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027463	1	->	2	A027448	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027463 Second column of A027448.
 * @author Sean A. Irvine
 */
public class A027463 extends A027448 {

  private long mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027464	1	->	3	A027448	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027464 Third column of A027448.
 * @author Sean A. Irvine
 */
public class A027464 extends A027448 {

  private long mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027481	1	->	3	A027477	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027481 Second subdiagonal of triangle A027477, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027481 extends A027477 {

  private int mN = 2;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, mN - 3).multiply(f).toZ();
  }
}
#!queue	A027483	1	->	3	A027481	--------------------------------
package irvine.oeis.a027;

/**
 * A027483 Second subdiagonal of triangle A027478, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027483 extends A027481 {

  @Override
  protected int power() {
    return 3;
  }
}
#!queue	A027485	1	->	3	A027481	--------------------------------
package irvine.oeis.a027;

/**
 * A027485 Second subdiagonal of triangle A027479, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027485 extends A027481 {

  @Override
  protected int power() {
    return 4;
  }
}
#!queue	A027487	1	->	2	A027477	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027487 Second column of triangle A027477, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027487 extends A027477 {

  private int mN = 1;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, 1).multiply(f).toZ();
  }
}
#!queue	A027488	1	->	3	A027477	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027488 Third column of triangle A027477, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027488 extends A027477 {

  private int mN = 2;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, 2).multiply(f).toZ();
  }
}
#!queue	A027490	1	->	2	A027478	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027490 Second column of Triangle A027478, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027490 extends A027478 {

  private int mN = 1;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, 1).multiply(f).toZ();
  }
}
#!queue	A027491	1	->	3	A027478	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027491 Third column of Triangle A027478, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027491 extends A027478 {

  private int mN = 2;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, 2).multiply(f).toZ();
  }
}
#!queue	A027493	1	->	2	A027479	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027493 Second column of Triangle A027479, constructed from the Stirling numbers of the first kind.
 * @author Sean A. Irvine
 */
public class A027493 extends A027479 {

  private int mN = 1;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, 1).multiply(f).toZ();
  }
}
#!queue	A027494	1	->	3	A027479	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027494 Third column of Triangle A027479, constructed from the Stirling numbers of the first kind..
 * @author Sean A. Irvine
 */
public class A027494 extends A027479 {

  private int mN = 2;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    final Z f = mF.factorial(++mN).pow(power());
    return mMatrix.get(mN - 1, 2).multiply(f).toZ();
  }
}
#!queue	A027499	1	->	2	A027495	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027499 Second diagonal of A027495.
 * @author Sean A. Irvine
 */
public class A027499 extends A027495 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027500	1	->	3	A027495	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027500 Third diagonal of A027495.
 * @author Sean A. Irvine
 */
public class A027500 extends A027495 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027502	1	->	2	A027496	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027502 Second diagonal of A027496.
 * @author Sean A. Irvine
 */
public class A027502 extends A027496 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027503	1	->	3	A027496	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027503 Third diagonal of A027496.
 * @author Sean A. Irvine
 */
public class A027503 extends A027496 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027505	1	->	2	A027497	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027505 Second diagonal of A027497.
 * @author Sean A. Irvine
 */
public class A027505 extends A027497 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027506	1	->	3	A027497	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027506 Third diagonal of A027497.
 * @author Sean A. Irvine
 */
public class A027506 extends A027497 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027508	1	->	2	A027495	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027508 Second column of A027495.
 * @author Sean A. Irvine
 */
public class A027508 extends A027495 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027509	1	->	3	A027495	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027509 Third column of A027495.
 * @author Sean A. Irvine
 */
public class A027509 extends A027495 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027511	1	->	2	A027496	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027511 Second column of A027496.
 * @author Sean A. Irvine
 */
public class A027511 extends A027496 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027512	1	->	3	A027496	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027512 Third column of A027496.
 * @author Sean A. Irvine
 */
public class A027512 extends A027496 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027514	1	->	2	A027497	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027514 Second column of A027497.
 * @author Sean A. Irvine
 */
public class A027514 extends A027497 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027515	1	->	3	A027497	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027515 Third column of A027497.
 * @author Sean A. Irvine
 */
public class A027515 extends A027497 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027520	1	->	2	A027516	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027520 Second diagonal of A027516.
 * @author Sean A. Irvine
 */
public class A027520 extends A027516 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027521	1	->	3	A027516	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027521 Third diagonal of A027516.
 * @author Sean A. Irvine
 */
public class A027521 extends A027516 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027523	1	->	2	A027517	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027523 Second diagonal of A027517.
 * @author Sean A. Irvine
 */
public class A027523 extends A027517 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027524	1	->	3	A027517	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027524 Third diagonal of A027517.
 * @author Sean A. Irvine
 */
public class A027524 extends A027517 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027526	1	->	2	A027518	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027526 Second diagonal of A027518.
 * @author Sean A. Irvine
 */
public class A027526 extends A027518 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027527	1	->	3	A027518	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027527 Third diagonal of A027518.
 * @author Sean A. Irvine
 */
public class A027527 extends A027518 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027529	1	->	2	A027516	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027529 Second column of A027516.
 * @author Sean A. Irvine
 */
public class A027529 extends A027516 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027530	1	->	3	A027516	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027530 Third column of A027516.
 * @author Sean A. Irvine
 */
public class A027530 extends A027516 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027532	1	->	2	A027517	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027532 Second column of A027517.
 * @author Sean A. Irvine
 */
public class A027532 extends A027517 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027533	1	->	3	A027517	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027533 Third column of A027517.
 * @author Sean A. Irvine
 */
public class A027533 extends A027517 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027535	1	->	2	A027518	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027535 Second column of A027518.
 * @author Sean A. Irvine
 */
public class A027535 extends A027518 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027536	1	->	3	A027518	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027536 Third column of A027518.
 * @author Sean A. Irvine
 */
public class A027536 extends A027518 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027541	1	->	3	A027537	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027541 Third diagonal of A027537.
 * @author Sean A. Irvine
 */
public class A027541 extends A027537 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027542	1	->	2	A027538	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027542 Second diagonal of A027538.
 * @author Sean A. Irvine
 */
public class A027542 extends A027538 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027543	1	->	3	A027538	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027543 Third diagonal of A027538.
 * @author Sean A. Irvine
 */
public class A027543 extends A027538 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027544	1	->	2	A027539	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027544 Second diagonal of A027539.
 * @author Sean A. Irvine
 */
public class A027544 extends A027539 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 1).multiply(mLcm).toZ();
  }
}
#!queue	A027545	1	->	3	A027539	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027545 Third diagonal of A027539.
 * @author Sean A. Irvine
 */
public class A027545 extends A027539 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, mN - 2).multiply(mLcm).toZ();
  }
}
#!queue	A027547	1	->	2	A027537	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027547 Second column of A027537.
 * @author Sean A. Irvine
 */
public class A027547 extends A027537 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027548	1	->	3	A027537	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027548 Third column of A027537.
 * @author Sean A. Irvine
 */
public class A027548 extends A027537 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027550	1	->	2	A027538	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027550 Second column of A027538.
 * @author Sean A. Irvine
 */
public class A027550 extends A027538 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027551	1	->	3	A027538	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027551 Third column of A027538.
 * @author Sean A. Irvine
 */
public class A027551 extends A027538 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027553	1	->	2	A027539	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027553 Second column of A027539.
 * @author Sean A. Irvine
 */
public class A027553 extends A027539 {

  private int mN = 0;
  {
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 1).multiply(mLcm).toZ();
  }
}
#!queue	A027554	1	->	3	A027539	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027554 Third column of A027539.
 * @author Sean A. Irvine
 */
public class A027554 extends A027539 {

  private int mN = 1;
  {
    step();
    step();
  }

  @Override
  public Z next() {
    step();
    return mMatrix.get(++mN, 2).multiply(mLcm).toZ();
  }
}
#!queue	A027593	0	->	1	A027594	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027593 Sequence satisfies T^2(a)=a, where T is defined below.
 * @author Sean A. Irvine
 */
public class A027593 extends A027594 {

  @Override
  protected Z select(final Z a, final Z b) {
    return b;
  }
}
#!queue	A027610	0	->	1	A047749	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a047.A047749;

/**
 * A027610 Number of chordal planar triangulations; also number of planar triangulations with maximal number of triangles; also number of graphs obtained from the tetrahedron by repeatedly inserting vertices of degree 3 into a triangular face; also number of uniquely 4-colorable planar graphs; also number of simplicial 3-clusters with n cells; also Apollonian networks.
 * @author Sean A. Irvine
 */
public class A027610 extends A047749 {

  private long mN = 0;

  @Override
  public Z next() {
    Z res = a1764(++mN).multiply2().divide(mN + 1).add(a47749(mN).multiply(9));
    if ((mN & 1) == 0) {
      res = res.add(a1764(mN / 2).multiply(5));
    }
    if ((mN - 1) % 3 == 0) {
      res = res.add(a1764((mN - 1) / 3).multiply(8));
    }
    if ((mN - 1) % 4 == 0) {
      res = res.add(a1764((mN - 1) / 4).multiply(6));
    }
    if ((mN - 2) % 6 == 0) {
      res = res.add(a1764((mN - 2) / 6).multiply(4));
    }
    if ((2 * mN - 1) % 3 == 0) {
      res = res.add(a47749((2 * mN - 1) / 3).multiply(4));
    }
    return res.divide(24);
  }
}
#!queue	A027696	1	->	0	A027669	--------------------------------
package irvine.oeis.a027;

import irvine.oeis.Conjectural;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A027696 Nonparametric solutions to problem in A027669: n such that for some m, the sum of the first m n-gonal numbers is again an n-gonal number.
 * @author Sean A. Irvine
 */
public class A027696 extends A027669 implements Conjectural {

  // of the sequence.
  private static final long HEURISTIC_MULTIPLIER = 100000;

  @Override
  protected boolean isExistsGonalSum(final long n) {
    Z sum = Z.ZERO;
    final TreeSet<Z> partialSums = new TreeSet<>();
    for (long k = 1; k < mN * HEURISTIC_MULTIPLIER; ++k) {
      final Z g = gonal(n, k);
      while (!partialSums.isEmpty() && partialSums.first().compareTo(g) <= 0) {
        if (g.equals(partialSums.pollFirst()) && (mN % 3 != 2 || 9 * k != mN * mN * mN - 6 * mN * mN + 3 * mN + 19)) {
          return true;
        }
      }
      sum = sum.add(g);
      partialSums.add(sum);
    }
    return false;
  }
}
#!queue	A027827	0	->	1	A000041	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A027827 Values of k for which 11 divides A000041(k).
 * @author Sean A. Irvine
 */
public class A027827 extends A000041 {

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(11) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A027830	0	->	1	A027622	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027830 Numbers k such that k + (k+1)^2 + (k+2)^3 + (k+3)^4 + (k+4)^5 is prime.
 * @author Sean A. Irvine
 */
public class A027830 extends A027622 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isProbablePrime()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A027840	0	->	1	A060240	--------------------------------
package irvine.oeis.a027;

import irvine.math.MemoryFunction2;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a060.A060240;

/**
 * A027840 Number of subgroups of index n in fundamental group of a certain fiber space.
 * @author Sean A. Irvine
 */
public class A027840 extends A060240 {

  private int mN = 0;

  private final MemoryFunction2<Integer, Z> mBeta = new MemoryFunction2<Integer, Z>() {
    @Override
    protected Z compute(final Integer k, final Integer e) {
      if (k == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      final IntegerPartition partition = new IntegerPartition(k);
      int[] p;
      while ((p = partition.next()) != null) {
        sum = sum.add(mF.factorial(k).divide(degree(k, p)).pow(e));
      }
      return sum;
    }
  };

  private Z bigR(final int n, final int e) {
    Z sum = Z.ZERO;
    final IntegerPartition partition = new IntegerPartition(n);
    int[] p;
    final int[] cnt = new int[n + 1];
    while ((p = partition.next()) != null) {
      IntegerPartition.toCountForm(p, cnt);
      Z b = Z.ONE;
      for (final int i : p) {
        b = b.multiply(mBeta.get(i, e));
      }
      b = b.multiply(n).multiply(Binomial.multinomial(p.length, cnt)).divide(p.length);
      sum = sum.signedAdd((p.length & 1) == 1, b);
    }
    return sum;
  }

  protected int nu() {
    return 2;
  }

  @Override
  public Z next() {
    return bigR(++mN, nu());
  }
}
#!queue	A027842	0	->	1	A027840	--------------------------------
package irvine.oeis.a027;

/**
 * A027842 Number of subgroups of index n in fundamental group of a certain fiber space.
 * @author Sean A. Irvine
 */
public class A027842 extends A027840 {

  @Override
  protected int nu() {
    return 1;
  }
}
#!queue	A027857	0	->	1	A027423	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027857 Number of positive divisors of n!, read mod n.
 * @author Sean A. Irvine
 */
public class A027857 extends A027423 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A027917	1	->	3	A001303	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000217;
import irvine.oeis.a001.A001303;

/**
 * A027917 a(n) = least k such that 1+2+...+k &gt;= E{1,2,...,n}, where E is the 3rd elementary symmetric function.
 * @author Sean A. Irvine
 */
public class A027917 extends A001303 {

  private final Sequence mA = new A000217();
  private long mK = -1;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027918	1	->	4	A000915	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000217;
import irvine.oeis.a000.A000915;

/**
 * A027918 Least k such that 1+2+...+k &gt;= E{1,2,...,n}, where E is the 4th elementary symmetric function.
 * @author Sean A. Irvine
 */
public class A027918 extends A000915 {

  private final Sequence mA = new A000217();
  private long mK = -1;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027919	1	->	3	A001303	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000914;
import irvine.oeis.a001.A001303;

/**
 * A027919 a(n) = least k such that 2nd elementary symmetric function of {1,2,...,k+1} &gt;= 3rd elementary symmetric function of {1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A027919 extends A001303 {

  private final Sequence mA = new A000914();
  private long mK = -1;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027920	1	->	4	A000915	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000914;
import irvine.oeis.a000.A000915;

/**
 * A027920 Least k such that 2nd elementary symmetric function of {1,2,...,k} &gt;= 4th elementary symmetric function of {1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A027920 extends A000915 {

  private final Sequence mA = new A000914();
  private long mK = -1;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027921	1	->	4	A000915	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000915;
import irvine.oeis.a001.A001303;

/**
 * A027921 a(n) = least k such that 3rd elementary symmetric function of {1,2,...,k} &gt;= 4th elementary symmetric function of {1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A027921 extends A000915 {

  private final Sequence mA = new A001303();
  private long mK = 0;

  @Override
  public Z next() {
    final Z t = super.next();
    while (mA.next().compareTo(t) < 0) {
      ++mK;
    }
    return Z.valueOf(++mK);
  }
}
#!queue	A027925	0	->	1	A000537	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000537;
import irvine.oeis.a000.A000914;

/**
 * A027925 a(n) = least k such that E{1,2,...,k} &gt;= 1^3 + 2^3 + ... + n^3, where E = 2nd elementary symmetric function.
 * @author Sean A. Irvine
 */
public class A027925 extends A000537 {

  private final Sequence mA = new A000914();
  private Z mT = Z.NEG_ONE;
  private long mK = -1;

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    while (mT.compareTo(t) < 0) {
      mT = mA.next();
      ++mK;
    }
    return Z.valueOf(mK);
  }
}
#!queue	A027936	0	->	1	A027935	--------------------------------
package irvine.oeis.a027;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A027936 Uniquification of array T given by A027935.
 * @author Sean A. Irvine
 */
public class A027936 extends A027935 {

  private long mRow = 1;
  private Z mLast = Z.ZERO;
  private Z mLeading = A027926.t(mRow, 2 * mRow - 2);
  private final TreeSet<Z> mSet = new TreeSet<>();

  @Override
  public Z next() {
    while (mSet.isEmpty() || mSet.first().compareTo(mLeading) > 0) {
      // Need to run through another row
      for (long k = 0; k <= mRow; ++k) {
        final Z t = A027926.t(mRow, 2 * k);
        if (t.compareTo(mLast) > 0) {
          mSet.add(t);
        }
      }
      mLeading = A027926.t(++mRow, 2 * mRow - 2);
    }
    mLast = mSet.pollFirst();
    return mLast;
  }
}
#!queue	A027985	0	->	1	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027985 a(n) = Sum{T(n,k)*T(n,k+1)}, 0&lt;=k&lt;=2n-1, T given by A027960.
 * @author Sean A. Irvine
 */
public class A027985 extends A027960 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long m = 0; m < 2 * mN; ++m) {
      sum = sum.add(get(mN, m).multiply(get(mN, m + 1)));
    }
    return sum;
  }
}
#!queue	A027986	0	->	2	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027986 Sum{T(n,k)*T(n,k+2)}, 0&lt;=k&lt;=2n-2, T given by A027960.
 * @author Sean A. Irvine
 */
public class A027986 extends A027960 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long m = 0; m < 2 * mN - 1; ++m) {
      sum = sum.add(get(mN, m).multiply(get(mN, m + 2)));
    }
    return sum;
  }
}
#!queue	A027987	0	->	3	A027960	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;

/**
 * A027987 a(n) = Sum{T(n,k)*T(n,k+3)}, 0&lt;=k&lt;=2n-3, T given by A027960.
 * @author Sean A. Irvine
 */
public class A027987 extends A027960 {

  private long mN = 2;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long m = 0; m < 2 * mN - 2; ++m) {
      sum = sum.add(get(mN, m).multiply(get(mN, m + 3)));
    }
    return sum;
  }
}
#!queue	A028243	0	->	1	A000392	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a000.A000392;

/**
 * A028243 a(n) = 3^(n-1) - 2*2^(n-1) + 1 (essentially Stirling numbers of second kind).
 * @author Sean A. Irvine
 */
public class A028243 extends A000392 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A028265	0	->	1	A028264	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028265 Odd elements in 3-Pascal triangle A028262 (by row) that are not 1.
 * @author Sean A. Irvine
 */
public class A028265 extends A028264 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (!Z.ONE.equals(t)) {
        return t;
      }
    }
  }
}
#!queue	A028274	0	->	1	A028272	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028274 Odd elements (greater than 1) to right of central elements in 3-Pascal triangle A028262.
 * @author Sean A. Irvine
 */
public class A028274 extends A028272 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isOdd()) {
        return t;
      }
    }
  }
}
#!queue	A028305	1	->	0	A007710	--------------------------------
package irvine.oeis.a028;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a007.A007710;
import irvine.util.Permutation;

/**
 * A028305 Triangle of numbers of permutations eliminating just k cards out of n in game of Mousetrap.
 * @author Sean A. Irvine
 */
public class A028305 extends A007710 {

  private int mN = 0;
  private int mM = -1;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    long count = 0;
    final Permutation perm = new Permutation(mN);
    int[] p;
    while ((p = perm.next()) != null) {
      if (isDiscardCount(Arrays.copyOf(p, p.length), mM)) {
        ++count;
      }
    }
    return Z.valueOf(count);
  }

}
#!queue	A028330	1	->	0	A014413	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a014.A014413;

/**
 * A028330 Elements to the right of the central elements of the even-Pascal triangle A028326.
 * @author Sean A. Irvine
 */
public class A028330 extends A014413 {

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A028331	1	->	0	A028330	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028331 Elements to the right of the central elements of the even-Pascal triangle A028326 that are not 2.
 * @author Sean A. Irvine
 */
public class A028331 extends A028330 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (!Z.TWO.equals(t)) {
        return t;
      }
    }
  }
}
#!queue	A028334	1	->	2	A001223	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a001.A001223;

/**
 * A028334 Differences between consecutive odd primes, divided by 2.
 * @author Sean A. Irvine
 */
public class A028334 extends A001223 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A028339	0	->	2	A028338	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028339 Coefficient of x^2 in expansion of (x+1)*(x+3)*...*(x+2*n-1).
 * @author Sean A. Irvine
 */
public class A028339 extends A028338 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}
#!queue	A028340	0	->	3	A028338	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028340 Coefficient of x^3 in expansion of (x+1)*(x+3)*...*(x+2*n-1).
 * @author Sean A. Irvine
 */
public class A028340 extends A028338 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3);
  }
}
#!queue	A028341	0	->	4	A028338	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028341 Coefficient of x^4 in expansion of (x+1)*(x+3)*...*(x+2*n-1).
 * @author Sean A. Irvine
 */
public class A028341 extends A028338 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, 4);
  }
}
#!queue	A028370	0	->	1	A000722	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a000.A000722;

/**
 * A028370 a(n) = (2^(n-1))!*2^(2^(n-1)-1).
 * @author Sean A. Irvine
 */
public class A028370 extends A000722 {

  private int mN = -1;

  @Override
  public Z next() {
    return super.next().shiftLeft(Z.ONE.shiftLeft(++mN).longValueExact() - 1);
  }
}
#!queue	A028371	0	->	2	A028366	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;

/**
 * A028371 a(n) = (2^(n-1)-1)!*2^((2^(n-1)-1)-1).
 * @author Sean A. Irvine
 */
public class A028371 extends A028366 {

  private int mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().shiftLeft(Z.ONE.shiftLeft(++mN).longValueExact() - 2);
  }
}
#!queue	A028815	1	->	0	A008578	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a008.A008578;

/**
 * A028815 a(n) = n-th prime + 1 (starting with 1).
 * @author Sean A. Irvine
 */
public class A028815 extends A008578 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A028894	0	->	1	A005614	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a005.A005614;

/**
 * A028894 a(n) = either 4a(n-1)+1 or 4a(n-1)+3 depending on corresponding term of A005614, +1 for 0, +3 for 1.
 * @author Sean A. Irvine
 */
public class A028894 extends A005614 {

  private Z mA = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
      super.next();
    } else {
      mA = mA.shiftLeft(2).add(super.next().multiply2().add(1));
    }
    return mA;
  }
}
#!queue	A028987	0	->	1	A010785	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A028987 Repdigit - 1 is prime.
 * @author Sean A. Irvine
 */
public class A028987 extends A010785 {

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.subtract(1).isProbablePrime()) {
        return p;
      }
    }
  }
}
#!queue	A028988	0	->	1	A010785	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A028988 Repdigit + 1 is prime.
 * @author Sean A. Irvine
 */
public class A028988 extends A010785 {

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.add(1).isProbablePrime()) {
        return p;
      }
    }
  }
}
#!queue	A029607	0	->	1	A029605	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029607 Even numbers in the (2,3)-Pascal triangle A029600 that are different from 2.
 * @author Sean A. Irvine
 */
public class A029607 extends A029605 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (Z.TWO.equals(t));
    return t;
  }
}
#!queue	A029615	0	->	1	A029614	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029615 Numbers to the right of the central elements of the (2,3)-Pascal triangle A029600 that are different from 3.
 * @author Sean A. Irvine
 */
public class A029615 extends A029614 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (Z.THREE.equals(t));
    return t;
  }
}
#!queue	A029637	0	->	1	A029635	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029637 Numbers in the (1,2)-Pascal triangle A029635 that are different from 2.
 * @author Sean A. Irvine
 */
public class A029637 extends A029635 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (Z.TWO.equals(t));
    return t;
  }
}
#!queue	A029638	0	->	1	A029635	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029638 Numbers in the (1,2)-Pascal triangle A029635 that are different from 1.
 * @author Sean A. Irvine
 */
public class A029638 extends A029635 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (Z.ONE.equals(t));
    return t;
  }
}
#!queue	A029640	0	->	1	A029635	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029640 Even numbers in the (1,2)-Pascal triangle A029635.
 * @author Sean A. Irvine
 */
public class A029640 extends A029635 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isOdd());
    return t;
  }
}
#!queue	A029642	1	->	0	A029636	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029642 Distinct odd numbers in the (1,2)-Pascal triangle A029635.
 * @author Sean A. Irvine
 */
public class A029642 extends A029636 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isEven());
    return t;
  }
}
#!queue	A029652	0	->	1	A029635	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029652 Odd numbers in the (1,2)-Pascal triangle A029635.
 * @author Sean A. Irvine
 */
public class A029652 extends A029635 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.isEven());
    return t;
  }
}
#!queue	A029656	0	->	1	A029653	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029656 Numbers in the (2,1)-Pascal triangle A029653 that are different from 1.
 * @author Sean A. Irvine
 */
public class A029656 extends A029653 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (Z.ONE.equals(t));
    return t;
  }
}
#!queue	A029714	1	->	0	A002034	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a002.A002034;

/**
 * A029714 a(n) = Sum_{k divides 3^n} S(k), where S is the Kempner function A002034.
 * @author Sean A. Irvine
 */
public class A029714 extends A002034 {

  private Z mA = Z.ZERO;
  private Z mN = Z.ONE;

  @Override
  public Z next() {
    mA = mA.add(kempner(mN));
    mN = mN.multiply(3);
    return mA;
  }
}
#!queue	A029715	1	->	0	A002034	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a002.A002034;

/**
 * A029715 a(n) = Sum_{k divides 2^n} S(k), where S is the Kempner function A002034.
 * @author Sean A. Irvine
 */
public class A029715 extends A002034 {

  private Z mA = Z.ZERO;
  private Z mN = Z.ONE;

  @Override
  public Z next() {
    mA = mA.add(kempner(mN));
    mN = mN.multiply2();
    return mA;
  }
}
#!queue	A029777	1	->	0	A029776	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029777 Cubes such that digits of cube root of n appear in n.
 * @author Sean A. Irvine
 */
public class A029777 extends A029776 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A029791	1	->	0	A029790	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029791 Squares such that digits of sqrt(n) are not present in n or n^(3/2).
 * @author Sean A. Irvine
 */
public class A029791 extends A029790 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A029792	1	->	0	A029790	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029792 Cubes such that digits of cube root of n are not present in n^(2/3) or n.
 * @author Sean A. Irvine
 */
public class A029792 extends A029790 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A029796	1	->	0	A029795	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029796 Cubes such that cube root of n and n have same digits.
 * @author Sean A. Irvine
 */
public class A029796 extends A029795 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A029798	1	->	0	A029797	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029798 Squares such that n and n^(3/2) have same digits.
 * @author Sean A. Irvine
 */
public class A029798 extends A029797 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A029799	1	->	0	A029797	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;

/**
 * A029799 Cubes such that n^(2/3) and n have same digits.
 * @author Sean A. Irvine
 */
public class A029799 extends A029797 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A029828	1	->	0	A013959	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a013.A013959;

/**
 * A029828 Eisenstein series E_12(q) (alternate convention E_6(q)), multiplied by 691.
 * @author Sean A. Irvine
 */
public class A029828 extends A013959 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.valueOf(691);
    }
    return super.next().multiply(65520);
  }
}
#!queue	A029829	1	->	0	A013963	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a013.A013963;

/**
 * A029829 Eisenstein series E_16(q) (alternate convention E_8(q)), multiplied by 3617.
 * @author Sean A. Irvine
 */
public class A029829 extends A013963 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.valueOf(3617);
    }
    return super.next().multiply(16320);
  }
}
#!queue	A029830	1	->	0	A013967	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a013.A013967;

/**
 * A029830 Eisenstein series E_20(q) (alternate convention E_10(q)), multiplied by 174611.
 * @author Sean A. Irvine
 */
public class A029830 extends A013967 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.valueOf(174611);
    }
    return super.next().multiply(13200);
  }
}
#!queue	A029831	1	->	0	A013971	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a013.A013971;

/**
 * A029831 Eisenstein series E_24(q) (alternate convention E_12(q)), multiplied by 236364091.
 * @author Sean A. Irvine
 */
public class A029831 extends A013971 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.valueOf(236364091);
    }
    return super.next().multiply(131040);
  }
}
#!queue	A029849	1	->	0	A002500	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000595;
import irvine.oeis.a002.A002500;

/**
 * A029849 Number of nonisomorphic and nonantiisomorphic relations.
 * @author Sean A. Irvine
 */
public class A029849 extends A002500 {

  private final Sequence mA = new A000595();

  @Override
  public Z next() {
    return super.next().add(mA.next()).divide2();
  }
}
#!queue	A029855	1	->	5	A033185	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.a033.A033185;

/**
 * A029855 Number of rooted trees where root has degree 4.
 * @author Sean A. Irvine
 */
public class A029855 extends A033185 {

  private int mN = 3;

  @Override
  public Z next() {
    return get(++mN, mN, 4);
  }
}
#!queue	A029890	0	->	1	A029889	--------------------------------
package irvine.oeis.a029;

import irvine.math.IntegerUtils;

/**
 * A029890 Number of odd graphical partitions.
 * @author Sean A. Irvine
 */
public class A029890 extends A029889 {

  {
    super.next();
  }

  @Override
  protected boolean accept(final int[] rowSums) {
    return (IntegerUtils.sum(rowSums) & 1) == 1;
  }
}
#!queue	A029891	0	->	1	A029889	--------------------------------
package irvine.oeis.a029;

import irvine.math.IntegerUtils;

/**
 * A029891 Number of even graphical partitions.
 * @author Sean A. Irvine
 */
public class A029891 extends A029889 {

  {
    super.next();
  }

  @Override
  protected boolean accept(final int[] rowSums) {
    return (IntegerUtils.sum(rowSums) & 1) == 0;
  }
}
#!queue	A029892	0	->	1	A029889	--------------------------------
package irvine.oeis.a029;

import java.util.HashSet;
import java.util.List;

import irvine.math.z.Z;

/**
 * A029892 Number of even graphical partitions of order 2n - number of odd partitions.
 * @author Sean A. Irvine
 */
public class A029892 extends A029889 {

  {
    super.next(); // skip 0
  }

  @Override
  protected long count(final HashSet<List<Integer>> seen) {
    long cnt = 0;
    for (final List<Integer> lst : seen) {
      int s = 0;
      for (final int l : lst) {
        s += l;
      }
      cnt += 1 - 2 * (s & 1);
    }
    return cnt;
  }

  @Override
  public Z next() {
    ++mN;
    return super.next();
  }
}
#!queue	A030076	0	->	1	A054055	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a054.A054055;

/**
 * A030076 a(n) = 10 - m, where m = maximal digit of n.
 * @author Sean A. Irvine
 */
public class A030076 extends A054055 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    return Z.TEN.subtract(super.next());
  }
}
#!queue	A030109	0	->	1	A030101	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030109 Write n in binary, reverse bits, subtract 1, divide by 2.
 * @author Sean A. Irvine
 */
public class A030109 extends A030101 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    return super.next().subtract(1).divide2();
  }
}
#!queue	A030176	0	->	1	A030177	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030176 Squares composed of digits {4,5,6}.
 * @author Sean A. Irvine
 */
public class A030176 extends A030177 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A030196	0	->	1	A000295	--------------------------------
package irvine.oeis.a030;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a000.A000295;
import irvine.oeis.a008.A008292;

/**
 * A030196 Distinct elements occurring in triangle of Eulerian numbers (sorted).
 * @author Sean A. Irvine
 */
public class A030196 extends A000295 {

  private final A008292 mEuler = new A008292();
  private final TreeSet<Z> mS = new TreeSet<>();
  private long mRow = 0;
  private Z mA = super.next();

  {
    next();
    next();
    mS.add(Z.ONE);
  }

  @Override
  public Z next() {
    if (mS.isEmpty() || mS.first().compareTo(mA) <= 0) {
      ++mRow;
      for (long col = 2; col <= (mRow + 1) / 2; ++col) {
        mS.add(mEuler.get(mRow, col));
      }
      mA = super.next();
    }
    return mS.pollFirst();
  }
}
#!queue	A030232	0	->	1	A027423	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a027.A027423;

/**
 * A030232 Numbers k such that the number of divisors of k! divides the number of divisors of (2k)!.
 * @author Sean A. Irvine
 */
public class A030232 extends A027423 {

  private final Sequence mA = new A027423();
  private long mN = 0;
  {
    mA.next();
    super.next();
  }
  
  @Override
  public Z next() {
    while (true) {
      ++mN;
      mA.next();
      if (mA.next().mod(super.next()).isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A030304	1	->	0	A030320	--------------------------------
package irvine.oeis.a030;

/**
 * A030304 Least k such that the base-2 representation of n begins at s(k), where s=A030190 (or equally A030302).
 * @author Sean A. Irvine
 */
public class A030304 extends A030320 {

  /** Construct the sequence. */
  public A030304() {
    super(new A030190(), -1);
  }

  @Override
  protected long first() {
    return -1;
  }
}
#!queue	A030309	0	->	1	A030308	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030309 Position of n-th 0 in A030308.
 * @author Sean A. Irvine
 */
public class A030309 extends A030308 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030310	0	->	1	A030308	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030310 Position of n-th 1 in A030308.
 * @author Sean A. Irvine
 */
public class A030310 extends A030308 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030314	0	->	1	A030308	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030314 (# 1's)-(# 0's) in first n terms of A030308.
 * @author Sean A. Irvine
 */
public class A030314 extends A030308 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    mSum = mSum.signedAdd(Z.ONE.equals(super.next()), Z.ONE);
    return mSum;
  }
}

#!queue	A030342	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030342 Position of n-th 0 in A030341.
 * @author Sean A. Irvine
 */
public class A030342 extends A030341 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030343	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030343 Position of n-th 1 in A030341.
 * @author Sean A. Irvine
 */
public class A030343 extends A030341 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030344	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030344 Position of n-th 2 in A030341.
 * @author Sean A. Irvine
 */
public class A030344 extends A030341 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030346	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030346 Length of n-th run of digit 0 in A030341.
 * @author Sean A. Irvine
 */
public class A030346 extends A030341 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    long cnt = 1;
    if (mFirst) {
      mFirst = false;
      --cnt;
    } else {
      while (!super.next().isZero()) {
        // do nothing
      }
    }
    while (super.next().isZero()) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030347	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030347 Length of n-th run of digit 1 in A030341.
 * @author Sean A. Irvine
 */
public class A030347 extends A030341 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.ONE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030348	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030348 Length of n-th run of digit 2 in A030341.
 * @author Sean A. Irvine
 */
public class A030348 extends A030341 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.TWO.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030349	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030349 (# 1's)-(# 0's) in first n terms of A030341.
 * @author Sean A. Irvine
 */
public class A030349 extends A030341 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 0) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030350	0	->	1	A030341	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030350 a(n) = (# 1's)-(# 2's) in first n terms of A030341.
 * @author Sean A. Irvine
 */
public class A030350 extends A030341 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 2) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030387	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030387 Position of n-th 0 in A030386.
 * @author Sean A. Irvine
 */
public class A030387 extends A030386 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030388	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030388 Position of n-th 1 in A030386.
 * @author Sean A. Irvine
 */
public class A030388 extends A030386 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030389	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030389 Position of n-th 2 in A030386.
 * @author Sean A. Irvine
 */
public class A030389 extends A030386 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030390	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030390 Position of n-th 3 in A030386.
 * @author Sean A. Irvine
 */
public class A030390 extends A030386 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030392	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030392 Length of n-th run of digit 0 in A030386.
 * @author Sean A. Irvine
 */
public class A030392 extends A030386 {

  @Override
  public Z next() {
    while (!super.next().isZero()) {
      // do nothing
    }
    long cnt = 1;
    while (super.next().isZero()) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030393	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030393 Length of n-th run of digit 1 in A030386.
 * @author Sean A. Irvine
 */
public class A030393 extends A030386 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.ONE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030394	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030394 Length of n-th run of digit 2 in A030386.
 * @author Sean A. Irvine
 */
public class A030394 extends A030386 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.TWO.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030395	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030395 Length of n-th run of digit 3 in A030386.
 * @author Sean A. Irvine
 */
public class A030395 extends A030386 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.THREE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030396	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030396 a(n)=(# 1's)-(# 0's) in first n terms of A030386.
 * @author Sean A. Irvine
 */
public class A030396 extends A030386 {

  private Z mSum = Z.ZERO;
  {
    super.next(); // skip 0th term that was added later to A030386
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 0) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030397	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030397 a(n)=(# 1's)-(# 2's) in first n terms of A030386.
 * @author Sean A. Irvine
 */
public class A030397 extends A030386 {

  private Z mSum = Z.ZERO;
  {
    super.next(); // skip 0th term that was added later to A030386
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 2) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030398	0	->	1	A030386	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030398 a(n)=(# 2's)-(# 3's) in first n terms of A030386.
 * @author Sean A. Irvine
 */
public class A030398 extends A030386 {

  private Z mSum = Z.ZERO;
  {
    super.next(); // skip 0th term that was added later to A030386
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 2) {
      mSum = mSum.add(1);
    } else if (t == 3) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030400	1	->	0	A030378	--------------------------------
package irvine.oeis.a030;

/**
 * A030400 a(n)=least k such that base 4 representation of n begins at s(k), where s=A030399.
 * @author Sean A. Irvine
 */
public class A030400 extends A030378 {

  /** Construct the sequence. */
  public A030400() {
    super(new A030399(), 0);
  }
}

#!queue	A030449	0	->	1	A005345	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a005.A005345;

/**
 * A030449 Number of elements in the free band (idempotent semigroup) on n generators.
 * @author Sean A. Irvine
 */
public class A030449 extends A005345 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A030463	1	->	0	A002385	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a002.A002385;

/**
 * A030463 Previous palindromic prime concatenated with this palindromic prime is prime.
 * @author Sean A. Irvine
 */
public class A030463 extends A002385 {

  private Z mP = super.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mP;
      mP = super.next();
      if (new Z(t.toString() + mP).isProbablePrime()) {
        return mP;
      }
    }
  }
}
#!queue	A030479	1	->	0	A030478	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030479 Cubes with property that all even digits occur together and all odd digits occur together.
 * @author Sean A. Irvine
 */
public class A030479 extends A030478 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A030486	1	->	0	A030484	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030486 When squared gives number composed of digits {2,5,6}.
 * @author Sean A. Irvine
 */
public class A030486 extends A030484 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}
#!queue	A030487	1	->	0	A030485	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030487 When squared gives number composed of digits {2, 5, 7}.
 * @author Sean A. Irvine
 */
public class A030487 extends A030485 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}
#!queue	A030504	3	->	4	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030504 Graham-Sloane-type lower bound on the size of a ternary (n,3,4) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030504 extends A030503 {

  @Override
  protected int w() {
    return 4;
  }
}

#!queue	A030505	3	->	5	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030505 Graham-Sloane-type lower bound on the size of a ternary (n,3,5) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030505 extends A030503 {

  @Override
  protected int w() {
    return 5;
  }
}

#!queue	A030506	3	->	6	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030506 Graham-Sloane-type lower bound on the size of a ternary (n,3,6) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030506 extends A030503 {

  @Override
  protected int w() {
    return 6;
  }
}

#!queue	A030507	3	->	7	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030507 Graham-Sloane-type lower bound on the size of a ternary (n,3,7) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030507 extends A030503 {

  @Override
  protected int w() {
    return 7;
  }
}

#!queue	A030508	3	->	8	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030508 Graham-Sloane-type lower bound on the size of a ternary (n,3,8) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030508 extends A030503 {

  @Override
  protected int w() {
    return 8;
  }
}

#!queue	A030509	3	->	9	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030509 Graham-Sloane-type lower bound on the size of a ternary (n,3,9) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030509 extends A030503 {

  @Override
  protected int w() {
    return 9;
  }
}

#!queue	A030510	3	->	10	A030503	--------------------------------
package irvine.oeis.a030;

/**
 * A030510 Graham-Sloane-type lower bound on the size of a ternary (n,3,10) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030510 extends A030503 {

  @Override
  protected int w() {
    return 10;
  }
}

#!queue	A030568	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030568 Position of n-th 0 in A030567.
 * @author Sean A. Irvine
 */
public class A030568 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030569	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030569 Position of n-th 1 in A030567.
 * @author Sean A. Irvine
 */
public class A030569 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030570	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030570 Position of n-th 2 in A030567.
 * @author Sean A. Irvine
 */
public class A030570 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030571	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030571 Position of n-th 3 in A030567.
 * @author Sean A. Irvine
 */
public class A030571 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030572	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030572 Position of n-th 4 in A030567.
 * @author Sean A. Irvine
 */
public class A030572 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030573	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030573 Position of n-th 5 in A030567.
 * @author Sean A. Irvine
 */
public class A030573 extends A030567 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A030575	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030575 Run length of n-th run of digit 0 in A030567.
 * @author Sean A. Irvine
 */
public class A030575 extends A030567 {

  @Override
  public Z next() {
    while (!super.next().isZero()) {
      // do nothing
    }
    long cnt = 1;
    while (super.next().isZero()) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030576	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030576 Length of n-th run of digit 1 in A030567.
 * @author Sean A. Irvine
 */
public class A030576 extends A030567 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.ONE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030577	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030577 Length of n-th run of digit 2 in A030567.
 * @author Sean A. Irvine
 */
public class A030577 extends A030567 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.TWO.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030578	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030578 Length of n-th run of digit 3 in A030567.
 * @author Sean A. Irvine
 */
public class A030578 extends A030567 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.THREE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030579	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030579 Length of n-th run of digit 4 in A030567.
 * @author Sean A. Irvine
 */
public class A030579 extends A030567 {

  @Override
  public Z next() {
    while (!Z.FOUR.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.FOUR.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030580	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030580 Length of n-th run of digit 5 in A030567.
 * @author Sean A. Irvine
 */
public class A030580 extends A030567 {

  @Override
  public Z next() {
    while (!Z.FIVE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.FIVE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A030581	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030581 a(n)=(# 1's)-(# 0's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030581 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 0) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030582	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030582 a(n)=(# 1's)-(# 2's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030582 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 2) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030583	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030583 a(n)=(# 2's)-(# 3's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030583 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 2) {
      mSum = mSum.add(1);
    } else if (t == 3) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030584	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030584 (# 3's)-(# 4's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030584 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 3) {
      mSum = mSum.add(1);
    } else if (t == 4) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030585	0	->	1	A030567	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030585 (# 4's)-(# 5's) in first n terms of A030567.
 * @author Sean A. Irvine
 */
public class A030585 extends A030567 {

  private Z mSum = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 4) {
      mSum = mSum.add(1);
    } else if (t == 5) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A030622	0	->	1	A000455	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000455;

/**
 * A030622 Powers of 2 grouped in pairs of two digits (version 1).
 * @author Sean A. Irvine
 */
public class A030622 extends A000455 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(10).add(super.next());
  }
}

#!queue	A030623	0	->	1	A000455	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000455;

/**
 * A030623 Powers of 2 grouped in pairs of 2 digits (version 2).
 * @author Sean A. Irvine
 */
public class A030623 extends A000455 {

  @Override
  public Z next() {
    return super.next().multiply(10).add(super.next());
  }
}

#!queue	A030624	0	->	1	A000455	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000455;

/**
 * A030624 Powers of 2 grouped in pairs of 2 digits (version 3).
 * @author Sean A. Irvine
 */
public class A030624 extends A000455 {

  @Override
  public Z next() {
    Z t = Z.ZERO;
    do {
      t = t.multiply(10).add(super.next());
    } while (t.compareTo(Z.TEN) < 0);
    return t;
  }
}

#!queue	A030692	0	->	1	A000578	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A030692 Smallest nontrivial extension of n-th cube which is a prime.
 * @author Sean A. Irvine
 */
public class A030692 extends A000578 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z t = super.next().multiply(10);
    long lim = 10;
    long v = -1;
    while (true) {
      v += 2;
      if (v >= lim) {
        lim *= 10;
        t = t.multiply(10);
        //v = 1; // to allow for leading 0s in what is appended
      }
      if (v % 5 != 0) {
        final Z u = t.add(v);
        if (u.isProbablePrime()) {
          return u;
        }
      }
    }
  }
}

#!queue	A030693	0	->	1	A000578	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A030693 Smallest nontrivial extension of n-th cube which is a square.
 * @author Sean A. Irvine
 */
public class A030693 extends A000578 {

  private static final long[] STEPS = {1, 1, 3, 1, 1, 3};
  {
    super.next();
  }

  @Override
  public Z next() {
    Z t = super.next().multiply(10);
    long lim = 10;
    long v = -1;
    int s = -1;
    while (true) {
      if (++s == STEPS.length) {
        s = 0;
      }
      v += STEPS[s];
      if (v >= lim) {
        lim *= 10;
        t = t.multiply(10);
        v = 0; // to allow for leading 0s in what is appended
        s = 0;
      }
      final Z u = t.add(v);
      if (u.isSquare()) {
        return u;
      }
    }
  }
}

#!queue	A030694	0	->	1	A030693	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030694 Square root of A030693.
 * @author Sean A. Irvine
 */
public class A030694 extends A030693 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}

#!queue	A030695	0	->	1	A000578	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A030695 Smallest nontrivial extension of n-th cube which is a cube.
 * @author Sean A. Irvine
 */
public class A030695 extends A000578 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z t = super.next().multiply(10);
    long lim = 10;
    long v = -1;
    while (true) {
      if (++v >= lim) {
        lim *= 10;
        t = t.multiply(10);
        v = 0; // to allow for leading 0s in what is appended
      }
      final Z u = t.add(v);
      if (ZUtils.isCube(u)) {
        return u;
      }
    }
  }
}

#!queue	A030696	0	->	1	A030695	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030696 Cube root of A030695.
 * @author Sean A. Irvine
 */
public class A030696 extends A030695 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}

#!queue	A030697	0	->	1	A000578	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A030697 Smallest nontrivial extension of n-th cube which is a cube not ending 000.
 * @author Sean A. Irvine
 */
public class A030697 extends A000578 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z t = super.next().multiply(10);
    long lim = 10;
    long v = 0;
    while (true) {
      if (++v >= lim) {
        lim *= 10;
        t = t.multiply(10);
        v = 1; // to allow for leading 0s in what is appended
      }
      final Z u = t.add(v);
      if (ZUtils.isCube(u)) {
        return u;
      }
    }
  }
}

#!queue	A030698	0	->	1	A030697	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030698 Cube root of A030697.
 * @author Sean A. Irvine
 */
public class A030698 extends A030697 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}

#!queue	A030979	0	->	1	A000984	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A030979 Numbers k such that binomial(2k,k) is not divisible by 3, 5 or 7.
 * @author Sean A. Irvine
 */
public class A030979 extends A000984 {

  @Override
  public Z next() {
    Z t;
    do {
      t = super.next();
    } while (t.mod(3) == 0 || t.mod(5) == 0 || t.mod(7) == 0);
    return Z.valueOf(mN);
  }
}
#!queue	A030999	0	->	1	A030998	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;

/**
 * A030999 Position of n-th 0 in A030998.
 * @author Sean A. Irvine
 */
public class A030999 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031000	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031000 Position of n-th 1 in A030998.
 * @author Sean A. Irvine
 */
public class A031000 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031001	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031001 Position of n-th 2 in A030998.
 * @author Sean A. Irvine
 */
public class A031001 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031002	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031002 Position of n-th 3 in A030998.
 * @author Sean A. Irvine
 */
public class A031002 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031003	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031003 Position of n-th 4 in A030998.
 * @author Sean A. Irvine
 */
public class A031003 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031004	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031004 Position of n-th 5 in A030998.
 * @author Sean A. Irvine
 */
public class A031004 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031005	0	->	1	A030998	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030998;

/**
 * A031005 Position of n-th 6 in A030998.
 * @author Sean A. Irvine
 */
public class A031005 extends A030998 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031008	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031008 Position of n-th 0 in A031007.
 * @author Sean A. Irvine
 */
public class A031008 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031009	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031009 Position of n-th 1 in A031007.
 * @author Sean A. Irvine
 */
public class A031009 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031010	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031010 Position of n-th 2 in A031007.
 * @author Sean A. Irvine
 */
public class A031010 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031011	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031011 Position of n-th 3 in A031007.
 * @author Sean A. Irvine
 */
public class A031011 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031012	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031012 Position of n-th 4 in A031007.
 * @author Sean A. Irvine
 */
public class A031012 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031013	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031013 Position of n-th 5 in A031007.
 * @author Sean A. Irvine
 */
public class A031013 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031014	0	->	1	A031007	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031014 Position of n-th 6 in A031007.
 * @author Sean A. Irvine
 */
public class A031014 extends A031007 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031046	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031046 Position of n-th 0 in A031045.
 * @author Sean A. Irvine
 */
public class A031046 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031047	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031047 Position of n-th 1 in A031045.
 * @author Sean A. Irvine
 */
public class A031047 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031048	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031048 Position of n-th 2 in A031045.
 * @author Sean A. Irvine
 */
public class A031048 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031049	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031049 Position of n-th 3 in A031045.
 * @author Sean A. Irvine
 */
public class A031049 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031050	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031050 Position of n-th 4 in A031045.
 * @author Sean A. Irvine
 */
public class A031050 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031051	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031051 Position of n-th 5 in A031045.
 * @author Sean A. Irvine
 */
public class A031051 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031052	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031052 Position of n-th 6 in A031045.
 * @author Sean A. Irvine
 */
public class A031052 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031053	0	->	1	A031045	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031053 Position of n-th 7 in A031045.
 * @author Sean A. Irvine
 */
public class A031053 extends A031045 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SEVEN.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031088	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031088 Position of n-th 0 in A031087.
 * @author Sean A. Irvine
 */
public class A031088 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031089	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031089 Position of n-th 1 in A031087.
 * @author Sean A. Irvine
 */
public class A031089 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031090	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031090 Position of n-th 2 in A031087.
 * @author Sean A. Irvine
 */
public class A031090 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031091	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031091 Position of n-th 3 in A031087.
 * @author Sean A. Irvine
 */
public class A031091 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031092	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031092 Position of n-th 4 in A031087.
 * @author Sean A. Irvine
 */
public class A031092 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031093	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031093 Position of n-th 5 in A031087.
 * @author Sean A. Irvine
 */
public class A031093 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031094	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031094 Position of n-th 6 in A031087.
 * @author Sean A. Irvine
 */
public class A031094 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031095	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031095 Position of n-th 7 in A031087.
 * @author Sean A. Irvine
 */
public class A031095 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SEVEN.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031096	0	->	1	A031087	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031096 Position of n-th 8 in A031087.
 * @author Sean A. Irvine
 */
public class A031096 extends A031087 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.EIGHT.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031179	0	->	1	A031178	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031179 Numbers having period-1 3-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031179 extends A031178 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031180	0	->	1	A031178	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031180 Numbers having period-2 3-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031180 extends A031178 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031181	0	->	1	A031178	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031181 Numbers having period-3 3-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031181 extends A031178 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031183	0	->	1	A031182	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031183 Numbers having period-1 4-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031183 extends A031182 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031184	0	->	1	A031182	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031184 Numbers having period-2 4-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031184 extends A031182 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031185	0	->	1	A031182	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031185 Numbers having period-7 4-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031185 extends A031182 {

  @Override
  public Z next() {
    while (!Z.SEVEN.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031187	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031187 Numbers having period-1 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031187 extends A031186 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031188	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031188 Numbers having period-2 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031188 extends A031186 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031189	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031189 Numbers having period-4 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031189 extends A031186 {

  @Override
  public Z next() {
    while (!Z.FOUR.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031190	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031190 Numbers having period-6 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031190 extends A031186 {

  @Override
  public Z next() {
    while (!Z.SIX.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031191	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031191 Numbers having period-10 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031191 extends A031186 {

  @Override
  public Z next() {
    while (!Z.TEN.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031192	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031192 Numbers having period-12 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031192 extends A031186 {

  private static final Z Z12 = Z.valueOf(12);

  @Override
  public Z next() {
    while (!Z12.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031193	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031193 Numbers having period-22 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031193 extends A031186 {

  private static final Z Z22 = Z.valueOf(22);

  @Override
  public Z next() {
    while (!Z22.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031194	0	->	1	A031186	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031194 Numbers having period-28 5-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031194 extends A031186 {

  private static final Z Z28 = Z.valueOf(28);

  @Override
  public Z next() {
    while (!Z28.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031196	0	->	1	A031195	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031196 Numbers having period-3 6-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031196 extends A031195 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031197	0	->	1	A031195	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031197 Numbers having period-4 6-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031197 extends A031195 {

  @Override
  public Z next() {
    while (!Z.FOUR.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031198	0	->	1	A031195	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031198 Numbers having period-10 6-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031198 extends A031195 {

  @Override
  public Z next() {
    while (!Z.TEN.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031199	0	->	1	A031195	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031199 Numbers having period-30 6-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031199 extends A031195 {

  private static final Z Z30 = Z.valueOf(30);

  @Override
  public Z next() {
    while (!Z30.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031201	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031201 Numbers having period-1 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031201 extends A031200 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031202	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031202 Numbers having period-2 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031202 extends A031200 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031203	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031203 Numbers having period-3 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031203 extends A031200 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031204	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031204 Numbers having period-12 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031204 extends A031200 {

  private static final Z Z12 = Z.valueOf(12);

  @Override
  public Z next() {
    while (!Z12.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031205	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031205 Numbers having period-14 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031205 extends A031200 {

  private static final Z Z14 = Z.valueOf(14);

  @Override
  public Z next() {
    while (!Z14.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031206	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031206 Numbers having period-21 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031206 extends A031200 {

  private static final Z Z21 = Z.valueOf(21);

  @Override
  public Z next() {
    while (!Z21.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031207	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031207 Numbers having period-27 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031207 extends A031200 {

  private static final Z Z27 = Z.valueOf(27);

  @Override
  public Z next() {
    while (!Z27.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031208	0	->	1	A031200	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031208 Numbers having period-30 7-digitized sequences.
 * @author Sean A. Irvine
 */
public class A031208 extends A031200 {

  private static final Z Z30 = Z.valueOf(30);

  @Override
  public Z next() {
    while (!Z30.equals(super.next())) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A031236	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031236 Position of n-th 0 in A031235.
 * @author Sean A. Irvine
 */
public class A031236 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031237	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031237 Position of n-th 1 in A031235.
 * @author Sean A. Irvine
 */
public class A031237 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031238	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031238 Position of n-th 2 in A031235.
 * @author Sean A. Irvine
 */
public class A031238 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031239	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031239 Position of n-th 3 in A031235.
 * @author Sean A. Irvine
 */
public class A031239 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031240	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031240 Position of n-th 4 in A031235.
 * @author Sean A. Irvine
 */
public class A031240 extends A031235 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031242	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031242 Length of n-th run of digit 0 in A031235.
 * @author Sean A. Irvine
 */
public class A031242 extends A031235 {

  @Override
  public Z next() {
    while (!super.next().isZero()) {
      // do nothing
    }
    long cnt = 1;
    while (super.next().isZero()) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031243	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031243 Length of n-th run of digit 1 in A031235.
 * @author Sean A. Irvine
 */
public class A031243 extends A031235 {

  @Override
  public Z next() {
    while (!Z.ONE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.ONE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031244	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031244 Length of n-th run of digit 2 in A031235.
 * @author Sean A. Irvine
 */
public class A031244 extends A031235 {

  @Override
  public Z next() {
    while (!Z.TWO.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.TWO.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031245	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031245 Length of n-th run of digit 3 in A031235.
 * @author Sean A. Irvine
 */
public class A031245 extends A031235 {

  @Override
  public Z next() {
    while (!Z.THREE.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.THREE.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031246	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031246 Length of n-th run of digit 4 in A031235.
 * @author Sean A. Irvine
 */
public class A031246 extends A031235 {

  @Override
  public Z next() {
    while (!Z.FOUR.equals(super.next())) {
      // do nothing
    }
    long cnt = 1;
    while (Z.FOUR.equals(super.next())) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A031247	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031247 a(n)=(# 1's)-(# 0's) in first n terms of A031235.
 * @author Sean A. Irvine
 */
public class A031247 extends A031235 {

  {
    super.next();
  }

  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 0) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A031248	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031248 a(n)=(# 1's)-(# 2's) in first n terms of A031235.
 * @author Sean A. Irvine
 */
public class A031248 extends A031235 {

  {
    super.next();
  }

  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 1) {
      mSum = mSum.add(1);
    } else if (t == 2) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A031249	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031249 a(n)=(# 2's)-(# 3's) in first n terms of A031235.
 * @author Sean A. Irvine
 */
public class A031249 extends A031235 {

  {
    super.next();
  }

  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 2) {
      mSum = mSum.add(1);
    } else if (t == 3) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A031250	0	->	1	A031235	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031250 (# 3's)-(# 4's) in first n terms of A031235.
 * @author Sean A. Irvine
 */
public class A031250 extends A031235 {

  {
    super.next();
  }

  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    final int t = super.next().intValue();
    if (t == 3) {
      mSum = mSum.add(1);
    } else if (t == 4) {
      mSum = mSum.subtract(1);
    }
    return mSum;
  }
}

#!queue	A031287	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031287 Position of n-th 0 in A007376.
 * @author Sean A. Irvine
 */
public class A031287 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031288	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031288 Position of n-th 1 in A007376.
 * @author Sean A. Irvine
 */
public class A031288 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031289	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031289 Position of n-th 2 in A007376.
 * @author Sean A. Irvine
 */
public class A031289 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031290	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031290 Position of n-th 3 in A007376.
 * @author Sean A. Irvine
 */
public class A031290 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031291	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031291 Position of n-th 4 in A007376.
 * @author Sean A. Irvine
 */
public class A031291 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031292	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031292 Position of n-th 5 in A007376.
 * @author Sean A. Irvine
 */
public class A031292 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031293	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031293 Position of n-th 6 in A007376.
 * @author Sean A. Irvine
 */
public class A031293 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031294	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031294 Position of n-th 7 in A007376.
 * @author Sean A. Irvine
 */
public class A031294 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SEVEN.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031295	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031295 Position of n-th 8 in A007376.
 * @author Sean A. Irvine
 */
public class A031295 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.EIGHT.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031296	0	->	1	A007376	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A031296 Position of n-th 9 in A007376.
 * @author Sean A. Irvine
 */
public class A031296 extends A007376 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.NINE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031299	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031299 Position of n-th 0 in A031298.
 * @author Sean A. Irvine
 */
public class A031299 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031300	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031300 Position of n-th 1 in A031298.
 * @author Sean A. Irvine
 */
public class A031300 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031301	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031301 Position of n-th 2 in A031298.
 * @author Sean A. Irvine
 */
public class A031301 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.TWO.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031302	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031302 Position of n-th 3 in A031298.
 * @author Sean A. Irvine
 */
public class A031302 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.THREE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031303	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031303 Position of n-th 4 in A031298.
 * @author Sean A. Irvine
 */
public class A031303 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FOUR.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031304	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031304 Position of n-th 5 in A031298.
 * @author Sean A. Irvine
 */
public class A031304 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.FIVE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031305	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031305 Position of n-th 6 in A031298.
 * @author Sean A. Irvine
 */
public class A031305 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031306	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031306 Position of n-th 7 in A031298.
 * @author Sean A. Irvine
 */
public class A031306 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SEVEN.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031307	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031307 Position of n-th 8 in A031298.
 * @author Sean A. Irvine
 */
public class A031307 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.EIGHT.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031308	0	->	1	A031298	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031308 Position of n-th 9 in A031298.
 * @author Sean A. Irvine
 */
public class A031308 extends A031298 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.NINE.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A031502	8	->	10	A030069	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030069;

/**
 * A031502 Size of lexicographic code of length n, Hamming distance 10 and weight 10.
 * @author Sean A. Irvine
 */
public class A031502 extends A030069 {

  private int mN = 9;

  @Override
  public Z next() {
    if (++mN > 63) {
      throw new UnsupportedOperationException();
    }
    return Z.valueOf(buildLexicographicCode(mN, 10, 10).size());
  }
}
#!queue	A031503	8	->	12	A030069	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030069;

/**
 * A031503 Size of lexicographic code of length n, Hamming distance 12 and weight 12.
 * @author Sean A. Irvine
 */
public class A031503 extends A030069 {

  private int mN = 11;

  @Override
  public Z next() {
    if (++mN > 63) {
      throw new UnsupportedOperationException();
    }
    return Z.valueOf(buildLexicographicCode(mN, 12, 12).size());
  }
}
#!queue	A031504	8	->	6	A030069	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a030.A030069;

/**
 * A031504 Size of lexicographic code of length n, Hamming distance 6 and weight 6.
 * @author Sean A. Irvine
 */
public class A031504 extends A030069 {

  private int mN = 5;

  @Override
  public Z next() {
    if (++mN > 63) {
      throw new UnsupportedOperationException();
    }
    return Z.valueOf(buildLexicographicCode(mN, 6, 6).size());
  }
}
#!queue	A031876	1	->	0	A031424	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;

/**
 * A031876 a(n) = Sum_{k=0..n} floor(k^(1/3)).
 * @author Sean A. Irvine
 */
public class A031876 extends A031424 {

  private Z mA = Z.ZERO;
  private Z mB = Z.ONE;
  private long mN = -1;
  private long mM = 2;
  private long mCube = 8;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    if (mN > 1) {
      Z t = mB.multiply2().subtract(mA);
      if (mN == mCube) {
        mCube = ++mM * mM * mM;
        t = t.add(1);
      }
      mA = mB;
      mB = t;
    }
    return mB;
  }
}
#!queue	A031877	0	->	1	A004086	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.a004.A004086;

/**
 * A031877 Nontrivial reversal numbers (numbers which are integer multiples of their reversals), excluding palindromic numbers and multiples of 10.
 * @author Sean A. Irvine
 */
public class A031877 extends A004086 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (mN % 10 != 0) {
        final Z n = Z.valueOf(mN);
        if (n.compareTo(t) > 0 && n.mod(t).isZero()) {
          return n;
        }
      }
    }
  }
}
#!queue	A032037	0	->	1	A001003	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a001.A001003;

/**
 * A032037 Doubles (index 2+) under "AIJ" (ordered, indistinct, labeled) transform.
 * @author Sean A. Irvine
 */
public class A032037 extends A001003 {

  private int mN = 0;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    return super.next().multiply(mF);
  }
}
#!queue	A032112	0	->	1	A006155	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a006.A006155;

/**
 * A032112 "BIJ" (reversible, indistinct, labeled) transform of 2,1,1,1...
 * @author Sean A. Irvine
 */
public class A032112 extends A006155 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().add(2).divide2();
  }
}
#!queue	A032165	0	->	1	A001692	--------------------------------
package irvine.oeis.a032;

import irvine.oeis.a001.A001692;

/**
 * A032165 Number of aperiodic necklaces of n beads of 10 colors.
 * @author Sean A. Irvine
 */
public class A032165 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 10;
  }
}
#!queue	A032166	0	->	1	A001692	--------------------------------
package irvine.oeis.a032;

import irvine.oeis.a001.A001692;

/**
 * A032166 Number of aperiodic necklaces of n beads of 11 colors.
 * @author Sean A. Irvine
 */
public class A032166 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 11;
  }
}
#!queue	A032167	0	->	1	A001692	--------------------------------
package irvine.oeis.a032;

import irvine.oeis.a001.A001692;

/**
 * A032167 Number of aperiodic necklaces of n beads of 12 colors.
 * @author Sean A. Irvine
 */
public class A032167 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 12;
  }
}
#!queue	A032321	0	->	1	A001037	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a001.A001037;

/**
 * A032321 Number of aperiodic necklaces with n labeled beads of 2 colors.
 * @author Sean A. Irvine
 */
public class A032321 extends A001037 {

  private long mN = 0;
  private Z mF = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return super.next().multiply(mF);
  }
}
#!queue	A032322	0	->	1	A027376	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a027.A027376;

/**
 * A032322 Number of aperiodic necklaces with n labeled beads of 3 colors.
 * @author Sean A. Irvine
 */
public class A032322 extends A027376 {

  private long mN = 0;
  private Z mF = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return super.next().multiply(mF);
  }
}
#!queue	A032323	0	->	1	A027377	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a027.A027377;

/**
 * A032323 Number of aperiodic necklaces with n labeled beads of 4 colors.
 * @author Sean A. Irvine
 */
public class A032323 extends A027377 {

  private long mN = 0;
  private Z mF = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return super.next().multiply(mF);
  }
}
#!queue	A032324	0	->	1	A001692	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a001.A001692;

/**
 * A032324 Number of aperiodic necklaces with n labeled beads of 5 colors.
 * @author Sean A. Irvine
 */
public class A032324 extends A001692 {

  private long mN = 0;
  private Z mF = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return super.next().multiply(mF);
  }
}
#!queue	A032348	5	->	0	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032348 Coefficients of Jacobi function c(3,m).
 * @author Sean A. Irvine
 */
public class A032348 extends A032428 {

  @Override
  protected int j() {
    return 3;
  }
}
#!queue	A032358	1	->	2	A003434	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a003.A003434;

/**
 * A032358 Number of iterations of phi(n) needed to reach 2.
 * @author Sean A. Irvine
 */
public class A032358 extends A003434 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A032427	5	->	0	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032427 Coefficients of Jacobi elliptic function c(4,m).
 * @author Sean A. Irvine
 */
public class A032427 extends A032428 {

  @Override
  protected int j() {
    return 4;
  }
}
#!queue	A032429	5	->	6	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032429 Coefficients of Jacobi elliptic function c(6,m).
 * @author Sean A. Irvine
 */
public class A032429 extends A032428 {

  @Override
  protected int j() {
    return 6;
  }
}
#!queue	A032430	5	->	7	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032430 Coefficients of Jacobi elliptic function c(7,m).
 * @author Sean A. Irvine
 */
public class A032430 extends A032428 {

  @Override
  protected int j() {
    return 7;
  }
}
#!queue	A032431	5	->	8	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032431 Coefficients of Jacobi elliptic function c(8,m).
 * @author Sean A. Irvine
 */
public class A032431 extends A032428 {

  @Override
  protected int j() {
    return 8;
  }
}
#!queue	A032432	5	->	9	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032432 Coefficients of Jacobi elliptic function c(9,m).
 * @author Sean A. Irvine
 */
public class A032432 extends A032428 {

  @Override
  protected int j() {
    return 9;
  }
}
#!queue	A032433	5	->	10	A032428	--------------------------------
package irvine.oeis.a032;

/**
 * A032433 Coefficients of Jacobi elliptic function c(10,m).
 * @author Sean A. Irvine
 */
public class A032433 extends A032428 {

  @Override
  protected int j() {
    return 10;
  }
}
#!queue	A032522	0	->	1	A000170	--------------------------------
package irvine.oeis.a032;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a000.A000170;

/**
 * A032522 Number of point symmetric solutions to non-attacking queens problem on n X n board.
 * @author Sean A. Irvine
 */
public class A032522 extends A000170 {

  {
    next();
  }

  private int[] rotate180(final int[] q) {
    final int n = q.length;
    final int[] r = new int[n];
    for (int x = 0; x < n; ++x) {
      r[n - x  - 1] = n - q[x] - 1;
    }
    return r;
  }

  @Override
  protected Z count(final int[] q) {
    final int[] q1 = rotate180(q);
    return Arrays.equals(q, q1) ? Z.ONE : Z.ZERO;
  }
}
#!queue	A032599	1	->	0	A000959	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.a000.A000959;

/**
 * A032599 Cubes of lucky numbers.
 * @author Sean A. Irvine
 */
public class A032599 extends A000959 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A032736	1	->	0	A032734	--------------------------------
package irvine.oeis.a032;

/**
 * A032736 a(n) cannot be prefixed or followed by any digit to form a prime ('empty' prefixes allowed).
 * @author Sean A. Irvine
 */
public class A032736 extends A032734 {

  private static final String[] PREFIXES = {"", "1", "2", "3", "4", "5", "6", "7", "8", "9"};

  @Override
  protected String[] prefixes() {
    return PREFIXES;
  }
}
#!queue	A032737	1	->	0	A032734	--------------------------------
package irvine.oeis.a032;

/**
 * A032737 a(n) cannot be prefixed or followed by any digit to form a prime ('empty' suffixes are allowed).
 * @author Sean A. Irvine
 */
public class A032737 extends A032734 {

  private static final String[] SUFFIXES = {"", "1", "3", "7", "9"};

  @Override
  protected String[] suffixes() {
    return SUFFIXES;
  }
}
#!queue	A032738	1	->	0	A032736	--------------------------------
package irvine.oeis.a032;

/**
 * A032738 a(n) cannot be prefixed or followed by any digit to form a prime ('empty' prefixes and suffixes are allowed).
 * @author Sean A. Irvine
 */
public class A032738 extends A032736 {

  private static final String[] SUFFIXES = {"", "1", "3", "7", "9"};

  @Override
  protected String[] suffixes() {
    return SUFFIXES;
  }
}
#!queue	A033148	0	->	1	A000170	--------------------------------
package irvine.oeis.a033;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a000.A000170;

/**
 * A033148 Number of rotationally symmetric solutions for queens on n X n board.
 * @author Sean A. Irvine
 */
public class A033148 extends A000170 {

  private int mN = 0;

  private int[] rotate90(final int[] q) {
    final int n = q.length;
    final int[] r = new int[n];
    for (int x = 0; x < n; ++x) {
      r[q[x]] = n - x - 1;
    }
    return r;
  }

  @Override
  protected Z count(final int[] q) {
    final int[] q1 = rotate90(q);
    return Arrays.equals(q, q1) ? Z.ONE : Z.ZERO;
  }

  @Override
  public Z next() {
    final long r = ++mN & 3;
    return r > 1 ? Z.ZERO : count(new int[mN], 0);
  }
}
#!queue	A033264	0	->	1	A005811	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.oeis.a005.A005811;

/**
 * A033264 Number of blocks of {1,0} in the binary expansion of n.
 * @author Sean A. Irvine
 */
public class A033264 extends A005811 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    final Z a = super.next();
    return a.subtract(a.add(1).divide2());
  }
}

#!queue	A033292	0	->	1	A143689	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.oeis.a143.A143689;

/**
 * A033292 A Connell-like sequence: take 1 number = 1 (mod Q), 2 numbers = 2 (mod Q), 3 numbers = 3 (mod Q), etc., where Q = 3.
 * @author Sean A. Irvine
 */
public class A033292 extends A143689 {

  private long mN = 0;
  private long mM = 0;
  private Z mT = null;

  @Override
  public Z next() {
    if (--mM < 0) {
      mM = mN++;
      mT = super.next();
    } else {
      mT = mT.add(3);
    }
    return mT;
  }
}

#!queue	A033293	0	->	1	A054552	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.oeis.a054.A054552;

/**
 * A033293 A Connell-like sequence: take 1 number = 1 (mod Q), 2 numbers = 2 (mod Q), 3 numbers = 3 (mod Q), etc., where Q = 8.
 * @author Sean A. Irvine
 */
public class A033293 extends A054552 {

  private long mN = 0;
  private long mM = 0;
  private Z mT = null;

  @Override
  public Z next() {
    if (--mM < 0) {
      mM = mN++;
      mT = super.next();
    } else {
      mT = mT.add(8);
    }
    return mT;
  }
}

#!queue	A033314	1	->	2	A000037	--------------------------------
package irvine.oeis.a033;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a000.A000037;
import irvine.util.array.LongDynamicLongArray;

/**
 * A033314 Least D in the Pellian x^2 - D*y^2 = 1 for which x has least solution n.
 * @author Sean A. Irvine
 */
public class A033314 extends A000037 {

  private static final long LIMIT = 10000000; // Stops very large results from being stored
  private static final Z Z_LIMIT = Z.valueOf(LIMIT);
  private final LongDynamicLongArray mA = new LongDynamicLongArray();
  private long mN = 1;

  @Override
  public Z next() {
    if (++mN >= LIMIT) {
      throw new UnsupportedOperationException();
    }
    while (mA.get(mN) == 0) {
      final Z d = super.next();
      final Q conv = A033313.solvePell(d);
      if (conv.num().compareTo(Z_LIMIT) < 0) {
        final long x = conv.num().longValueExact();
        if (mA.get(x) == 0) {
          mA.set(x, d.longValueExact());
        }
      }
    }
    return Z.valueOf(mA.get(mN));
  }
}

#!queue	A033618	0	->	2	A010785	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A033618 Number of ways n-th repdigit number, A010785(n), can be expressed as a polygonal number.
 * @author Sean A. Irvine
 */
public class A033618 extends A010785 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z r = super.next();
    if (Z.TWO.equals(r)) {
      return Z.TWO; // Not sure why this special case needed
    }
    final Z t = r.multiply2();
    long c = 0;
    for (final Z n : Jaguar.factor(t).divisors()) {
      if (!Z.ONE.equals(n)) {
        final Z q = t.divide(n);
        final Z n1 = n.subtract(1);
        if (q.mod(n1).equals(Z.TWO.mod(n1))) {
          ++c;
        }
      }
    }
    return Z.valueOf(c);
  }
}
#!queue	A033700	0	->	5	A002851	--------------------------------
package irvine.oeis.a033;

import irvine.math.graph.Graph;
import irvine.math.graph.GraphUtils;
import irvine.oeis.a002.A002851;

/**
 * A033700 Number of connected transitive 4-valent (or quartic) graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A033700 extends A002851 {

  {
    for (int k = 0; k <= degree(); ++k) {
      next();
    }
  }

  @Override
  protected long getCount(final Graph graph) {
    return GraphUtils.isTransitive(graph) ? 1 : 0;
  }

  @Override
  protected int degree() {
    return 4;
  }
}
#!queue	A033702	0	->	1	A010785	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A033702 Number of polygonal numbers which are n-digit repdigits.
 * @author Sean A. Irvine
 */
public class A033702 extends A010785 {

  {
    super.next();
  }

  @Override
  public Z next() {
    long c = 0;
    for (int k = 1; k < 10; ++k) {
      final Z r = super.next();
      if (!Z.ONE.equals(r)) {
        final Z t = r.multiply2();
        for (final Z n : Jaguar.factor(t).divisors()) {
          if (!Z.ONE.equals(n)) {
            final Z q = t.divide(n);
            final Z n1 = n.subtract(1);
            if (q.mod(n1).equals(Z.TWO.mod(n1))) {
              ++c;
            }
          }
        }
      }
    }
    return Z.valueOf(c);
  }
}
#!queue	A033867	0	->	1	A033866	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A033867 Palindrome reached from A033866(n) by Reverse-then-add.
 * @author Sean A. Irvine
 */
public class A033867 extends A033866 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z s = super.next();
    for (int k = 0; k < mN; ++k) {
      s = s.add(ZUtils.reverse(s));
    }
    return s;
  }
}
#!queue	A033882	1	->	0	A033880	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;

/**
 * A033882 Abundancy of the abundant or perfect numbers: m = sigma(n)-2n for n such that m &gt;= 0.
 * @author Sean A. Irvine
 */
public class A033882 extends A033880 {

  @Override
  public Z next() {
    while (true) {
      final Z a = super.next();
      if (a.signum() >= 0) {
        return a;
      }
    }
  }
}
#!queue	A033883	1	->	0	A033879	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;

/**
 * A033883 Deficiency of the deficient or perfect numbers: m = 2n - sigma(n) for n such that m &gt;= 0.
 * @author Sean A. Irvine
 */
public class A033883 extends A033879 {

  @Override
  public Z next() {
    while (true) {
      final Z a = super.next();
      if (a.signum() >= 0) {
        return a;
      }
    }
  }
}
#!queue	A033952	0	->	1	A007376	--------------------------------
package irvine.oeis.a033;

import irvine.math.z.Z;
import irvine.oeis.a007.A007376;

/**
 * A033952 Write 1,2,... in a clockwise spiral on a square lattice, writing each digit at a separate lattice point, starting with 1 at the origin and 2 at x=0, y=-1; sequence gives the numbers on the positive x-axis.
 * @author Sean A. Irvine
 */
public class A033952 extends A007376 {

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    ++mN;
    final long t = 4 * mN * mN - 5 * mN + 2;
    while (mM < t) {
      super.next();
      ++mM;
    }
    ++mM;
    return super.next();
  }
}
#!queue	A034267	0	->	1	A034261	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;

/**
 * A034267 a(n)=f(n,n) where f is given in A034261.
 * @author Sean A. Irvine
 */
public class A034267 extends A034261 {

  private long mN = -1;

  @Override
  public Z next() {
    return f(++mN, mN);
  }
}

#!queue	A034274	0	->	1	A034261	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;

/**
 * A034274 a(n)=f(n,n-1) where f is given in A034261.
 * @author Sean A. Irvine
 */
public class A034274 extends A034261 {

  private long mN = 1;

  @Override
  public Z next() {
    return f(++mN, mN - 1);
  }
}

#!queue	A034275	0	->	1	A034261	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;

/**
 * A034275 a(n)=f(n,n-2) where f is given in A034261.
 * @author Sean A. Irvine
 */
public class A034275 extends A034261 {

  private long mN = 0;

  @Override
  public Z next() {
    return f(++mN, mN - 2);
  }
}

#!queue	A034404	0	->	1	A002311	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a002.A002311;

/**
 * A034404 Values of C(n,3) which can be written as C(x,3) + C(y,3).
 * @author Sean A. Irvine
 */
public class A034404 extends A002311 {

  @Override
  public Z next() {
    return Binomial.binomial(super.next().add(2), Z.THREE);
  }
}
#!queue	A034853	2	->	3	A034781	--------------------------------
package irvine.oeis.a034;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A034853 Triangle giving number of trees with n &gt;= 3 nodes and diameter d &gt;= 2.
 * @author Sean A. Irvine
 */
public class A034853 extends A034781 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = 2;
  private int mD = 2;

  private Polynomial<Z> r(final int diameter, final int n) {
    final Z[] r = new Z[n + 1];
    for (int k = 0; k < r.length; ++k) {
      r[k] = t(k, diameter);
    }
    return Polynomial.create(r);
  }

  private Z s(final int points, final int h) {
    if (points <= 1) {
      return Z.valueOf(points);
    }
    Z s = Z.ZERO;
    for (int k = 0; k <= h; ++k) {
      s = s.add(t(points, k));
    }
    return s;
  }

  private Polynomial<Z> sx(final int diameter, final int n) {
    final Z[] s = new Z[n + 1];
    for (int k = 0; k < s.length; ++k) {
      s[k] = s(k, diameter);
    }
    return Polynomial.create(s);
  }

  private Z d(final int points, final int diameter) {
    final int d = diameter / 2;
    if ((diameter & 1) == 0) {
      return RING.subtract(r(d, points), RING.multiply(r(d - 1, points), sx(d - 1, points), points)).coeff(points);
    } else {
      return RING.add(RING.pow(r(d, points), 2, points), r(d, points / 2).substitutePower(2, points)).coeff(points).divide2();
    }
  }

  @Override
  public Z next() {
    if (++mD >= mN) {
      ++mN;
      mD = 2;
    }
    return d(mN, mD);
  }
}
#!queue	A034854	2	->	0	A034855	--------------------------------
package irvine.oeis.a034;

import java.util.ArrayList;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A034854 Triangle giving number of labeled trees with n &gt;= 3 nodes and diameter d &gt;= 2.
 * @author Sean A. Irvine
 */
public class A034854 extends A034855 {

  private Polynomial<Q> r0(final int d, final int n) {
    if (d < 0) {
      return RING.zero();
    }
    final ArrayList<Q> coeff = new ArrayList<>();
    for (int k = 0; k <= n; ++k) {
      coeff.add(new Q(r(k, d), mF.factorial(k)));
    }
    return RING.create(coeff);
  }

  protected Z t(final int d, final int p) {
    final int dd = d / 2;
    if ((d & 1) == 0) {
      final Polynomial<Q> t0 = RING.subtract(r0(dd, p), RING.multiply(gf(dd - 1, p), r0(dd - 1, p), p));
      return t0.coeff(p).multiply(mF.factorial(p)).toZ();
    } else {
      final Polynomial<Q> t0 = RING.pow(r0(dd, p), 2, p);
      return t0.coeff(p).multiply(mF.factorial(p)).toZ().divide2();
    }
  }

  private int mP = 2;
  private int mD = 2;

  @Override
  public Z next() {
    if (++mD >= mP) {
      ++mP;
      mD = 2;
    }
    return t(mD, mP);
  }
}
#!queue	A034929	0	->	1	A091836	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;
import irvine.oeis.a091.A091836;

/**
 * A034929 A triangle of Motzkin ballot numbers, read by rows.
 * @author Sean A. Irvine
 */
public class A034929 extends A091836 {

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (--mM < 1) {
      mM = ++mN;
    }
    return t(mN, mM);
  }
}

#!queue	A034971	0	->	1	A000364	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A034971 a(n) = floor(E_(n+1)/E_(n)) where E_n is n-th Euler number (see A028296 and A000364).
 * @author Sean A. Irvine
 */
public class A034971 extends A000364 {

  {
    super.next();
  }
  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.divide(t);
  }
}
#!queue	A034973	0	->	1	A001405	--------------------------------
package irvine.oeis.a034;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A034973 Number of distinct prime factors in central binomial coefficients C(n, floor(n/2)), the terms of A001405.
 * @author Sean A. Irvine
 */
public class A034973 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).omega());
  }
}
#!queue	A034974	0	->	1	A001405	--------------------------------
package irvine.oeis.a034;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A034974 Number of divisors of binomial(n, floor(n/2)), the terms of A001405.
 * @author Sean A. Irvine
 */
public class A034974 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).sigma0();
  }
}
#!queue	A034980	1	->	0	A034982	--------------------------------
package irvine.oeis.a034;

import irvine.oeis.a020.A020802;
import irvine.oeis.a131.A131594;

/**
 * A034980 a(n)^2 is smallest positive square starting with a string of n 2's.
 * @author Sean A. Irvine
 */
public class A034980 extends A034982 {

  /** Construct the sequence. */
  public A034980() {
    // sqrt(45), sqrt(2)/3
    super(new A020802(), new A131594(), "2", null);
  }
}
#!queue	A035001	1	->	0	A035002	--------------------------------
package irvine.oeis.a035;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A035001 Sorted elements of table (A035002) of a(m,n) = sum(a(m-k,n), k=1..m-1)+sum(a(m,n-k), k=1..n-1).
 * @author Sean A. Irvine
 */
public class A035001 extends A035002 {

  private final TreeSet<Z> mA = new TreeSet<>();
  private int mN = 0;

  @Override
  public Z next() {
    while (mA.isEmpty() || mA.first().compareTo(get(mN, 1)) >= 0) {
      ++mN;
      for (int m = 1; m <= mN; ++m) {
        mA.add(get(mN - m + 1, m));
      }
    }
    return mA.pollFirst();
  }
}
#!queue	A035015	1	->	2	A003285	--------------------------------
package irvine.oeis.a035;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A035015 Period of continued fraction for square root of n-th squarefree integer.
 * @author Sean A. Irvine
 */
public class A035015 extends A003285 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (LongUtils.isSquareFree(mN) && !t.isZero()) {
        return t;
      }
    }
  }
}
#!queue	A035065	0	->	1	A034886	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a034.A034886;

/**
 * A035065 Numbers k such that k! has a prime number of digits.
 * @author Sean A. Irvine
 */
public class A035065 extends A034886 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().isProbablePrime()) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A035066	0	->	1	A034886	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a034.A034886;

/**
 * A035066 Prime lengths of factorials: see A035065.
 * @author Sean A. Irvine
 */
public class A035066 extends A034886 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A035067	0	->	1	A034886	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a034.A034886;
import irvine.util.string.StringUtils;

/**
 * A035067 n! has a palindromic prime number of digits.
 * @author Sean A. Irvine
 */
public class A035067 extends A034886 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z t = super.next();
      if (t.isProbablePrime() && StringUtils.isPalindrome(t.toString())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A035068	0	->	1	A035066	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.util.string.StringUtils;

/**
 * A035068 Palindromic prime lengths of factorials: see A035067.
 * @author Sean A. Irvine
 */
public class A035068 extends A035066 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (StringUtils.isPalindrome(t.toString())) {
        return t;
      }
    }
  }
}
#!queue	A035088	1	->	0	A035087	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035088 Number of labeled polygonal cacti (Husimi graphs) with n nodes.
 * @author Sean A. Irvine
 */
public class A035088 extends A035087 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().divide(Math.max(1, mN));
  }
}
#!queue	A035112	0	->	1	A000367	--------------------------------
package irvine.oeis.a035;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A035112 Smallest even index 2a such that n-th irregular prime p (A000928(n)) divides Bernoulli_{2a} with 0&lt;=2a&lt;=p-3.
 * @author Sean A. Irvine
 */
public class A035112 extends A000367 {

  private final ArrayList<Z> mB = new ArrayList<>();
  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      final long q = mP / 2;
      while (mB.size() < q) {
        mB.add(super.next());
      }
      for (int k = 1; k <= (mP - 3) / 2; ++k) {
        if (mB.get(k).mod(mP) == 0) {
          return Z.valueOf(2L * k);
        }
      }
    }
  }
}
#!queue	A035128	0	->	1	A035130	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035128 Rotating digits of a(n)^3 right once still yields a cube.
 * @author Sean A. Irvine
 */
public class A035128 extends A035130 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}
#!queue	A035129	0	->	1	A035131	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035129 Rotating digits of a(n)^3 left once still yields a cube.
 * @author Sean A. Irvine
 */
public class A035129 extends A035131 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}
#!queue	A035130	0	->	1	A000578	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A035130 Cubes when digits rotated right once remain cubic.
 * @author Sean A. Irvine
 */
public class A035130 extends A000578 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    while (true) {
      final Z s = super.next();
      final String t = s.toString();
      if (ZUtils.isCube(new Z(t.charAt(t.length() - 1) + t.substring(0, t.length() - 1)))) {
        return s;
      }
    }
  }
}
#!queue	A035131	0	->	1	A000578	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A035131 Cubes that when digits rotated left once remain cubic.
 * @author Sean A. Irvine
 */
public class A035131 extends A000578 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    while (true) {
      final Z s = super.next();
      final String t = s.toString();
      if ((t.length() == 1 || t.charAt(1) != '0') && ZUtils.isCube(new Z(t.substring(1) + t.charAt(0)))) {
        return s;
      }
    }
  }
}
#!queue	A035163	0	->	1	A000364	--------------------------------
package irvine.oeis.a035;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A035163 Composite numbers k, not a power of 2, such that the E(k) == 1 (mod k), where E(k) is the k-th Euler number (A000364).
 * @author Sean A. Irvine
 */
public class A035163 extends A000364 {

  {
    super.next(); // skip 0
  }
  private long mN = 0;
  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(++mN) == 1 && (mN & (mN - 1)) != 0 && !mPrime.isPrime(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A035314	0	->	-1	A013973	--------------------------------
package irvine.oeis.a035;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a013.A013973;

/**
 * A035314 Fourier coefficients of T_8.
 * @author Sean A. Irvine
 */
public class A035314 extends A013973 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final Polynomial<Z> mE3 = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mE3.add(super.next());
    return RING.coeff(mE3, RING.pow(RING.eta(RING.x(), mN), 24, mN), mN);
  }
}

#!queue	A035315	0	->	-1	A004009	--------------------------------
package irvine.oeis.a035;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a004.A004009;

/**
 * A035315 Fourier coefficients of T_{10}.
 * @author Sean A. Irvine
 */
public class A035315 extends A004009 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final Polynomial<Z> mE4 = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mE4.add(super.next());
    return RING.coeff(mE4, RING.pow(RING.eta(RING.x(), mN), 24, mN), mN);
  }
}

#!queue	A035330	1	->	0	A035324	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035330 5-fold convolution of A001700(n), n &gt;= 0.
 * @author Sean A. Irvine
 */
public class A035330 extends A035324 {

  private long mN = 4;

  @Override
  public Z next() {
    return get(++mN, 5L);
  }
}

#!queue	A035469	0	->	1	A007559	--------------------------------
package irvine.oeis.a035;

import java.util.ArrayList;
import java.util.List;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a007.A007559;
import irvine.oeis.transform.BellTransform;

/**
 * A035469 Triangle read by rows, the Bell transform of the triple factorial numbers A007559(n+1) without column 0.
 * @author Sean A. Irvine
 */
public class A035469 extends A007559 {

  private final List<Q> mA = new ArrayList<>();
  private BellTransform mBellTransform = null;
  private int mN = 0;
  private int mM = 0;
  {
    super.next();
    mA.add(Q.ZERO);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      mA.add(new Q(super.next()));
      ++mN;
      mM = 1;
      mBellTransform = new BellTransform(mA);
    }
    return mBellTransform.get(mN, mM).toZ();
  }
}

#!queue	A035487	0	->	1	A001966	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a001.A001966;

/**
 * A035487 Second column of Stolarsky array.
 * @author Sean A. Irvine
 */
public class A035487 extends A001966 {

  private long mN = -1;

  @Override
  public Z next() {
    return super.next().subtract(++mN);
  }
}

#!queue	A035491	0	->	1	A035485	--------------------------------
package irvine.oeis.a035;

import java.util.Iterator;

import irvine.math.z.Z;

/**
 * A035491 Relevant part of deck in Guy's shuffling problem (A035485): row n of the table lists the first 2n "cards" (numbers) after the n-th shuffle.
 * @author Sean A. Irvine
 */
public class A035491 extends A035485 {

  private int mN = 1;
  private Iterator<Long> mIterator = null;
  {
    super.next();
  }

  @Override
  public Z next() {
    if (++mN >= mDeck.size()) {
      super.next();
      mIterator = mDeck.iterator();
      mN = 2;
    }
    return Z.valueOf(mIterator.next());
  }
}

#!queue	A035493	0	->	1	A035485	--------------------------------
package irvine.oeis.a035;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A035493 Order in which new cards appear on top of deck in Guy's shuffling problem A035485.
 * @author Sean A. Irvine
 */
public class A035493 extends A035485 {

  private final TreeSet<Z> mSeen = new TreeSet<>();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (mSeen.add(t)) {
        return t;
      }
    }
  }
}

#!queue	A035496	0	->	1	A035485	--------------------------------
package irvine.oeis.a035;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A035496 Numbers of the form x*y^2 + y*z^2 + z*x^2, x,y,z &gt;= 1.
 * @author Sean A. Irvine
 */
public class A035496 extends A035485 {

  private final TreeSet<Z> mA = new TreeSet<>();
  private long mX = 1;

  @Override
  public Z next() {
    if (mA.isEmpty() || mA.first().compareTo(Z.valueOf(mX * mX + mX)) > 0) {
      for (long y = 1; y <= mX; ++y) {
        for (long z = 1; z <= mX; ++z) {
          mA.add(Z.valueOf(mX * y * y + y * z * z + z * mX * mX));
        }
      }
      ++mX;
    }
    return mA.pollFirst();
  }
}

#!queue	A035500	0	->	1	A035485	--------------------------------
package irvine.oeis.a035;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A035500 Shuffles at which new cards appear on top of deck in Guy's shuffling problem A035485.
 * @author Sean A. Irvine
 */
public class A035500 extends A035485 {

  private final TreeSet<Z> mSeen = new TreeSet<>();
  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z t = super.next();
      if (mSeen.add(t)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A035522	1	->	0	A035342	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035522 Reverse and add (in binary) - written in base 10.
 * @author Sean A. Irvine
 */
public class A035522 extends A035342 {

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.add(new Z(new StringBuilder(mN.toString(2)).reverse(), 2));
    return mN;
  }
}

#!queue	A035523	1	->	0	A035342	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035523 Reverse and add (in base 3).
 * @author Sean A. Irvine
 */
public class A035523 extends A035342 {

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.add(new Z(new StringBuilder(mN.toString(3)).reverse(), 3));
    return mN;
  }
}

#!queue	A035524	1	->	0	A035342	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035524 Reverse and add (in base 4).
 * @author Sean A. Irvine
 */
public class A035524 extends A035342 {

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.add(new Z(new StringBuilder(mN.toString(4)).reverse(), 4));
    return mN;
  }
}

#!queue	A035526	1	->	0	A035342	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;

/**
 * A035526 Reverse and add (in binary).
 * @author Sean A. Irvine
 */
public class A035526 extends A035342 {

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.add(new Z(new StringBuilder(mN.toString(2)).reverse(), 2));
    return new Z(mN.toString(2));
  }
}

#!queue	A035928	0	->	1	A036044	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.a036.A036044;

/**
 * A035928 Numbers n such that BCR(n) = n, where BCR = binary-complement-and-reverse = take one's complement then reverse bit order.
 * @author Sean A. Irvine
 */
public class A035928 extends A036044 {

  @Override
  public Z next() {
    while (true) {
      final long v = super.next().longValueExact();
      if (v == mN) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A036047	0	->	1	A036046	--------------------------------
package irvine.oeis.a036;

import java.util.List;

import irvine.math.z.Z;

/**
 * A036047 Product of order of cycles of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036047 extends A036046 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    Z res = Z.ONE;
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        res = res.multiply(c);
      }
    }
    return res;
  }
}
#!queue	A036048	0	->	1	A036046	--------------------------------
package irvine.oeis.a036;

import java.util.List;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A036048 Number of different cycle lengths of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036048 extends A036046 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    return Z.valueOf(set.size());
  }
}
#!queue	A036049	0	->	1	A036046	--------------------------------
package irvine.oeis.a036;

import java.util.List;

import irvine.math.z.Z;

/**
 * A036049 Number of cycles of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036049 extends A036046 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    int cycles = 0;
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        ++cycles;
      }
    }
    return Z.valueOf(cycles);
  }
}
#!queue	A036050	0	->	1	A036046	--------------------------------
package irvine.oeis.a036;

import java.util.List;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A036050 Sum of the lengths of the cycle types of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036050 extends A036046 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    Z sum = Z.ZERO;
    for (final int s : set) {
      sum = sum.add(s);
    }
    return sum;
  }
}
#!queue	A036053	0	->	1	A036052	--------------------------------
package irvine.oeis.a036;

import java.util.List;

import irvine.math.z.Z;

/**
 * A036053 Product of order of cycles of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036053 extends A036052 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    Z res = Z.ONE;
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        res = res.multiply(c);
      }
    }
    return res;
  }
}
#!queue	A036054	0	->	1	A036052	--------------------------------
package irvine.oeis.a036;

import java.util.List;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A036054 Number of different cycle lengths of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036054 extends A036052 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    return Z.valueOf(set.size());
  }
}
#!queue	A036055	0	->	1	A036052	--------------------------------
package irvine.oeis.a036;

import java.util.List;

import irvine.math.z.Z;

/**
 * A036055 Number of cycles of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036055 extends A036052 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    int cycles = 0;
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        ++cycles;
      }
    }
    return Z.valueOf(cycles);
  }
}
#!queue	A036056	0	->	1	A036052	--------------------------------
package irvine.oeis.a036;

import java.util.List;
import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A036056 Sum of the lengths of the cycle types of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036056 extends A036052 {

  {
    super.next();
  }

  @Override
  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    Z sum = Z.ZERO;
    for (final int s : set) {
      sum = sum.add(s);
    }
    return sum;
  }
}
#!queue	A036060	1	->	3	A033502	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a033.A033502;

/**
 * A036060 Number of 3-component Carmichael numbers C = (6M + 1)(12M + 1)(18M + 1) &lt; 10^n.
 * @author Sean A. Irvine
 */
public class A036060 extends A033502 {

  private Z mA = super.next();
  private Z mLim = Z.valueOf(1000);
  private long mCnt = 0;

  @Override
  public Z next() {
    while (mA.compareTo(mLim) < 0) {
      ++mCnt;
      mA = super.next();
    }
    mLim = mLim.multiply(10);
    return Z.valueOf(mCnt);
  }
}
#!queue	A036276	1	->	0	A001864	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a001.A001864;

/**
 * A036276 a(n) = A001864(n+1)/2.
 * @author Sean A. Irvine
 */
public class A036276 extends A001864 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}

#!queue	A036360	1	->	0	A001865	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a001.A001865;

/**
 * A036360 Number of labeled connected functional digraphs.
 * @author Sean A. Irvine
 */
public class A036360 extends A001865 {

  @Override
  public Z next() {
    return super.next().multiply(mN * (long) mN);
  }
}
#!queue	A036437	0	->	1	A036370	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036437 Triangle of coefficients of generating function of ternary rooted trees of height exactly n.
 * @author Sean A. Irvine
 */
public class A036437 extends A036370 {

  private int mM = 0;
  private int mN = 0;

  @Override
  public Z next() {
    if (++mM >= max(mN)) {
      ++mN;
      mM = mN;
    }
    return get(mN, mM).subtract(get(mN - 1, mM));
  }
}
#!queue	A036451	1	->	0	A002182	--------------------------------
package irvine.oeis.a036;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a002.A002182;

/**
 * A036451 Maximal value of d(x) (the number of divisors of x, A000005) if the binary order (see A029837) of x, the value g(x) = n.
 * @author Sean A. Irvine
 */
public class A036451 extends A002182 {

  private final PrimeDivision mFactor = new PrimeDivision();
  private Z mLim = null;
  private Z mA = super.next();

  @Override
  public Z next() {
    mLim = mLim == null ? Z.ONE : mLim.multiply2();
    Z sigma0 = Z.ZERO;
    while (mA.compareTo(mLim) <= 0) {
      sigma0 = sigma0.max(mFactor.factorize(mA).sigma0());
      mA = super.next();
    }
    return sigma0;
  }
}

#!queue	A036462	0	->	1	A104320	--------------------------------
package irvine.oeis.a036;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a104.A104320;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A036462 Conjecturally, a power of 2 written in base 3 cannot have this many 0's.
 * @author Sean A. Irvine
 */
public class A036462 extends A104320 {

  // A104321 is better sequence for running a search for this!

  private final TreeSet<Long> mReported = new TreeSet<>();
  private final LongDynamicBooleanArray mSeen = new LongDynamicBooleanArray();
  private long mZ = 114; // Number of zeros to consider

  @Override
  public Z next() {
    while (true) {
      ++mZ;
      // Heuristic is to wait until we have seen count 10 times higher than target
      while (mSeen.length() < 10 * mZ) {
        final long zeros = super.next().longValueExact();
        if (mReported.contains(zeros)) {
          throw new RuntimeException("Heuristic failure: " + zeros + " is not in the sequence, found with n=" + mN);
        }
        mSeen.set(zeros);
      }
      if (!mSeen.isSet(mZ)) {
        mReported.add(mZ);
        return Z.valueOf(mZ);
      }
    }
  }
}

#!queue	A036484	1	->	0	A002182	--------------------------------
package irvine.oeis.a036;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a002.A002182;

/**
 * A036484 a(n) is the minimal number of binary order n which has maximal number of divisors in this interval.
 * @author Sean A. Irvine
 */
public class A036484 extends A002182 {

  private final PrimeDivision mFactor = new PrimeDivision();
  private Z mLim = null;
  private Z mA = super.next();

  @Override
  public Z next() {
    mLim = mLim == null ? Z.ONE : mLim.multiply2();
    Z sigma0 = Z.ZERO;
    Z bestA = Z.ZERO;
    while (mA.compareTo(mLim) <= 0) {
      final Z s = mFactor.factorize(mA).sigma0();
      if (s.compareTo(sigma0) > 0) {
        sigma0 = s;
        bestA = mA;
      }
      mA = super.next();
    }
    return bestA;
  }
}

#!queue	A036497	1	->	0	A008578	--------------------------------
package irvine.oeis.a036;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a008.A008578;

/**
 * A036497 Number of partitions of n into distinct primes (counting 1 as a prime).
 * @author Sean A. Irvine
 */
public class A036497 extends A008578 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private int mN = -1;
  private int mP = 0;
  private Polynomial<Z> mPoly = RING.one();

  @Override
  public Z next() {
    ++mN;
    while (mN > mP) {
      mP = super.next().intValueExact();
      mPoly = RING.multiply(mPoly, RING.onePlusXToTheN(mP));
    }
    return mPoly.coeff(mN);
  }
}

#!queue	A036558	1	->	0	A003136	--------------------------------
package irvine.oeis.a036;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a003.A003136;

/**
 * A036558 Squared distances that can arise in any Barlow packing of spheres of diameter sqrt(3) (the scale being the simplest one that makes this an integer sequence).
 * @author Sean A. Irvine
 */
public class A036558 extends A003136 {

  private final TreeSet<Z> mA = new TreeSet<>();
  {
    mA.add(super.next());
  }
  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (mN.compareTo(mA.last()) > 0) {
        mA.add(super.next());
      }
      if (mA.contains(mN) && mN.mod(3) == 0) {
        // i.e. z == 0, n == 3k
        return mN;
      }
      if (mA.contains(mN.subtract(2)) && mN.mod(3) == 0) {
        // i.e. z == 1, n == 3k
        return mN;
      }
      Z u;
      for (long z = 2; (u = mN.subtract(Z.valueOf(z).square().multiply2())).signum() >= 0; ++z) {
        if (mA.contains(u)) {
          return mN;
        }
      }
    }
  }
}
#!queue	A036571	1	->	0	A001614	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a001.A001614;

/**
 * A036571 Binary packing of Connell sequence (shifted once right).
 * @author Sean A. Irvine
 */
public class A036571 extends A001614 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ZERO : Z.ONE.shiftLeft(super.next().longValueExact() - 1).add(mA);
    return mA;
  }
}
#!queue	A036655	1	->	0	A000084	--------------------------------
package irvine.oeis.a036;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000084;

/**
 * A036655 Numbers d_n used in recurrence for series-parallel numbers.
 * @author Sean A. Irvine
 */
public class A036655 extends A000084 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Polynomial<Z> mS = RING.empty();
  private final Polynomial<Z> mSp = RING.empty();
  private final Polynomial<Z> mSm = RING.empty();
  {
    mS.add(Z.ZERO);
    mSp.add(Z.ONE);
    mSm.add(Z.ONE);
  }

  @Override
  public Z next() {
    ++mN;
    final Z s = super.next();
    mS.add(s);
    mSp.add(s);
    mSm.add(s.negate());
    final Polynomial<Z> sp = RING.diff(mS);
    final Polynomial<Z> num = RING.multiply(sp, mSm, mN);
    return RING.coeff(num, mSp, mN);
  }
}
#!queue	A036671	0	->	1	A000598	--------------------------------
package irvine.oeis.a036;

import irvine.math.group.DihedralGroup;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a000.A000598;

/**
 * A036671 Number of isomers C_n H_{2n} without double bonds.
 * @author Sean A. Irvine
 */
public class A036671 extends A000598 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mG = RING.empty();
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    mG.add(new Q(super.next()));
    final Polynomial<Q> g = RING.divide(RING.add(RING.pow(mG, 2, mN), mG.substitutePower(2, mN)).shift(1), Q.TWO);
    Polynomial<Q> sum = RING.zero();
    for (int k = 3; k <= mN; ++k) {
      sum = RING.add(sum, DihedralGroup.cycleIndex(k).apply(g, mN));
    }
    return sum.coeff(mN).toZ();
  }
}
#!queue	A036676	1	->	0	A000621	--------------------------------
package irvine.oeis.a036;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000621;

/**
 * A036676 Used by Polya in calculating A000598.
 * @author Sean A. Irvine
 */
public class A036676 extends A000621 {

  protected static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  protected final Polynomial<Z> mQ = RING.empty();
  protected int mBonds = -1;

  @Override
  public Z next() {
    ++mBonds;
    mQ.add(super.next());
    final Polynomial<Z> q3 = RING.pow(mQ, 3, mBonds);
    final Polynomial<Z> qqs2 = RING.multiply(RING.multiply(mQ, mQ.substitutePower(2, mBonds), mBonds), Z.THREE);
    final Polynomial<Z> qs3 = RING.multiply(mQ.substitutePower(3, mBonds), Z.TWO);
    return RING.multiply(RING.add(RING.subtract(q3, qqs2), qs3), mQ.shift(1), mBonds).coeff(mBonds).divide(6);
  }
}
#!queue	A036677	1	->	0	A036676	--------------------------------
package irvine.oeis.a036;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A036677 Used by Polya in calculating A000598.
 * @author Sean A. Irvine
 */
public class A036677 extends A036676 {

  protected final Polynomial<Z> mP = RING.empty();

  @Override
  public Z next() {
    mP.add(super.next());
    final Polynomial<Z> qps2 = RING.multiply(RING.multiply(mQ, mP.substitutePower(2, mBonds), mBonds), Z.TWO);
    final Polynomial<Z> t = RING.multiply(RING.subtract(RING.pow(mQ, 2, mBonds), mQ.substitutePower(2, mBonds)), mP, mBonds);
    return RING.multiply(RING.add(qps2, t), mQ.shift(1), mBonds).coeff(mBonds).divide2();
  }
}
#!queue	A036678	1	->	0	A036677	--------------------------------
package irvine.oeis.a036;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A036678 Used by Polya in calculating A000598.
 * @author Sean A. Irvine
 */
public class A036678 extends A036677 {

  private final Polynomial<Z> mM = RING.empty();

  @Override
  public Z next() {
    mM.add(super.next());
    final Polynomial<Z> pp2 = RING.multiply(RING.multiply(mP, mP.substitutePower(2, mBonds), mBonds), Z.TWO);
    final Polynomial<Z> mqq = RING.multiply(RING.subtract(RING.pow(mQ, 2, mBonds), mQ.substitutePower(2, mBonds)), mM, mBonds);
    final Polynomial<Z> qpp = RING.multiply(RING.subtract(RING.pow(mP, 2, mBonds), mP.substitutePower(2, mBonds)), mQ, mBonds);
    return RING.multiply(RING.add(RING.add(pp2, mqq), qpp), mQ.shift(1), mBonds).coeff(mBonds).divide2();
  }
}
#!queue	A036761	1	->	0	A033950	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a033.A033950;

/**
 * A036761 Number of refactorable integers (A033950) of binary order (A029837) n.
 * @author Sean A. Irvine
 */
public class A036761 extends A033950 {

  private Z mLim = Z.ONE;
  private Z mA = super.next();

  @Override
  public Z next() {
    long count = 0;
    while (mA.compareTo(mLim) <= 0) {
      ++count;
      mA = super.next();
    }
    mLim = mLim.multiply2();
    return Z.valueOf(count);
  }
}
#!queue	A036789	2	->	0	A022821	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.a022.A022821;

/**
 * A036789 a(n) = Sum_{i=0..n} floor((2*i + 2)/(n - i + 1)).
 * @author Sean A. Irvine
 */
public class A036789 extends A022821 {

  @Override
  public Z next() {
    return super.next().subtract(mN - 1);
  }
}
#!queue	A036832	4	->	5	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036832 Schoenheim bound L_1(n,5,4).
 * @author Sean A. Irvine
 */
public class A036832 extends A036831 {

  private long mN = 4;

  @Override
  public Z next() {
    return l(++mN, 5, 4, 1);
  }
}
#!queue	A036833	4	->	6	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036833 Schoenheim bound L_1(n,6,5).
 * @author Sean A. Irvine
 */
public class A036833 extends A036831 {

  private long mN = 5;

  @Override
  public Z next() {
    return l(++mN, 6, 5, 1);
  }
}
#!queue	A036834	4	->	7	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036834 Schoenheim bound L_1(n,7,6).
 * @author Sean A. Irvine
 */
public class A036834 extends A036831 {

  private long mN = 6;

  @Override
  public Z next() {
    return l(++mN, 7, 6, 1);
  }
}
#!queue	A036835	4	->	8	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036835 Schoenheim bound L_1(n,8,7).
 * @author Sean A. Irvine
 */
public class A036835 extends A036831 {

  private long mN = 7;

  @Override
  public Z next() {
    return l(++mN, 8, 7, 1);
  }
}
#!queue	A036836	4	->	9	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036836 Schoenheim bound L_1(n,9,8).
 * @author Sean A. Irvine
 */
public class A036836 extends A036831 {

  private long mN = 8;

  @Override
  public Z next() {
    return l(++mN, 9, 8, 1);
  }
}
#!queue	A036837	4	->	7	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036837 Schoenheim bound L_1(n,n-5,n-6).
 * @author Sean A. Irvine
 */
public class A036837 extends A036831 {

  private long mN = 6;

  @Override
  public Z next() {
    return l(++mN, mN - 5, mN - 6, 1);
  }
}
#!queue	A036838	4	->	0	A036831	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036838 Triangle read by rows: T(n,k) = value of Schoenheim bound L_1(n+2,k+2,k+1) on covering numbers (0 &lt;= k &lt;= n).
 * @author Sean A. Irvine
 */
public class A036838 extends A036831 {

  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return l(mN + 2, mM + 2, mM + 1, 1);
  }
}
#!queue	A036919	1	->	0	A036918	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;

/**
 * A036919 A036918/2.
 * @author Sean A. Irvine
 */
public class A036919 extends A036918 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A037031	1	->	0	A000720	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A037031 Number of combinations of n objects taken pi(n) at a time.
 * @author Sean A. Irvine
 */
public class A037031 extends A000720 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    final Z pi = super.next();
    return Binomial.binomial(mN, pi);
  }
}

#!queue	A037203	1	->	0	A001223	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;
import irvine.oeis.a001.A001223;

/**
 * A037203 Number of terms by which A001223 lags behind A037201.
 * @author Sean A. Irvine
 */
public class A037203 extends A001223 {

  private Z mPrev = Z.ZERO;
  private long mLag = 0;

  @Override
  public Z next() {
    final Z t = mPrev;
    mPrev = super.next();
    if (t.equals(mPrev)) {
      ++mLag;
    }
    return Z.valueOf(mLag);
  }
}
#!queue	A037204	1	->	0	A037203	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;

/**
 * A037204 Numbers that occur in runs of length 1 in A037203.
 * @author Sean A. Irvine
 */
public class A037204 extends A037203 {

  private Z mA = super.next();
  private Z mB = super.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mA;
      mA = mB;
      mB = super.next();
      if (!t.equals(mA) && !mA.equals(mB)) {
        return mA;
      }
    }
  }
}
#!queue	A037453	0	->	1	A037454	--------------------------------
package irvine.oeis.a037;
// Generated by gen_seq4.pl rebase at 2020-12-01 23:09
// DO NOT EDIT here!

/**
 * A037453 Positive numbers whose base-5 representation contains no 3 or 4.
 * @author Georg Fischer
 */
public class A037453 extends A037454 {

  /** Construct the sequence. */
  public A037453() {
    super(1, 3, 5);
  }
}
#!queue	A037459	0	->	1	A037454	--------------------------------
package irvine.oeis.a037;
// Generated by gen_seq4.pl rebase at 2020-12-01 23:09
// DO NOT EDIT here!

/**
 * A037459 Sum{d(i)*5^i: i=0,1,...,m}, where Sum{d(i)*4^i: i=0,1,...,m} is the base 4 representation of n.
 * @author Georg Fischer
 */
public class A037459 extends A037454 {

  /** Construct the sequence. */
  public A037459() {
    super(1, 4, 5);
  }
}
#!queue	A037461	0	->	1	A037454	--------------------------------
package irvine.oeis.a037;
// Generated by gen_seq4.pl rebase at 2020-11-30 22:51
// DO NOT EDIT here!

/**
 * A037461 a(n)=Sum{d(i)*7^i: i=0,1,...,m}, where Sum{d(i)*4^i: i=0,1,...,m} is the base 4 representation of n.
 * @author Georg Fischer
 */
public class A037461 extends A037454 {

  /** Construct the sequence. */
  public A037461() {
    super(1, 4, 7);
  }
}
#!queue	A037479	0	->	1	A037454	--------------------------------
package irvine.oeis.a037;
// Generated by gen_seq4.pl rebase at 2020-12-01 23:09
// DO NOT EDIT here!

/**
 * A037479 a(n)=Sum{d(i)*10^i: i=0,1,...,m}, where Sum{d(i)*9^i: i=0,1,...,m} is the base 9 representation of n.
 * @author Georg Fischer
 */
public class A037479 extends A037454 {

  /** Construct the sequence. */
  public A037479() {
    super(1, 9, 10);
  }
}
#!queue	A037834	0	->	1	A005811	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;
import irvine.oeis.a005.A005811;

/**
 * A037834 a(n) = Sum_{i=1..m} |d(i) - d(i-1)|, where Sum_{i=0..m} d(i)*2^i is the base-2 representation of n.
 * @author Sean A. Irvine
 */
public class A037834 extends A005811 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A037862	0	->	1	A037861	--------------------------------
package irvine.oeis.a037;

/**
 * A037862 a(n)=(number of digits &lt;=1)-(number of digits &gt;1) in base 3 representation of n.
 * @author Sean A. Irvine
 */
public class A037862 extends A037861 {

  {
    super.next(); // skip 0
  }

  @Override
  protected long base() {
    return 3;
  }
}
#!queue	A037992	1	->	0	A050376	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;
import irvine.oeis.a050.A050376;

/**
 * A037992 Smallest number with 2^n divisors.
 * @author Sean A. Irvine
 */
public class A037992 extends A050376 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply(super.next());
    return mA;
  }
}
#!queue	A038005	2	->	0	A033178	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a033.A033178;

/**
 * A038005 Odd k such that b(k) is less than b(k-1) and b(k+1). b(k): A033178.
 * @author Sean A. Irvine
 */
public class A038005 extends A033178 {

  private Z mA = super.next();
  private Z mB = super.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mA;
      mA = mB;
      mB = super.next();
      if ((mN & 1) == 0 && mA.compareTo(t) < 0 && mA.compareTo(mB) < 0) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A038007	2	->	1	A033178	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a033.A033178;

/**
 * A038007 Even numbers k such that b(k) is greater than b(k-1) and b(k+1); b(k) = A033178(k).
 * @author Sean A. Irvine
 */
public class A038007 extends A033178 {

  private Z mA = null;
  private Z mB = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = super.next();
      mB = super.next();
    }
    while (true) {
      final Z t = mA;
      mA = mB;
      mB = super.next();
      if ((mN & 1) == 1 && mA.compareTo(t) > 0 && mA.compareTo(mB) > 0) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A038009	2	->	0	A038007	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038009 Values of A038007 not ending in 6 or 8.
 * @author Sean A. Irvine
 */
public class A038009 extends A038007 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      final long r = t.mod(10);
      if (r != 6 && r != 8) {
        return t;
      }
    }
  }
}
#!queue	A038011	2	->	0	A038007	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038011 Values of A038007 ending in 2.
 * @author Sean A. Irvine
 */
public class A038011 extends A038007 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) == 2) {
        return t;
      }
    }
  }
}
#!queue	A038013	2	->	0	A038007	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038013 Values of A038005 ending in 3.
 * @author Sean A. Irvine
 */
public class A038013 extends A038007 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) == 3) {
        return t;
      }
    }
  }
}
#!queue	A038015	0	->	1	A030247	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a030.A030247;

/**
 * A038015 Number of pointed (distinguished element) idempotent groupoids.
 * @author Sean A. Irvine
 */
public class A038015 extends A030247 {

  @Override
  protected int start() {
    return 0;
  }

  @Override
  protected Z fix(final int[] j) {
    return super.fix(j).multiply(j[1]);
  }
}

#!queue	A038017	0	->	1	A030257	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a030.A030257;

/**
 * A038017 Number of n-element commutative groupoids with an identity ("pointed" groupoids).
 * @author Sean A. Irvine
 */
public class A038017 extends A030257 {

  @Override
  protected int start() {
    return 0;
  }

  @Override
  protected Z fix(final int[] j) {
    return super.fix(j).multiply(j[1]);
  }
}

#!queue	A038033	1	->	3	A000313	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000313;

/**
 * A038033 a(n) = A000166(n-1)*n*(n-1).
 * @author Sean A. Irvine
 */
public class A038033 extends A000313 {

  {
    next();
    next();
    next();
  }

  @Override
  public Z next() {
    return super.next().multiply(6);
  }
}
#!queue	A038054	1	->	0	A038049	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038054 Number of labeled trees with 2-colored leaves.
 * @author Sean A. Irvine
 */
public class A038054 extends A038049 {

  private boolean mFirst = true;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    final Z t = mA;
    mA = super.next();
    return t.multiply(mN).add(mA).divide(mN);
  }
}
#!queue	A038058	1	->	0	A038057	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038058 Number of labeled trees with 2-colored nodes.
 * @author Sean A. Irvine
 */
public class A038058 extends A038057 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().divide(mN);
  }
}
#!queue	A038062	1	->	0	A038061	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038062 Number of labeled trees with 3-colored nodes.
 * @author Sean A. Irvine
 */
public class A038062 extends A038061 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().divide(mN);
  }
}
#!queue	A038078	1	->	0	A038077	--------------------------------
package irvine.oeis.a038;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A038078 Number of identity trees with 2-colored nodes.
 * @author Sean A. Irvine
 */
public class A038078 extends A038077 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final Polynomial<Z> mB = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Z.ZERO);
      return Z.ONE;
    }
    mB.add(super.next());
    return mB.coeff(mN).subtract(mB.substitutePower(2, mN).coeff(mN).add(RING.multiply(mB, mB, mN).coeff(mN)).divide2());
  }
}
#!queue	A038089	1	->	6	A038084	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A038089 Number of n-node rooted identity trees of height 5.
 * @author Sean A. Irvine
 */
public class A038089 extends A038084 {

  private final Sequence mA = new A038083();
  {
    for (int k = 0; k < 5; ++k) {
      next();
    }
  }

  @Override
  public Z next() {
    final Z u = super.next();
    if (u == null) {
      return null;
    }
    final Z t = mA.next();
    return t == null ? u : u.subtract(t);
  }
}
#!queue	A038090	1	->	7	A038085	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A038090 Number of n-node rooted identity trees of height 6.
 * @author Sean A. Irvine
 */
public class A038090 extends A038085 {

  private final Sequence mA = new A038084();
  {
    for (int k = 0; k < 6; ++k) {
      next();
    }
  }

  @Override
  public Z next() {
    final Z u = super.next();
    if (u == null) {
      return null;
    }
    final Z t = mA.next();
    return t == null ? u : u.subtract(t);
  }
}
#!queue	A038091	1	->	8	A038086	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A038091 Number of n-node rooted identity trees of height 7.
 * @author Sean A. Irvine
 */
public class A038091 extends A038086 {

  private final Sequence mA = new A038085();
  {
    for (int k = 0; k < 7; ++k) {
      next();
    }
  }

  @Override
  public Z next() {
    final Z u = super.next();
    if (u == null) {
      return null;
    }
    final Z t = mA.next();
    return t == null ? u : u.subtract(t);
  }
}
#!queue	A038092	1	->	9	A038087	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A038092 Number of n-node rooted identity trees of height 8.
 * @author Sean A. Irvine
 */
public class A038092 extends A038087 {

  private final Sequence mA = new A038086();
  {
    for (int k = 0; k < 8; ++k) {
      next();
    }
  }

  @Override
  public Z next() {
    final Z u = super.next();
    if (u == null) {
      return null;
    }
    final Z t = mA.next();
    return t == null ? u : u.subtract(t);
  }
}
#!queue	A038107	1	->	0	A000720	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A038107 Number of primes &lt; n^2.
 * @author Sean A. Irvine
 */
public class A038107 extends A000720 {

  private long mN = 0;
  private long mLim = 0;
  private long mSquareM1 = 0;

  @Override
  public Z next() {
    if (mLim == 0) {
      ++mLim;
      return Z.ZERO;
    }
    while (mN < mSquareM1) {
      ++mN;
      super.next();
    }
    ++mN;
    mSquareM1 = ++mLim * mLim - 1;
    return super.next();
  }
}
#!queue	A038108	1	->	2	A001358	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a001.A001358;

/**
 * A038108 Number of prime pairs {p,q}, such that pq &lt; n^2.
 * @author Sean A. Irvine
 */
public class A038108 extends A001358 {

  private long mCount = 0;
  private long mN = 1;
  private Z mS = super.next();

  @Override
  public Z next() {
    final Z square = Z.valueOf(++mN).square();
    while (mS.compareTo(square) < 0) {
      mS = super.next();
      ++mCount;
    }
    return Z.valueOf(mCount);
  }
}
#!queue	A038190	0	->	-2	A038189	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038190 Pagoda sequence: a(0) = b(n)-b(n-2) mod 3, where b(n) = A038189(n).
 * @author Sean A. Irvine
 */
public class A038190 extends A038189 {

  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    final Z t = mA;
    mA = mB;
    mB = super.next();
    return mB.subtract(t).mod(Z.THREE);
  }
}
#!queue	A038360	0	->	3	A000079	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000079;
import irvine.oeis.a000.A000931;

/**
 * A038360 Ranks of certain relations among Euler sums of weight n.
 * @author Sean A. Irvine
 */
public class A038360 extends A000079 {

  private final Sequence mA = new A000931().skip(6);

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A038377	0	->	1	A037040	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a037.A037040;

/**
 * A038377 Number of odd nonprimes &lt;= (2n+1)^2.
 * @author Sean A. Irvine
 */
public class A038377 extends A037040 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A038398	0	->	1	A000578	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A038398 Concatenate first n cubes in reverse order.
 * @author Sean A. Irvine
 */
public class A038398 extends A000578 {

  private final StringBuilder mS = new StringBuilder();
  {
    super.next();
  }

  @Override
  public Z next() {
    mS.insert(0, super.next());
    return new Z(mS);
  }
}
#!queue	A038494	0	->	1	A000384	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A038494 Images of hexamorphic numbers: suppose k-th hexagonal number H(k) (A000384) ends in k; sequence gives positive values of H(k).
 * @author Sean A. Irvine
 */
public class A038494 extends A000384 {

  private long mN = 0;
  private long mLim = 10;
  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (++mN == mLim) {
        mLim *= 10;
      }
      if (t.mod(mLim) == mN) {
        return t;
      }
    }
  }
}
#!queue	A038735	1	->	6	A038730	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038735 T(n,n-6), array T as in A038730.
 * @author Sean A. Irvine
 */
public class A038735 extends A038730 {

  private long mN = 6;

  @Override
  public Z next() {
    return t(++mN, mN - 6);
  }
}
#!queue	A038736	1	->	0	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038736 T(3*n + 1, n + 1), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038736 extends A038792 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(3 * ++mN + 1, mN + 1);
  }
}
#!queue	A038742	1	->	5	A038738	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038742 T(n,n-5), array T as in A038738.
 * @author Sean A. Irvine
 */
public class A038742 extends A038738 {

  private long mN = 5;

  @Override
  public Z next() {
    return t(++mN, mN - 5);
  }
}
#!queue	A038743	1	->	6	A038738	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038743 T(n,n-6), array T as in A038738.
 * @author Sean A. Irvine
 */
public class A038743 extends A038738 {

  private long mN = 6;

  @Override
  public Z next() {
    return t(++mN, mN - 6);
  }
}
#!queue	A038744	1	->	0	A038738	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038744 T(2n,n), array T as in A038738.
 * @author Sean A. Irvine
 */
public class A038744 extends A038738 {

  private long mN = -1;

  @Override
  public Z next() {
    return t(2 * ++mN + 1, mN + 1);
  }
}
#!queue	A038746	0	->	1	A173380	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a173.A173380;

/**
 * A038746 Coefficients arising in the enumeration of configurations of linear chains.
 * @author Sean A. Irvine
 */
public class A038746 extends A173380 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(4).divide(8);
  }
}
#!queue	A038753	0	->	1	A000041	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A038753 Nonprime partition numbers.
 * @author Sean A. Irvine
 */
public class A038753 extends A000041 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    while (true) {
      final Z partitions = super.next();
      if (!partitions.isProbablePrime()) {
        return partitions;
      }
    }
  }
}
#!queue	A038774	0	->	1	A038776	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicLongArray;

/**
 * A038774 Cycle lengths of the permutation that converts the forest of depth-first planar planted binary trees into breadth-first representation.
 * @author Sean A. Irvine
 */
public class A038774 extends A038776 {

  private static final long USED = -1;
  private final LongDynamicLongArray mA = new LongDynamicLongArray();
  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    while (true) {
      long m = ++mN;
      if (mA.get(mN) == USED) {
        continue;
      }
      long cnt = 0;
      do {
        while (mA.get(m) == 0) {
          mA.set(++mM, super.next().longValueExact());
        }
        ++cnt;
        final long t = mA.get(m);
        mA.set(m, USED);
        m = t;
      } while (m != mN);
      return Z.valueOf(cnt);
    }
  }
}
#!queue	A038775	0	->	1	A038774	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A038775 a(n) is the number of cycles of the permutation that converts forest(n) of depth-first planar planted binary trees into breadth-first representation.
 * @author Sean A. Irvine
 */
public class A038775 extends A038774 {

  private long mN = 0;
  private Z mSum = Z.ZERO;
  private long mM = 0;

  @Override
  public Z next() {
    final Z target = Binomial.catalan(++mN);
    do {
      mSum = mSum.add(super.next());
      ++mM;
    } while (!mSum.equals(target));
    return Z.valueOf(mM);
  }
}
#!queue	A038776	0	->	1	A014486	--------------------------------
package irvine.oeis.a038;

import java.util.LinkedList;
import java.util.TreeMap;

import irvine.math.z.Z;
import irvine.oeis.a014.A014486;

/**
 * A038776 The sequence a[1] to a[ cat[n] ] is the permutation that converts forest[n] of depth-first planar planted binary trees into breadth-first representation.
 * @author Sean A. Irvine
 */
public class A038776 extends A014486 {

  {
    super.next(); // skip 0
  }

  private final TreeMap<Z, Long> mOrdering = new TreeMap<>();
  private final LinkedList<Z> mA = new LinkedList<>();
  private int mBitCount = 1;
  private long mM = 0;
  private long mN = -1;

  private void step() {
    Z t = super.next();
    if (t.bitCount() == mBitCount) {
      mOrdering.put(t, ++mN);
      mA.add(t);
    } else {
      mOrdering.clear();
      mA.clear();
      mN = mM - 1;
      for (int k = 0; k <= mN; ++k) {
        t = super.next();
      }
      mOrdering.put(t, ++mN);
      mA.add(t);
      mBitCount = t.bitCount();
    }
  }

  private long getIndex(final Z n) {
    while (!mOrdering.containsKey(n)) {
      step();
    }
    // We can remove because this is a permutation
    return mOrdering.remove(n);
  }

  private static class Node {
    private Node mLeft = null;
    private Node mRight = null;
  }

  private void dfs(final Node node, final StringBuilder sb) {
    if (node == null) {
      sb.append('0');
    } else {
      sb.append(1);
      dfs(node.mLeft, sb);
      dfs(node.mRight, sb);
    }
  }

  private Z bfsTodfs(final Z n) {
    if (n.isZero()) {
      return Z.ZERO;
    }
    final String s = n.toString(2);
    // Build dfs tree
    final Node root = new Node();
    final LinkedList<Node> bfs = new LinkedList<>();
    bfs.add(root);
    for (int k = 1; k + 1 < s.length(); k += 2) { // k == 0 is root
      final Node node = bfs.pollFirst();
      if (s.charAt(k) == '1') {
        final Node t = new Node();
        node.mLeft = t;
        bfs.add(t);
      }
      if (s.charAt(k + 1) == '1') {
        final Node t = new Node();
        node.mRight = t;
        bfs.add(t);
      }
    }
    final StringBuilder sb = new StringBuilder();
    dfs(root, sb);
    //System.out.println(s + " -> " + sb);
    return new Z(sb, 2).divide2(); // Ignore last implicit 0
  }

  @Override
  public Z next() {
    if (mA.isEmpty()) {
      step();
    }
    ++mM;
    return Z.valueOf(getIndex(bfsTodfs(mA.pollFirst())) + 1);
  }
}
#!queue	A038793	1	->	3	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038793 T(n,n-3), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038793 extends A038792 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 4L);
  }
}
#!queue	A038794	1	->	4	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038794 T(n,n-4), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038794 extends A038792 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 5L);
  }
}
#!queue	A038795	1	->	5	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038795 T(n,n-5), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038795 extends A038792 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 6L);
  }
}
#!queue	A038796	1	->	6	A038792	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;

/**
 * A038796 T(n,n-6), array T as in A038792.
 * @author Sean A. Irvine
 */
public class A038796 extends A038792 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, 7L);
  }
}
#!queue	A039593	0	->	1	A001405	--------------------------------
package irvine.oeis.a039;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A039593 Number of unitary divisors of central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A039593 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).unitarySigma0();
  }
}
#!queue	A039594	0	->	1	A000384	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A039594 Hexamorphic numbers: k such that the k-th hexagonal number ends with k.
 * @author Sean A. Irvine
 */
public class A039594 extends A000384 {

  private long mN = 0;
  private long mLim = 10;
  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z h = super.next();
      if (++mN == mLim) {
        mLim *= 10;
      }
      if (h.mod(mLim) == mN) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A039653	1	->	0	A000203	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A039653 a(0) = 0; for n &gt; 0, a(n) = sigma(n)-1.
 * @author Sean A. Irvine
 */
public class A039653 extends A000203 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().subtract(1);
  }
}
#!queue	A039657	1	->	0	A040025	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a040.A040025;

/**
 * A039657 Number of digits in all (2n+1)-digit palindromic primes.
 * @author Sean A. Irvine
 */
public class A039657 extends A040025 {

  private long mN = -1;

  @Override
  public Z next() {
    mN += 2;
    return super.next().multiply(mN);
  }
}
#!queue	A039732	2	->	1	A039731	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;

/**
 * A039732 a(n) = s(n+1)/2, s=A039731.
 * @author Sean A. Irvine
 */
public class A039732 extends A039731 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A039801	1	->	2	A038498	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a038.A038498;

/**
 * A039801 Column 2 of Inverse partition triangle A038498.
 * @author Sean A. Irvine
 */
public class A039801 extends A038498 {

  private long mN = 0;
  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    for (long k = 0; k < mN; ++k) {
      super.next();
    }
    ++mN;
    return super.next();
  }
}
#!queue	A039802	1	->	3	A038498	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a038.A038498;

/**
 * A039802 Column 3 of Inverse partition triangle A038498.
 * @author Sean A. Irvine
 */
public class A039802 extends A038498 {

  private long mN = 1;
  {
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    for (long k = 0; k < mN; ++k) {
      super.next();
    }
    ++mN;
    return super.next();
  }
}
#!queue	A039803	1	->	4	A038498	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a038.A038498;

/**
 * A039803 Column 4 of inverse partition triangle A038498.
 * @author Sean A. Irvine
 */
public class A039803 extends A038498 {

  private long mN = 2;
  {
    for (int k = 0; k < 7; ++k) {
      super.next();
    }
  }

  @Override
  public Z next() {
    for (long k = 0; k < mN; ++k) {
      super.next();
    }
    ++mN;
    return super.next();
  }
}
#!queue	A039804	1	->	5	A038498	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a038.A038498;

/**
 * A039804 Column 5 of Inverse partition triangle A038498.
 * @author Sean A. Irvine
 */
public class A039804 extends A038498 {

  private long mN = 3;
  {
    for (int k = 0; k < 11; ++k) {
      super.next();
    }
  }

  @Override
  public Z next() {
    for (long k = 0; k < mN; ++k) {
      super.next();
    }
    ++mN;
    return super.next();
  }
}
#!queue	A039806	1	->	0	A039805	--------------------------------
package irvine.oeis.a039;

/**
 * A039806 Matrix 4th power of partition triangle A008284.
 * @author Sean A. Irvine
 */
public class A039806 extends A039805 {

  @Override
  protected int exponent() {
    return 4;
  }
}
#!queue	A039807	1	->	0	A039805	--------------------------------
package irvine.oeis.a039;

/**
 * A039807 Matrix 5th power of partition triangle A008284.
 * @author Sean A. Irvine
 */
public class A039807 extends A039805 {

  @Override
  protected int exponent() {
    return 5;
  }
}
#!queue	A039919	0	->	1	A002212	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a002.A002212;

/**
 * A039919 Related to enumeration of edge-rooted catafusenes.
 * @author Sean A. Irvine
 */
public class A039919 extends A002212 {

  private Z mSum = super.next();

  @Override
  public Z next() {
    final Z t = super.next();
    final Z u = mSum;
    mSum = mSum.add(t);
    return t.subtract(u);
  }
}
#!queue	A039953	2	->	1	A003022	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a003.A003022;

/**
 * A039953 Triangle of "canonical" optimal Golomb rulers.
 * @author Sean A. Irvine
 */
public class A039953 extends A003022 {

  {
    super.next();
  }

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN >= mPositions.length) {
      super.next();
      mN = 1;
    }
    return Z.valueOf(mPositions[mN] - mPositions[mN - 1]);
  }
}
#!queue	A039963	1	->	0	A035263	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a035.A035263;

/**
 * A039963 The period-doubling sequence A035263 repeated.
 * @author Sean A. Irvine
 */
public class A039963 extends A035263 {

  private Z mA = null;

  @Override
  public Z next() {
    if (mA != null) {
      final Z t = mA;
      mA = null;
      return t;
    }
    mA = super.next();
    return mA;
  }
}

#!queue	A039968	0	->	1	A005043	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a005.A005043;

/**
 * A039968 An example of a d-perfect sequence.
 * @author Sean A. Irvine
 */
public class A039968 extends A005043 {

  private long mMult = -1;

  @Override
  public Z next() {
    final long r = super.next().mod(3);
    mMult = -mMult;
    return Z.valueOf((3 + r * mMult) % 3);
  }
}

#!queue	A039974	0	->	1	A006318	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a006.A006318;

/**
 * A039974 An example of a d-perfect sequence.
 * @author Sean A. Irvine
 */
public class A039974 extends A006318 {

  private long mMult = -1;

  @Override
  public Z next() {
    final long r = super.next().mod(3);
    mMult = -mMult;
    return Z.valueOf((3 + r * mMult) % 3);
  }
}

#!queue	A039975	0	->	1	A006318	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.a006.A006318;

/**
 * A039975 An example of a d-perfect sequence: a(n) = A006318(n-1) mod 3.
 * @author Sean A. Irvine
 */
public class A039975 extends A006318 {

  @Override
  public Z next() {
    return super.next().mod(Z.THREE);
  }
}

#!queue	A039990	0	->	1	A039987	--------------------------------
package irvine.oeis.a039;

/**
 * A039990 k th digit of a(n) is the number of different digits within 4 of k (not including k).
 * @author Sean A. Irvine
 */
public class A039990 extends A039987 {

  @Override
  protected int shift() {
    return 4;
  }
}

#!queue	A040016	0	->	1	A000149	--------------------------------
package irvine.oeis.a040;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000149;

/**
 * A040016 Largest prime &lt; e^n.
 * @author Sean A. Irvine
 */
public class A040016 extends A000149 {

  {
    super.next();
  }
  private final Fast mPrime = new Fast();
  private Z mP = Z.NEG_ONE;

  @Override
  public Z next() {
    final Z t = super.next();
    Z a = mP;
    while (mP.compareTo(t) <= 0) {
      a = mP;
      mP = mPrime.nextPrime(mP);
    }
    return a;
  }
}
#!queue	A040025	1	->	0	A016115	--------------------------------
package irvine.oeis.a040;

import irvine.math.z.Z;
import irvine.oeis.a016.A016115;

/**
 * A040025 a(n) is the number of prime palindromes with 2n+1 digits.
 * @author Sean A. Irvine
 */
public class A040025 extends A016115 {

  @Override
  public Z next() {
    final Z r = super.next();
    super.next();
    return r;
  }
}
#!queue	A043089	1	->	0	A031941	--------------------------------
package irvine.oeis.a043;

import irvine.oeis.a031.A031941;

/**
 * A043089 Every string of 2 consecutive base-3 digits contains exactly 2 distinct numbers.
 * @author Sean A. Irvine
 */
public class A043089 extends A031941 {

  /** Construct the sequence. */
  public A043089() {
    super(3, 0);
  }
}
#!queue	A043090	1	->	0	A031941	--------------------------------
package irvine.oeis.a043;

import irvine.oeis.a031.A031941;

/**
 * A043090 Every string of 2 consecutive base 4 digits contains exactly 2 distinct numbers.
 * @author Sean A. Irvine
 */
public class A043090 extends A031941 {

  /** Construct the sequence. */
  public A043090() {
    super(4, 0);
  }
}
#!queue	A043091	1	->	0	A031941	--------------------------------
package irvine.oeis.a043;

import irvine.oeis.a031.A031941;

/**
 * A043091 Every string of 2 consecutive base 5 digits contains exactly 2 distinct numbers.
 * @author Sean A. Irvine
 */
public class A043091 extends A031941 {

  /** Construct the sequence. */
  public A043091() {
    super(5, 0);
  }
}
#!queue	A043093	1	->	0	A031941	--------------------------------
package irvine.oeis.a043;

import irvine.oeis.a031.A031941;

/**
 * A043093 Every string of 2 consecutive base 7 digits contains exactly 2 distinct numbers.
 * @author Sean A. Irvine
 */
public class A043093 extends A031941 {

  /** Construct the sequence. */
  public A043093() {
    super(7, 0);
  }
}
#!queue	A043094	1	->	0	A031941	--------------------------------
package irvine.oeis.a043;

import irvine.oeis.a031.A031941;

/**
 * A043094 Every string of 2 consecutive base 8 digits contains exactly 2 distinct numbers.
 * @author Sean A. Irvine
 */
public class A043094 extends A031941 {

  /** Construct the sequence. */
  public A043094() {
    super(8, 0);
  }
}
#!queue	A043294	0	->	1	A000984	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000984;

/**
 * A043294 Sum of digits of binomial(2n,n).
 * @author Sean A. Irvine
 */
public class A043294 extends A000984 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()));
  }
}

#!queue	A043295	0	->	1	A000367	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000367;

/**
 * A043295 Sum of digits of numerator of Bernoulli number B(2n).
 * @author Sean A. Irvine
 */
public class A043295 extends A000367 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next().abs()));
  }
}

#!queue	A043296	0	->	1	A002445	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002445;

/**
 * A043296 Sum of digits of denominator of Bernoulli number B(2n).
 * @author Sean A. Irvine
 */
public class A043296 extends A002445 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next().abs()));
  }
}

#!queue	A043303	1	->	0	A001067	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.oeis.a001.A001067;

/**
 * A043303 Numerator of B(4n+2)/(2n+1) where B(m) are the Bernoulli numbers.
 * @author Sean A. Irvine
 */
public class A043303 extends A001067 {

  @Override
  public Z next() {
    final Z t = super.next();
    super.next();
    return t;
  }
}

#!queue	A043544	2	->	1	A043306	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;

/**
 * A043544 Numbers k such that s(k)&lt;s(k-1), where s(k)=sum of all digits in all base b representations of k, for 2&lt;=b&lt;=k.
 * @author Sean A. Irvine
 */
public class A043544 extends A043306 {

  private Z mA = super.next();
  private long mN = 2;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z t = mA;
      mA = super.next();
      if (mA.compareTo(t) < 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A043720	2	->	1	A043544	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;

/**
 * A043720 a(n)=(1/2)*s(n), where s=A043544.
 * @author Sean A. Irvine
 */
public class A043720 extends A043544 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}

#!queue	A045645	0	->	1	A011545	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a011.A011545;

/**
 * A045645 Concatenate first n terms of A011545.
 * @author Sean A. Irvine
 */
public class A045645 extends A011545 {

  private final StringBuilder mA = new StringBuilder();

  @Override
  public Z next() {
    mA.append(super.next());
    return new Z(mA);
  }
}
#!queue	A045720	1	->	0	A035324	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a035.A035324;

/**
 * A045720 3-fold convolution of A001700(n), n &gt;= 0.
 * @author Sean A. Irvine
 */
public class A045720 extends A035324 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3L);
  }
}

#!queue	A045739	1	->	2	A094040	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a094.A094040;

/**
 * A045739 Number of edges in all noncrossing forests on n nodes on a circle.
 * @author Sean A. Irvine
 */
public class A045739 extends A094040 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 1; k < mN; ++k) {
      sum = sum.add(t(mN, k).multiply(k));
    }
    return sum;
  }
}
#!queue	A045747	0	->	1	A007662	--------------------------------
package irvine.oeis.a045;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a007.A007662;

/**
 * A045747 Number of prime factors of n!!!! (A007662), with multiplicity.
 * @author Sean A. Irvine
 */
public class A045747 extends A007662 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).bigOmega());
  }
}
#!queue	A045766	0	->	1	A006882	--------------------------------
package irvine.oeis.a045;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A045766 Number of prime factors of double factorials n!! (A006882), with multiplicity.
 * @author Sean A. Irvine
 */
public class A045766 extends A006882 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).bigOmega());
  }
}
#!queue	A045767	0	->	1	A007661	--------------------------------
package irvine.oeis.a045;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a007.A007661;

/**
 * A045767 Number of prime factors of triple factorials n!!! (A007661), with multiplicity.
 * @author Sean A. Irvine
 */
public class A045767 extends A007661 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).bigOmega());
  }
}
#!queue	A045814	0	->	1	A045812	--------------------------------
package irvine.oeis.a045;

/**
 * A045814 Number of times the digits are repeated in A045813.
 * @author Sean A. Irvine
 */
public class A045814 extends A045812 {

  @Override
  protected int base() {
    return 4;
  }
}

#!queue	A045816	0	->	1	A045812	--------------------------------
package irvine.oeis.a045;

/**
 * A045816 Number of times the digits are repeated in A045815.
 * @author Sean A. Irvine
 */
public class A045816 extends A045812 {

  @Override
  protected int base() {
    return 6;
  }
}

#!queue	A045881	0	->	1	A000230	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A045881 Smallest of first string of exactly 2n-1 consecutive composite integers.
 * @author Sean A. Irvine
 */
public class A045881 extends A000230 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A045894	1	->	0	A035324	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a035.A035324;

/**
 * A045894 4-fold convolution of A001700(n), n &gt;= 0.
 * @author Sean A. Irvine
 */
public class A045894 extends A035324 {

  private long mN = 3;

  @Override
  public Z next() {
    return get(++mN, 4L);
  }
}

#!queue	A045905	1	->	0	A045829	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002212;
import irvine.oeis.a039.A039660;

/**
 * A045905 Catafusenes (see reference for precise definition).
 * @author Sean A. Irvine
 */
public class A045905 extends A045829 {

  private final Sequence mB = new A045445();
  private final Sequence mC = new A002212();
  private final Sequence mD = new A039660();
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mC.next();
      return Z.ZERO;
    }
    Z t = super.next().add(mD.next().multiply2());
    if ((mN & 1) == 0) {
      t = t.add(mB.next().multiply(3));
      if ((mN & 3) == 0) {
        t = t.add(mC.next().multiply2());
      }
    }
    return t.divide(8);
  }
}
#!queue	A045923	0	->	1	A272090	--------------------------------
package irvine.oeis.a045;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.a272.A272090;

/**
 * A045923 Number of irreducible representations of symmetric group S_n for which every matrix has determinant 1.
 * @author Sean A. Irvine
 */
public class A045923 extends A272090 {

  private int mN = 0;

  @Override
  public Z next() {
    return IntegerPartition.partitions(++mN).subtract(super.next());
  }
}
#!queue	A045978	1	->	0	A002385	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a002.A002385;

/**
 * A045978 Palindromic primes that are "near miss circular primes" (all cyclic shifts except one are primes).
 * @author Sean A. Irvine
 */
public class A045978 extends A002385 {

  private boolean isNearCircular(final Z p) {
    final String s = p.toString();
    boolean sawNonPrime = false;
    for (int k = 1; k < s.length(); ++k) {
      if (!new Z(s.substring(k) + s.substring(0, k)).isProbablePrime()) {
        if (sawNonPrime) {
          return false;
        }
        sawNonPrime = true;
      }
    }
    return sawNonPrime;
  }

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (isNearCircular(p)) {
        return p;
      }
    }
  }
}
#!queue	A045979	0	->	1	A002445	--------------------------------
package irvine.oeis.a045;

import irvine.math.z.Z;
import irvine.oeis.a002.A002445;

/**
 * A045979 Bernoulli number B_{2n} has denominator 6.
 * @author Sean A. Irvine
 */
public class A045979 extends A002445 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.SIX.equals(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A046053	0	->	1	A002275	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A046053 Total number of prime factors of the repunit R(n)=(10^n-1)/9.
 * @author Sean A. Irvine
 */
public class A046053 extends A002275 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A046102	0	->	1	A005663	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a005.A005663;
import irvine.oeis.a005.A005664;

/**
 * A046102 Denominators of convergents to the comma of Pythagoras.
 * @author Sean A. Irvine
 */
public class A046102 extends A005663 {

  private final Sequence mD = new A005664();

  {
    next(); // skip 0th
  }

  @Override
  public Z next() {
    return super.next().subtract(mD.next());
  }
}
#!queue	A046109	1	->	0	A046080	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046109 Number of lattice points (x,y) on the circumference of a circle of radius n with center at (0,0).
 * @author Sean A. Irvine
 */
public class A046109 extends A046080 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().multiply(8).add(4);
  }
}
#!queue	A046110	1	->	0	A046080	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046110 Number of lattice points on circumference of a circle of radius (2n+1)/2 with center at (1/2,0).
 * @author Sean A. Irvine
 */
public class A046110 extends A046080 {

  @Override
  public Z next() {
    final Z t = super.next();
    super.next();
    return t.multiply(4).add(2);
  }
}
#!queue	A046111	1	->	0	A046080	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046111 Number of lattice points on circumference of a circle of radius 1/3,2/3,4/3,5/3,... with center at (1/3,0).
 * @author Sean A. Irvine
 */
public class A046111 extends A046080 {

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 2) {
      super.next();
      mN = 0;
    }
    return super.next().multiply2().add(1);
  }
}
#!queue	A046112	0	->	1	A006339	--------------------------------
package irvine.oeis.a046;

import irvine.oeis.a006.A006339;

/**
 * A046112 a(n) is smallest integral radius of circle centered at (0,0) having 8n-4 lattice points on its circumference; a(n)/2 is smallest half-integral radius circle centered at (1/2,0) having 4n-2 lattice points; a(n)/3 is smallest third-integral radius circle centered at (1/3,0) having 2n-1 lattice points.
 * @author Sean A. Irvine
 */
public class A046112 extends A006339 {
  // Differs only in offset
}
#!queue	A046164	0	->	14	A343146	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a343.A343146;

/**
 * A046164 Number of distinct solutions to reverse the 8 puzzle (3 X 3 analog of the 4 X 4 15 puzzle) in 28, 30, 32, ... moves.
 * @author Sean A. Irvine
 */
public class A046164 extends A343146 {

  private static final long TARGET_STATE = 0b1000_0111_0110_0101_0100_0011_0010_0001_0000L;
  private boolean[] mUsed = null;
  private int mN = 26;
  private long mCount = 0;
  private long mSum = 0; // Work around historical over counting

  @Override
  protected long targetState() {
    return TARGET_STATE;
  }

  private void search(final int id, final int stepsRemaining) {
    if (stepsRemaining == 0) {
      if (id == mTargetId) {
        ++mCount;
      }
      return;
    }
    for (final int newId : mTransitions[id]) {
      if (!mUsed[newId]) {
        mUsed[newId] = true;
        search(newId, stepsRemaining - 1);
        mUsed[newId] = false;
      }
    }
  }

  @Override
  protected void init() {
    super.init();
    if (mUsed == null) {
      mUsed = new boolean[mTransitions.length];
    }
  }

  @Override
  public Z next() {
    init();
    mCount = 0;
    mN += 2;
    search(mStateToId.get(START_STATE), mN);
    mSum = mCount - mSum; // Work around historical inaccuracy?
    return Z.valueOf(mSum);
  }
}
#!queue	A046171	0	->	1	A001411	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a001.A001411;

/**
 * A046171 Number of inequivalent self-avoiding walks of length n on a 2-D lattice which start at origin, take first step in {+1,0} direction and if any steps are vertical, a step up is taken before a step down.
 * @author Sean A. Irvine
 */
public class A046171 extends A001411 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    return super.next().add(4).divide(8);
  }
}
#!queue	A046212	0	->	1	A002457	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a002.A002457;

/**
 * A046212 First numerator and then denominator of central elements of Leibniz's Harmonic Triangle.
 * @author Sean A. Irvine
 */
public class A046212 extends A002457 {

  private boolean mNumerator = false;

  @Override
  public Z next() {
    mNumerator = !mNumerator;
    return mNumerator ? Z.ONE : super.next();
  }
}
#!queue	A046234	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046234 Cubes which are palindromes in base 5.
 * @author Sean A. Irvine
 */
public class A046234 extends A046232 {

  @Override
  protected int base() {
    return 5;
  }
}
#!queue	A046236	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046236 Cubes which are palindromes in base 6.
 * @author Sean A. Irvine
 */
public class A046236 extends A046232 {

  @Override
  protected int base() {
    return 6;
  }
}
#!queue	A046238	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046238 Cubes which are palindromes in base 7.
 * @author Sean A. Irvine
 */
public class A046238 extends A046232 {

  @Override
  protected int base() {
    return 7;
  }
}
#!queue	A046240	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046240 Cubes which are palindromes in base 8.
 * @author Sean A. Irvine
 */
public class A046240 extends A046232 {

  @Override
  protected int base() {
    return 8;
  }
}
#!queue	A046242	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046242 Cubes which are palindromes in base 9.
 * @author Sean A. Irvine
 */
public class A046242 extends A046232 {

  @Override
  protected int base() {
    return 9;
  }
}
#!queue	A046244	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046244 Cubes which are palindromes in base 11.
 * @author Sean A. Irvine
 */
public class A046244 extends A046232 {

  @Override
  protected int base() {
    return 11;
  }
}
#!queue	A046246	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046246 Cubes which are palindromes in base 12.
 * @author Sean A. Irvine
 */
public class A046246 extends A046232 {

  @Override
  protected int base() {
    return 12;
  }
}
#!queue	A046248	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046248 Cubes which are palindromes in base 13.
 * @author Sean A. Irvine
 */
public class A046248 extends A046232 {

  @Override
  protected int base() {
    return 13;
  }
}
#!queue	A046250	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046250 Cubes which are palindromes in base 14.
 * @author Sean A. Irvine
 */
public class A046250 extends A046232 {

  @Override
  protected int base() {
    return 14;
  }
}
#!queue	A046252	1	->	0	A046232	--------------------------------
package irvine.oeis.a046;

/**
 * A046252 Cubes which are palindromes in base 15.
 * @author Sean A. Irvine
 */
public class A046252 extends A046232 {

  @Override
  protected int base() {
    return 15;
  }
}
#!queue	A046278	1	->	0	A000959	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a000.A000959;

/**
 * A046278 Concatenate lucky numbers.
 * @author Sean A. Irvine
 */
public class A046278 extends A000959 {

  private final StringBuilder mA = new StringBuilder();

  @Override
  public Z next() {
    mA.append(super.next());
    return new Z(mA);
  }
}
#!queue	A046439	1	->	0	A046432	--------------------------------
package irvine.oeis.a046;

/**
 * A046439 9 steps needed to reach a prime under "Sum of digits raised to its digits' powers" procedure.
 * @author Sean A. Irvine
 */
public class A046439 extends A046432 {

  @Override
  protected int steps() {
    return 9;
  }
}
#!queue	A046454	1	->	0	A046447	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A046454 Concatenation of the 5 prime factors of composite a(n) is a palindrome.
 * @author Sean A. Irvine
 */
public class A046454 extends A046447 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (Jaguar.factor(t).bigOmega() == 5) {
        return t;
      }
    }
  }
}
#!queue	A046457	1	->	0	A046447	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A046457 Concatenation of the 8 prime factors of composite a(n) is a palindrome.
 * @author Sean A. Irvine
 */
public class A046457 extends A046447 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (Jaguar.factor(t).bigOmega() == 8) {
        return t;
      }
    }
  }
}
#!queue	A046471	0	->	1	A046019	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046471 Number of numbers k&gt;1 such that k equals the sum of digits in k^n.
 * @author Sean A. Irvine
 */
public class A046471 extends A046019 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A046646	0	->	1	A001764	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a001.A001764;

/**
 * A046646 Number of certain rooted planar maps.
 * @author Sean A. Irvine
 */
public class A046646 extends A001764 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return super.next();
    }
    return super.next().multiply2();
  }
}
#!queue	A046651	1	->	0	A091599	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a091.A091599;

/**
 * A046651 Triangle of rooted planar maps.
 * @author Sean A. Irvine
 */
public class A046651 extends A091599 {

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (--mM <= 0) {
      mM = ++mN;
    }
    return t(mN, mM);
  }
}
#!queue	A046652	1	->	0	A091665	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a091.A091665;

/**
 * A046652 Triangle of rooted planar maps, read by rows.
 * @author Sean A. Irvine
 */
public class A046652 extends A091665 {

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (--mM <= 0) {
      mM = ++mN;
    }
    return t(mN, mM);
  }
}
#!queue	A046721	0	->	2	A006657	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a006.A006657;
import irvine.util.Pair;

/**
 * A046721 Number of semi-meanders of order n with 2 components.
 * @author Sean A. Irvine
 */
public class A046721 extends A006657 {

  @Override
  protected Iterable<Pair<Integer, Z>> initialStates(final MeandersByComponents mbc) {
    return mbc.semiMeanderInitialStates(k -> Boolean.TRUE);
  }

  private int mN = components() - 1;

  @Override
  public Z next() {
    ++mN;
    final SimpleProcessor<Pair<Integer, Z>> processor = new SimpleProcessor<Pair<Integer, Z>>() {
      @Override
      protected Z total(final Iterable<Pair<Pair<Integer, Z>, Z>> counts) {
        Z count = Z.ZERO;
        for (final Pair<Pair<Integer, Z>, Z> e : counts) {
          if (e.left().left() == components()) {
            count = count.add(e.right());
          }
        }
        return count;
      }
    };
    processor.setCreateStateMachine(k -> new MeandersByComponents(k, components()));
    return processor.process(mN, initialStates(new MeandersByComponents(mN, components())));
  }
}
#!queue	A046722	0	->	3	A046721	--------------------------------
package irvine.oeis.a046;

/**
 * A046722 Number of semi-meanders of order n with 3 components.
 * @author Sean A. Irvine
 */
public class A046722 extends A046721 {

  @Override
  protected int components() {
    return 3;
  }
}
#!queue	A046723	0	->	4	A046721	--------------------------------
package irvine.oeis.a046;

/**
 * A046723 Number of semi-meanders of order n with 4 components.
 * @author Sean A. Irvine
 */
public class A046723 extends A046721 {

  @Override
  protected int components() {
    return 4;
  }
}
#!queue	A046724	0	->	5	A046721	--------------------------------
package irvine.oeis.a046;

/**
 * A046724 Number of semi-meanders of order n with 5 components.
 * @author Sean A. Irvine
 */
public class A046724 extends A046721 {

  @Override
  protected int components() {
    return 5;
  }
}
#!queue	A046725	0	->	6	A046721	--------------------------------
package irvine.oeis.a046;

/**
 * A046725 Number of semi-meanders of order n with 6 components.
 * @author Sean A. Irvine
 */
public class A046725 extends A046721 {

  @Override
  protected int components() {
    return 6;
  }
}
#!queue	A046726	0	->	1	A046721	--------------------------------
package irvine.oeis.a046;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.util.Pair;

/**
 * A046726 Triangle of numbers of semi-meanders of order n with k components.
 * @author Sean A. Irvine
 */
public class A046726 extends A046721 {

  private int mN = 0;
  private int mM = 0;
  private Z[] mTotals = null;

  @Override
  public Z next() {
    if (--mM < 1) {
      mM = ++mN;
      mTotals = new Z[mN + 1];
      Arrays.fill(mTotals, Z.ZERO);
      final SimpleProcessor<Pair<Integer, Z>> processor = new SimpleProcessor<Pair<Integer, Z>>() {
        @Override
        protected Z total(final Iterable<Pair<Pair<Integer, Z>, Z>> counts) {
          for (final Pair<Pair<Integer, Z>, Z> e : counts) {
            final int components = e.left().left();
            mTotals[components] = mTotals[components].add(e.right());
          }
          return null; // not used
        }
      };
      processor.setCreateStateMachine(k -> new MeandersByComponents(k, mN + 1));
      processor.process(mN, initialStates(new MeandersByComponents(mN, components())));
    }
    return mTotals[mM];
  }
}
#!queue	A046728	0	->	1	A000230	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A046728 Let p1, p2 be first pair of consecutive primes with difference 2n; let p3, p4 be 2nd such pair; sequence gives "wadi" value p3-p1.
 * @author Sean A. Irvine
 */
public class A046728 extends A000230 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z p1 = super.next();
    // Search for second gap of required size
    Z p3 = mPrime.nextPrime(p1);
    while (true) {
      final Z p4 = mPrime.nextPrime(p3);
      if (p4.subtract(p3).intValueExact() == mGapSize) {
        return p3.subtract(p1);
      }
      p3 = p4;
    }
  }
}
#!queue	A046753	0	->	1	A000367	--------------------------------
package irvine.oeis.a046;

import java.util.TreeSet;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A046753 Prime factors of |numerator(B(2n))| which are &gt;= 2n+3.
 * @author Sean A. Irvine
 */
public class A046753 extends A000367 {

  private final TreeSet<Z> mA = new TreeSet<>();
  private Z mT = Z.THREE;

  @Override
  public Z next() {
    while (mA.isEmpty()) {
      mT = mT.add(2);
      for (final Z p : Jaguar.factor(super.next().abs()).toZArray()) {
        if (p.compareTo(mT) >= 0) {
          mA.add(p);
        }
      }
    }
    return mA.pollFirst();
  }
}
#!queue	A046789	0	->	1	A000230	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A046789 Lower prime of the second gap of 2n between primes.
 * @author Sean A. Irvine
 */
public class A046789 extends A000230 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z p1 = super.next();
    // Search for second gap of required size
    Z p3 = mPrime.nextPrime(p1);
    while (true) {
      final Z p4 = mPrime.nextPrime(p3);
      if (p4.subtract(p3).intValueExact() == mGapSize) {
        return p3;
      }
      p3 = p4;
    }
  }
}
#!queue	A046801	0	->	1	A000225	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A046801 Number of divisors of 2^n-1.
 * @author Sean A. Irvine
 */
public class A046801 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z a = super.next();
    return a.compareTo(Z.TWO) < 0 ? Z.ONE : Jaguar.factor(a).sigma0();
  }
}

#!queue	A046812	0	->	1	A046811	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046812 Number of prime anagrams of A046811(n).
 * @author Sean A. Irvine
 */
public class A046812 extends A046811 {

  @Override
  public Z next() {
    return Z.valueOf(A046810.numberOfPrimeAnagrams(super.next().toString()));
  }
}
#!queue	A046815	0	->	1	A000119	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000045;
import irvine.oeis.a000.A000119;
import irvine.util.array.DynamicLongArray;

/**
 * A046815 Smallest number which can be written as the sum of distinct Fibonacci numbers in n ways and such that the Zeckendorf representation of the number uses only even-subscripted Fibonacci numbers.
 * @author Sean A. Irvine
 */
public class A046815 extends A000119 {

  private final Sequence mFibo = new A000045();
  private long mM = -1;
  private int mN = 0;
  private final DynamicLongArray mFirst = new DynamicLongArray();
  private final DynamicLongArray mFiboCache = new DynamicLongArray();

  private long fibo(final int k) {
    while (k >= mFiboCache.length()) {
      mFiboCache.set(mFiboCache.length(), mFibo.next().longValueExact());
    }
    return mFiboCache.get(k);
  }

  private boolean isEvenIndexZeckendorf(final long n) {
    int k = 1;
    while (fibo(k) <= n) {
      ++k;
    }
    long m = n;
    while (m != 0) {
      final long f = fibo(k);
      if (f > m) {
        --k;
      } else {
        if ((k & 1) == 1) {
          return false;
        }
        m -= f;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    ++mN;
    while (mFirst.get(mN) == 0) {
      ++mM;
      final int v = super.next().intValueExact();
      if (mFirst.get(v) == 0 && isEvenIndexZeckendorf(mM)) {
        mFirst.set(v, mM);
      }
    }
    return Z.valueOf(mFirst.get(mN));
  }
}
#!queue	A046885	0	->	1	A046714	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;

/**
 * A046885 Row sums of triangle A046658.
 * @author Sean A. Irvine
 */
public class A046885 extends A046714 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.TWO : mA.multiply(5);
    return mA.subtract(super.next());
  }
}
#!queue	A046932	2	->	1	A055061	--------------------------------
package irvine.oeis.a046;

import java.util.List;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a055.A055061;

/**
 * A046932 a(n) = period of x^n + x + 1 over GF(2), i.e., the smallest integer m&gt;0 such that x^n + x + 1 divides x^m + 1 over GF(2).
 * @author Sean A. Irvine
 */
public class A046932 extends A055061 {

  private int mN = 0;

  @Override
  public Z next() {
    final long[] c = new long[++mN + 1];
    c[0] = 1;
    c[1] = 1;
    c[mN] = 1;
    final Polynomial<Z> f = Polynomial.create(c);
    final List<Polynomial<Z>> factors = factor(f);
    Z per = Z.ONE;
    for (final Polynomial<Z> p : factors) {
      per = per.lcm(periodIrreducible(p));
    }
    return per;
  }
}
#!queue	A046996	0	->	2	A001181	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.a001.A001181;

/**
 * A046996 Number of Baxter permutations: A001181/2.
 * @author Sean A. Irvine
 */
public class A046996 extends A001181 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A047003	0	->	1	A047000	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047003 T(n,n-1), array T given by A047000.
 * @author Sean A. Irvine
 */
public class A047003 extends A047000 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047004	0	->	2	A047000	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047004 T(n,n-2), array T given by A047000.
 * @author Sean A. Irvine
 */
public class A047004 extends A047000 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047005	0	->	3	A047000	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047005 T(n,n-3), array T given by A047000.
 * @author Sean A. Irvine
 */
public class A047005 extends A047000 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047013	0	->	1	A047010	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047013 T(n,n-1), array T given by A047010.
 * @author Sean A. Irvine
 */
public class A047013 extends A047010 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047014	0	->	2	A047010	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047014 T(n,n-2), array T given by A047010.
 * @author Sean A. Irvine
 */
public class A047014 extends A047010 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047015	0	->	3	A047010	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047015 T(n,n-3), array T given by A047010.
 * @author Sean A. Irvine
 */
public class A047015 extends A047010 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047023	0	->	1	A047020	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047023 T(n,n-1), array T given by A047020.
 * @author Sean A. Irvine
 */
public class A047023 extends A047020 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047024	0	->	2	A047020	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047024 T(n,n-2), array T given by A047020.
 * @author Sean A. Irvine
 */
public class A047024 extends A047020 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047025	0	->	3	A047020	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047025 T(n,n-3), array T given by A047020.
 * @author Sean A. Irvine
 */
public class A047025 extends A047020 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047029	0	->	1	A047020	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047029 T(2n,n), array T given by A047020.
 * @author Sean A. Irvine
 */
public class A047029 extends A047020 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A047033	0	->	1	A047030	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047033 T(n,n-1), array T as in A047030.
 * @author Sean A. Irvine
 */
public class A047033 extends A047030 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047034	0	->	2	A047030	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047034 T(n,n-2), array T as in A047030.
 * @author Sean A. Irvine
 */
public class A047034 extends A047030 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047035	0	->	3	A047030	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047035 T(n,n-3), array T as in A047030.
 * @author Sean A. Irvine
 */
public class A047035 extends A047030 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047043	0	->	1	A047040	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047043 T(n,n-1), array T as in A047040; T(n-1,n), array T given by A047050.
 * @author Sean A. Irvine
 */
public class A047043 extends A047040 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047044	0	->	2	A047040	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047044 T(n,n-2), array T as in A047040; T(n-2,n), array T given by A047050.
 * @author Sean A. Irvine
 */
public class A047044 extends A047040 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047045	0	->	3	A047040	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047045 T(n,n-3), array T as in A047040; T(n-3,n), array T given by A047050.
 * @author Sean A. Irvine
 */
public class A047045 extends A047040 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047063	0	->	1	A047060	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047063 T(n,n-1), array T as in A047060.
 * @author Sean A. Irvine
 */
public class A047063 extends A047060 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047064	0	->	2	A047060	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047064 T(n,n-2), array T as in A047060.
 * @author Sean A. Irvine
 */
public class A047064 extends A047060 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047065	0	->	3	A047060	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047065 T(n,n-3), array T as in A047060.
 * @author Sean A. Irvine
 */
public class A047065 extends A047060 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047087	0	->	1	A047080	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047087 a(n) = A047080(2*n, n+1).
 * @author Sean A. Irvine
 */
public class A047087 extends A047080 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN, mN + 1);
  }
}
#!queue	A047088	0	->	1	A047080	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047088 a(n) = A047080(2*n+1, n+2).
 * @author Sean A. Irvine
 */
public class A047088 extends A047080 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN + 1, mN + 2);
  }
}
#!queue	A047092	0	->	1	A047089	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047092 T(n,n-1), array T as in A047089.
 * @author Sean A. Irvine
 */
public class A047092 extends A047089 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(2 * ++mN - 1, mN);
  }
}
#!queue	A047093	0	->	2	A047089	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047093 T(n,n-2), array T as in A047089.
 * @author Sean A. Irvine
 */
public class A047093 extends A047089 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(2 * ++mN - 2, mN);
  }
}
#!queue	A047094	0	->	3	A047089	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047094 T(n,n-3), array T as in A047089.
 * @author Sean A. Irvine
 */
public class A047094 extends A047089 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(2 * ++mN - 3, mN);
  }
}
#!queue	A047099	0	->	1	A047098	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047099 a(n) = A047098(n)/2.
 * @author Sean A. Irvine
 */
public class A047099 extends A047098 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A047103	0	->	1	A047100	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047103 T(n,n-1), array T as in A047100.
 * @author Sean A. Irvine
 */
public class A047103 extends A047100 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047104	0	->	2	A047100	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047104 T(n,n-2), array T as in A047100.
 * @author Sean A. Irvine
 */
public class A047104 extends A047100 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047105	0	->	3	A047100	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047105 T(n,n-3), array T as in A047100.
 * @author Sean A. Irvine
 */
public class A047105 extends A047100 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047113	0	->	1	A047110	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047113 T(n,n-1), array T as in A047110.
 * @author Sean A. Irvine
 */
public class A047113 extends A047110 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047114	0	->	2	A047110	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047114 T(n,n-2), array T as in A047110.
 * @author Sean A. Irvine
 */
public class A047114 extends A047110 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047115	0	->	3	A047110	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047115 T(n,n-3), array T as in A047110.
 * @author Sean A. Irvine
 */
public class A047115 extends A047110 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047123	0	->	1	A047120	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047123 T(n,n-1), array T as in A047120.
 * @author Sean A. Irvine
 */
public class A047123 extends A047120 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047124	0	->	2	A047120	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047124 T(n,n-2), array T as in A047120.
 * @author Sean A. Irvine
 */
public class A047124 extends A047120 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047125	0	->	3	A047120	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047125 T(n,n-3), array T as in A047120.
 * @author Sean A. Irvine
 */
public class A047125 extends A047120 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047133	0	->	1	A047130	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047133 T(n,n-1), array T as in A047130.
 * @author Sean A. Irvine
 */
public class A047133 extends A047130 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047134	0	->	2	A047130	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047134 T(n,n-2), array T as in A047130.
 * @author Sean A. Irvine
 */
public class A047134 extends A047130 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047135	0	->	3	A047130	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047135 a(n) = T(n,n-3), array T as in A047130.
 * @author Sean A. Irvine
 */
public class A047135 extends A047130 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047143	0	->	1	A047140	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047143 T(n,n-1), array T as in A047140.
 * @author Sean A. Irvine
 */
public class A047143 extends A047140 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047144	0	->	2	A047140	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047144 T(n,n-2), array T as in A047140.
 * @author Sean A. Irvine
 */
public class A047144 extends A047140 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047145	0	->	3	A047140	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047145 T(n,n-3), array T as in A047140.
 * @author Sean A. Irvine
 */
public class A047145 extends A047140 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047153	0	->	1	A047150	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047153 T(n,n-1), array T as in A047150.
 * @author Sean A. Irvine
 */
public class A047153 extends A047150 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A047154	0	->	2	A047150	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047154 T(n,n-2), array T as in A047150.
 * @author Sean A. Irvine
 */
public class A047154 extends A047150 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A047155	0	->	3	A047150	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047155 T(n,n-3), array T as in A047150.
 * @author Sean A. Irvine
 */
public class A047155 extends A047150 {

  private long mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A047171	1	->	0	A047161	--------------------------------
package irvine.oeis.a047;
// Generated by gen_seq4.pl subsele at 2021-04-29 22:59
// DO NOT EDIT here!

/**
 * A047171 Number of nonempty subsets of {1,2,...,n} in which exactly 1/2 of the elements are &lt;= (n-1)/2.
 * @author Georg Fischer
 */
public class A047171 extends A047161 {

  /** Construct the sequence. */
  public A047171() {
    super(0, 1, 2, -1, 2);
  }
}
#!queue	A047662	0	->	1	A008288	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.a008.A008288;

/**
 * A047662 Square array a(n,k) read by antidiagonals: a(n,1)=n, a(1,k)=k, a(n,k)=a(n-1,k-1)+a(n-1,k)+a(n,k-1)+1.
 * @author Sean A. Irvine
 */
public class A047662 extends A008288 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next().divide2();
      if (t.signum() > 0) {
        return t;
      }
    }
  }
}
#!queue	A047676	1	->	0	A047675	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047676 Main diagonal of square array defined in A047675.
 * @author Sean A. Irvine
 */
public class A047676 extends A047675 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A047751	0	->	1	A047749	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047751 Number of dissectable polyhedra with symmetry of type K.
 * @author Sean A. Irvine
 */
public class A047751 extends A047749 {

  private long mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    } else if (mN % 12 != 5) {
      return Z.ZERO;
    } else {
      return super.next();
    }
  }
}

#!queue	A047752	0	->	1	A047749	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047752 Number of dissectable polyhedra with symmetry of type J.
 * @author Sean A. Irvine
 */
public class A047752 extends A047749 {

  private final Sequence mA = new A001764();
  private long mN = 0;

  @Override
  public Z next() {
    if (++mN % 12 != 5) {
      return Z.ZERO;
    } else {
      return mA.next().subtract(super.next()).divide2();
    }
  }
}

#!queue	A047758	0	->	1	A001764	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047758 Number of dissectable polyhedra with symmetry of type G.
 * @author Sean A. Irvine
 */
public class A047758 extends A001764 {

  private final Sequence mA = new A047751();
  private final Sequence mB = new A047752();
  private final Sequence mC = new A047753();
  private long mN = 0;

  @Override
  public Z next() {
    final Z t = mA.next().add(mB.next().multiply2()).add(mC.next().multiply(3));
    if ((++mN & 3) != 1) {
      return Z.ZERO;
    } else {
      return super.next().subtract(t).divide(6);
    }
  }
}

#!queue	A047762	0	->	1	A047749	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A047762 Number of dissectable polyhedra with symmetry of type E.
 * @author Sean A. Irvine
 */
public class A047762 extends A047749 {

  {
    super.next();
  }
  private final Sequence mA = new A047760();
  private final Sequence mB = new A047758();
  private final Sequence mC = new A047754();
  private final Sequence mD = new A047753();
  private final Sequence mE = new A047752();
  private final Sequence mF = new A047751();
  private boolean mEven = true;

  @Override
  public Z next() {
    final Z t = super.next().subtract(mA.next().multiply2()
      .add(mB.next().multiply(6))
      .add(mC.next().multiply2())
      .add(mD.next().multiply(3))
      .add(mE.next().multiply2())
      .add(mF.next())
    );
    mEven = !mEven;
    if (mEven) {
      return Z.ZERO;
    } else {
      return t.divide(4);
    }
  }
}
#!queue	A047764	0	->	1	A047749	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047764 Number of dissectable polyhedra with symmetry of type Q.
 * @author Sean A. Irvine
 */
public class A047764 extends A047749 {

  private long mN = 0;

  @Override
  public Z next() {
    return (++mN % 6) != 2 ? Z.ZERO : super.next();
  }
}

#!queue	A047765	0	->	1	A047749	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A047765 Number of dissectable polyhedra with symmetry of type P.
 * @author Sean A. Irvine
 */
public class A047765 extends A047749 {

  {
    super.next();
  }
  private final Sequence mA = new A047764();
  private boolean mOdd = false;

  @Override
  public Z next() {
    final Z a = mA.next();
    mOdd = !mOdd;
    return mOdd ? Z.ZERO : super.next().subtract(a);
  }
}
#!queue	A047766	0	->	1	A001764	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047766 Number of dissectable polyhedra with symmetry of type O.
 * @author Sean A. Irvine
 */
public class A047766 extends A001764 {

  private final Sequence mA = new A047764();
  private long mN = 0;

  @Override
  public Z next() {
    final Z a = mA.next();
    return (++mN % 6) != 2 ? Z.ZERO : super.next().subtract(a).divide2();
  }
}

#!queue	A047767	0	->	1	A047765	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047767 a(n) = A047765(2n).
 * @author Sean A. Irvine
 */
public class A047767 extends A047765 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A047769	0	->	1	A001764	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047769 Number of dissectable polyhedra with symmetry of type M.
 * @author Sean A. Irvine
 */
public class A047769 extends A001764 {

  {
    super.next();
  }
  private final Sequence mA = new A047764();
  private final Sequence mB = new A047765();
  private final Sequence mC = new A047766();
  private boolean mOdd = false;

  @Override
  public Z next() {
    final Z t = mA.next().add(mB.next()).add(mC.next().multiply2());
    mOdd = !mOdd;
    return mOdd ? Z.ZERO : super.next().subtract(t).divide2();
  }
}
#!queue	A047770	0	->	1	A047769	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047770 a(n) = A047769(2n).
 * @author Sean A. Irvine
 */
public class A047770 extends A047769 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A047771	0	->	1	A001764	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001764;

/**
 * A047771 Number of dissectable polyhedra with symmetry of type L.
 * @author Sean A. Irvine
 */
public class A047771 extends A001764 {

  {
    super.next();
  }
  private final Sequence mA = new A047764();
  private final Sequence mB = new A047765();
  private final Sequence mC = new A047766();
  private boolean mOdd = false;

  @Override
  public Z next() {
    final Z t = mA.next().add(mB.next().multiply(3)).add(mC.next().multiply2());
    mOdd = !mOdd;
    return mOdd ? Z.ZERO : super.next().subtract(t).divide(6);
  }
}

#!queue	A047772	0	->	1	A047771	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047772 Dissections: bisection of A047771.
 * @author Sean A. Irvine
 */
public class A047772 extends A047771 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A047775	0	->	1	A047749	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A047775 Number of dissectable polyhedra with symmetry of type B.
 * @author Sean A. Irvine
 */
public class A047775 extends A047749 {

  {
    super.next();
  }

  private final Sequence mA = new A047773();
  private final Sequence mB = new A047760();
  private final Sequence mC = new A047753();
  private final Sequence mD = new A047751();
  private final Sequence mE = new A047764();
  private final Sequence mF = new A047765();

  @Override
  public Z next() {
    return super.next()
      .subtract(mA.next().multiply2())
      .subtract(mB.next().multiply2())
      .subtract(mC.next())
      .subtract(mD.next())
      .subtract(mE.next())
      .subtract(mF.next())
      .divide2();
  }
}

#!queue	A047809	1	->	0	A000378	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.a000.A000378;

/**
 * A047809 a(n) counts different values of i^2+j^2+k^2 &lt;= n^2 or number of distances from the origin to all integer points inside a sphere of radius n.
 * @author Sean A. Irvine
 */
public class A047809 extends A000378 {

  private Z mA = super.next();
  private long mC = 0;
  private long mN = -1;

  @Override
  public Z next() {
    final Z n2 = Z.valueOf(++mN).square();
    while (mA.compareTo(n2) <= 0) {
      ++mC;
      mA = super.next();
    }
    return Z.valueOf(mC);
  }
}
#!queue	A047893	0	->	1	A000364	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.a000.A000364;

/**
 * A047893 Number of decimal digits of Euler (Zig) numbers A000364: a(n) = ceiling(log_10(|E(2n)|)), where E is Euler's E function.
 * @author Sean A. Irvine
 */
public class A047893 extends A000364 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return Z.ONE.equals(t) ? Z.ZERO : Z.valueOf(t.toString().length());
  }
}
#!queue	A047982	1	->	0	A047980	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;

/**
 * A047982 a(n) = A047980(2n+1).
 *
 * @author Sean A. Irvine
 */
public class A047982 extends A047980 {

  @Override
  public Z next() {
    final Z res = super.next();
    super.next();
    return res;
  }
}
#!queue	A048057	0	->	-2	A058550	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a010.A010839;
import irvine.oeis.a058.A058550;

/**
 * A048057 Fourier coefficients of T_{12}.
 * @author Sean A. Irvine
 */
public class A048057 extends A058550 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048100	0	->	-2	A013974	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a010.A010839;
import irvine.oeis.a013.A013974;

/**
 * A048100 Fourier coefficients of T_{16}.
 * @author Sean A. Irvine
 */
public class A048100 extends A013974 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048101	0	->	-2	A008410	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a008.A008410;
import irvine.oeis.a010.A010839;

/**
 * A048101 Fourier coefficients of T_{18}.
 * @author Sean A. Irvine
 */
public class A048101 extends A008410 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048110	0	->	-2	A013973	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a010.A010839;
import irvine.oeis.a013.A013973;

/**
 * A048110 Fourier coefficients of T_{20}.
 * @author Sean A. Irvine
 */
public class A048110 extends A013973 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048115	0	->	3	A048114	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048115 (1/2)*Sum{T(n,i): i=0,1,...,n}, where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048115 extends A048114 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A048116	0	->	1	A048113	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048116 a(n) = T(2n,n), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048116 extends A048113 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN);
  }
}
#!queue	A048117	0	->	2	A048116	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048117 a(n)=(1/2)*T(2n,n), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048117 extends A048116 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A048119	0	->	2	A048118	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048119 a(n)=(1/2)*T(2n+1,n+1), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048119 extends A048118 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A048120	0	->	1	A048113	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048120 a(n)=T(2n,n+1), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048120 extends A048113 {

  private long mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A048121	0	->	1	A048120	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048121 a(n) = (1/2)*T(2n,n+1), where T is given by A048113.
 * @author Sean A. Irvine
 */
public class A048121 extends A048120 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A048138	1	->	2	A001065	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001065;
import irvine.util.array.LongDynamicIntArray;

/**
 * A048138 a(n) = number of m such that sum of proper divisors of m (A001065(m)) is n.
 * @author Sean A. Irvine
 */
public class A048138 extends A001065 {

  private final LongDynamicIntArray mA = new LongDynamicIntArray();
  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    final long lim = ++mN * mN;
    while (mM <= lim) {
      final long v = super.next().longValueExact();
      mA.set(v, mA.get(v) + 1);
      ++mM;
    }
    return Z.valueOf(mA.get(mN));
  }
}
#!queue	A048145	0	->	-2	A004009	--------------------------------
package irvine.oeis.a048;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a004.A004009;
import irvine.oeis.a010.A010839;

/**
 * A048145 Fourier coefficients of T_{22}.
 * @author Sean A. Irvine
 */
public class A048145 extends A004009 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private final Sequence mDelta2 = new A010839();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mD2 = RING.empty();

  @Override
  public Z next() {
    mD2.add(mDelta2.next());
    mG.add(super.next());
    return RING.coeff(mG, mD2, ++mN);
  }
}
#!queue	A048179	1	->	4	A001430	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001430;

/**
 * A048179 Number of graphs with n nodes and n+1 edges.
 * @author Sean A. Irvine
 */
public class A048179 extends A001430 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return numberLinearGraphs(++mN, mN + 1);
  }
}
#!queue	A048180	1	->	4	A001430	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001430;

/**
 * A048180 Number of graphs with n nodes and n+2 edges.
 * @author Sean A. Irvine
 */
public class A048180 extends A001430 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return numberLinearGraphs(++mN, mN + 2);
  }
}
#!queue	A048202	1	->	2	A004978	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a004.A004978;

/**
 * A048202 a(n)=T(n,2), array T given by A048201.
 * @author Sean A. Irvine
 */
public class A048202 extends A004978 {

  private Z mA = super.next();
  private Z mB = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mB;
    mB = super.next();
    return mB.subtract(t);
  }
}
#!queue	A048203	1	->	3	A004978	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a004.A004978;

/**
 * A048203 a(n)=T(n,3), array T given by A048201.
 * @author Sean A. Irvine
 */
public class A048203 extends A004978 {

  private Z mA = super.next();
  private Z mB = super.next();
  private Z mC = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = mB;
    mB = mC;
    mC = super.next();
    return mC.subtract(t);
  }
}
#!queue	A048292	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048292 1-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048292 extends A001203 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(Z.TEN) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048293	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048293 Positions of 1-digit terms in the continued fraction for Pi (3 is at position 0).
 * @author Sean A. Irvine
 */
public class A048293 extends A001203 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z t = super.next();
      if (t.compareTo(Z.TEN) < 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A048294	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048294 2-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048294 extends A001203 {

  private static final Z UPPER = Z.valueOf(100);

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(Z.TEN) >= 0 && t.compareTo(UPPER) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048384	0	->	1	A048380	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048384 Squares resulting from procedure described in A048383.
 * @author Sean A. Irvine
 */
public class A048384 extends A048380 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isSquare()) {
        return t;
      }
    }
  }
}
#!queue	A048387	0	->	1	A048385	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048387 Squares resulting from procedure described in A048386.
 * @author Sean A. Irvine
 */
public class A048387 extends A048385 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isSquare()) {
        return t;
      }
    }
  }
}
#!queue	A048392	0	->	1	A048390	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048392 Squares resulting from procedure described in A048391.
 * @author Sean A. Irvine
 */
public class A048392 extends A048390 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isSquare()) {
        return t;
      }
    }
  }
}
#!queue	A048394	0	->	1	A048390	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048394 Primes resulting from procedure described in A048393.
 * @author Sean A. Irvine
 */
public class A048394 extends A048390 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A048403	1	->	0	A048408	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048403 Primes with consecutive digits that differ exactly by 6.
 * @author Sean A. Irvine
 */
public class A048403 extends A048408 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.isProbablePrime()) {
        return t;
      }
    }
  }
}
#!queue	A048406	1	->	0	A033068	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.a033.A033068;

/**
 * A048406 Numbers whose consecutive digits differ by 4.
 * @author Sean A. Irvine
 */
public class A048406 extends A033068 {

  @Override
  protected int base() {
    return 10;
  }

  @Override
  protected long diff() {
    return 4;
  }

  @Override
  protected long start() {
    return 0;
  }
}
#!queue	A048407	1	->	0	A048406	--------------------------------
package irvine.oeis.a048;

/**
 * A048407 Numbers whose consecutive digits differ by 5.
 * @author Sean A. Irvine
 */
public class A048407 extends A048406 {

  @Override
  protected long diff() {
    return 5;
  }
}
#!queue	A048408	1	->	0	A048406	--------------------------------
package irvine.oeis.a048;

/**
 * A048408 Numbers whose consecutive digits differ by 6.
 * @author Sean A. Irvine
 */
public class A048408 extends A048406 {

  @Override
  protected long diff() {
    return 6;
  }
}
#!queue	A048409	1	->	0	A048406	--------------------------------
package irvine.oeis.a048;

/**
 * A048409 Numbers whose consecutive digits differ by 7.
 * @author Sean A. Irvine
 */
public class A048409 extends A048406 {

  @Override
  protected long diff() {
    return 7;
  }
}
#!queue	A048410	1	->	0	A048406	--------------------------------
package irvine.oeis.a048;

/**
 * A048410 Numbers whose consecutive digits differ by 8.
 * @author Sean A. Irvine
 */
public class A048410 extends A048406 {

  @Override
  protected long diff() {
    return 8;
  }
}
#!queue	A048456	1	->	0	A047844	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;

/**
 * A048456 First terms from generation 1 onwards.
 * @author Sean A. Irvine
 */
public class A048456 extends A047844 {

  private long mN = 0;

  @Override
  public Z next() {
    return get(1L, ++mN);
  }
}
#!queue	A048461	1	->	0	A047844	--------------------------------
package irvine.oeis.a048;

import java.util.Comparator;
import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;
import irvine.util.Pair;

/**
 * A048461 Numbers in sorted order taken from all generations.
 * @author Sean A. Irvine
 */
public class A048461 extends A047844 {

  private final TreeSet<Pair<Long, Long>> mA = new TreeSet<>(Comparator.comparing((Pair<Long, Long> o) -> get(o.left(), o.right())).thenComparingLong(Pair::left));
  {
    mA.add(new Pair<>(1L, 1L));
  }
  private Z mPrev = Z.ZERO;

  @Override
  public Z next() {
    while (true) {
      final Pair<Long, Long> a = mA.pollFirst();
      mA.add(new Pair<>(a.left() + 1, a.right()));
      mA.add(new Pair<>(a.left(), a.right() + 1));
      final Z t = get(a.left(), a.right());
      if (!t.equals(mPrev)) {
        mPrev = t;
        return t;
      }
    }
  }
}
#!queue	A048462	1	->	0	A047844	--------------------------------
package irvine.oeis.a048;

import java.util.Comparator;
import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;
import irvine.util.Pair;

/**
 * A048462 Odd numbers in sorted order from generation 2 onwards.
 * @author Sean A. Irvine
 */
public class A048462 extends A047844 {

  private final TreeSet<Pair<Long, Long>> mA = new TreeSet<>(Comparator.comparing((Pair<Long, Long> o) -> get(o.left(), o.right())).thenComparingLong(Pair::left));
  {
    mA.add(new Pair<>(1L, 2L));
  }
  private Z mPrev = Z.ZERO;

  @Override
  public Z next() {
    while (true) {
      final Pair<Long, Long> a = mA.pollFirst();
      mA.add(new Pair<>(a.left() + 1, a.right()));
      mA.add(new Pair<>(a.left(), a.right() + 1));
      final Z t = get(a.left(), a.right());
      if (t.isOdd() && !t.equals(mPrev)) {
        mPrev = t;
        return t;
      }
    }
  }
}
#!queue	A048463	1	->	0	A047844	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;

/**
 * A048463 Smallest prime occurring in generation n (0 if none).
 * @author Sean A. Irvine
 */
public class A048463 extends A047844 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z t;
    long m = 0;
    while (m <= mN) {
      t = get(++m, mN);
      if (t.isProbablePrime()) {
        return t;
      }
    }
//    while ((t = get(++m, mN)).isOdd()) {
//      if (t.isProbablePrime()) {
//        return t;
//      }
//    }
    return Z.ZERO;
  }
}
#!queue	A048466	1	->	2	A047844	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a047.A047844;

/**
 * A048466 Total number of primes in "generation" n.
 * @author Sean A. Irvine
 */
public class A048466 extends A047844 {

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    long c = 0;
    long m = 0;
    while (++m <= mN) {
      if (get(m, mN).isProbablePrime()) {
        ++c;
      }
    }
//    while (get(++m, mN).isOdd()) {
//      if (get(m, mN).isProbablePrime()) {
//        ++c;
//      }
//    }
    return Z.valueOf(c);
  }
}
#!queue	A048529	0	->	1	A002378	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002378;
import irvine.util.array.DynamicLongArray;

/**
 * A048529 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 0's.
 * @author Sean A. Irvine
 */
public class A048529 extends A002378 {

  private final DynamicLongArray mFirst = new DynamicLongArray();
  private int mN = 0;
  private long mM = 0; // offset by 1 since we use 0 as sentinel

  protected int digit() {
    return 0;
  }

  @Override
  public Z next() {
    ++mN;
    while (mFirst.get(mN) == 0) {
      ++mM;
      final int zeros = ZUtils.digitCounts(super.next())[digit()];
      if (mFirst.get(zeros) == 0) {
        mFirst.set(zeros, mM);
      }
    }
    return Z.valueOf(mFirst.get(mN) - 1);
  }
}
#!queue	A048530	0	->	1	A002378	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002378;
import irvine.util.array.DynamicArray;

/**
 * A048530 Smallest oblong (promic) number containing exactly n 0's.
 * @author Sean A. Irvine
 */
public class A048530 extends A002378 {

  private final DynamicArray<Z> mFirst = new DynamicArray<>();
  private int mN = 0;

  protected int digit() {
    return 0;
  }

  @Override
  public Z next() {
    ++mN;
    while (mFirst.get(mN) == null) {
      final Z pronic = super.next();
      final int zeros = ZUtils.digitCounts(pronic)[digit()];
      if (mFirst.get(zeros) == null) {
        mFirst.set(zeros, pronic);
      }
    }
    return mFirst.get(mN);
  }
}
#!queue	A048531	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048531 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 1's.
 * @author Sean A. Irvine
 */
public class A048531 extends A048529 {

  @Override
  protected int digit() {
    return 1;
  }
}
#!queue	A048532	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048532 Smallest oblong (promic) number containing exactly n 1's.
 * @author Sean A. Irvine
 */
public class A048532 extends A048530 {

  @Override
  protected int digit() {
    return 1;
  }
}
#!queue	A048533	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048533 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 2's.
 * @author Sean A. Irvine
 */
public class A048533 extends A048529 {

  @Override
  protected int digit() {
    return 2;
  }
}
#!queue	A048534	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048534 Smallest oblong (promic) number containing exactly n 2's.
 * @author Sean A. Irvine
 */
public class A048534 extends A048530 {

  @Override
  protected int digit() {
    return 2;
  }
}
#!queue	A048535	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048535 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 3's.
 * @author Sean A. Irvine
 */
public class A048535 extends A048529 {

  @Override
  protected int digit() {
    return 3;
  }
}
#!queue	A048536	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048536 Smallest oblong (promic) number containing exactly n 3's.
 * @author Sean A. Irvine
 */
public class A048536 extends A048530 {

  @Override
  protected int digit() {
    return 3;
  }
}
#!queue	A048537	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048537 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 4's.
 * @author Sean A. Irvine
 */
public class A048537 extends A048529 {

  @Override
  protected int digit() {
    return 4;
  }
}
#!queue	A048538	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048538 Smallest oblong (promic) number containing exactly n 4's.
 * @author Sean A. Irvine
 */
public class A048538 extends A048530 {

  @Override
  protected int digit() {
    return 4;
  }
}
#!queue	A048539	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048539 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 5's.
 * @author Sean A. Irvine
 */
public class A048539 extends A048529 {

  @Override
  protected int digit() {
    return 5;
  }
}
#!queue	A048540	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048540 Smallest oblong (promic) number containing exactly n 5's.
 * @author Sean A. Irvine
 */
public class A048540 extends A048530 {

  @Override
  protected int digit() {
    return 5;
  }
}
#!queue	A048541	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048541 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 6's.
 * @author Sean A. Irvine
 */
public class A048541 extends A048529 {

  @Override
  protected int digit() {
    return 6;
  }
}
#!queue	A048542	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048542 Smallest oblong (promic) number containing exactly n 6's.
 * @author Sean A. Irvine
 */
public class A048542 extends A048530 {

  @Override
  protected int digit() {
    return 6;
  }
}
#!queue	A048543	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048543 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 7's.
 * @author Sean A. Irvine
 */
public class A048543 extends A048529 {

  @Override
  protected int digit() {
    return 7;
  }
}
#!queue	A048544	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048544 Smallest oblong (promic) number containing exactly n 7's.
 * @author Sean A. Irvine
 */
public class A048544 extends A048530 {

  @Override
  protected int digit() {
    return 7;
  }
}
#!queue	A048545	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048545 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 8's.
 * @author Sean A. Irvine
 */
public class A048545 extends A048529 {

  @Override
  protected int digit() {
    return 8;
  }
}
#!queue	A048546	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048546 Smallest oblong (promic) number containing exactly n 8's.
 * @author Sean A. Irvine
 */
public class A048546 extends A048530 {

  @Override
  protected int digit() {
    return 8;
  }
}
#!queue	A048547	0	->	1	A048529	--------------------------------
package irvine.oeis.a048;

/**
 * A048547 a(n) is the smallest value of m such that A002378(m), the m-th oblong number, contains exactly n 9's.
 * @author Sean A. Irvine
 */
public class A048547 extends A048529 {

  @Override
  protected int digit() {
    return 9;
  }
}
#!queue	A048548	0	->	1	A048530	--------------------------------
package irvine.oeis.a048;

/**
 * A048548 Smallest oblong (promic) number containing exactly n 9's.
 * @author Sean A. Irvine
 */
public class A048548 extends A048530 {

  @Override
  protected int digit() {
    return 9;
  }
}
#!queue	A048550	1	->	0	A048549	--------------------------------
package irvine.oeis.a048;

/**
 * A048550 p(n+1) is next smallest prime beginning with p(n), initial prime is 3.
 * @author Sean A. Irvine
 */
public class A048550 extends A048549 {

  /** Construct the sequence. */
  public A048550() {
    super("3");
  }
}
#!queue	A048551	1	->	0	A048549	--------------------------------
package irvine.oeis.a048;

/**
 * A048551 p(n+1) is next smallest prime beginning with p(n), initial prime is 5.
 * @author Sean A. Irvine
 */
public class A048551 extends A048549 {

  /** Construct the sequence. */
  public A048551() {
    super("5");
  }
}
#!queue	A048552	1	->	0	A048549	--------------------------------
package irvine.oeis.a048;

/**
 * A048552 a(n+1) is next smallest prime beginning with a(n), initial prime is a(0) = 7.
 * @author Sean A. Irvine
 */
public class A048552 extends A048549 {

  /** Construct the sequence. */
  public A048552() {
    super("7");
  }
}
#!queue	A048553	1	->	0	A048549	--------------------------------
package irvine.oeis.a048;

/**
 * A048553 a(n+1) is next smallest prime beginning with a(n), initial prime is 11.
 * @author Sean A. Irvine
 */
public class A048553 extends A048549 {

  /** Construct the sequence. */
  public A048553() {
    super("11");
  }
}
#!queue	A048554	1	->	0	A048549	--------------------------------
package irvine.oeis.a048;

/**
 * A048554 p(n+1) is next smallest prime beginning with p(n), initial prime is 13.
 * @author Sean A. Irvine
 */
public class A048554 extends A048549 {

  /** Construct the sequence. */
  public A048554() {
    super("13");
  }
}
#!queue	A048555	1	->	0	A048549	--------------------------------
package irvine.oeis.a048;

/**
 * A048555 p(n+1) is next smallest prime beginning with p(n), initial prime is 17.
 * @author Sean A. Irvine
 */
public class A048555 extends A048549 {

  /** Construct the sequence. */
  public A048555() {
    super("17");
  }
}
#!queue	A048556	1	->	0	A048549	--------------------------------
package irvine.oeis.a048;

/**
 * A048556 p(n+1) is next smallest prime beginning with p(n), initial prime is 19.
 * @author Sean A. Irvine
 */
public class A048556 extends A048549 {

  /** Construct the sequence. */
  public A048556() {
    super("19");
  }
}
#!queue	A048558	1	->	0	A048557	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048558 a(n+1)^2 is next smallest nontrivial square beginning with a(n)^2, initial square is 1.
 * @author Sean A. Irvine
 */
public class A048558 extends A048557 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}
#!queue	A048559	1	->	0	A048557	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048559 a(n+1) is next smallest nontrivial square beginning with a(n), initial square is 4.
 * @author Sean A. Irvine
 */
public class A048559 extends A048557 {

  /** Construct the sequence. */
  public A048559() {
    super(Z.FOUR);
  }
}
#!queue	A048560	1	->	0	A048559	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048560 a(n+1)^2 is next smallest nontrivial square beginning with a(n)^2, initial square is 4.
 * @author Sean A. Irvine
 */
public class A048560 extends A048559 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}
#!queue	A048561	1	->	0	A048557	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048561 a(n+1) is next smallest nontrivial square beginning with a(n), initial square is 9.
 * @author Sean A. Irvine
 */
public class A048561 extends A048557 {

  /** Construct the sequence. */
  public A048561() {
    super(Z.NINE);
  }
}
#!queue	A048562	1	->	0	A048561	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048562 a(n+1)^2 is next smallest nontrivial square beginning with a(n)^2, initial square is 9.
 * @author Sean A. Irvine
 */
public class A048562 extends A048561 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}
#!queue	A048619	1	->	0	A002944	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001405;
import irvine.oeis.a002.A002944;

/**
 * A048619 a(n) = LCM(binomial(n,0), ..., binomial(n,n)) / binomial(n,floor(n/2)).
 * @author Sean A. Irvine
 */
public class A048619 extends A002944 {

  private final Sequence mA = new A001405();

  @Override
  public Z next() {
    return super.next().divide(mA.next());
  }
}

#!queue	A048633	0	->	1	A001405	--------------------------------
package irvine.oeis.a048;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A048633 Largest squarefree number dividing n-th central binomial coefficient C(n,[ n/2 ]).
 * @author Sean A. Irvine
 */
public class A048633 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).squareFreeKernel();
  }
}
#!queue	A048664	0	->	1	A001168	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001168;

/**
 * A048664 Number of rooted 2-dimensional polyominoes with n square cells, with no symmetries removed.
 * @author Sean A. Irvine
 */
public class A048664 extends A001168 {

  private long mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}
#!queue	A048715	1	->	0	A098941	--------------------------------
package irvine.oeis.a048;
// Generated by gen_seq4.pl parm3 at 2021-06-27 09:47

import irvine.oeis.a098.A098941;

/**
 * A048715 Binary expansion matches (100(0)*)*(0|1|10)?; or, Zeckendorf-like expansion of n using recurrence f(n) = f(n-1) + f(n-3).
 * @author Georg Fischer
 */
public class A048715 extends A098941 {

  /** Construct the sequence. */
  public A048715() {
    super(2, "(100(0)*)*(0|1|10)?");
  }
}
#!queue	A048717	1	->	0	A098941	--------------------------------
package irvine.oeis.a048;
// Generated by gen_seq4.pl parm3 at 2021-06-27 09:47

import irvine.oeis.a098.A098941;

/**
 * A048717 Binary expansion matches ((0)*00(1*)11)*(0*).
 * @author Georg Fischer
 */
public class A048717 extends A098941 {

  /** Construct the sequence. */
  public A048717() {
    super(2, "(11(1)*00(0)*)*(0|11(1)*(0)?)?");
  }
}
#!queue	A048718	1	->	0	A098941	--------------------------------
package irvine.oeis.a048;
// Generated by gen_seq4.pl parm3 at 2021-06-27 09:47

import irvine.oeis.a098.A098941;

/**
 * A048718 Binary expansion matches ((0)*0001)*(0*); or, Zeckendorf-like expansion of n using recurrence f(n) = f(n-1) + f(n-4).
 * @author Georg Fischer
 */
public class A048718 extends A098941 {

  /** Construct the sequence. */
  public A048718() {
    super(2, "(1000(0)*)*(0|1|10|100)?");
  }
}
#!queue	A048719	1	->	0	A098941	--------------------------------
package irvine.oeis.a048;
// Generated by gen_seq4.pl parm3 at 2021-06-27 09:47

import irvine.oeis.a098.A098941;

/**
 * A048719 Binary expansion matches ((0)*0011)*(0*).
 * @author Georg Fischer
 */
public class A048719 extends A098941 {

  /** Construct the sequence. */
  public A048719() {
    super(2, "(1100(0)*)*(0|11(0)?)?");
  }
}
#!queue	A048829	-1	->	0	A048830	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048829 Number of rooted identity game trees of height &lt;=n, first player to reach to reach top wins. Second player wins.
 * @author Sean A. Irvine
 */
public class A048829 extends A048830 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return Z.ONE.shiftLeft(super.next().longValueExact());
  }
}
#!queue	A048830	-1	->	0	A014221	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a014.A014221;

/**
 * A048830 Number of rooted identity game trees of height &lt;=n, first player to reach to reach top wins. First player wins.
 * @author Sean A. Irvine
 */
public class A048830 extends A014221 {

  private final MemorySequence mC = MemorySequence.cachedSequence(new A014221());
  private int mN = 0;

  @Override
  public Z next() {
    if (++mN <= 2) {
      return mN == 1 ? Z.ZERO : Z.ONE;
    }
    return mC.a(mN).subtract(Z.ONE.shiftLeft(mC.a(mN - 1).longValueExact() - mC.a(mN - 2).longValueExact()));
  }
}
#!queue	A048859	0	->	1	A001044	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001044;

/**
 * A048859 A sieve: keep the first 2 numbers, delete the next 3 numbers; keep the next 3 numbers, delete the next 4 numbers; keep the next 4 numbers, delete the next 5 numbers; and so on. In other words, keep the next k numbers and delete the next k+1 numbers, for k = 2, 3, ...
 * @author Sean A. Irvine
 */
public class A048859 extends A001044 {

  private long mN = 2;
  private long mM = 0;
  private long mK = 3;

  @Override
  public Z next() {
    if (--mK == 0) {
      mM += ++mN;
      mK = mN;
    }
    return Z.valueOf(++mM);
  }
}

#!queue	A048882	1	->	0	A035529	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.a035.A035529;

/**
 * A048882 A convolution triangle of numbers obtained from A034255.
 * @author Sean A. Irvine
 */
public class A048882 extends A035529 {

  @Override
  protected long degree() {
    return 4;
  }
}

#!queue	A048888	1	->	0	A048887	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048888 a(n) = Sum{T(m,n+1-m): m=1,2,...,n}, array T as in A048887.
 * @author Sean A. Irvine
 */
public class A048888 extends A048887 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long m = 1; m <= mN; ++m) {
      sum = sum.add(get(mN + 1 - m, m));
    }
    return sum;
  }
}

#!queue	A048955	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048955 Positions of 2-digit terms in the continued fraction for Pi (3 is at position 0).
 * @author Sean A. Irvine
 */
public class A048955 extends A001203 {

  private static final Z UPPER = Z.valueOf(100);
  private long mM = -1;

  @Override
  public Z next() {
    while (true) {
      ++mM;
      final Z t = super.next();
      if (t.compareTo(Z.TEN) >= 0 && t.compareTo(UPPER) < 0) {
        return Z.valueOf(mM);
      }
    }
  }
}
#!queue	A048956	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048956 3-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048956 extends A001203 {

  private static final Z LOWER = Z.valueOf(100);
  private static final Z UPPER = Z.valueOf(1000);

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048957	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048957 Positions of 3-digit terms in the continued fraction for Pi (3 is at position 0).
 * @author Sean A. Irvine
 */
public class A048957 extends A001203 {

  private static final Z LOWER = Z.valueOf(100);
  private static final Z UPPER = Z.valueOf(1000);
  private long mM = -1;

  @Override
  public Z next() {
    while (true) {
      ++mM;
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return Z.valueOf(mM);
      }
    }
  }
}
#!queue	A048958	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048958 4-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048958 extends A001203 {

  private static final Z LOWER = Z.valueOf(1000);
  private static final Z UPPER = Z.valueOf(10000);

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048959	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048959 Positions of 4-digit terms in the continued fraction for Pi (3 is at position 0).
 * @author Sean A. Irvine
 */
public class A048959 extends A001203 {

  private static final Z LOWER = Z.valueOf(1000);
  private static final Z UPPER = Z.valueOf(10000);
  private long mM = -1;

  @Override
  public Z next() {
    while (true) {
      ++mM;
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return Z.valueOf(mM);
      }
    }
  }
}
#!queue	A048960	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048960 5-digit terms in the continued fraction for Pi.
 * @author Sean A. Irvine
 */
public class A048960 extends A001203 {

  private static final Z LOWER = Z.valueOf(10000);
  private static final Z UPPER = Z.valueOf(100000);

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return t;
      }
    }
  }
}
#!queue	A048961	0	->	1	A001203	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.a001.A001203;

/**
 * A048961 Positions of 5-digit terms in the continued fraction for Pi (3 is position 0).
 * @author Sean A. Irvine
 */
public class A048961 extends A001203 {

  private static final Z LOWER = Z.valueOf(10000);
  private static final Z UPPER = Z.valueOf(100000);
  private long mM = -1;

  @Override
  public Z next() {
    while (true) {
      ++mM;
      final Z t = super.next();
      if (t.compareTo(LOWER) >= 0 && t.compareTo(UPPER) < 0) {
        return Z.valueOf(mM);
      }
    }
  }
}
#!queue	A048982	1	->	0	A048868	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;

/**
 * A048982 Number of numbers which have a "prime-rich" reduced residue system (RRS) and binary order n.
 * @author Sean A. Irvine
 */
public class A048982 extends A048868 {

  private Z mA = super.next();
  private Z mUpper = Z.ONE;

  @Override
  public Z next() {
    long cnt = 0;
    while (mA.compareTo(mUpper) <= 0) {
      ++cnt;
      mA = super.next();
    }
    mUpper = mUpper.multiply2();
    return Z.valueOf(cnt);
  }
}

#!queue	A049019	0	->	1	A048996	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a036.A036038;
import irvine.oeis.a048.A048996;

/**
 * A049019 Number of preferential arrangements (onto functions) associated with each numeric partition, partitions in Abramowitz and Stegun order, irregular triangle read by rows.
 * @author Sean A. Irvine
 */
public class A049019 extends A048996 {

  private final Sequence mA = new A036038();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(mA.next());
  }
}
#!queue	A049056	1	->	0	A049055	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049056 Number of minimal ordered covers of a labeled n-set.
 * @author Sean A. Irvine
 */
public class A049056 extends A049055 {

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.add(super.next());
    }
    return sum;
  }
}
#!queue	A049124	1	->	0	A049125	--------------------------------
package irvine.oeis.a049;
// Generated by gen_seq4.pl parm3 at 2021-05-01 20:49
// DO NOT EDIT here!

/**
 * A049124 Revert transform of (-1 + x + x^2)/((x - 1)*(x + 1)).
 * @author Georg Fischer
 */
public class A049124 extends A049125 {

  /** Construct the sequence. */
  public A049124() {
    super(new long[] {-1, +1, +1}, new long[] {-1, +0, +1});
  }
}
#!queue	A049240	0	->	1	A010052	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a010.A010052;

/**
 * A049240 Smallest nonnegative value taken on by x^2 - n*y^2 for an infinite number of integer pairs (x, y).
 * @author Sean A. Irvine
 */
public class A049240 extends A010052 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.ONE.subtract(super.next());
  }
}
#!queue	A049355	1	->	0	A049354	--------------------------------
package irvine.oeis.a049;

/**
 * A049355 Digitally balanced numbers in base 4: equal numbers of 0's, 1's, ... 3's.
 * @author Sean A. Irvine
 */
public class A049355 extends A049354 {

  @Override
  protected int base() {
    return 4;
  }
}
#!queue	A049377	1	->	0	A049352	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049377 Row sums of triangle A049352.
 * @author Sean A. Irvine
 */
public class A049377 extends A049352 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(super.next());
    }
    return sum;
  }
}
#!queue	A049378	1	->	0	A049353	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049378 Row sums of triangle A049353.
 * @author Sean A. Irvine
 */
public class A049378 extends A049353 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(super.next());
    }
    return sum;
  }
}
#!queue	A049402	1	->	0	A049374	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049402 Row sums of triangle A049374.
 * @author Sean A. Irvine
 */
public class A049402 extends A049374 {

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(super.next());
    }
    return sum;
  }
}
#!queue	A049454	1	->	0	A000010	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a000.A000010;

/**
 * A049454 a(n) = 1 + Sum_{i=1..n} phi(i)^2.
 * @author Sean A. Irvine
 */
public class A049454 extends A000010 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.add(super.next().square());
    return mA;
  }
}
#!queue	A049461	1	->	2	A000214	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000214;
import irvine.oeis.a053.A053037;

/**
 * A049461 Number of equivalence classes of self-dual Boolean functions of n variables under action of LSD(n,2).
 * @author Sean A. Irvine
 */
public class A049461 extends A000214 {

  private final Sequence mA = new A053037();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A049575	0	->	1	A000041	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A049575 Prime partition numbers.
 * @author Sean A. Irvine
 */
public class A049575 extends A000041 {

  @Override
  public Z next() {
    while (true) {
      final Z part = super.next();
      if (part.isProbablePrime()) {
        return part;
      }
    }
  }
}

#!queue	A049586	1	->	0	A051953	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a051.A051953;

/**
 * A049586 a(n) is the GCD of the cototients (A051953) of n and n+1.
 * @author Sean A. Irvine
 */
public class A049586 extends A051953 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.gcd(t);
  }
}

#!queue	A049709	0	->	3	A049708	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049709 a(n) = (1/2) * Sum_{i=0..n} T(i,n-i), array T as in A049704.
 * @author Sean A. Irvine
 */
public class A049709 extends A049708 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A049716	3	->	1	A049711	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049716 a(n) = 2*n + 1 - prevprime(2*n + 1).
 * @author Sean A. Irvine
 */
public class A049716 extends A049711 {

  @Override
  public Z next() {
    final Z res = super.next();
    super.next();
    return res;
  }
}
#!queue	A049786	1	->	2	A049783	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049786 a(n) = T(n,n-1), array T as in A049783.
 * @author Sean A. Irvine
 */
public class A049786 extends A049783 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(t(++mN, mN - 1));
  }
}
#!queue	A049787	1	->	3	A049783	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049787 a(n) = T(n,n-2), array T as in A049783.
 * @author Sean A. Irvine
 */
public class A049787 extends A049783 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(t(++mN, mN - 2));
  }
}
#!queue	A049788	1	->	4	A049783	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049788 a(n) = T(n,n-3), array T as in A049783.
 * @author Sean A. Irvine
 */
public class A049788 extends A049783 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(t(++mN, mN - 3));
  }
}
#!queue	A049789	1	->	5	A049783	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049789 a(n) = T(n,n-4), array T as in A049783.
 * @author Sean A. Irvine
 */
public class A049789 extends A049783 {

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(t(++mN, mN - 4));
  }
}
#!queue	A049793	1	->	2	A049790	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049793 a(n) = T(n,n-1), array T as in A049790.
 * @author Sean A. Irvine
 */
public class A049793 extends A049790 {

  private long mN = 0;

  @Override
  public Z next() {
    return ++mN == 1 ? Z.ONE : Z.valueOf(t(mN, mN - 1));
  }
}
#!queue	A049794	1	->	3	A049790	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049794 a(n) = T(n,n-2), array T as in A049790.
 * @author Sean A. Irvine
 */
public class A049794 extends A049790 {

  private long mN = 0;

  @Override
  public Z next() {
    return ++mN <= 2 ? Z.valueOf(mN) : Z.valueOf(t(mN, mN - 2));
  }
}
#!queue	A049795	1	->	4	A049790	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049795 a(n) = T(n,n-3), array T as in A049790.
 * @author Sean A. Irvine
 */
public class A049795 extends A049790 {

  private long mN = 0;

  @Override
  public Z next() {
    return ++mN <= 3 ? Z.valueOf(mN) : Z.valueOf(t(mN, mN - 3));
  }
}
#!queue	A049796	1	->	5	A049790	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049796 a(n) = T(n,n-4), array T as in A049790.
 * @author Sean A. Irvine
 */
public class A049796 extends A049790 {

  private long mN = 0;

  @Override
  public Z next() {
    return ++mN <= 4 ? Z.valueOf(mN) : Z.valueOf(t(mN, mN - 4));
  }
}
#!queue	A049799	1	->	3	A049801	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049799 a(n) = Sum_{k = 3..n} T(n,k), where the array T is A049801.
 * @author Sean A. Irvine
 */
public class A049799 extends A049801 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 1; k <= mN; ++k) {
      sum = sum.add(t(mN, k));
    }
    return sum;
  }
}
#!queue	A049801	1	->	3	A049765	--------------------------------
package irvine.oeis.a049;

/**
 * A049801 Triangular array T, read by rows: T(n,k) = n mod floor(k/3), k = 3..n and n &gt;= 3.
 * @author Sean A. Irvine
 */
public class A049801 extends A049765 {

  @Override
  protected long t(final long n, final long m) {
    return (n + 2) % ((m + 2) / 3);
  }
}
#!queue	A049806	2	->	1	A023022	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a023.A023022;

/**
 * A049806 Number of Farey fractions of order n that are &lt;=1/2; cf. A049805.
 * @author Sean A. Irvine
 */
public class A049806 extends A023022 {

  private Z mSum = null;

  @Override
  public Z next() {
    mSum = mSum == null ? Z.ONE : mSum.add(super.next());
    return mSum;
  }
}
#!queue	A049821	1	->	3	A002859	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.a002.A002859;

/**
 * A049821 a(n) = j + k, where u(n) = u(j) + u(k) is the unique sum of Ulam numbers described in A002859 (with 1 &lt;= j &lt; k &lt; n).
 * @author Sean A. Irvine
 */
public class A049821 extends A002859 {

  // This is not done efficiently

  {
    super.next();
    super.next();
  }

  protected Z select(final int k, final int j) {
    return Z.valueOf(k + j + 2);
  }

  @Override
  public Z next() {
    final Z t = super.next();
    for (int k = mSeq.size() - 2; k >= 0; --k) {
      final Z r = t.subtract(mSeq.get(k));
      for (int j = k - 1; j >= 0; --j) {
        final int c = r.compareTo(mSeq.get(j));
        if (c >= 0) {
          if (c == 0) {
            return select(k, j);
          }
          break;
        }
      }
    }
    throw new RuntimeException();
  }
}
#!queue	A049843	1	->	2	A049816	--------------------------------
package irvine.oeis.a049;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;

/**
 * A049843 Triangular array T read by rows: T(n,k)=number of nonzero remainders when Euclidean algorithm acts on primes p(n) and p(k), k=1,2,...,n-1; n=2,3,4,...
 * @author Sean A. Irvine
 */
public class A049843 extends A049816 {

  private final Fast mPrime = new Fast();
  private long mN = 2;
  private long mM = 0;

  @Override
  public Z next() {
    mM = mPrime.nextPrime(mM);
    if (mM >= mN) {
      mN = mPrime.nextPrime(mN);
      mM = 2;
    }
    return Z.valueOf(t(mN, mM));
  }
}
#!queue	A049844	1	->	2	A049843	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049844 a(n) = Sum_{k=1..n-1} T(n,k), array T as in A049843.
 * @author Sean A. Irvine
 */
public class A049844 extends A049843 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      sum = sum.add(super.next());
    }
    return sum;
  }
}
#!queue	A049846	1	->	2	A049843	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049846 a(n) = Max_{k=1..n-1} T(n,k), array T as in A049843.
 * @author Sean A. Irvine
 */
public class A049846 extends A049843 {

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z max = Z.ZERO;
    for (long k = 0; k < mN; ++k) {
      max = max.max(super.next());
    }
    return max;
  }
}
#!queue	A049847	3	->	2	A049716	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049847 a(n) = (2*n + 1 - prevprime(2*n+1))/2.
 * @author Sean A. Irvine
 */
public class A049847 extends A049716 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A049877	1	->	3	A049821	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049877 a(n) = max(j,k), where u(n) = u(j) + u(k) is the unique sum of Ulam numbers described in A002859 (with 1 &lt;= j &lt; k &lt; n).
 * @author Sean A. Irvine
 */
public class A049877 extends A049821 {

  @Override
  protected Z select(final int k, final int j) {
    return Z.valueOf(k + 1);
  }
}
#!queue	A049878	1	->	3	A049821	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049878 a(n) = min(j,k), where u(n) = u(j) + u(k) is the unique sum of Ulam numbers described in A002859 (with 1 &lt;= j &lt; k &lt; n).
 * @author Sean A. Irvine
 */
public class A049878 extends A049821 {

  @Override
  protected Z select(final int k, final int j) {
    return Z.valueOf(j + 1);
  }
}
#!queue	A049879	1	->	3	A049821	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;

/**
 * A049879 a(n) = |j - k|, where u(n) = u(j) + u(k) is the unique sum of Ulam numbers described in A002859 (with 1 &lt;= j &lt; k &lt; n).
 * @author Sean A. Irvine
 */
public class A049879 extends A049821 {

  @Override
  protected Z select(final int k, final int j) {
    return Z.valueOf(k - j);
  }
}
#!queue	A049881	2	->	3	A049880	--------------------------------
package irvine.oeis.a049;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A049881 a(n) is the number of distinct sums of 3 different primes chosen from the first n primes.
 * @author Sean A. Irvine
 */
public class A049881 extends A049880 {

  protected final TreeSet<Long> mSeen2 = new TreeSet<>();
  private long mP = 3;

  @Override
  public Z next() {
    super.next();
    mP = mPrime.nextPrime(mP);
    for (final long q : mSeen) {
      mSeen2.add(mP + q);
    }
    return Z.valueOf(mSeen2.size());
  }
}
#!queue	A049882	2	->	4	A049881	--------------------------------
package irvine.oeis.a049;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A049882 a(n) is the number of distinct sums of 4 different primes chosen from the first n primes.
 * @author Sean A. Irvine
 */
public class A049882 extends A049881 {

  private final TreeSet<Long> mSeen3 = new TreeSet<>();
  private long mP = 5;

  @Override
  public Z next() {
    super.next();
    mP = mPrime.nextPrime(mP);
    for (final long q : mSeen2) {
      mSeen3.add(mP + q);
    }
    return Z.valueOf(mSeen3.size());
  }
}
#!queue	A050148	1	->	2	A050143	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050148 a(n) = T(n,n-2), array T as in A050143.
 * @author Sean A. Irvine
 */
public class A050148 extends A050143 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN, mN - 2);
  }
}
#!queue	A050149	1	->	3	A050143	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050149 a(n) = T(n,n-3), array T as in A050143.
 * @author Sean A. Irvine
 */
public class A050149 extends A050143 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, mN - 3);
  }
}
#!queue	A050188	0	->	3	A001840	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a001.A001840;

/**
 * A050188 T(n,3), array T as in A050186; a count of aperiodic binary words.
 * @author Sean A. Irvine
 */
public class A050188 extends A001840 {

  @Override
  public Z next() {
    return super.next().multiply(mN + 3);
  }
}
#!queue	A050189	0	->	4	A006918	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a006.A006918;

/**
 * A050189 T(n,4), array T as in A050186; a count of aperiodic binary words.
 * @author Sean A. Irvine
 */
public class A050189 extends A006918 {

  @Override
  public Z next() {
    return super.next().multiply(mN + 4);
  }
}
#!queue	A050191	0	->	6	A011796	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a011.A011796;

/**
 * A050191 T(n,6), array T as in A050186; a count of aperiodic binary words.
 * @author Sean A. Irvine
 */
public class A050191 extends A011796 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().multiply(mN);
  }
}
#!queue	A050369	0	->	1	A074206	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a074.A074206;

/**
 * A050369 Number of ordered factorizations of n into 2 kinds of 2, 3 kinds of 3, ...
 * @author Sean A. Irvine
 */
public class A050369 extends A074206 {

  {
    super.next();
  }
  private long mN = 0;

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}
#!queue	A050640	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050640 a(n+1) is next smallest nontrivial cube containing a(n) as a substring, initial term is 1.
 * @author Sean A. Irvine
 */
public class A050640 extends A000578 {

  {
    super.next(); // skip 0
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.contains(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050641	0	->	1	A050640	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050641 a(n+1)^3 is next smallest nontrivial cube containing a(n)^3 as a substring.
 * @author Sean A. Irvine
 */
public class A050641 extends A050640 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}
#!queue	A050642	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050642 a(n+1) is next smallest nontrivial cube containing a(n) as a substring, initial term is 8.
 * @author Sean A. Irvine
 */
public class A050642 extends A000578 {

  {
    super.next(); // skip 0
    super.next(); // skip 1
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.contains(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050643	0	->	1	A050642	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050643 a(n+1)^3 is next smallest nontrivial cube containing a(n)^3 as a substring, initial term is 8.
 * @author Sean A. Irvine
 */
public class A050643 extends A050642 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}
#!queue	A050644	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050644 a(n+1) is next smallest nontrivial cube containing a(n) as a substring, initial term is 27.
 * @author Sean A. Irvine
 */
public class A050644 extends A000578 {

  {
    super.next(); // skip 0
    super.next(); // skip 1
    super.next(); // skip 8
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.contains(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050645	0	->	1	A050644	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050645 a(n+1)^3 is next smallest nontrivial cube containing a(n)^3 as a substring, initial term is 27.
 * @author Sean A. Irvine
 */
public class A050645 extends A050644 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}
#!queue	A050646	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050646 a(n+1) is next smallest cube ending with a(n), initial term is 1.
 * @author Sean A. Irvine
 */
public class A050646 extends A000578 {

  {
    super.next(); // skip 0
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.endsWith(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050647	0	->	1	A050646	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050647 a(n+1)^3 is next smallest cube ending with a(n)^3, initial term is 1.
 * @author Sean A. Irvine
 */
public class A050647 extends A050646 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}
#!queue	A050648	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050648 a(n+1) is next smallest cube ending with a(n), initial term is 8.
 * @author Sean A. Irvine
 */
public class A050648 extends A000578 {

  {
    super.next(); // skip 0
    super.next(); // skip 1
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.endsWith(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050649	0	->	1	A050648	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050649 a(n+1)^3 is next smallest cube ending with a(n)^3, initial term is 8.
 * @author Sean A. Irvine
 */
public class A050649 extends A050648 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}
#!queue	A050650	0	->	1	A000578	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A050650 a(n+1) is next smallest cube ending with a(n), initial term is 27.
 * @author Sean A. Irvine
 */
public class A050650 extends A000578 {

  {
    super.next(); // skip 0
    super.next(); // skip 1
    super.next(); // skip 8
  }
  private String mS = "";

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (t.mod(10) != 0) {
        final String s = t.toString();
        if (s.endsWith(mS)) {
          mS = s;
          return t;
        }
      }
    }
  }
}
#!queue	A050651	0	->	1	A050650	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;

/**
 * A050651 a(n+1)^3 is next smallest cube ending with a(n)^3, initial term is 27.
 * @author Sean A. Irvine
 */
public class A050651 extends A050650 {

  @Override
  public Z next() {
    return super.next().root(3);
  }
}
#!queue	A050716	1	->	0	A050674	--------------------------------
package irvine.oeis.a050;

/**
 * A050716 Inserting a digit '6' between all adjacent digits of n makes a prime.
 * @author Sean A. Irvine
 */
public class A050716 extends A050674 {

  /** Construct the sequence. */
  public A050716() {
    super('6');
  }
}
#!queue	A050726	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050726 Decimal expansion of 5^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050726 extends A050724 {

  @Override
  protected long multiplier() {
    return 5;
  }
}

#!queue	A050728	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050728 Decimal expansion of 7^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050728 extends A050724 {

  @Override
  protected long multiplier() {
    return 7;
  }
}

#!queue	A050729	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050729 Decimal expansion of 8^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050729 extends A050724 {

  @Override
  protected long multiplier() {
    return 8;
  }
}

#!queue	A050730	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050730 Decimal expansion of 9^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050730 extends A050724 {

  @Override
  protected long multiplier() {
    return 9;
  }
}

#!queue	A050731	1	->	0	A050724	--------------------------------
package irvine.oeis.a050;

/**
 * A050731 Decimal expansion of 11^n contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050731 extends A050724 {

  @Override
  protected long multiplier() {
    return 11;
  }
}

#!queue	A050734	0	->	1	A050733	--------------------------------
package irvine.oeis.a050;

/**
 * A050734 Numbers of form 4^k (values of k see A050725) containing no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050734 extends A050733 {

  @Override
  protected long multiplier() {
    return 4;
  }
}

#!queue	A050767	1	->	0	A050703	--------------------------------
package irvine.oeis.a050;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A050767 Let f(m) = smallest composite number that takes m steps of "add prime factors to number" to reach a prime and g(m) be the prime that is reached. Sequence gives values of g(m), sorted and duplicates removed.
 * @author Sean A. Irvine
 */
public class A050767 extends A050703 {

  private final LongDynamicBooleanArray mSteps = new LongDynamicBooleanArray();
  private final TreeSet<Z> mA = new TreeSet<>();
  private Z mPrev = Z.ZERO;
  private Z mN = Z.ONE;

  @Override
  public Z next() {
    while (mA.isEmpty() || mA.first().compareTo(mN) >= 0) {
      mN = mN.add(1);
      if (!mN.isProbablePrime()) {
        long cnt = 0;
        Z t = mN;
        while (true) {
          ++cnt;
          t = f(t);
          if (t.isProbablePrime()) {
            if (!mSteps.isSet(cnt)) {
              if (t.compareTo(mPrev) > 0) {
                mA.add(t);
              }
              mSteps.set(cnt);
            }
            break;
          }
        }
      }
    }
    mPrev = mA.pollFirst();
    return mPrev;
  }
}
#!queue	A050768	1	->	0	A050703	--------------------------------
package irvine.oeis.a050;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;

/**
 * A050768 Iterated procedure 'composite k added to sum of its prime factors reaches a prime' yields 1 skipped prime.
 * @author Sean A. Irvine
 */
public class A050768 extends A050703 {

  private final Fast mPrime = new Fast();
  private long mN = 1;

  @Override
  public Z next() {
    while (true) {
      final Z n = Z.valueOf(++mN);
      if (!n.isProbablePrime()) {
        Z t = f(n);
        while (!t.isProbablePrime()) {
          t = f(t);
        }
        Z p = n;
        for (int k = 0; k <= iterations() && p.compareTo(t) <= 0; ++k) {
          p = mPrime.nextPrime(p);
        }
        if (t.equals(p)) {
          return n;
        }
      }
    }
  }
}
#!queue	A050769	1	->	0	A050768	--------------------------------
package irvine.oeis.a050;

/**
 * A050769 Iterated procedure 'composite k added to sum of its prime factors reaches a prime' yields 2 skipped primes.
 * @author Sean A. Irvine
 */
public class A050769 extends A050768 {

  @Override
  protected int iterations() {
    return 2;
  }
}
#!queue	A050770	1	->	0	A050768	--------------------------------
package irvine.oeis.a050;

/**
 * A050770 Iterated procedure 'composite k added to sum of its prime factors reaches a prime' yields 3 skipped primes.
 * @author Sean A. Irvine
 */
public class A050770 extends A050768 {

  @Override
  protected int iterations() {
    return 3;
  }
}
#!queue	A050771	1	->	0	A050768	--------------------------------
package irvine.oeis.a050;

/**
 * A050771 Iterated procedure 'composite k added to sum of its prime factors reaches a prime' yields 4 skipped primes.
 * @author Sean A. Irvine
 */
public class A050771 extends A050768 {

  @Override
  protected int iterations() {
    return 4;
  }
}
#!queue	A050777	1	->	0	A050703	--------------------------------
package irvine.oeis.a050;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.util.array.DynamicLongArray;

/**
 * A050777 First occurrence from iterated procedure 'composite k added to sum of its prime factors reaches a prime' yielding n skipped primes.
 * @author Sean A. Irvine
 */
public class A050777 extends A050703 {

  private final DynamicLongArray mFirsts = new DynamicLongArray();
  private final Fast mPrime = new Fast();
  private int mM = 0;
  private long mN = 1;

  @Override
  public Z next() {
    ++mM;
    while (mFirsts.get(mM) == 0) {
      final Z n = Z.valueOf(++mN);
      if (!n.isProbablePrime()) {
        Z t = f(n);
        while (!t.isProbablePrime()) {
          t = f(t);
        }
        Z p = n;
        int cnt = 0;
        while (p.compareTo(t) < 0) {
          p = mPrime.nextPrime(p);
          ++cnt;
        }
        if (mFirsts.get(cnt) == 0) {
          mFirsts.set(cnt, mN);
        }
      }
    }
    return Z.valueOf(mFirsts.get(mM));
  }
}
#!queue	A050943	1	->	0	A034706	--------------------------------
package irvine.oeis.a050;

import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000217;
import irvine.oeis.a034.A034706;

/**
 * A050943 The sum of 2 or more consecutive nonzero triangular numbers.
 * @author Sean A. Irvine
 */
public class A050943 extends A034706 {

  /** Construct the sequence. */
  public A050943() {
    super(2, MemorySequence.cachedSequence(new A000217().skip(1)));
  }
}

#!queue	A051009	0	->	1	A001601	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a001.A001601;

/**
 * A051009 Reduced denominators of Newton's iteration for sqrt(2).
 * @author Sean A. Irvine
 */
public class A051009 extends A001601 {

  @Override
  public Z next() {
    return super.next().square().subtract(1).divide2().sqrt().max(Z.ONE);
  }
}
#!queue	A051059	1	->	0	A048141	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a048.A048141;

/**
 * A051059 a(n) = A048141(3*n+1).
 * @author Sean A. Irvine
 */
public class A051059 extends A048141 {

  @Override
  public Z next() {
    final Z t = super.next();
    super.next();
    super.next();
    return t;
  }
}
#!queue	A051060	1	->	0	A048141	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a048.A048141;

/**
 * A051060 a(n) = A048141(3*n+2).
 * @author Sean A. Irvine
 */
public class A051060 extends A048141 {

  @Override
  public Z next() {
    super.next();
    final Z t = super.next();
    super.next();
    return t;
  }
}
#!queue	A051106	1	->	2	A048601	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a048.A048601;

/**
 * A051106 Second diagonal of triangle A048601.
 * @author Sean A. Irvine
 */
public class A051106 extends A048601 {

  private int mN = 1;

  @Override
  public Z next() {
    return t(++mN, 2);
  }
}
#!queue	A051146	0	->	1	A051145	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051146 Sequence b(n) mentioned in A051145.
 * @author Sean A. Irvine
 */
public class A051146 extends A051145 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return t.or(mA);
  }
}
#!queue	A051177	0	->	1	A000041	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A051177 Perfectly partitioned numbers: numbers k that divide the number of partitions p(k).
 * @author Sean A. Irvine
 */
public class A051177 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A051178	0	->	1	A027423	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a027.A027423;

/**
 * A051178 Numbers k such that k divides the number of divisors of k!.
 * @author Sean A. Irvine
 */
public class A051178 extends A027423 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A051192	0	->	7	A050186	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a050.A050186;

/**
 * A051192 T(n,7), array T as in A050186; a count of aperiodic binary words.
 * @author Sean A. Irvine
 */
public class A051192 extends A050186 {

  private long mN = 6;

  @Override
  public Z next() {
    return t(++mN, 7);
  }
}
#!queue	A051201	0	->	1	A050186	--------------------------------
package irvine.oeis.a051;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a050.A050186;

/**
 * A051201 Sum of elements of the set { [ n/k ] : 1 &lt;= k &lt;= n }.
 * @author Sean A. Irvine
 */
public class A051201 extends A050186 {

  private long mN = 0;

  @Override
  public Z next() {
    final Z m = CR.valueOf(4 * ++mN + 1).sqrt().subtract(CR.ONE).divide(CR.TWO).floor();
    Z sum = m.multiply(m.add(1)).divide2();
    for (long k = 1; k <= mN / (m.longValueExact() + 1); ++k) {
      sum = sum.add(mN / k);
    }
    return sum;
  }
}
#!queue	A051223	0	->	1	A000170	--------------------------------
package irvine.oeis.a051;

import irvine.oeis.a000.A000170;

/**
 * A051223 Number of ways of placing n nonattacking superqueens on an n X n board.
 * @author Sean A. Irvine
 */
public class A051223 extends A000170 {

  // Not really competitive ...

  private static final int[] DELTA_X = {-2, -2, -1, -1, 1, 1, 2, 2};
  private static final int[] DELTA_Y = {1, -1, 2, -2, 2, -2, 1, -1};
  {
    next(); // skip 0
  }

  static boolean isKnightConsistent(final int[] q, final int n) {
    for (int k = 0; k < n; ++k) {
      final int col = q[n];
      for (int d = 0; d < DELTA_X.length; ++d) {
        final int x = col + DELTA_X[d];
        final int y = n + DELTA_Y[d];
        if (x >= 0 && x < q.length && y >= 0 && y < n && q[y] == x) {
          return false;
        }
      }
    }
    return true;
  }

  @Override
  protected boolean isConsistent(final int[] q, final int n) {
    // Check queen-style moves
    if (!super.isConsistent(q, n)) {
      return false;
    }
    // Check knight-style moves
    return isKnightConsistent(q, n);
  }
}
#!queue	A051224	0	->	1	A002562	--------------------------------
package irvine.oeis.a051;

import irvine.oeis.a002.A002562;

/**
 * A051224 Number of ways of placing n nonattacking superqueens on n X n board (symmetric solutions count only once).
 * @author Sean A. Irvine
 */
public class A051224 extends A002562 {

  @Override
  protected boolean isConsistent(final int[] q, final int n) {
    // Check queen-style moves
    if (!super.isConsistent(q, n)) {
      return false;
    }
    // Check knight-style moves
    return A051223.isKnightConsistent(q, n);
  }
}
#!queue	A051241	0	->	1	A000595	--------------------------------
package irvine.oeis.a051;

import irvine.math.IntegerUtils;
import irvine.oeis.a000.A000595;

/**
 * A051241 Number of relations with 5 arguments on n nodes.
 * @author Sean A. Irvine
 */
public class A051241 extends A000595 {

  {
    super.next();
  }

  @Override
  protected int t(final int[] s) {
    int sum = 0;
    for (int i = 1; i < s.length; ++i) {
      for (int j = 1; j < s.length; ++j) {
        final int ij = i * j;
        final int lij = IntegerUtils.lcm(i, j);
        for (int k = 1; k < s.length; ++k) {
          final int ijk = ij * k;
          final int lijk = IntegerUtils.lcm(lij, k);
          for (int l = 1; l < s.length; ++l) {
            final int ijkl = ijk * l;
            final int lijkl = IntegerUtils.lcm(lijk, l);
            for (int m = 1; m < s.length; ++m) {
              final int lcm = IntegerUtils.lcm(lijkl, m);
              sum += (ijkl * m / lcm) * s[i] * s[j] * s[k] * s[l] * s[m];
            }
          }
        }
      }
    }
    return sum;
  }
}
#!queue	A051259	0	->	1	A051258	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051259 Every 25th Fibocyclotomic number.
 * @author Sean A. Irvine
 */
public class A051259 extends A051258 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    for (int k = 0; k < 24; ++k) {
      super.next();
    }
    return super.next();
  }
}
#!queue	A051260	0	->	1	A051259	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051260 Every 25th Fibocyclotomic number divided by 5.
 * @author Sean A. Irvine
 */
public class A051260 extends A051259 {

  @Override
  public Z next() {
    return super.next().divide(5);
  }
}
#!queue	A051350	1	->	0	A141468	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a141.A141468;

/**
 * A051350 Sum of digit-sums of first n nonprimes.
 * @author Sean A. Irvine
 */
public class A051350 extends A141468 {

  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    mA = mA.add(ZUtils.digitSum(super.next()));
    return mA;
  }
}
#!queue	A051417	0	->	1	A025547	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a025.A025547;

/**
 * A051417 Quotients of consecutive values of lcm {1, 3, 5 ..., 2n-1} or A025547(n+1)/A025547(n).
 * @author Sean A. Irvine
 */
public class A051417 extends A025547 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.divide(t);
  }
}
#!queue	A051466	1	->	2	A025487	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.MultiplicativeClosureSequence;
import irvine.oeis.a002.A002110;
import irvine.oeis.a025.A025487;

/**
 * A051466 Largest product of primorials less than A025487(n) that divides A025487(n).
 * @author Sean A. Irvine
 */
public class A051466 extends A025487 {

  {
    super.next();
  }
  private final MemorySequence mA = MemorySequence.cachedSequence(new MultiplicativeClosureSequence(new A002110().skip(1)));

  @Override
  public Z next() {
    final Z t = super.next();
    int k = -1;
    Z res = Z.ONE;
    while (true) {
      final Z a = mA.a(++k);
      if (a.compareTo(t) >= 0) {
        break;
      }
      if (t.mod(a).isZero()) {
        res = a;
      }
    }
    return res;
  }
}
#!queue	A051474	1	->	0	A014450	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014450;

/**
 * A051474 (Terms in A014450)/2.
 * @author Georg Fischer
 */
public class A051474 extends A014450 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A051475	1	->	0	A014472	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014472;

/**
 * A051475 (Terms in A014472)/2.
 * @author Georg Fischer
 */
public class A051475 extends A014472 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A051476	1	->	0	A014733	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014733;

/**
 * A051476 (Terms in A014733)/4.
 * @author Georg Fischer
 */
public class A051476 extends A014733 {

  @Override
  public Z next() {
    return super.next().divide(4);
  }
}
#!queue	A051477	1	->	0	A014759	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014759;

/**
 * A051477 (Terms in A014759)/4.
 * @author Georg Fischer
 */
public class A051477 extends A014759 {

  @Override
  public Z next() {
    return super.next().divide(4);
  }
}
#!queue	A051514	1	->	0	A014762	--------------------------------
package irvine.oeis.a051;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a014.A014762;

/**
 * A051514 (Terms in A014762)/4.
 * @author Georg Fischer
 */
public class A051514 extends A014762 {

  @Override
  public Z next() {
    return super.next().divide(4);
  }
}
#!queue	A051541	0	->	1	A051539	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051541 Quotients of consecutive values of LCM {1, 5, 9, 13, 17, ..., (4n+1)}.
 * @author Sean A. Irvine
 */
public class A051541 extends A051539 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.divide(t);
  }
}
#!queue	A051544	0	->	1	A051536	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051544 Quotients of consecutive values of lcm {1, 4, 7, 10, 13 ...,(3n+1)} (A016777).
 * @author Sean A. Irvine
 */
public class A051544 extends A051536 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.divide(t);
  }
}
#!queue	A051548	1	->	0	A000005	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a000.A000005;

/**
 * A051548 a(n) = LCM { tau(1), ..., tau(n) }, a(0) = 1.
 * @author Sean A. Irvine
 */
public class A051548 extends A000005 {

  private Z mLcm = null;

  @Override
  public Z next() {
    mLcm = mLcm == null ? Z.ONE : mLcm.lcm(super.next());
    return mLcm;
  }
}
#!queue	A051549	1	->	0	A000203	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A051549 a(n) = LCM { sigma(1), ..., sigma(n) }.
 * @author Sean A. Irvine
 */
public class A051549 extends A000203 {

  private Z mLcm = Z.ONE;

  @Override
  public Z next() {
    mLcm = mLcm.lcm(super.next());
    return mLcm;
  }
}
#!queue	A051552	0	->	1	A051540	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051552 Quotients of consecutive values of LCM {b(0), b(1) ...,b(n)}, b() = A016789.
 * @author Sean A. Irvine
 */
public class A051552 extends A051540 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.divide(t);
  }
}
#!queue	A051640	0	->	2	A000244	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a000.A000244;

/**
 * A051640 a(n) contains the digit b-1 in all bases b from 2 to n.
 * @author Sean A. Irvine
 */
public class A051640 extends A000244 {

  private long mN = 1;
  private long mM = 1;

  private boolean isOk(final long n, final long b) {
    long m = n;
    while (m != 0) {
      if (m % b == b - 1) {
        return true;
      }
      m /= b;
    }
    return false;
  }

  private boolean is(final long n, final long b) {
    for (long k = b; k >= 2; --k) {
      if (!isOk(n, k)) {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    ++mN;
    while (!is(mM, mN)) {
      ++mM;
    }
    return Z.valueOf(mM);
  }
}
#!queue	A051642	1	->	0	A001097	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a001.A001097;

/**
 * A051642 Values of A (the short leg) of a Pythagorean triangle with A and C (the hypotenuse) both prime and part of a twin prime.
 * @author Sean A. Irvine
 */
public class A051642 extends A001097 {

  @Override
  public Z next() {
    while (true) {
      final Z a = super.next();
      final Z u = a.add(1).divide2();
      final Z c = u.square().multiply(2).subtract(u.multiply(2)).add(1);
      if (c.isProbablePrime() && (c.add(2).isProbablePrime() || c.subtract(2).isProbablePrime())) {
        final Z b = u.multiply(2).multiply(u.subtract(1));
        if (a.square().add(b.square()).equals(c.square())) {
          return a;
        }
      }
    }
  }
}
#!queue	A051643	1	->	0	A047812	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a047.A047812;

/**
 * A051643 Central elements in Parker's partition triangle.
 * @author Sean A. Irvine
 */
public class A051643 extends A047812 {

  private int mN = -1;

  @Override
  public Z next() {
    mN += 2;
    return get(mN).coeff(mN * mN / 2);
  }
}
#!queue	A051671	1	->	0	A048559	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a048.A048559;

/**
 * A051671 Smallest positive number whose digits concatenated with all previous terms forms a perfect square.
 * @author Sean A. Irvine
 */
public class A051671 extends A048559 {

  private String mA = "";

  @Override
  public Z next() {
    final String t = mA;
    mA = super.next().toString();
    return new Z(mA.substring(t.length()));
  }
}

#!queue	A051677	0	->	1	A000332	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000292;
import irvine.oeis.a000.A000332;

/**
 * A051677 Tetrahedron-tree numbers: a(n)=sum(b(m),m=1..n), b(m)=1, 1,3, 1,3,6, 1,3,6,10,..., 1,2,...,i*(i+1)2.
 * @author Sean A. Irvine
 */
public class A051677 extends A000332 {

  private final MemorySequence mA = MemorySequence.cachedSequence(new A000292());
  {
    super.next();
    super.next();
    super.next();
  }
  private Z mT = super.next();
  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      mT = super.next();
      mM = 0;
      ++mN;
    }
    return mT.add(mA.a(mM));
  }
}
#!queue	A051678	0	->	1	A002415	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000330;
import irvine.oeis.a002.A002415;

/**
 * A051678 Square-pyramid-tree numbers: a(n) = sum(b(m),m=1..n), b(m) = 1^2, 1^2,2^2, 1^2,2^2,3^2,.. = (A002260)^2.
 * @author Sean A. Irvine
 */
public class A051678 extends A002415 {

  private final MemorySequence mA = MemorySequence.cachedSequence(new A000330());
  {
    super.next();
  }
  private Z mT = super.next();
  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      mT = super.next();
      mM = 0;
      ++mN;
    }
    return mT.add(mA.a(mM));
  }
}
#!queue	A051684	0	->	1	A001464	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a001.A001464;

/**
 * A051684 Auxiliary sequence for calculation of number of even permutations of degree n and order exactly 2.
 * @author Sean A. Irvine
 */
public class A051684 extends A001464 {

  {
    super.next();
  }
  private boolean mSign = true;

  @Override
  public Z next() {
    mSign = !mSign;
    return Z.NEG_ONE.signedAdd(mSign, super.next());
  }
}
#!queue	A051754	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051754 Consider problem of placing N queens on an n X n board so that each queen attacks precisely 1 other. Sequence gives maximal number of queens.
 * @author Sean A. Irvine
 */
public class A051754 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    solve(++mN, 1);
    return Z.valueOf(mMaximalQueens);
  }
}
#!queue	A051756	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051756 Consider the problem of placing N queens on an n X n board so that each queen attacks precisely 3 others. Sequence gives maximal number of queens.
 * @author Sean A. Irvine
 */
public class A051756 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    solve(++mN, 3);
    return Z.valueOf(mMaximalQueens);
  }
}
#!queue	A051757	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051757 Consider problem of placing A051754(n) queens on an n X n board so that each queen attacks precisely 1 other. Sequence gives number of solutions up to square symmetry.
 * @author Sean A. Irvine
 */
public class A051757 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    return Z.valueOf(solve(++mN, 1));
  }
}
#!queue	A051758	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051758 Consider problem of placing A051755(n) queens on an n X n board so that each queen attacks precisely 2 others. Sequence gives number of solutions up to square symmetry.
 * @author Sean A. Irvine
 */
public class A051758 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    return Z.valueOf(solve(++mN, 2));
  }
}
#!queue	A051759	3	->	2	A019654	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a019.A019654;

/**
 * A051759 Consider the problem of placing A051756(n) queens on an n X n board so that each queen attacks precisely 3 others. Sequence gives number of solutions up to square symmetry.
 * @author Sean A. Irvine
 */
public class A051759 extends A019654 {

  private int mN = 1;

  @Override
  public Z next() {
    return Z.valueOf(solve(++mN, 3));
  }
}
#!queue	A051776	0	->	1	A051775	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051776 Table T(n,m) = Nim-product of n and m, read by antidiagonals, for n &gt;= 1, m &gt;= 1.
 * @author Sean A. Irvine
 */
public class A051776 extends A051775 {

  private Z mN = Z.ONE;
  private Z mM = Z.ZERO;

  @Override
  public Z next() {
    mM = mM.subtract(1);
    if (mM.signum() <= 0) {
      mM = mN;
      mN = mN.add(1);
    }
    return get(mN.subtract(mM), mM);
  }
}
#!queue	A051841	0	->	1	A001037	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000048;
import irvine.oeis.a001.A001037;

/**
 * A051841 Number of binary Lyndon words with an even number of 1's.
 * @author Sean A. Irvine
 */
public class A051841 extends A001037 {

  private final Sequence mA = new A000048();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A051906	0	->	1	A007705	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;
import irvine.oeis.a007.A007705;

/**
 * A051906 Number of ways of placing n nonattacking queens on an n X n toroidal chessboard.
 * @author Sean A. Irvine
 */
public class A051906 extends A007705 {

  private boolean mEven = false;

  @Override
  public Z next() {
    mEven = !mEven;
    return mEven ? super.next() : Z.ZERO;
  }
}
#!queue	A051911	0	->	1	A051775	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051911 Triangle T(n,m) = Nim-product of n and m, read by rows, 1&lt;=n&lt;=m.
 * @author Sean A. Irvine
 */
public class A051911 extends A051775 {

  private Z mN = Z.ZERO;
  private Z mM = Z.ZERO;

  @Override
  public Z next() {
    mM = mM.add(1);
    if (mM.compareTo(mN) > 0) {
      mN = mN.add(1);
      mM = Z.ONE;
    }
    return get(mN, mM);
  }
}
#!queue	A051917	0	->	1	A051775	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Z;

/**
 * A051917 Inverse of n under Nim (or Conway) multiplication.
 * @author Sean A. Irvine
 */
public class A051917 extends A051775 {

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    Z m = Z.ZERO;
    while (true) {
      m = m.add(1);
      if (Z.ONE.equals(get(mN, m))) {
        return m;
      }
    }
  }
}
#!queue	A052001	0	->	1	A000041	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A052001 Even partition numbers.
 * @author Sean A. Irvine
 */
public class A052001 extends A000041 {

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.isEven()) {
        return p;
      }
    }
  }
}
#!queue	A052002	0	->	1	A000041	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A052002 Numbers with an odd number of partitions.
 * @author Sean A. Irvine
 */
public class A052002 extends A000041 {

  @Override
  public Z next() {
    while (super.next().isEven()) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A052003	0	->	1	A000041	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A052003 Odd partition numbers.
 * @author Sean A. Irvine
 */
public class A052003 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.isOdd()) {
        return p;
      }
    }
  }
}
#!queue	A052048	1	->	0	A052047	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;

/**
 * A052048 Cubes whose digits occur with the same frequency.
 * @author Sean A. Irvine
 */
public class A052048 extends A052047 {

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}

#!queue	A052062	1	->	0	A052061	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;

/**
 * A052062 Squares containing no palindromic substring except single digits.
 * @author Sean A. Irvine
 */
public class A052062 extends A052061 {

  @Override
  public Z next() {
    return super.next().square();
  }
}

#!queue	A052170	1	->	0	A333361	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a333.A333361;

/**
 * A052170 Number of directed loopless multigraphs with n arcs.
 * @author Sean A. Irvine
 */
public class A052170 extends A333361 {

  private int mN = -1;

  @Override
  public Z next() {
    return g(2 * ++mN, mN).coeff(mN);
  }
}
#!queue	A052171	1	->	0	A138107	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a138.A138107;

/**
 * A052171 Number of directed multigraphs with loops on an infinite set of nodes containing a total of n arcs.
 * @author Sean A. Irvine
 */
public class A052171 extends A138107 {

  private int mN = -1;

  @Override
  public Z next() {
    return g(2 * ++mN, mN).coeff(mN);
  }
}
#!queue	A052186	1	->	0	A006932	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a006.A006932;

/**
 * A052186 Number of permutations of [n] with no strong fixed points.
 * @author Sean A. Irvine
 */
public class A052186 extends A006932 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    final Z t = super.next();
    return mF.subtract(t);
  }
}

#!queue	A052216	0	->	1	A055235	--------------------------------
package irvine.oeis.a052;
// Generated by gen_seq4.pl parm2 at 2021-10-18 12:36

import irvine.oeis.a055.A055235;

/**
 * A052216 Sum of two powers of 10.
 * @author Georg Fischer
 */
public class A052216 extends A055235 {

  /** Construct the sequence. */
  public A052216() {
    super(10);
  }
}
#!queue	A052246	1	->	0	A000422	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a000.A000422;

/**
 * A052246 Concatenation of integers from n down to 0.
 * @author Sean A. Irvine
 */
public class A052246 extends A000422 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().multiply(10);
  }
}

#!queue	A052265	1	->	0	A052107	--------------------------------
package irvine.oeis.a052;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.IntegerUtils;
import irvine.math.Mobius;
import irvine.math.group.PolynomialRing;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A052265 Triangle giving T(n,r) = number of equivalence classes of Boolean functions of n variables and range r=0..2^n under action of symmetric group.
 * @author Sean A. Irvine
 */
public class A052265 extends A052107 {

  // After Andrew Howroyd

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = 0;
  private int mM = -1;
  private Z mF = Z.ONE;
  private Polynomial<Z> mRow = RING.onePlusXToTheN(1);

  private Polynomial<Z> fix(final int[] q) {
    final Z lcm = IntegerUtils.lcm(q);
    final ArrayList<Z> u = new ArrayList<>();
    final Z[] v = Jaguar.factor(lcm).divisors();
    for (final Z d : v) {
      int w = 0;
      for (final int j : q) {
        final int g = IntegerUtils.gcd(d.intValueExact(), j);
        w += g;
      }
      u.add(Z.ONE.shiftLeft(w));
    }
    Polynomial<Z> prod = RING.one();
    for (int i = 0; i < v.length; ++i) {
      final int t = v[i].intValue();
      int sum = 0;
      for (int j = 0; j <= i; ++j) {
        if (v[i].mod(v[j]).isZero()) {
          final int d = v[i].divide(v[j]).intValueExact();
          final int mu = Mobius.mobius(d);
          sum += mu * u.get(j).intValueExact();
        }
      }
      prod = RING.multiply(prod, RING.pow(RING.onePlusXToTheN(t), sum / t));
    }
    return prod;
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      if (++mN > 1) {
        mF = mF.multiply(mN);
      }
      mM = 0;
      mRow = RING.zero();
      final IntegerPartition part = new IntegerPartition(mN);
      int[] p;
      while ((p = part.next()) != null) {
        mRow = RING.add(mRow, RING.multiply(fix(p), IntegerPartition.permCount(p, 1)));
      }
    }
    return mRow.coeff(mM).divide(mF);
  }
}
#!queue	A052283	1	->	0	A052107	--------------------------------
package irvine.oeis.a052;

import irvine.math.IntegerUtils;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;

/**
 * A052283 Triangle read by rows: T(n,k) is the number of unlabeled directed graphs on n nodes with k arcs, k=0..n*(n-1).
 * @author Sean A. Irvine
 */
public class A052283 extends A052107 {

  // After Andrew Howroyd

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private Polynomial<Z> mRow = RING.zero();
  protected int mK = -1;
  protected int mM = 0;

  private Polynomial<Z> edgesPoly(final int[] v) {
    Polynomial<Z> prod = RING.one();
    for (int i = 1; i < v.length; ++i) {
      for (int j = 0; j < i; ++j) {
        final int g = IntegerUtils.gcd(v[i], v[j]);
        prod = RING.multiply(prod, RING.pow(RING.onePlusXToTheN(v[i] * v[j] / g), 2L * g));
      }
    }
    for (final int j : v) {
      prod = RING.multiply(prod, RING.pow(RING.onePlusXToTheN(j), j - 1));
    }
    return prod;
  }

  protected Polynomial<Z> g(final int n) {
    Polynomial<Z> row = RING.zero();
    final IntegerPartition part = new IntegerPartition(n);
    int[] p;
    while ((p = part.next()) != null) {
      row = RING.add(row, RING.multiply(edgesPoly(p), IntegerPartition.permCount(p, 1)));
    }
    return RING.divide(row, mF.factorial(n));
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      if (++mK <= 1) {
        return Z.ONE;
      }
      mRow = g(mK);
      mM = 0;
    }
    return mRow.coeff(mM);
  }
}
#!queue	A052309	0	->	1	A048805	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a048.A048805;

/**
 * A052309 Column 1 of triangle A052308.
 * @author Sean A. Irvine
 */
public class A052309 extends A048805 {

  private boolean mFirst = true;

  /** Construct the sequence. */
  public A052309() {
    super(new A052307());
  }

  @Override
  public Z next() {
    step();
    final Z res = super.next();
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return res;
  }
}
#!queue	A052312	0	->	1	A048805	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a047.A047996;
import irvine.oeis.a048.A048805;

/**
 * A052312 Column 1 of triangle A052311.
 * @author Sean A. Irvine
 */
public class A052312 extends A048805 {

  private boolean mFirst = true;

  /** Construct the sequence. */
  public A052312() {
    super(new A047996());
  }

  @Override
  public Z next() {
    step();
    final Z res = super.next();
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return res;
  }
}
#!queue	A052317	1	->	0	A052316	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A052317 Number of labeled trees with n nodes and 2-colored internal (non-leaf) nodes.
 * @author Sean A. Irvine
 */
public class A052317 extends A052316 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mB = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Q.ZERO);
      return Z.ONE;
    }
    mF = mF.multiply(mN);
    mB.add(new Q(super.next(), mF));
    final Q t = mB.get(mN).subtract(mB.get(mN - 1)).subtract(RING.pow(mB, 2, mN).coeff(mN).divide(2));
    return t.multiply(mF).toZ();
  }
}

#!queue	A052319	0	->	1	A006882	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A052319 Number of increasing rooted trimmed trees with n nodes.
 * @author Sean A. Irvine
 */
public class A052319 extends A006882 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> NEG_X = RING.negate(RING.x());
  private final Polynomial<Q> mBPrime = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN > 0) {
      mBPrime.add(new Q(super.next(), mF));
      mF = mF.multiply(mN);
    }
    final Polynomial<Q> b = RING.add(RING.one(), RING.integrate(mBPrime));
    return RING.coeff(RING.one(), RING.substitute(b, NEG_X, mN), mN).multiply(mF).toZ();
  }
}
#!queue	A052320	1	->	0	A052318	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A052320 Number of labeled trimmed trees with n nodes.
 * @author Sean A. Irvine
 */
public class A052320 extends A052318 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mB = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Q.ZERO);
      return Z.ONE;
    }
    mF = mF.multiply(mN);
    mB.add(new Q(super.next(), mF));
    if (mN <= 2) {
      return Z.ONE; // avoid need for "corrections" to e.g.f.
    } else if (mN == 3) {
      return Z.ZERO;
    } else if (mN == 4) {
      return Z.FOUR;
    } else {
      final Q t = mB.get(mN).subtract(RING.pow(mB, 2, mN).coeff(mN).divide(2));
      return t.multiply(mF).toZ();
    }
  }
}
#!queue	A052323	1	->	0	A052322	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A052323 Number of labeled trees with a forbidden limb of length 3.
 * @author Sean A. Irvine
 */
public class A052323 extends A052322 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Z[] SMALL = {Z.ONE, Z.ONE, Z.ONE, Z.THREE, Z.FOUR, Z.valueOf(65), Z.valueOf(576)};
  private final Polynomial<Q> mB = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mB.add(Q.ZERO);
      return Z.ONE;
    }
    mF = mF.multiply(mN);
    mB.add(new Q(super.next(), mF));
    if (mN < SMALL.length) {
      return SMALL[mN]; // avoid need for "corrections" to e.g.f.
    } else {
      final Q t = mB.get(mN).subtract(RING.pow(mB, 2, mN).coeff(mN).divide(2));
      return t.multiply(mF).toZ();
    }
  }
}
#!queue	A052324	1	->	0	A052318	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A052324 Number of increasing rooted trees with a forbidden limb of length 3.
 * @author Sean A. Irvine
 */
public class A052324 extends A052318 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> X3 = RING.monomial(new Q(1, 6), 3);
  private Polynomial<Q> mA = RING.zero();
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    mF = mF.multiply(mN);
    mA = RING.integrate(RING.exp(RING.subtract(mA, X3), mN));
    return mA.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A052338	0	->	1	A050443	--------------------------------
package irvine.oeis.a052;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a050.A050443;

/**
 * A052338 a(n) = A050443(n-th prime)/(n-th prime).
 * @author Sean A. Irvine
 */
public class A052338 extends A050443 {

  private final Fast mPrime = new Fast();
  protected long mN = -1;

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (mPrime.isPrime(++mN)) {
        return t.divide(mN);
      }
    }
  }
}
#!queue	A052366	1	->	0	A318795	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a318.A318795;

/**
 * A052366 Number of nonnegative integer 4 X 4 matrices with sum of elements equal to n, under row and column permutations.
 * @author Sean A. Irvine
 */
public class A052366 extends A318795 {

  private int mN = -1;

  @Override
  public Z next() {
    return m(4, 4, ++mN);
  }
}
#!queue	A052367	1	->	0	A318795	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a318.A318795;

/**
 * A052367 Number of nonnegative integer 5 X 5 matrices with sum of elements equal to n, under row and column permutations.
 * @author Sean A. Irvine
 */
public class A052367 extends A318795 {

  private int mN = -1;

  @Override
  public Z next() {
    return m(5, 5, ++mN);
  }
}
#!queue	A052371	1	->	0	A052107	--------------------------------
package irvine.oeis.a052;

import irvine.math.IntegerUtils;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A052371 Triangle T(n,k) of n X n binary matrices with k=0...n^2 ones up to row and column permutations.
 * @author Sean A. Irvine
 */
public class A052371 extends A052107 {

  // After Andrew Howroyd

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private Polynomial<Q> mRow = RING.zero();
  private int mN = -1;
  private int mM = 0;

  private Polynomial<Q> c(final int[] p, final int[] q) {
    Polynomial<Q> prod = RING.one();
    for (final int j : q) {
      for (final int i : p) {
        final Polynomial<Q> f = RING.pow(RING.onePlusXToTheN(IntegerUtils.lcm(i, j)), IntegerUtils.gcd(i, j));
        prod = RING.multiply(prod, f);
      }
    }
    return prod;
  }

  /*
  c(p, q)={prod(i=1, #p, prod(j=1, #q, (1 + x^lcm(p[i], q[j]))^gcd(p[i], q[j])))}

row(n)={my(s=0); forpart(p=n, forpart(q=n, s+=permcount(p) * permcount(q) * c(p, q))); Vec(s/(n!^2))}

for(n=1, 5, print(row(n)))
   */

  protected Polynomial<Q> row(final int n) {
    Polynomial<Q> sum = RING.zero();
    final IntegerPartition part = new IntegerPartition(n);
    int[] q;
    while ((q = part.next()) != null) {
      final Z pcq = IntegerPartition.permCount(q, 1);
      final IntegerPartition part2 = new IntegerPartition(n);
      int[] p;
      while ((p = part2.next()) != null) {
        sum = RING.add(sum, RING.multiply(c(p, q), new Q(IntegerPartition.permCount(p, 1).multiply(pcq))));
      }
    }
    return RING.multiply(sum, new Q(Z.ONE, mF.factorial(n).square()));
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      if (++mN == 0) {
        return Z.ONE;
      }
      mRow = row(mN);
      mM = 0;
    }
    return mRow.coeff(mM).toZ();
  }
}
#!queue	A052372	1	->	0	A318795	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a318.A318795;

/**
 * A052372 Number of nonnegative integer 6 X 6 matrices with sum of elements equal to n, under row and column permutations.
 * @author Sean A. Irvine
 */
public class A052372 extends A318795 {

  private int mN = -1;

  @Override
  public Z next() {
    return m(6, 6, ++mN);
  }
}
#!queue	A052373	1	->	0	A318795	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a318.A318795;

/**
 * A052373 Number of nonnegative integer 7 X 7 matrices with sum of elements equal to n, under row and column permutations.
 * @author Sean A. Irvine
 */
public class A052373 extends A318795 {

  private int mN = -1;

  @Override
  public Z next() {
    return m(7, 7, ++mN);
  }
}
#!queue	A052434	1	->	2	A000720	--------------------------------
package irvine.oeis.a052;

import irvine.math.Mobius;
import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A052434 Nearest integer to R(n) - pi(n), where R(x) is the Riemann prime counting function.
 * @author Sean A. Irvine
 */
public class A052434 extends A000720 {

  // This is slow ... and heuristic ...

  private static final long HEURISTIC_TERMS = 10000;

  private long mN = 1;
  {
    super.next();
  }

  protected CR riemann(final long n) {
    return new CR() {
      @Override
      protected Z approximate(final int precision) {
        final CR ncr = CR.valueOf(n);
        Z sum = Z.ZERO;
        long k = 0;
        while (true) {
          final CR kcr = CR.valueOf(++k);
          final Z t = ncr.pow(kcr.inverse()).li().divide(kcr).getApprox(precision);
          if (t.isZero() || k > HEURISTIC_TERMS) {
            break;
          }
          final int mobius = Mobius.mobius(k);
          if (mobius != 0) {
            sum = sum.signedAdd(mobius == 1, t);
          }
        }
        return sum;
      }
    };
  }

  @Override
  public Z next() {
    final CR r = riemann(++mN);
    //System.out.println(mN + " R=" + r);
    return r.subtract(CR.valueOf(super.next())).round();
  }
}
#!queue	A052435	1	->	2	A000720	--------------------------------
package irvine.oeis.a052;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A052435 a(n) = round(li(n) - pi(n)), where li is the logarithmic integral and pi(x) is the number of primes &lt;= x.
 * @author Sean A. Irvine
 */
public class A052435 extends A000720 {

  private long mN = 1;
  {
    super.next();
  }

  @Override
  public Z next() {
    return CR.valueOf(++mN).li().subtract(CR.valueOf(super.next())).round();
  }
}
#!queue	A052480	1	->	0	A002385	--------------------------------
package irvine.oeis.a052;

import java.util.ArrayList;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002385;
import irvine.util.Permutation;

/**
 * A052480 Primes associated with A052507.
 * @author Sean A. Irvine
 */
public class A052480 extends A002385 {

  private final ArrayList<Z> mA = new ArrayList<>();
  private int mM = 0;

  private Permutation permuter(final Z prime) {
    final int[] cnts = ZUtils.digitCounts(prime);
    final int sum = (int) IntegerUtils.sum(cnts);
    final int[] digits = new int[sum];
    for (int k = 0, i = 0; k < cnts.length; ++k) {
      for (int j = 0; j < cnts[k]; ++j) {
        digits[i++] = k;
      }
    }
    return new Permutation(digits);
  }

  private Z permToZ(final int[] p) {
    Z t = Z.ZERO;
    for (int v : p) {
      t = t.multiply(10).add(v);
    }
    return t;
  }

  @Override
  public Z next() {
    if (++mM >= mA.size()) {
      mA.clear();
      mM = 0;
      final Z palin = super.next();
      final Permutation perm = permuter(palin);
      int[] p;
      while ((p = perm.next()) != null) {
        if (p[0] != 0) {
          final Z t = permToZ(p);
          if (t.isProbablePrime()) {
            mA.add(t);
          }
        }
      }
    }
    return mA.get(mM);
  }
}
#!queue	A052755	1	->	0	A005754	--------------------------------
package irvine.oeis.a052;
// Generated by gen_seq4.pl A005754/parm2 at 2021-12-02 17:30

import irvine.oeis.a005.A005754;

/**
 * A052755 G.f. A(x) satisfies: A(x) = exp( Sum_{k&gt;=1} (-1)^(k+1) * A(x^k)^3 * x^k / k ).
 * @author Georg Fischer
 */
public class A052755 extends A005754 {

  /** Construct the sequence. */
  public A052755() {
    super(3);
  }
}
#!queue	A052775	1	->	0	A005754	--------------------------------
package irvine.oeis.a052;
// Generated by gen_seq4.pl A005754/parm2 at 2021-12-02 17:30

import irvine.oeis.a005.A005754;

/**
 * A052775 G.f. A(x) satisfies: A(x) = exp( Sum_{k&gt;=1} (-1)^(k+1) * A(x^k)^4 * x^k / k ).
 * @author Georg Fischer
 */
public class A052775 extends A005754 {

  /** Construct the sequence. */
  public A052775() {
    super(4);
  }
}
#!queue	A052779	6	->	0	A001233	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a001.A001233;

/**
 * A052779 Expansion of e.g.f.: (log(1-x))^6.
 * @author Sean A. Irvine
 */
public class A052779 extends A001233 {

  private long mN = -1;

  @Override
  public Z next() {
    return ++mN < 6 ? Z.ZERO : super.next().multiply(720);
  }
}
#!queue	A052798	1	->	0	A005754	--------------------------------
package irvine.oeis.a052;
// Generated by gen_seq4.pl A005754/parm2 at 2021-12-02 17:30

import irvine.oeis.a005.A005754;

/**
 * A052798 G.f. A(x) satisfies: A(x) = exp( Sum_{k&gt;=1} (-1)^(k+1) * A(x^k)^5 * x^k / k ).
 * @author Georg Fischer
 */
public class A052798 extends A005754 {

  /** Construct the sequence. */
  public A052798() {
    super(5);
  }
}
#!queue	A052853	1	->	0	A050383	--------------------------------
package irvine.oeis.a052;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a050.A050383;

/**
 * A052853 A simple grammar.
 * @author Sean A. Irvine
 */
public class A052853 extends A050383 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mC = RING.empty();
  {
    mC.add(Q.ZERO);
  }

  @Override
  public Z next() {
    mC.add(new Q(super.next().negate()));
    Q sum = Q.ZERO;
    for (int j = 1; j <= mN; ++j) {
      sum = sum.add(RING.log1p(mC.substitutePower(j, mN), mN).coeff(mN).multiply(new Q(Euler.phiAsLong(j), j)));
    }
    return sum.negate().toZ();
  }
}
#!queue	A052894	1	->	0	A053492	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.a053.A053492;

/**
 * A052894 a(n) is the number of Schr\u00f6der trees on n vertices with a prescribed root.
 * @author Sean A. Irvine
 */
public class A052894 extends A053492 {

  @Override
  public Z next() {
    return super.next().divide(mN);
  }
}
#!queue	A053015	1	->	0	A089210	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a089.A089210;

/**
 * A053015 A089210 prefixed by an initial zero.
 * @author Georg Fischer
 */
public class A053015 extends A089210 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return mN == 0 ? Z.ZERO : super.next();
  }
}
#!queue	A053021	0	->	1	A027423	--------------------------------
package irvine.oeis.a053;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a027.A027423;

/**
 * A053021 Number of divisors function applied twice to n!.
 * @author Sean A. Irvine
 */
public class A053021 extends A027423 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A053023	0	->	1	A053021	--------------------------------
package irvine.oeis.a053;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A053023 Divisor function applied thrice to n!.
 * @author Sean A. Irvine
 */
public class A053023 extends A053021 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A053058	0	->	1	A000578	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A053058 Cubes whose digit sum is also a cube.
 * @author Sean A. Irvine
 */
public class A053058 extends A000578 {

  @Override
  public Z next() {
    while (true) {
      final Z cube = super.next();
      final long d = ZUtils.digitSum(cube);
      if (ZUtils.isCube(Z.valueOf(d))) {
        return cube;
      }
    }
  }
}
#!queue	A053250	1	->	0	A027358	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a027.A027357;
import irvine.oeis.a027.A027358;

/**
 * A053250 Coefficients of the '3rd order' mock theta function phi(q).
 * @author Sean A. Irvine
 */
public class A053250 extends A027358 {

  private Sequence mA = null;
  private boolean mSign = true;

  @Override
  public Z next() {
    if (mA == null) {
      mA = new A027357();
      return Z.ONE;
    }
    mSign = !mSign;
    return mSign ? super.next().subtract(mA.next()) : mA.next().subtract(super.next());
  }
}
#!queue	A053286	0	->	1	A000051	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000051;

/**
 * A053286 Cototient of 2^n +1.
 * @author Sean A. Irvine
 */
public class A053286 extends A000051 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return n.subtract(Euler.phi(n));
  }
}

#!queue	A053287	0	->	1	A000225	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A053287 Euler totient function (A000010) of 2^n - 1.
 * @author Sean A. Irvine
 */
public class A053287 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}

#!queue	A053288	0	->	1	A000225	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A053288 Cototient of 2^n - 1.
 * @author Sean A. Irvine
 */
public class A053288 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return n.subtract(Euler.phi(n));
  }
}

#!queue	A053299	0	->	1	A000230	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A053299 First n-digit prime to begin a gap.
 * @author Sean A. Irvine
 */
public class A053299 extends A000230 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply(10);
    while (true) {
      final Z p = super.next();
      if (p.compareTo(mA) > 0) {
        return p;
      }
    }
  }
}

#!queue	A053301	0	->	1	A053299	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;

/**
 * A053301 Prime gaps associated with A053299.
 * @author Sean A. Irvine
 */
public class A053301 extends A053299 {

  @Override
  public Z next() {
    final Z p = super.next();
    return mPrime.nextPrime(p).subtract(p);
  }
}

#!queue	A053370	1	->	0	A039955	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039955;

/**
 * A053370 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of x for n == 1 mod 4.
 * @author Sean A. Irvine
 */
public class A053370 extends A039955 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z[] unit = QuadraticFieldUtils.fundamentalUnitPair(super.next());
    return unit[0].subtract(unit[1]).divide2();
  }
}
#!queue	A053371	1	->	0	A039956	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039956;

/**
 * A053371 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of x for n == 2 mod 4.
 * @author Sean A. Irvine
 */
public class A053371 extends A039956 {

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[0].divide2();
  }
}
#!queue	A053372	1	->	0	A039957	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039957;

/**
 * A053372 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of x for n == 3 mod 4.
 * @author Sean A. Irvine
 */
public class A053372 extends A039957 {

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[0].divide2();
  }
}
#!queue	A053374	1	->	0	A039956	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039956;

/**
 * A053374 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of y for n == 2 mod 4.
 * @author Sean A. Irvine
 */
public class A053374 extends A039956 {

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[1].divide2();
  }
}
#!queue	A053375	1	->	0	A039957	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.QuadraticFieldUtils;
import irvine.math.z.Z;
import irvine.oeis.a039.A039957;

/**
 * A053375 Write fundamental unit for real quadratic field of discriminant n as x + y*omega; sequence gives values of y for n == 3 mod 4.
 * @author Sean A. Irvine
 */
public class A053375 extends A039957 {

  @Override
  public Z next() {
    return QuadraticFieldUtils.fundamentalUnitPair(super.next())[1].divide2();
  }
}
#!queue	A053381	1	->	0	A209675	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a209.A209675;

/**
 * A053381 Maximal number of linearly independent smooth nowhere-zero vector fields on a (2n+1)-sphere.
 * @author Sean A. Irvine
 */
public class A053381 extends A209675 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A053419	1	->	0	A339063	--------------------------------
package irvine.oeis.a053;

import irvine.oeis.a339.A339063;

/**
 * A053419 Number of graphs with loops (symmetric relations) with n edges.
 * @author Sean A. Irvine
 */
public class A053419 extends A339063 {

  private static final int[] PREFIX = {1};

  @Override
  protected int[] getPrefix() {
    return PREFIX;
  }
}
#!queue	A053454	1	->	0	A054733	--------------------------------
package irvine.oeis.a053;

import java.util.ArrayList;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a054.A054733;

/**
 * A053454 Number of weakly connected digraphs with n arcs.
 * @author Sean A. Irvine
 */
public class A053454 extends A054733 {

  private final ArrayList<Polynomial<Z>> mA = new ArrayList<>();
  private int mN = -2;

  @Override
  public Z next() {
    if (++mN <= 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    int k = -1;
    while (true) {
      if (++k >= mA.size()) {
        mA.add(getRow(mA.size() + 2));
      }
      final Polynomial<Z> row = mA.get(k);
      final Z t = row.coeff(mN);
      if (t.isZero() && mN <= row.degree()) {
        return sum;
      }
      sum = sum.add(t);
    }
  }
}
#!queue	A053512	1	->	2	A007764	--------------------------------
package irvine.oeis.a053;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a007.A007764;

/**
 * A053512 Half the number of non-self-intersecting paths from one corner of an n X n grid to the opposite corner.
 * @author Georg Fischer
 */
public class A053512 extends A007764 {

  protected int mN;
  
  /** Construct the sequence. */
  public A053512() {
    mN = 1;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A053551	0	->	1	A053549	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A053551 REVEGF transform of [1,2,12,152,3640,...] (A053549).
 * @author Sean A. Irvine
 */
public class A053551 extends A053549 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mA = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;
  private boolean mSign = true;
  {
    mA.add(new Q(super.next()));
    next();
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mA.add(new Q(super.next(), mF));
    final Z t = RING.reversion(mA, mN).coeff(mN).multiply(mF).toZ();
    mSign = !mSign;
    return mSign ? t : t.negate();
  }
}
#!queue	A053552	0	->	1	A053549	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;

/**
 * A053552 E.g.f. is obtained by reversion of e.g.f. for A053549.
 * @author Sean A. Irvine
 */
public class A053552 extends A053549 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mA = RING.empty();
  private Z mF = Z.ONE;
  private int mN = -1;
  {
    next();
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mA.add(new Q(super.next(), mF));
    return RING.reversion(mA, mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A053615	1	->	0	A004738	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a004.A004738;

/**
 * A053615 Pyramidal sequence: distance to nearest product of two consecutive integers (promic or heteromecic numbers).
 * @author Sean A. Irvine
 */
public class A053615 extends A004738 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A053622	1	->	2	A000720	--------------------------------
package irvine.oeis.a053;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A053622 a(n) = round( n/log(n) - pi(n) ).
 * @author Sean A. Irvine
 */
public class A053622 extends A000720 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z pi = super.next();
    final CR n = CR.valueOf(mN);
    return n.divide(n.log()).round().subtract(pi);
  }
}
#!queue	A053630	0	->	1	A000058	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a000.A000058;

/**
 * A053630 Pythagorean spiral: a(n-1), a(n)-1 and a(n) are sides of a right triangle.
 * @author Sean A. Irvine
 */
public class A053630 extends A000058 {

  @Override
  public Z next() {
    return super.next().multiply2().subtract(1);
  }
}
#!queue	A053634	0	->	3	A000031	--------------------------------
package irvine.oeis.a053;
// Generated by gen_seq4.pl seqop a000 A000031 divide2() 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000031;

/**
 * A053634 a(n) = Sum_{ d divides n } phi(d)*2^(n/d)/(2n).
 * @author Georg Fischer
 */
public class A053634 extends A000031 {
  private int mN = 3 - 1;
  
  /** Construct the sequence. */
  public A053634() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A053656	0	->	1	A000031	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a000.A000031;

/**
 * A053656 Number of cyclic graphs with oriented edges on n nodes (up to symmetry of dihedral group).
 * @author Sean A. Irvine
 */
public class A053656 extends A000031 {

  {
    super.next(); // skip 0
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return ((mN & 1) == 0 ? t.add(Z.ONE.shiftLeft(mN / 2 - 1)) : t).divide2();
  }
}
#!queue	A053657	0	->	1	A001898	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.a001.A001898;

/**
 * A053657 a(n) = Product_{p prime} p^{ Sum_{k&gt;=0} floor[(n-1)/((p-1)p^k)]}.
 * @author Sean A. Irvine
 */
public class A053657 extends A001898 {

  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (mN > 0) {
      mF = mF.multiply(mN + 1);
    }
    return super.next().multiply(mF);
  }
}
#!queue	A053701	0	->	1	A005900	--------------------------------
package irvine.oeis.a053;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.a005.A005900;

/**
 * A053701 Vertically symmetric numbers.
 * @author Sean A. Irvine
 */
public class A053701 extends A005900 {

  private static final char[] DIGITS = {'0', '1', '2', '5', '8'};
  private final TreeSet<Z> mA = new TreeSet<>();
  private int mLength = -1; // Length of half the number!
  private long mLimit = 1;

  private StringBuilder reverseSpecial(final CharSequence s) {
    final StringBuilder sb = new StringBuilder();
    for (int k = s.length() - 1; k >= 0; --k) {
      final char c = s.charAt(k);
      switch (c) {
        case '2':
          sb.append('5');
          break;
        case '5':
          sb.append('2');
          break;
        default:
          sb.append(c);
          break;
      }
    }
    return sb;
  }

  @Override
  public Z next() {
    if (mA.isEmpty()) {
      if (++mLength == 0) {
        mA.add(Z.ONE);
        mA.add(Z.EIGHT);
        return Z.ZERO;
      }
      final long start = mLimit;
      mLimit *= DIGITS.length;
      for (long k = start; k < mLimit; ++k) {
        final StringBuilder sb = new StringBuilder();
        long m = k;
        for (int j = 0; j < mLength; ++j) {
          sb.append(DIGITS[(int) m % DIGITS.length]);
          m /= DIGITS.length;
        }
        final String rev = reverseSpecial(sb).toString();
        mA.add(new Z(rev + sb)); // even length
        mA.add(new Z(rev + '0' + sb)); // odd length
        mA.add(new Z(rev + '1' + sb)); // odd length
        mA.add(new Z(rev + '8' + sb)); // odd length
      }
    }
    return mA.pollFirst();
  }
}
#!queue	A053719	1	->	0	A053676	--------------------------------
package irvine.oeis.a053;

import irvine.oeis.a000.A000330;

/**
 * A053719 Let Py(n)=A000330(n)=n-th square pyramidal number. Consider all integer triples (i,j,k), j &gt;= k&gt;0, with Py(i)=Py(j)+Py(k), ordered by increasing i; sequence gives i values.
 * @author Sean A. Irvine
 */
public class A053719 extends A053676 {

  /** Construct the sequence. */
  public A053719() {
    super(new A000330());
  }
}

#!queue	A053720	1	->	0	A053677	--------------------------------
package irvine.oeis.a053;

import irvine.oeis.a000.A000330;

/**
 * A053720 Let Py(n)=A000330(n)=n-th square pyramidal number. Consider all integer triples (i,j,k), j &gt;= k&gt;0, with Py(i)=Py(j)+Py(k), ordered by increasing i; sequence gives j values.
 * @author Sean A. Irvine
 */
public class A053720 extends A053677 {

  /** Construct the sequence. */
  public A053720() {
    super(new A000330());
  }
}

#!queue	A053721	1	->	0	A053678	--------------------------------
package irvine.oeis.a053;

import irvine.oeis.a000.A000330;

/**
 * A053721 Let Py(n)=A000330(n)=n-th square pyramidal number. Consider all integer triples (i,j,k), j &gt;= k&gt;0, with Py(i)=Py(j)+Py(k), ordered by increasing i; sequence gives k values.
 * @author Sean A. Irvine
 */
public class A053721 extends A053678 {

  /** Construct the sequence. */
  public A053721() {
    super(new A000330());
  }
}

#!queue	A053734	0	->	1	A000016	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000016;
import irvine.oeis.a000.A000048;

/**
 * A053734 A000016-A000048 (when they are lined up so that the two 16's match).
 * @author Sean A. Irvine
 */
public class A053734 extends A000016 {

  private final Sequence mA = new A000048();
  {
    next(); // skip 0th
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A053773	1	->	0	A053718	--------------------------------
package irvine.oeis.a053;

import irvine.math.group.GaloisField;

/**
 * A053773 Number of n X n binary matrices of order dividing 8 (i.e., number of solutions of X^8=I in GL(n,2)).
 * @author Sean A. Irvine
 */
public class A053773 extends A053718 {

  /** Construct the sequence. */
  public A053773() {
    super(8, new GaloisField(2), 0);
  }
}
#!queue	A053785	0	->	1	A000583	--------------------------------
package irvine.oeis.a053;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000583;

/**
 * A053785 Nextprime(n^4) - n^4.
 * @author Sean A. Irvine
 */
public class A053785 extends A000583 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n4 = super.next();
    return mPrime.nextPrime(n4).subtract(n4);
  }
}
#!queue	A053786	0	->	1	A000583	--------------------------------
package irvine.oeis.a053;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000583;

/**
 * A053786 a(n) = next prime after n^4.
 * @author Sean A. Irvine
 */
public class A053786 extends A000583 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mPrime.nextPrime(super.next());
  }
}
#!queue	A053787	0	->	1	A000584	--------------------------------
package irvine.oeis.a053;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000584;

/**
 * A053787 Nextprime(n^5) - n^5.
 * @author Sean A. Irvine
 */
public class A053787 extends A000584 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n5 = super.next();
    return mPrime.nextPrime(n5).subtract(n5);
  }
}
#!queue	A053788	0	->	1	A000584	--------------------------------
package irvine.oeis.a053;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000584;

/**
 * A053788 Next prime after n^5.
 * @author Sean A. Irvine
 */
public class A053788 extends A000584 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mPrime.nextPrime(super.next());
  }
}
#!queue	A053878	1	->	2	A002182	--------------------------------
package irvine.oeis.a053;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a002.A002182;

/**
 * A053878 Difference between numerator and denominator of lowest terms fraction from division of a highly composite number (1) by its predecessor.
 * @author Sean A. Irvine
 */
public class A053878 extends A002182 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z b = mA;
    mA = super.next();
    final Q t = new Q(mA, b);
    return t.num().subtract(t.den());
  }
}
#!queue	A054012	2	->	1	A054009	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;

/**
 * A054012 Nonzero values of n read modulo (number of proper divisors of n).
 * @author Sean A. Irvine
 */
public class A054012 extends A054009 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (!t.isZero()) {
        return t;
      }
    }
  }
}
#!queue	A054112	0	->	3	A054110	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;

/**
 * A054112 T(n,n-3), array T as in A054110.
 * @author Sean A. Irvine
 */
public class A054112 extends A054110 {

  private long mN = 2;

  @Override
  public Z next() {
    return t(++mN, mN - 3);
  }
}
#!queue	A054348	1	->	0	A042942	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a042.A042942;

/**
 * A054348 Triangular array whose rows are successive generations of the variant of the Kolakoski sequence described in A042942.
 * @author Sean A. Irvine
 */
public class A054348 extends A042942 {

  private long mM = 0;

  @Override
  public Z next() {
    if (++mM == mLimit) {
      super.next();
      mM = 0;
    }
    return ((mSeq.get(mM >>> 5) >>> (mM & 0x1F)) & 1) == 0 ? Z.ONE : Z.TWO;
  }
}
#!queue	A054349	1	->	0	A042942	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a042.A042942;

/**
 * A054349 Successive generations of the variant of the Kolakoski sequence described in A042942.
 * @author Sean A. Irvine
 */
public class A054349 extends A042942 {

  @Override
  public Z next() {
    super.next();
    final StringBuilder sb = new StringBuilder();
    for (long k = 0; k < mLimit; ++k) {
      sb.append(((mSeq.get(k >>> 5) >>> (k & 0x1F)) & 1) == 0 ? '1' : '2');
    }
    return new Z(sb);
  }
}
#!queue	A054350	1	->	0	A000002	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000002;

/**
 * A054350 Triangular array whose rows are successive generations of the Kolakoski sequence A000002.
 * @author Sean A. Irvine
 */
public class A054350 extends A000002 {

  private final Sequence mRowLengths = new A054352();
  private long mRowLength = mRowLengths.next().longValueExact();
  private long mM = -1;

  @Override
  public Z next() {
    if (++mM == mRowLength) {
      mRowLength = mRowLengths.next().longValueExact();
      // Underlying Kolakoski generator is using a different rule
      while (mLimit < mRowLength) {
        rewrite();
      }
      mM = 0;
    }
    return isSet(mM) ? Z.TWO : Z.ONE;
  }
}
#!queue	A054351	1	->	0	A000002	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000002;

/**
 * A054351 Successive generations of the Kolakoski sequence A000002.
 * @author Sean A. Irvine
 */
public class A054351 extends A000002 {

  private final StringBuilder mS = new StringBuilder();
  private final Sequence mRowLengths = new A054352();
  private long mN = 0;

  @Override
  public Z next() {
    final long mRowLength = mRowLengths.next().longValueExact();
    while (mN < mRowLength) {
      mS.append(super.next());
      ++mN;
    }
    return new Z(mS);
  }
}
#!queue	A054481	1	->	2	A002182	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a002.A002182;

/**
 * A054481 Highest common factor of successive highly composite numbers (1), A002182.
 * @author Sean A. Irvine
 */
public class A054481 extends A002182 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.gcd(t);
  }
}
#!queue	A054482	1	->	2	A002182	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a002.A002182;

/**
 * A054482 Denominator of lowest terms fraction from division of a highly composite number (1) by its predecessor.
 * @author Sean A. Irvine
 */
public class A054482 extends A002182 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return t.divide(mA.gcd(t));
  }
}
#!queue	A054483	1	->	2	A002182	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a002.A002182;

/**
 * A054483 Numerator of lowest terms fraction from division of a highly composite number (1) by its predecessor.
 * @author Sean A. Irvine
 */
public class A054483 extends A002182 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.divide(mA.gcd(t));
  }
}
#!queue	A054503	1	->	0	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054503 Table T(n,k) giving log_b(k), 1&lt;=k&lt;=p, where p = n-th prime and b = smallest primitive root of p (A001918).
 * @author Sean A. Irvine
 */
public class A054503 extends A001918 {

  private Z mB = null;
  private Z mM = Z.ZERO;

  @Override
  public Z next() {
    mM = mM.add(1);
    if (mM.compareTo(mP) >= 0) {
      mB = super.next();
      mM = Z.ONE;
    }
    long lg = 0;
    Z t = Z.ONE;
    while (!t.equals(mM)) {
      t = t.modMultiply(mB, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054505	1	->	2	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054505 Log_b 2 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054505 extends A001918 {

  {
    super.next(); // skip 2
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.TWO.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054506	1	->	3	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054506 Log_b 3 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054506 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.THREE.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054507	1	->	3	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054507 Log_b 4 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054507 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.FOUR.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054508	1	->	4	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054508 Log_b 5 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054508 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.FIVE.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054509	1	->	4	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054509 Log_b 6 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054509 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.SIX.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054510	1	->	5	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054510 Log_b 7 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054510 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
    super.next(); // skip 7
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.SEVEN.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054511	1	->	5	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054511 Log_b 8 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054511 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
    super.next(); // skip 7
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.EIGHT.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054512	1	->	5	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054512 Log_b 9 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054512 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
    super.next(); // skip 7
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.NINE.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054513	1	->	5	A001918	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a001.A001918;

/**
 * A054513 Log_b 10 where b is smallest primitive root (A001918) mod n-th prime.
 * @author Sean A. Irvine
 */
public class A054513 extends A001918 {

  {
    super.next(); // skip 2
    super.next(); // skip 3
    super.next(); // skip 5
    super.next(); // skip 7
  }

  @Override
  public Z next() {
    final Z b = super.next();
    long lg = 0;
    Z t = Z.ONE;
    while (!Z.TEN.equals(t)) {
      t = t.modMultiply(b, mP);
      ++lg;
    }
    return Z.valueOf(lg);
  }
}
#!queue	A054538	0	->	1	A000013	--------------------------------
package irvine.oeis.a054;
// manually dersimpln at 2021-09-27 18:28

import irvine.math.z.Z;
import irvine.oeis.a000.A000013;

/**
 * A054538 A000013 / 2.
 * @author Georg Fischer
 */
public class A054538 extends A000013 {

  protected int mN;
  
  /** Construct the sequence */
  public A054538() {
    mN = 0;
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A054539	0	->	3	A000016	--------------------------------
package irvine.oeis.a054;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a000.A000016;

/**
 * A054539 A000016 / 2.
 * @author Georg Fischer
 */
public class A054539 extends A000016 {

  /** Construct the sequence. */
  public A054539() {
    super.next();
    super.next();
    super.next();
  }
  
  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A054565	0	->	1	A000244	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a000.A000244;

/**
 * A054565 Numbers n such that 3 is the first digit of 3^n.
 * @author Sean A. Irvine
 */
public class A054565 extends A000244 {

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().toString().startsWith("3")) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A054581	0	->	1	A340811	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a340.A340811;

/**
 * A054581 Number of unlabeled 2-trees with n nodes.
 * @author Sean A. Irvine
 */
public class A054581 extends A340811 {

  private int mN = -1;

  @Override
  public Z next() {
    return u(++mN, 3).coeff(mN);
  }
}
#!queue	A054590	0	->	1	A000273	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000273;
import irvine.oeis.a003.A003085;

/**
 * A054590 Number of disconnected digraphs with n unlabeled nodes.
 * @author Sean A. Irvine
 */
public class A054590 extends A000273 {

  {
    super.next(); // skip 0th
  }
  private final Sequence mA = new A003085();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A054660	0	->	1	A000048	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a000.A000048;

/**
 * A054660 Number of monic irreducible polynomials over GF(4) of degree n with fixed nonzero trace.
 * @author Sean A. Irvine
 */
public class A054660 extends A000048 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}

#!queue	A054678	1	->	2	A054681	--------------------------------
package irvine.oeis.a054;

/**
 * A054678 n consecutive primes differ by a multiple of 4 starting at a(n).
 * @author Sean A. Irvine
 */
public class A054678 extends A054681 {

  /** Construct the sequence. */
  public A054678() {
    super(4);
    next();
  }
}


#!queue	A054680	1	->	2	A054681	--------------------------------
package irvine.oeis.a054;

/**
 * A054680 n consecutive primes differ by a multiple of 8 starting at a(n).
 * @author Sean A. Irvine
 */
public class A054680 extends A054681 {

  /** Construct the sequence. */
  public A054680() {
    super(8);
    next();
  }
}


#!queue	A054692	2	->	0	A054690	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;

/**
 * A054692 Endpoints for runs of consecutive primes mentioned in A054691.
 * @author Sean A. Irvine
 */
public class A054692 extends A054690 {

  private Z mA = super.next();

  @Override
  public Z next() {
    Z p = mA;
    do {
      mA = super.next();
    } while (p.equals(mA));
    for (int k = 1; k < mN; ++k) {
      p = mPrime.nextPrime(p);
    }
    return p;
  }
}

#!queue	A054733	1	->	2	A052283	--------------------------------
package irvine.oeis.a054;

import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.polynomial.PolynomialUtils;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a052.A052283;

/**
 * A054733 Triangle of number of (weakly) connected unlabeled digraphs with n nodes and k arcs (n &gt;=2, k &gt;= 1).
 * @author Sean A. Irvine
 */
public class A054733 extends A052283 {

  private final Polynomial<Polynomial<Q>> mP = new PolynomialRingField<>(new PolynomialRingField<>(Rationals.SINGLETON)).empty();
  private Polynomial<Z> mRow = RING.zero();
  {
    mP.add(PolynomialUtils.zToQ(RING.one()));
    ++mK;
    ++mK;
  }

  protected Polynomial<Z> getRow(final int n) {
    while (mP.size() <= n) {
      mP.add(PolynomialUtils.zToQ(g(mP.size())));
    }
    final DegreeLimitedPolynomialRingField<Q> fld = new DegreeLimitedPolynomialRingField<>(Rationals.SINGLETON, n * (n - 1));
    return PolynomialUtils.qToZ(PolynomialUtils.inverseEuler(fld, mP).coeff(n).shift(-1));
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      if (++mK <= 1) {
        return Z.ONE;
      }
      mRow = getRow(mK);
      mM = 0;
    }
    return mRow.coeff(mM);
  }
}
#!queue	A054738	1	->	0	A054737	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;

/**
 * A054738 Squares which can be split into two nonzero squares (perhaps with leading zeros) in exactly two different ways.
 * @author Sean A. Irvine
 */
public class A054738 extends A054737 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A054745	1	->	0	A002854	--------------------------------
package irvine.oeis.a054;

import irvine.math.IntegerUtils;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a002.A002854;

/**
 * A054745 Number of nonisomorphic binary n-state automata without output under input permutations.
 * @author Sean A. Irvine
 */
public class A054745 extends A002854 {

  private static final int[][] PART2 = {{0, 2, 0}, {0, 0, 1}}; // precomputed partitions of 2 in count form

  /** Construct the sequence. */
  public A054745() {
    super(0);
  }

  @Override
  protected Q m(final int[] p) {
    // p is partition in count form
    Z sum = Z.ZERO;
      for (final int[] t : PART2) {
        Z prod = Z.ONE;
        for (int r = 1; r < p.length; ++r) {
          for (int s = 1; s < t.length; ++s) {
            final int lcm = IntegerUtils.lcm(r, s);
            int s1 = 0;
            for (int d = 1; d < p.length; ++d) {
              if (lcm % d == 0) {
                s1 += d * p[d];
              }
            }
            final int exponent = p[r] * t[s] * IntegerUtils.gcd(r, s);
            prod = prod.multiply(Z.valueOf(s1).pow(exponent));
          }
        }
        sum = sum.add(prod);
      }
    return new Q(sum.divide2());
  }
}
#!queue	A054760	1	->	0	A198300	--------------------------------
package irvine.oeis.a054;

import irvine.math.graph.Graph;
import irvine.math.nauty.GenerateGraphs;
import irvine.math.nauty.GraphProcessor;
import irvine.math.z.Z;
import irvine.oeis.a198.A198300;
import irvine.util.string.StringUtils;

/**
 * A054760 Table T(n,k) = order of (n,k)-cage (smallest n-regular graph of girth k), n &gt;= 2, k &gt;= 3, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A054760 extends A198300 implements GraphProcessor {

  private static class FoundItException extends RuntimeException { }
  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));

  @Override
  public void process(final Graph graph) {
    if (graph.girth() >= mM + 3) {
      throw new FoundItException(); // Abort any further computation we found the solution
    }
  }

  @Override
  public Z next() {
    int n = super.next().intValueExact();
    while (true) {
      final int degree = mN + 1 - mM;
      if (mVerbose) {
        StringUtils.message("Trying " + n + " vertices with degree " + degree + " and target girth " + (mM + 3));
      }
      final GenerateGraphs gg = new GenerateGraphs(0);
      gg.setProcessor(this);
      gg.setVertices(n);
      gg.setMinDeg(degree);
      gg.setMaxDeg(degree);
      gg.setMinEdges(0);
      gg.setMaxEdges(Integer.MAX_VALUE);
      gg.setConnectionLevel(1);
      gg.sanitizeParams();
      try {
        gg.run(false, mM > 2, mM > 1, 0, 0);
      } catch (final FoundItException e) {
        return Z.valueOf(n);
      }
      ++n;
    }
  }

}
#!queue	A054815	1	->	0	A054800	--------------------------------
package irvine.oeis.a054;
// Generated by gen_seq4.pl A054800/parm4 at 2022-02-14 19:19

/**
 * A054815 Third term of strong prime sextets: p(m-1)-p(m-2) &gt; p(m)-p(m-1) &gt; p(m+1)-p(m) &gt; p(m+2)-p(m+1) &gt; p(m+3)-p(m+2).
 * @author Georg Fischer
 */
public class A054815 extends A054800 {

  /** Construct the sequence. */
  public A054815() {
    super(3, 1, 6);
  }
}
#!queue	A054816	1	->	0	A054800	--------------------------------
package irvine.oeis.a054;
// Generated by gen_seq4.pl A054800/parm4 at 2022-02-14 19:19

/**
 * A054816 Fourth term of strong prime sextets: p(m-2)-p(m-3) &gt; p(m-1)-p(m-2) &gt; p(m)-p(m-1) &gt; p(m+1)-p(m) &gt; p(m+2)-p(m+1).
 * @author Georg Fischer
 */
public class A054816 extends A054800 {

  /** Construct the sequence. */
  public A054816() {
    super(4, 1, 6);
  }
}
#!queue	A054817	1	->	0	A054800	--------------------------------
package irvine.oeis.a054;
// Generated by gen_seq4.pl A054800/parm4 at 2022-02-14 19:19

/**
 * A054817 Fifth term of strong prime sextets: p(m-3)-p(m-4) &gt; p(m-2)-p(m-3) &gt; p(m-1)-p(m-2) &gt; p(m)-p(m-1) &gt; p(m+1)-p(m).
 * @author Georg Fischer
 */
public class A054817 extends A054800 {

  /** Construct the sequence. */
  public A054817() {
    super(5, 1, 6);
  }
}
#!queue	A054818	1	->	0	A054800	--------------------------------
package irvine.oeis.a054;
// Generated by gen_seq4.pl A054800/parm4 at 2022-02-14 19:19

/**
 * A054818 Sixth term of strong prime sextets: p(m-4)-p(m-5) &gt; p(m-3)-p(m-4) &gt; p(m-2)-p(m-3) &gt; p(m-1)-p(m-2) &gt; p(m)-p(m-1).
 * @author Georg Fischer
 */
public class A054818 extends A054800 {

  /** Construct the sequence. */
  public A054818() {
    super(6, 1, 6);
  }
}
#!queue	A054906	0	->	1	A020483	--------------------------------
package irvine.oeis.a054;
// manually 2023-06-18

import irvine.oeis.a020.A020483;

/**
 * A054906 Smallest number x such that sigma(x+2n) = sigma(x)+2n (first definition).
 *
 * @author Georg Fischer
 */
public class A054906 extends A020483 {

  /** Construct the sequence. */
  public A054906() {
    next();
  }
}
#!queue	A054916	0	->	1	A005177	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a005.A005176;
import irvine.oeis.a005.A005177;

/**
 * A054916 Number of connected unlabeled regular graphs with n nodes such that complement is also connected.
 * @author Sean A. Irvine
 */
public class A054916 extends A005177 {

  private final Sequence mA = new A005176();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().multiply2().subtract(mA.next());
  }
}
#!queue	A054935	0	->	1	A006384	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a006.A006384;
import irvine.oeis.a006.A006849;

/**
 * A054935 Number of planar maps with n edges up to orientation-preserving duality.
 * @author Sean A. Irvine
 */
public class A054935 extends A006384 {

  private final A006849 mSeq = new A006849();
  private boolean mAlt = true;

  {
    super.next();
  }

  @Override
  public Z next() {
    mAlt = !mAlt;
    return super.next().add(mAlt ? mSeq.next() : Z.ZERO).divide2();
  }
}
#!queue	A054936	0	->	1	A006385	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006384;
import irvine.oeis.a006.A006385;

/**
 * A054936 Number of achiral planar maps on n nodes up to orientation-preserving isomorphisms.
 * @author Sean A. Irvine
 */
public class A054936 extends A006385 {

  private final Sequence mA = new A006384();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().multiply2().subtract(mA.next());
  }
}
#!queue	A054937	0	->	1	A006385	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006385;

/**
 * A054937 Number of chiral planar maps on n nodes up to orientation-preserving isomorphisms.
 * @author Sean A. Irvine
 */
public class A054937 extends A006385 {

  private final Sequence mA = new A054936();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A054948	1	->	0	A003030	--------------------------------
package irvine.oeis.a054;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a003.A003030;

/**
 * A054948 Number of labeled semi-strong digraphs on n nodes.
 * @author Sean A. Irvine
 */
public class A054948 extends A003030 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private Z mF = Z.ONE;
  private final Polynomial<Q> mA = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mA.add(mN == 0 ? Q.ZERO : new Q(super.next(), mF));
    return RING.exp(mA, mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A054960	0	->	1	A000088	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000088;
import irvine.oeis.a000.A000171;

/**
 * A054960 Number of unlabeled graphs with n nodes and an odd number of edges.
 * @author Sean A. Irvine
 */
public class A054960 extends A000088 {

  private final Sequence mA = new A000171();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next()).divide2();
  }
}
#!queue	A054970	0	->	1	A000384	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a000.A000384;
import irvine.util.string.StringUtils;

/**
 * A054970 Index numbers for palindromic hexagonal numbers.
 * @author Sean A. Irvine
 */
public class A054970 extends A000384 {

  @Override
  public Z next() {
    while (true) {
      final Z hex = super.next();
      if (StringUtils.isPalindrome(hex.toString())) {
        return mN;
      }
    }
  }
}
#!queue	A054971	0	->	1	A000566	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.a000.A000566;
import irvine.util.string.StringUtils;

/**
 * A054971 n(5n-3)/2 is a palindromic heptagonal number.
 * @author Sean A. Irvine
 */
public class A054971 extends A000566 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z hex = super.next();
      if (StringUtils.isPalindrome(hex.toString())) {
        return mN;
      }
    }
  }
}
#!queue	A054976	0	->	1	A002724	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002724;
import irvine.oeis.a002.A002725;

/**
 * A054976 Number of binary n X n matrices with no zero rows or columns, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A054976 extends A002724 {

  private final Sequence mA2725 = new A002725();
  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return mA.add(t).subtract(mA2725.next().multiply2());
  }
}

#!queue	A054992	0	->	1	A000051	--------------------------------
package irvine.oeis.a054;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000051;

/**
 * A054992 Number of prime factors of 2^n + 1 (counted with multiplicity).
 * @author Sean A. Irvine
 */
public class A054992 extends A000051 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A055011	1	->	0	A048549	--------------------------------
package irvine.oeis.a055;

import irvine.oeis.a048.A048549;

/**
 * A055011 a(n+1) = next smallest prime beginning with a(n) when written in binary, starting with 2.
 * @author Sean A. Irvine
 */
public class A055011 extends A048549 {

  /** Construct the sequence. */
  public A055011() {
    super("10", 2);
  }
}
#!queue	A055019	0	->	1	A051885	--------------------------------
package irvine.oeis.a055;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a051.A051885;

/**
 * A055019 Numbers n such that A051885(p_n) is prime, where p_n=A000040(n) is the n-th prime.
 * @author Sean A. Irvine
 */
public class A055019 extends A051885 {

  private final Fast mPrime = new Fast();
  private long mN = -1;
  private long mPi = 0;

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (mPrime.isPrime(++mN)) {
        ++mPi;
        if (t.isProbablePrime()) {
          return Z.valueOf(mPi);
        }
      }
    }
  }
}
#!queue	A055026	0	->	1	A055028	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055026 Number of Gaussian primes of successive norms (indexed by A055025).
 * @author Sean A. Irvine
 */
public class A055026 extends A055028 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (!t.isZero()) {
        return t;
      }
    }
  }
}
#!queue	A055027	0	->	1	A055029	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055027 Number of inequivalent Gaussian primes of successive norms (indexed by A055025).
 * @author Sean A. Irvine
 */
public class A055027 extends A055029 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      if (!t.isZero()) {
        return t;
      }
    }
  }
}
#!queue	A055036	0	->	1	A000400	--------------------------------
package irvine.oeis.a055;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000400;

/**
 * A055036 Min[x] composite zero site for sigma(x+6^n) - sigma(x) - 6^n.
 * @author Sean A. Irvine
 */
public class A055036 extends A000400 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z f = super.next();
    Z k = Z.THREE;
    while (true) {
      k = k.add(1);
      if (!k.isProbablePrime() && Jaguar.factor(f.add(k)).sigma().equals(Jaguar.factor(k).sigma().add(f))) {
        return k;
      }
    }
  }
}
#!queue	A055082	0	->	1	A056152	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a056.A056152;

/**
 * A055082 Number of 4 X n binary matrices with no zero rows or columns, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A055082 extends A056152 {

  private int mN = 0;

  @Override
  public Z next() {
    return a(++mN, 4);
  }
}
#!queue	A055083	0	->	1	A056152	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a056.A056152;

/**
 * A055083 Number of 5 X n binary matrices with no zero rows or columns, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A055083 extends A056152 {

  private int mN = 0;

  @Override
  public Z next() {
    return a(++mN, 5);
  }
}
#!queue	A055084	0	->	1	A056152	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a056.A056152;

/**
 * A055084 Number of 6 X n binary matrices with no zero rows or columns, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A055084 extends A056152 {

  private int mN = 0;

  @Override
  public Z next() {
    return a(++mN, 6);
  }
}
#!queue	A055097	2	->	1	A055096	--------------------------------
package irvine.oeis.a055;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A055097 Number of divisors for each term in the triangle A055096. It is 2 for primes (all of the form 4k+1).
 * @author Georg Fischer
 */
public class A055097 extends A055096 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A055106	1	->	2	A055105	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055106 Triangle T(n,k) giving number of symmetric polynomials of degree n in k noncommuting variables, n &gt;=2, 2 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A055106 extends A055105 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return t.isZero() ? super.next() : t;
  }
}
#!queue	A055107	1	->	2	A055106	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055107 Triangle T(k,n) giving number of symmetric polynomials of degree n in k noncommuting variables, n &gt;=2, 2 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A055107 extends A055106 {

  @Override
  protected Z a(final int k, final int n) {
    return super.a(n - k + 1, n);
  }
}
#!queue	A055131	1	->	0	A005098	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a005.A005098;

/**
 * A055131 Those composite s for which A055095[s] = 2.
 * @author Sean A. Irvine
 */
public class A055131 extends A005098 {

  @Override
  public Z next() {
    return super.next().multiply(4).add(1).multiply(3);
  }
}
#!queue	A055132	2	->	1	A055096	--------------------------------
package irvine.oeis.a055;

import irvine.math.Mobius;
import irvine.math.z.Z;

/**
 * A055132 Moebius function (A008683) applied to each term in the triangle A055096.
 * @author Sean A. Irvine
 */
public class A055132 extends A055096 {

  @Override
  public Z next() {
    return Z.valueOf(Mobius.mobius(super.next().longValueExact()));
  }
}
#!queue	A055152	0	->	1	A003180	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a003.A003180;

/**
 * A055152 Proper covers of an unlabeled n-set.
 * a(n) = (A003180(n) - 2*A003180(n-1))/4.
 * @author Georg Fischer
 */
public class A055152 extends A003180 {

  private Z mA1;

  /** Construct the sequence. */
  public A055152() {
    mA1 = super.next();
  }

  @Override
  public Z next() {
    final Z mA = super.next();
    final Z result = mA.subtract(mA1.multiply2()).divide(4);
    mA1 = mA;
    return result;
  }
}
#!queue	A055165	1	->	0	A000410	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000410;

/**
 * A055165 Number of invertible n X n matrices with entries equal to 0 or 1.
 * @author Sean A. Irvine
 */
public class A055165 extends A000410 {

  private Z mF = Z.ONE;
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    final Z t = super.next();
    mF = mF.multiply(mN);
    return Binomial.binomial((1L << mN) - 1, mN).subtract(t).multiply(mF);
  }
}
#!queue	A055166	1	->	0	A000043	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a000.A000043;

/**
 * A055166 Number of Mersenne prime exponents between 10^n and 10^(n+1).
 * @author Sean A. Irvine
 */
public class A055166 extends A000043 {

  private long mLimit = 1;

  @Override
  public Z next() {
    long cnt = mLimit == 1 ? 0 : 1;
    mLimit *= 10;
    while (super.next().longValueExact() < mLimit) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A055197	0	->	1	A005728	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a005.A005728;

/**
 * A055197 Numbers k such that A005728(k) is not prime.
 * @author Georg Fischer
 */
public class A055197 extends A005728 {

  private int mK = 0;

  /** Construct the sequence. */
  public A055197() {
    super.next();
  }

  @Override
  public Z next() {
    ++mK;
    while (super.next().isProbablePrime()) {
      ++mK;
    }
    return Z.valueOf(mK);
  }
}
#!queue	A055223	0	->	2	A000866	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000866;

/**
 * A055223 One-fourth the digital sum of base 5 representations of 2^n.
 * @author Sean A. Irvine
 */
public class A055223 extends A000866 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()) / 4);
  }
}
#!queue	A055261	0	->	1	A055235	--------------------------------
package irvine.oeis.a055;
// Generated by gen_seq4.pl parm2 at 2021-10-18 12:36

/**
 * A055261 Sums of two powers of 16.
 * @author Georg Fischer
 */
public class A055261 extends A055235 {

  /** Construct the sequence. */
  public A055261() {
    super(16);
  }
}
#!queue	A055290	1	->	2	A055277	--------------------------------
package irvine.oeis.a055;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A055290 Triangle of trees with n nodes and k leaves, 2 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A055290 extends A055277 {

  private static final Polynomial<Polynomial<Q>> CONS = RING_X.add(RING_X.subtract(RING_X.one(), RING_X.x()), XY);

  private Polynomial<Polynomial<Q>> mGF = super.gf(1);
  private int mDeg = 1;

  @Override
  protected Polynomial<Polynomial<Q>> gf(final int n) {
    if (n > mDeg) {
      final Polynomial<Polynomial<Q>> b = super.gf(n);
      final Polynomial<Polynomial<Q>> bSubs = doubleSubstitute(b, 2);
      final Polynomial<Polynomial<Q>> bSquare = RING_X.multiply(b, b, n);
      mGF = RING_X.add(RING_X.multiply(CONS, b),
        RING_X.multiply(RING_X.subtract(bSubs, bSquare), constant(Q.HALF)));
      mDeg = n;
    }
    return mGF;
  }

  private int mN = 1;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM > mN) {
      mM = 2;
      ++mN;
    }
    return gf(mN).coeff(mN).coeff(mM).toZ();
  }
}
#!queue	A055347	0	->	1	A048805	--------------------------------
package irvine.oeis.a055;

import irvine.oeis.FilterSequence;
import irvine.oeis.a048.A048805;

/**
 * A055347 Matrix inverse of triangle A055340(n+1,k).
 * @author Sean A. Irvine
 */
public class A055347 extends A048805 {

  /** Construct the sequence. */
  public A055347() {
    super(new FilterSequence(new A055340(), FilterSequence.NONZERO).skip(1));
  }
}
#!queue	A055348	0	->	1	A055347	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055348 Column 1 of triangle A055347.
 * @author Sean A. Irvine
 */
public class A055348 extends A055347 {

  private long mN = -2;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k < mN; ++k) {
      super.next();
    }
    return super.next();
  }
}
#!queue	A055370	0	->	1	A048805	--------------------------------
package irvine.oeis.a055;

import irvine.oeis.FilterSequence;
import irvine.oeis.a048.A048805;

/**
 * A055370 Matrix inverse of triangle A055363(n+2,k).
 * @author Sean A. Irvine
 */
public class A055370 extends A048805 {

  /** Construct the sequence. */
  public A055370() {
    super(new FilterSequence(new A055363(), FilterSequence.NONZERO).skip(2));
  }
}
#!queue	A055371	0	->	1	A055370	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055371 Column 1 of triangle A055370.
 * @author Sean A. Irvine
 */
public class A055371 extends A055370 {

  private long mN = -2;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k < mN; ++k) {
      super.next();
    }
    return super.next();
  }
}
#!queue	A055452	0	->	2	A055450	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055452 T(n,n-2), array T as in A055450.
 * @author Sean A. Irvine
 */
public class A055452 extends A055450 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN + 2, mN);
  }
}
#!queue	A055453	0	->	3	A055450	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055453 T(n,n-3), array T as in A055450.
 * @author Sean A. Irvine
 */
public class A055453 extends A055450 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN + 3, mN);
  }
}
#!queue	A055454	0	->	4	A055450	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055454 T(n,n-4), array T as in A055450.
 * @author Sean A. Irvine
 */
public class A055454 extends A055450 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN + 4, mN);
  }
}
#!queue	A055455	0	->	5	A055450	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055455 T(n,n-5), array T as in A055450.
 * @author Sean A. Irvine
 */
public class A055455 extends A055450 {

  private long mN = -1;

  @Override
  public Z next() {
    return get(++mN + 5, mN);
  }
}
#!queue	A055459	2	->	1	A007712	--------------------------------
package irvine.oeis.a055;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a007.A007712;
import irvine.util.Permutation;

/**
 * A055459 a(n) = number of permutations of {1,...,n} which are twice but not 3-times reformable.
 * @author Sean A. Irvine
 */
public class A055459 extends A007712 {

  private int mN = 3;
  private Z mF = Z.SIX;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    long count = 0;
    final Permutation perm = new Permutation(mN);
    int[] p;
    while ((p = perm.next()) != null) {
      final int[] reform = reform(Arrays.copyOf(p, p.length));
      if (reform != null) {
        final int[] reform2 = reform(reform);
        if (reform2 != null && reform(reform2) == null) {
          ++count;
        }
      }
    }
    return Z.valueOf(count);
  }
}
#!queue	A055497	1	->	-1	A008578	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a008.A008578;

/**
 * A055497 a(-1) = 4, a(0) = 5; thereafter a(n) = 4 + (Product_{k=1..n} prime(k))^2.
 * @author Sean A. Irvine
 */
public class A055497 extends A008578 {

  private Z mA = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
      return Z.FOUR;
    }
    mA = mA.multiply(super.next().square());
    return mA.add(4);
  }
}
#!queue	A055507	2	->	1	A210286	--------------------------------
package irvine.oeis.a055;
// Generated by gen_seq4.pl A210000/parmof3 at 2022-02-02 22:52

import irvine.oeis.a210.A210286;

/**
 * A055507 a(n) = Sum_{k=1..n} d(k)*d(n+1-k), where d(k) is number of positive divisors of k.
 * @author Georg Fischer
 */
public class A055507 extends A210286 {

  /** Construct the sequence. */
  public A055507() {
    super(2, n -> new Long[] {1L, n}, (n, w, x, y, z) -> w * z + x * y == n);
  }
}
#!queue	A055531	0	->	2	A001831	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a001.A001831;

/**
 * A055531 Number of labeled order relations on n nodes in which longest chain has 2 nodes.
 * @author Sean A. Irvine
 */
public class A055531 extends A001831 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A055540	0	->	1	A327371	--------------------------------
package irvine.oeis.a055;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a327.A327371;

/**
 * A055540 Total number of leaves (nodes of vertex degree 1) in all graphs of n nodes.
 * @author Sean A. Irvine
 */
public class A055540 extends A327371 {

  private int mN = 0;

  @Override
  public Z next() {
    final Polynomial<Z> t = g(++mN).coeff(mN);
    Z sum = Z.ZERO;
    for (int k = 1; k <= t.degree(); ++k) {
      sum = sum.add(t.get(k).multiply(k));
    }
    return sum;
  }
}
#!queue	A055542	0	->	1	A000088	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a000.A000088;

/**
 * A055542 Total number of nodes in all simple graphs of n nodes.
 * @author Sean A. Irvine
 */
public class A055542 extends A000088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(mN);
  }
}
#!queue	A055543	0	->	1	A000055	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a000.A000055;

/**
 * A055543 Total number of nodes in all trees with n nodes.
 * @author Sean A. Irvine
 */
public class A055543 extends A000055 {

  private long mN = 0;

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(++mN);
  }
}
#!queue	A055560	0	->	1	A001106	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a001.A001106;
import irvine.util.string.StringUtils;

/**
 * A055560 Base numbers of 9-gonal palindromic numbers.
 * @author Sean A. Irvine
 */
public class A055560 extends A001106 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (!StringUtils.isPalindrome(super.next().toString())) {
      // do nothing
    }
    return mN;
  }
}
#!queue	A055597	0	->	1	A048855	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a048.A048855;

/**
 * A055597 Powers of 2 in phi(n!).
 * @author Sean A. Irvine
 */
public class A055597 extends A048855 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(super.next().makeOdd().auxiliary());
  }
}
#!queue	A055600	1	->	0	A003586	--------------------------------
package irvine.oeis.a055;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a003.A003586;

/**
 * A055600 Numbers of form 2^i*3^j+1 with i, j &gt;= 0.
 * @author Georg Fischer
 */
public class A055600 extends A003586 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A055656	0	->	1	A048855	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000142;
import irvine.oeis.a048.A048855;

/**
 * A055656 Excess in exponents of powers of 2 in EulerPhi of n! compared to that of n!.
 * @author Sean A. Irvine
 */
public class A055656 extends A048855 {

  private final Sequence mF = new A000142().skip(1);

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(super.next().makeOdd().auxiliary() - mF.next().makeOdd().auxiliary());
  }
}

#!queue	A055667	1	->	0	A055668	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055667 Number of Eisenstein-Jacobi primes of norm n.
 * @author Sean A. Irvine
 */
public class A055667 extends A055668 {

  @Override
  public Z next() {
    return super.next().multiply(6);
  }
}
#!queue	A055668	1	->	0	A035143	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a035.A035143;

/**
 * A055668 Number of inequivalent Eisenstein-Jacobi primes of norm n.
 * @author Sean A. Irvine
 */
public class A055668 extends A035143 {

  private final Sequence mNorms = new A055664();
  private long mM = 0;

  /** Construct the sequence. */
  public A055668() {
    super(-3);
  }

  @Override
  public Z next() {
    if (mM == 0) {
      mM = mNorms.next().longValueExact();
      return Z.ZERO;
    }
    if (mN < mM - 1) {
      super.next();
      return Z.ZERO;
    }
    mM = mNorms.next().longValueExact();
    return super.next();
  }
}
#!queue	A055679	0	->	1	A048855	--------------------------------
package irvine.oeis.a055;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a048.A048855;

/**
 * A055679 Number of distinct prime factors of phi(n!).
 * @author Sean A. Irvine
 */
public class A055679 extends A048855 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mFactor.factorize(super.next()).omega());
  }
}
#!queue	A055684	2	->	3	A023022	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a023.A023022;

/**
 * A055684 Number of different n-pointed stars.
 * @author Sean A. Irvine
 */
public class A055684 extends A023022 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A055723	1	->	0	A000959	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a000.A000959;

/**
 * A055723 Number of lucky numbers (A000959) &lt;= 10^n.
 * @author Sean A. Irvine
 */
public class A055723 extends A000959 {

  private long mLimit = 0;
  private long mCount = 0;

  @Override
  public Z next() {
    mLimit = mLimit == 0 ? 1 : mLimit * 10;
    while (super.next().longValueExact() <= mLimit) {
      ++mCount;
    }
    return Z.valueOf(mCount++);
  }
}
#!queue	A055724	1	->	0	A031158	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a031.A031158;

/**
 * A055724 Number of lucky twins &lt;= 10^n.
 * @author Sean A. Irvine
 */
public class A055724 extends A031158 {

  private long mLimit = 0;
  private long mCount = 0;

  @Override
  public Z next() {
    mLimit = mLimit == 0 ? 1 : mLimit * 10;
    while (super.next().longValueExact() <= mLimit) {
      ++mCount;
    }
    return Z.valueOf(mCount++);
  }
}
#!queue	A055728	1	->	0	A031157	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.a031.A031157;

/**
 * A055728 Number of prime lucky numbers &lt;10^n.
 * @author Sean A. Irvine
 */
public class A055728 extends A031157 {

  private long mLimit = 0;
  private long mCount = 0;

  @Override
  public Z next() {
    mLimit = mLimit == 0 ? 1 : mLimit * 10;
    while (super.next().longValueExact() < mLimit) {
      ++mCount;
    }
    return Z.valueOf(mCount++);
  }
}
#!queue	A055866	0	->	2	A055818	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;

/**
 * A055866 Largest number that has the same number of digits in base 10 and base n, or 0 if no such number exists.
 * @author Sean A. Irvine
 */
public class A055866 extends A055818 {

  private static final Z[] SMALL = {
    null,
    null,
    Z.ONE,
    Z.TWO,
    Z.valueOf(15),
    Z.valueOf(124),
    Z.valueOf(1295),
    Z.valueOf(117648),
    Z.valueOf(1073741823),
    new Z("109418989131512359208"),
    Z.ZERO,
    new Z("9999999999999999999999999"),
    Z.valueOf(9999999999999L),
    Z.valueOf(999999999),
    Z.valueOf(9999999),
    Z.valueOf(999999),
    Z.valueOf(99999),
    Z.valueOf(99999),
    Z.valueOf(9999),
    Z.valueOf(9999),
    Z.valueOf(9999),
    Z.valueOf(9999),
  };
  private static final Z Z99 = Z.valueOf(99);
  private static final Z Z999 = Z.valueOf(999);
  private int mN = 1;

  @Override
  public Z next() {
    if (++mN < SMALL.length) {
      return SMALL[mN];
    }
    if (mN <= 31) {
      return Z999;
    }
    if (mN <= 99) {
      return Z99;
    }
    return Z.NINE;
  }
}
#!queue	A055936	1	->	0	A000625	--------------------------------
package irvine.oeis.a055;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000625;

/**
 * A055936 Stereoisomeric homologs with molecular formula C_{3+n} H_{6+2n}.
 * @author Sean A. Irvine
 */
public class A055936 extends A000625 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final Polynomial<Z> mB = RING.empty();

  @Override
  public Z next() {
    mB.add(super.next());
    return RING.pow(mB, 6, mN).coeff(mN)
      .add(RING.pow(mB.substitutePower(2, mN), 3, mN).coeff(mN).multiply(3))
      .add(RING.pow(mB.substitutePower(3, mN), 2, mN).coeff(mN).multiply2())
      .divide(6);
  }
}
#!queue	A055969	0	->	1	A000273	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000273;
import irvine.oeis.a003.A003086;

/**
 * A055969 Number of unlabeled digraphs with n nodes and an odd number of arcs.
 * @author Sean A. Irvine
 */
public class A055969 extends A000273 {

  private final Sequence mA = new A003086();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next()).divide2();
  }
}
#!queue	A056054	0	->	1	A002387	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002387;

/**
 * A056054 a(n) = smallest even number 2m such that value of odd harmonic series Sum_{j=0..m} 1/(2j) is &gt; n.
 * @author Sean A. Irvine
 */
public class A056054 extends A002387 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next().multiply2();
  }
}
#!queue	A056056	0	->	1	A056057	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;

/**
 * A056056 Square root of largest square dividing n-th central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056056 extends A056057 {

  @Override
  public Z next() {
    return super.next().sqrt();
  }
}
#!queue	A056057	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056057 The largest square which divides n-th central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056057 extends A001405 {

  protected final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return n.divide(mFactor.factorize(n).core());
  }
}
#!queue	A056058	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056058 Squarefree part of the n-th central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056058 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return mFactor.factorize(n).core();
  }
}
#!queue	A056059	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056059 GCD of largest square and squarefree part of central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A056059 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    final Z core = mFactor.factorize(n).core();
    return core.gcd(n.divide(core));
  }
}
#!queue	A056060	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056060 The powerfree part of the central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A056060 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = mFactor.factorize(super.next());
    Z prod = Z.ONE;
    for (final Z p : fs.toZArray()) {
      if (fs.getExponent(p) == 1) {
        prod = prod.multiply(p);
      }
    }
    return prod;
  }
}
#!queue	A056061	0	->	1	A056056	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;

/**
 * A056061 Number of square divisors of central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A056061 extends A056056 {

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).sigma0();
  }
}
#!queue	A056077	0	->	1	A001142	--------------------------------
package irvine.oeis.a056;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a001.A001142;

/**
 * A056077 Indices n of terms of sequence A001142, Product_{k=0..n} binomial(n,k), that are divisible by all primes &lt;= n.
 * @author Sean A. Irvine
 */
public class A056077 extends A001142 {

  private final Fast mPrime = new Fast();
  {
    super.next();
  }

  private boolean is(final Z t) {
    for (long p = 2; p <= mN; p = mPrime.nextPrime(p)) {
      if (t.mod(p) != 0) {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      if (is(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A056136	0	->	1	A029578	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a029.A029578;

/**
 * A056136 Largest positive integer whose harmonic mean with another positive integer is n.
 * @author Sean A. Irvine
 */
public class A056136 extends A029578 {

  private long mN = 0;
  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(++mN).divide2();
  }
}
#!queue	A056139	0	->	2	A030664	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a030.A030664;

/**
 * A056139 a(n) = n^2 - primefloor(n)*primeceiling(n).
 * @author Sean A. Irvine
 */
public class A056139 extends A030664 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(mN + 1).square().subtract(super.next());
  }
}
#!queue	A056152	0	->	2	A028657	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a028.A028657;

/**
 * A056152 Triangular array giving number of bipartite graphs with n vertices, no isolated vertices and a distinguished bipartite block with k=1..n-1 vertices, up to isomorphism.
 * @author Sean A. Irvine
 */
public class A056152 extends A028657 {

  @Override
  protected Z a(final int n, final int k) {
    return super.a(n, k).subtract(super.a(n - 1, k)).subtract(super.a(n, k - 1)).add(super.a(n - 1, k - 1));
  }

  private int mN = 1;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    return a(mM, mN - mM);
  }
}

#!queue	A056173	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056173 Number of unitary prime divisors of central binomial coefficient C(n, floor(n/2)) (A001405).
 * @author Sean A. Irvine
 */
public class A056173 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = mFactor.factorize(super.next());
    long cnt = 0;
    for (final Z p : fs.toZArray()) {
      if (fs.getExponent(p) == 1) {
        ++cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A056175	0	->	1	A056057	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A056175 Number of nonunitary prime divisors of the central binomial coefficient C(n, floor(n/2)) (A001405).
 * @author Sean A. Irvine
 */
public class A056175 extends A056057 {

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A056187	1	->	0	A056788	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.LeastPrimeFactorizer;
import irvine.math.z.Z;

/**
 * A056187 Least prime factor of n^n + (n+1)^(n+1).
 * @author Sean A. Irvine
 */
public class A056187 extends A056788 {

  @Override
  public Z next() {
    return LeastPrimeFactorizer.lpf(super.next());
  }
}
#!queue	A056201	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056201 Characteristic cube divisor (A056191) of central binomial coefficient (A001405).
 * @author Sean A. Irvine
 */
public class A056201 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = mFactor.factorize(super.next());
    Z prod = Z.ONE;
    for (final Z p : fs.toZArray()) {
      final int e = fs.getExponent(p);
      if (e > 1 && (e & 1) == 1) {
        prod = prod.multiply(p.pow(3));
      }
    }
    return prod;
  }
}
#!queue	A056202	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056202 Central binomial coefficient A001405(n) divided by its characteristic cube divisor A056201(n).
 * @author Sean A. Irvine
 */
public class A056202 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    final FactorSequence fs = mFactor.factorize(n);
    Z prod = Z.ONE;
    for (final Z p : fs.toZArray()) {
      final int e = fs.getExponent(p);
      if (e > 1 && (e & 1) == 1) {
        prod = prod.multiply(p.pow(3));
      }
    }
    return n.divide(prod);
  }
}
#!queue	A056207	0	->	1	A003095	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a003.A003095;

/**
 * A056207 Number of binary trees of height &lt;= n.
 * @author Sean A. Irvine
 */
public class A056207 extends A003095 {

  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(2);
  }
}
#!queue	A056304	0	->	1	A000048	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000048;
import irvine.oeis.a002.A002075;

/**
 * A056304 Number of primitive (period n) n-bead necklace structures using exactly three different colored beads.
 * A002075(n)-A000048(n)
 * @author Georg Fischer
 */
public class A056304 extends A000048 {

  private Sequence mSeq = new A002075();

  /** Construct the sequence. */
  public A056304() {
    super.next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056353	1	->	0	A152176	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a152.A152176;

/**
 * A056353 Number of bracelet structures using a maximum of three different colored beads.
 * @author Sean A. Irvine
 */
public class A056353 extends A152176 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(mN, 1).add(t(mN, 2)).add(t(mN, 3));
  }
}
#!queue	A056354	1	->	0	A152176	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a152.A152176;

/**
 * A056354 Number of bracelet structures using a maximum of four different colored beads.
 * @author Sean A. Irvine
 */
public class A056354 extends A152176 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(mN, 1).add(t(mN, 2)).add(t(mN, 3)).add(t(mN, 4));
  }
}
#!queue	A056355	1	->	0	A152176	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a152.A152176;

/**
 * A056355 Number of bracelet structures using a maximum of five different colored beads.
 * @author Sean A. Irvine
 */
public class A056355 extends A152176 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(mN, 1).add(t(mN, 2)).add(t(mN, 3)).add(t(mN, 4)).add(t(mN, 5));
  }
}
#!queue	A056356	1	->	0	A152176	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a152.A152176;

/**
 * A056356 Number of bracelet structures using a maximum of six different colored beads.
 * @author Sean A. Irvine
 */
public class A056356 extends A152176 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(mN, 1).add(t(mN, 2)).add(t(mN, 3)).add(t(mN, 4)).add(t(mN, 5)).add(t(mN, 6));
  }
}
#!queue	A056357	0	->	1	A000011	--------------------------------
package irvine.oeis.a056;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a000.A000011;

/**
 * A056357 Number of bracelet structures using exactly two different colored beads.
 * @author Georg Fischer
 */
public class A056357 extends A000011 {

  protected int mN;
  
  /** Construct the sequence. */
  public A056357() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(1);
  }
}
#!queue	A056366	0	->	1	A000046	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000007;
import irvine.oeis.a000.A000046;

/**
 * A056366 Number of primitive (period n) bracelet structures using exactly two different colored beads.
 * @author Sean A. Irvine
 */
public class A056366 extends A000046 {

  private final Sequence mA = new A000007();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A056367	0	->	1	A056362	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000046;

/**
 * A056367 Number of primitive (period n) bracelet structures using exactly three different colored beads.
 * @author Sean A. Irvine
 */
public class A056367 extends A056362 {

  private final Sequence mA = new A000046();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A056368	0	->	1	A056363	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056368 Number of primitive (period n) bracelet structures using exactly four different colored beads.
 * @author Sean A. Irvine
 */
public class A056368 extends A056363 {

  private final Sequence mA = new A056362();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A056369	0	->	1	A056364	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056369 Number of primitive (period n) bracelet structures using exactly five different colored beads.
 * @author Sean A. Irvine
 */
public class A056369 extends A056364 {

  private final Sequence mA = new A056363();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A056370	0	->	1	A056365	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056370 Number of primitive (period n) bracelet structures using exactly six different colored beads.
 * @author Sean A. Irvine
 */
public class A056370 extends A056365 {

  private final Sequence mA = new A056364();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A056415	0	->	1	A002729	--------------------------------
package irvine.oeis.a056;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a002.A002729;

/**
 * A056415 Number of step cyclic shifted sequences using exactly two different symbols.
 * @author Georg Fischer
 */
public class A056415 extends A002729 {

  protected int mN;
  
  /** Construct the sequence. */
  public A056415() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(2);
  }
}
#!queue	A056482	0	->	1	A056476	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056482 Number of primitive (aperiodic) palindromic structures using exactly three different symbols.
 * @author Georg Fischer
 */
public class A056482 extends A056476 {

  private final Sequence mSeq = new A056477();

  {
    next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056483	0	->	1	A056477	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056483 Number of primitive (aperiodic) palindromic structures using exactly four different symbols.
 * @author Georg Fischer
 */
public class A056483 extends A056477 {

  private final Sequence mSeq = new A056478();

  {
    next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056484	0	->	1	A056478	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056484 Number of primitive (aperiodic) palindromic structures using exactly five different symbols.
 * @author Georg Fischer
 */
public class A056484 extends A056478 {

  private final Sequence mSeq = new A056479();

  {
    next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056485	0	->	1	A056479	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056485 Number of primitive (aperiodic) palindromic structures using exactly six different symbols.
 * @author Georg Fischer
 */
public class A056485 extends A056479 {

  private final Sequence mSeq = new A056480();

  {
    next();
  }

  @Override
  public Z next() {
    return mSeq.next().subtract(super.next());
  }
}
#!queue	A056504	1	->	0	A285012	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285012;

/**
 * A056504 Number of periodic palindromic structures of length n using a maximum of three different symbols.
 * @author Sean A. Irvine
 */
public class A056504 extends A285012 {

  private int mN = -1;

  @Override
  public Z next() {
    return t(++mN, 3).add(t(mN, 2)).add(t(mN, 1));
  }
}
#!queue	A056505	1	->	0	A285012	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285012;

/**
 * A056505 Number of periodic palindromic structures using a maximum of four different symbols.
 * @author Sean A. Irvine
 */
public class A056505 extends A285012 {

  private int mN = -1;

  @Override
  public Z next() {
    return t(++mN, 4).add(t(mN, 3)).add(t(mN, 2)).add(t(mN, 1));
  }
}
#!queue	A056506	1	->	0	A285012	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285012;

/**
 * A056506 Number of periodic palindromic structures using a maximum of five different symbols.
 * @author Sean A. Irvine
 */
public class A056506 extends A285012 {

  private int mN = -1;

  @Override
  public Z next() {
    return t(++mN, 5).add(t(mN, 4)).add(t(mN, 3)).add(t(mN, 2)).add(t(mN, 1));
  }
}
#!queue	A056507	1	->	0	A285012	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285012;

/**
 * A056507 Number of periodic palindromic structures using a maximum of six different symbols.
 * @author Sean A. Irvine
 */
public class A056507 extends A285012 {

  private int mN = -1;

  @Override
  public Z next() {
    return t(++mN, 6).add(t(mN, 5)).add(t(mN, 4)).add(t(mN, 3)).add(t(mN, 2)).add(t(mN, 1));
  }
}
#!queue	A056513	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056513 Number of primitive (period n) periodic palindromic structures using a maximum of two different symbols.
 * @author Sean A. Irvine
 */
public class A056513 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 2).add(get(mN, 1));
  }
}
#!queue	A056514	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056514 Number of primitive (period n) periodic palindromic structures using a maximum of three different symbols.
 * @author Sean A. Irvine
 */
public class A056514 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 3).add(get(mN, 2)).add(get(mN, 1));
  }
}
#!queue	A056515	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056515 Number of primitive (period n) periodic palindromic structures using a maximum of four different symbols.
 * @author Sean A. Irvine
 */
public class A056515 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 4).add(get(mN, 3)).add(get(mN, 2)).add(get(mN, 1));
  }
}
#!queue	A056516	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056516 Number of primitive (period n) periodic palindromic structures using a maximum of five different symbols.
 * @author Sean A. Irvine
 */
public class A056516 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 5).add(get(mN, 4)).add(get(mN, 3)).add(get(mN, 2)).add(get(mN, 1));
  }
}
#!queue	A056517	1	->	0	A285037	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a285.A285037;

/**
 * A056517 Number of primitive (period n) periodic palindromic structures using a maximum of six different symbols.
 * @author Sean A. Irvine
 */
public class A056517 extends A285037 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 6).add(get(mN, 5)).add(get(mN, 4)).add(get(mN, 3)).add(get(mN, 2)).add(get(mN, 1));
  }
}
#!queue	A056536	0	->	1	A091018	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a091.A091018;

/**
 * A056536 Mapping from half-antidiagonal reading of the triangle (as used in A028297) to the column-by-column reading of the triangular tables.
 * @author Sean A. Irvine
 */
public class A056536 extends A091018 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A056582	0	->	2	A000312	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000312;
import irvine.oeis.a002.A002109;

/**
 * A056582 Highest common factor (or GCD) of n^n and hyperfactorial(n-1), i.e., gcd(n^n, product(k^k) for k &lt; n).
 * @author Sean A. Irvine
 */
public class A056582 extends A000312 {

  private final Sequence mA = new A002109();
  {
    super.next();
    super.next();
    mA.next();
  }

  @Override
  public Z next() {
    return super.next().gcd(mA.next());
  }
}
#!queue	A056596	0	->	1	A027423	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a027.A027423;
import irvine.oeis.a055.A055993;

/**
 * A056596 Number of nonsquare divisors of n!.
 * @author Sean A. Irvine
 */
public class A056596 extends A027423 {

  private final Sequence mA = new A055993();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}

#!queue	A056609	0	->	1	A034386	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a034.A034386;

/**
 * A056609 a(n) = rad(n!)/rad(A001142(n)) where rad(n) is the squarefree kernel of n, A007947(n).
 * @author Sean A. Irvine
 */
public class A056609 extends A034386 {

  private final Sequence mA = new A056606();
  {
    next();
  }

  @Override
  public Z next() {
    return super.next().divide(mA.next());
  }
}

#!queue	A056610	0	->	1	A034386	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a034.A034386;
import irvine.oeis.a048.A048633;

/**
 * A056610 Quotient: squarefree kernel of lcm(1,..,n) (or of n!) divided by kernel of central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056610 extends A034386 {

  private final Sequence mA = new A048633();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(mA.next());
  }
}

#!queue	A056621	1	->	2	A002931	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A056621 a(n) is the total radius of gyration of all self-avoiding polygons of length 2n on the square lattice.
 * @author Sean A. Irvine
 */
public class A056621 extends A002931 {

  {
    super.next();
  }

  @Override
  protected Z postFilter() {
    Z total = Z.ZERO;
    for (final Polygon polygon : mPolygons) {
      // Radius of gyration
      long r2 = 0;
      for (final Point pt1 : polygon) {
        final int x1 = pt1.left();
        final int y1 = pt1.right();
        for (final Point pt2 : polygon) {
          if (pt2 == pt1) {
            break;
          }
          final int x2 = pt2.left();
          final int y2 = pt2.right();
          final long dx = x1 - x2;
          final long dy = y1 - y2;
          r2 += dx * dx + dy * dy;
        }
      }
      total = total.add(r2);
    }
    return total;
  }
}
#!queue	A056625	1	->	2	A002931	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A056625 a(n) is the total area of all self-avoiding polygons of length 2n on the square lattice.
 * @author Sean A. Irvine
 */
public class A056625 extends A002931 {

  {
    super.next();
  }

  @Override
  protected Z postFilter() {
    Z total = Z.ZERO;
    for (final Polygon polygon : mPolygons) {
      // Area
      int area = 0;
      Point pt0 = null;
      for (final Point pt1 : polygon) {
        if (pt0 != null) {
          area += pt0.left() * pt1.right() - pt1.left() * pt0.right();
        }
        pt0 = pt1;
      }
      // Wrap around to get the last point closing the polygon
      for (final Point pt1 : polygon) {
        area += pt0.left() * pt1.right() - pt1.left() * pt0.right();
        break;
      }
      total = total.add(area / 2);
    }
    return total;
  }
}
#!queue	A056631	1	->	2	A002931	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A056631 a(n) is the total second area moment of all self-avoiding polygons of length 2n on the square lattice.
 * @author Sean A. Irvine
 */
public class A056631 extends A002931 {

  {
    super.next();
  }

  @Override
  protected Z postFilter() {
    Z total = Z.ZERO;
    for (final Polygon polygon : mPolygons) {
      // Area
      int area = 0;
      Point pt0 = null;
      for (final Point pt1 : polygon) {
        if (pt0 != null) {
          area += pt0.left() * pt1.right() - pt1.left() * pt0.right();
        }
        pt0 = pt1;
      }
      // Wrap around to get the last point closing the polygon
      for (final Point pt1 : polygon) {
        area += pt0.left() * pt1.right() - pt1.left() * pt0.right();
        break;
      }
      area /= 2;
      // Second moment
      total = total.add((long) area * area);
    }
    return total;
  }
}
#!queue	A056634	1	->	8	A002931	--------------------------------
package irvine.oeis.a056;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A056634 Number of polygons of length 2n with one hole on square lattice (not allowing rotations).
 * @author Sean A. Irvine
 */
public class A056634 extends A002931 {

  // WARNING: This is insanely slow

  private static final Point ORIGIN = new Point(0, 0);
  private final List<List<Polygon>> mSmall = new ArrayList<>();
  private final List<List<int[]>> mSmallBounds = new ArrayList<>();
  {
    mSmall.add(Collections.emptyList()); // 0
  }
  private final A002931 mSmallGenerator = new A002931() {
    @Override
    protected Z postFilter() {
      final ArrayList<Polygon> polys = new ArrayList<>();
      for (final Polygon p : mPolygons) {
        if (p.contains(ORIGIN)) {
          polys.add(p);
        } else {
          // To an evil back translation to ensure (0,0) is a point
          final Polygon trans = new Polygon(null, null);
          boolean first = true;
          int dx = 0;
          int dy = 0;
          for (final Point pt : p) {
            if (first) {
              dx = pt.left();
              dy = pt.right();
              first = false;
            }
            trans.add(new Point(pt.left() - dx, pt.right() - dy));
          }
          polys.add(trans);
        }
      }
      mSmall.add(polys);
      return Z.ZERO;
    }
  };
  private final long[] mCnt = new long[100];
  {
    super.next(); // 2
    super.next(); // 4
    super.next(); // 6
    super.next(); // 8
    super.next(); // 10
  }

  private int[] getBounds(final Polygon polygon) {
    int maxX = 0;
    int maxY = 0;
    for (final Point pt : polygon) {
      final int x = pt.left();
      if (x > maxX) {
        maxX = x;
      }
      final int y = pt.right();
      if (y > maxY) {
        maxY = y;
      }
    }
    return new int[] {maxX, maxY};
  }

  private List<Polygon> polys(final int n) {
    while (n >= mSmall.size()) {
      mSmallGenerator.next();
      final ArrayList<int[]> bounds = new ArrayList<>();
      for (final Polygon p : mSmall.get(mSmall.size() - 1)) {
        bounds.add(getBounds(p));
      }
      mSmallBounds.add(bounds);
    }
    return mSmall.get(n);
  }

  private boolean isInside(final Polygon polygon, final int x, final int y) {
    if (polygon.contains(new Point(x, y))) {
      return false; // Quick exit if this point hits the polygon
    }
    boolean inside = false;
    final int[] vertx = new int[polygon.size()];
    final int[] verty = new int[polygon.size()];
    int k = 0;
    for (final Point pt : polygon) {
      vertx[k] = pt.left();
      verty[k] = pt.right();
      ++k;
    }
    int p1x = vertx[0];
    int p1y = verty[0];
    for (int i = 1; i <= vertx.length; i++) {
      final int p2x = vertx[i % vertx.length];
      final int p2y = verty[i % vertx.length];
      if (y > Math.min(p1y, p2y) && y <= Math.max(p1y, p2y) && x <= Math.max(p1x, p2x) /*&& p1y != p2y*/) {
        final int c = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
        if (p1x == p2x || x <= c) {
          inside = !inside;
        }
      }
      p1x = p2x;
      p1y = p2y;
    }

    return inside;
  }

  private boolean isOk(final Polygon p, final Polygon q, final int x, final int y) {
    for (final Point pt : q) {
      if (p.contains(new Point(pt.left() + x, pt.right() + y))) {
        return false;
      }
    }
    return true;
  }

  @Override
  protected Z postFilter() {
    for (final Polygon polygon : mPolygons) {
      // Compute bounds
      final int[] bounds = getBounds(polygon);
      final int maxX = bounds[0];
      final int maxY = bounds[1];
      // Test each point potentially inside the bounding rectangle
      for (int y = 1; y < maxY; ++y) {
        for (int x = 1; x < maxX; ++x) {
          if (isInside(polygon, x, y)) {
            // See if we can play a smaller polygon inside
            for (int j = 1; j < mN / 2 - 4; ++j) {
              final List<Polygon> qp = polys(j);
              final List<int[]> qbounds = mSmallBounds.get(j);
              for (int k = 0; k < qp.size(); ++k) {
                final Polygon q = qp.get(k);
                final int[] qxy = qbounds.get(k);
                if (qxy[0] + x < maxX && qxy[1] + y < maxY && isOk(polygon, q, x, y)) {
                  ++mCnt[polygon.size() + q.size()];
                }
              }
            }
          }
        }
      }
    }
//    for (int j = 0; j < mCnt.length; ++j) {
//      if (mCnt[j] > 0) {
//        System.out.println(j + " " + mCnt[j]);
//      }
//    }
    return Z.valueOf(mCnt[mN + 4]);
  }
}
#!queue	A056646	0	->	1	A056056	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056646 Square root of largest unitary square divisor of central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056646 extends A056056 {

  private final Sequence mA = new A056059();

  @Override
  public Z next() {
    return super.next().divide(mA.next());
  }
}
#!queue	A056647	0	->	1	A056057	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056647 Largest unitary square divisor of central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056647 extends A056057 {

  private final Sequence mA = new A056059();

  @Override
  public Z next() {
    return super.next().divide(mA.next().square());
  }
}
#!queue	A056648	0	->	1	A056057	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056648 Number of unitary square divisors of central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056648 extends A056057 {

  private final Sequence mA = new A056059();
  private final PrimeDivision mFactor = new PrimeDivision();

  @Override
  public Z next() {
    return Z.ONE.shiftLeft(mFactor.factorize(super.next().sqrt().divide(mA.next())).omega());
  }
}
#!queue	A056649	0	->	1	A056061	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A056649 Number of non-unitary square divisors of central binomial coefficient.
 * @author Sean A. Irvine
 */
public class A056649 extends A056061 {

  private final Sequence mA = new A056648();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A056670	0	->	1	A001405	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A056670 Largest prime factor of which the exponent exceeds 1 among prime factors of central binomial coefficient, C(n, floor(n/2)); largest non-unitary prime factor of A001405(n); or the maximal prime divisor of the largest square divisor(A056057(n)) of C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A056670 extends A001405 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = mFactor.factorize(super.next());
    final Z[] f = fs.toZArray();
    for (int k = f.length - 1; k >= 0; --k) {
      if (fs.getExponent(f[k]) > 1) {
        return f[k];
      }
    }
    return Z.ONE;
  }
}
#!queue	A056672	0	->	1	A055773	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;
import irvine.oeis.a055.A055773;

/**
 * A056672 Number of unitary and squarefree divisors of n! Also, number of divisors of the special squarefree part of n!, A055773(n).
 * @author Sean A. Irvine
 */
public class A056672 extends A055773 {

  private final PrimeDivision mFactor = new PrimeDivision();
  {
    super.next();
  }

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).sigma0();
  }
}
#!queue	A056673	0	->	1	A056060	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.PrimeDivision;
import irvine.math.z.Z;

/**
 * A056673 Number of unitary and squarefree divisors of binomial(n, floor(n/2)). Also the number of divisors of the powerfree part of A001405(n), A056060(n).
 * @author Sean A. Irvine
 */
public class A056673 extends A056060 {

  private final PrimeDivision mFactor = new PrimeDivision();

  @Override
  public Z next() {
    return mFactor.factorize(super.next()).sigma0();
  }
}
#!queue	A056676	0	->	1	A039593	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a039.A039593;

/**
 * A056676 Number of non-unitary but squarefree divisors of binomial(n,floor(n/2)). Also number of nonsquarefree but unitary divisors of binomial(n,floor(n/2)).
 * @author Sean A. Irvine
 */
public class A056676 extends A039593 {

  private final Sequence mA = new A056673();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A056790	1	->	0	A056788	--------------------------------
package irvine.oeis.a056;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A056790 Greatest prime factor of n^n + (n+1)^(n+1).
 * @author Sean A. Irvine
 */
public class A056790 extends A056788 {

  @Override
  public Z next() {
    final Z[] p = Jaguar.factor(super.next()).toZArray();
    return p[p.length - 1];
  }
}
#!queue	A056794	0	->	1	A002378	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a002.A002378;
import irvine.util.string.StringUtils;

/**
 * A056794 Numbers n such that n*(n-1) is an oblong (promic, A002378) palindrome.
 * @author Sean A. Irvine
 */
public class A056794 extends A002378 {

  @Override
  public Z next() {
    while (true) {
      if (StringUtils.isPalindrome(super.next().toString())) {
        return mN;
      }
    }
  }
}
#!queue	A056835	1	->	0	A024619	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a024.A024619;

/**
 * A056835 a(n) = lcm(s(1),...,s(n)) where {s(n)} = A024619 and a(0) = 1.
 * @author Sean A. Irvine
 */
public class A056835 extends A024619 {

  private Z mLcm = null;

  @Override
  public Z next() {
    mLcm = mLcm == null ? Z.ONE : mLcm.lcm(super.next());
    return mLcm;
  }
}
#!queue	A056851	0	->	1	A034886	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a034.A034886;

/**
 * A056851 Integers n such that the number of digits in n! is a cube.
 * @author Sean A. Irvine
 */
public class A056851 extends A034886 {

  @Override
  public Z next() {
    while (true) {
      if (ZUtils.isCube(super.next())) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A056872	0	->	1	A000041	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000009;
import irvine.oeis.a000.A000041;

/**
 * A056872 Numbers n such that n | p(n) + q(n) where p(n) = partition numbers (A000041) and q(n) = partition numbers into distinct parts (A000009).
 * @author Sean A. Irvine
 */
public class A056872 extends A000041 {

  private final Sequence mA = new A000009();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next().add(mA.next());
      if (mN > 0 && t.mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A056873	0	->	1	A000041	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000009;
import irvine.oeis.a000.A000041;

/**
 * A056873 Numbers n such that n | p(n) - q(n) where p(n) = partition numbers (A000041) and q(n) = partition numbers into distinct parts (A000009).
 * @author Sean A. Irvine
 */
public class A056873 extends A000041 {

  private final Sequence mA = new A000009();

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next().subtract(mA.next());
      if (mN > 0 && t.mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A056897	1	->	0	A056896	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;

/**
 * A056897 Smallest square where a(n)+n is prime.
 * @author Sean A. Irvine
 */
public class A056897 extends A056896 {

  @Override
  public Z next() {
    return super.next().subtract(mN);
  }
}
#!queue	A056904	1	->	0	A005473	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.a005.A005473;

/**
 * A056904 Floor[p/24] where p is a prime which is 4 more than a square.
 * @author Sean A. Irvine
 */
public class A056904 extends A005473 {

  @Override
  public Z next() {
    return super.next().divide(24);
  }
}
#!queue	A056947	1	->	0	A029828	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.PrependSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000594;
import irvine.oeis.a029.A029828;

/**
 * A056947 Theta series of nonexistent Niemeier lattice of Coxeter number 1.
 * @author Sean A. Irvine
 */
public class A056947 extends A029828 {

  private final Sequence mA = new PrependSequence(new A000594(), 0);

  @Override
  public Z next() {
    return super.next().subtract(mA.next().multiply(48936)).divide(691);
  }
}
#!queue	A056973	0	->	1	A023416	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a023.A023416;
import irvine.oeis.a033.A033264;

/**
 * A056973 Number of blocks of {0,0} in the binary expansion of n.
 * @author Sean A. Irvine
 */
public class A056973 extends A023416 {

  {
    super.next();
  }
  private final Sequence mA = new A033264();

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A057004	0	->	1	A160449	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.FiniteSequence;
import irvine.oeis.a160.A160449;
import irvine.oeis.transform.InverseEulerTransform;

/**
 * A057004 Array T(n,k) = number of conjugacy classes of subgroups of index k in free group of rank n, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A057004 extends A160449 {

  private int mN = 2;
  private int mM = 1;

  @Override
  protected Z t(final int n, final int k) {
    final FiniteSequence seq = new FiniteSequence();
    for (int j = 1; j < n; ++j) {
      seq.add(super.t(j, k));
    }
    final InverseEulerTransform iet = new InverseEulerTransform(seq);
    for (int j = 2; j < n; ++j) {
      iet.next();
    }
    return iet.next();
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 2;
    }
    return t(mM, mN - mM);
  }
}
#!queue	A057013	0	->	1	A057004	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057013 Number of conjugacy classes of subgroups of index n in free group of rank n.
 * @author Sean A. Irvine
 */
public class A057013 extends A057004 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN + 1, mN);
  }
}
#!queue	A057019	0	->	1	A006882	--------------------------------
package irvine.oeis.a057;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A057019 Difference between n!! and the first prime after n!! + 1.
 * @author Sean A. Irvine
 */
public class A057019 extends A006882 {

  private final Fast mPrime = new Fast();
  {
    super.next(); // skip 0!!
  }

  @Override
  public Z next() {
    final Z df = super.next();
    return mPrime.nextPrime(df.add(1)).subtract(df);
  }
}
#!queue	A057034	0	->	4	A006882	--------------------------------
package irvine.oeis.a057;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A057034 Difference between n!! and the first prime before n!! - 1.
 * @author Sean A. Irvine
 */
public class A057034 extends A006882 {

  private final Fast mPrime = new Fast();
  {
    super.next(); // skip 0!!
    super.next(); // skip 1!!
    super.next(); // skip 2!!
    super.next(); // skip 3!!
  }

  @Override
  public Z next() {
    final Z df = super.next();
    return df.subtract(mPrime.prevPrime(df.subtract(1)));
  }
}
#!queue	A057046	1	->	0	A057036	--------------------------------
package irvine.oeis.a057;
// Generated by gen_seq4.pl A057036/parm4 at 2022-01-27 21:17

import irvine.oeis.a000.A000079;

/**
 * A057046 Let R(i,j) be the rectangle with antidiagonals 1; 2,3; 4,5,6; ...; each k is an R(i(k),j(k)) and A057046(n)=i(2^n).
 * @author Georg Fischer
 */
public class A057046 extends A057036 {

  /** Construct the sequence. */
  public A057046() {
    super(new A000079(), 1, 0);
  }
}
#!queue	A057047	1	->	0	A057036	--------------------------------
package irvine.oeis.a057;
// Generated by gen_seq4.pl A057036/parm4 at 2022-01-27 21:17

import irvine.oeis.a000.A000079;

/**
 * A057047 Let R(i,j) be the rectangle with antidiagonals 1; 2,3; 4,5,6; ...; each k is an R(i(k),j(k)) and A057047(n)=j(2^n).
 * @author Georg Fischer
 */
public class A057047 extends A057036 {

  /** Construct the sequence. */
  public A057047() {
    super(new A000079(), 2, 0);
  }
}
#!queue	A057055	1	->	3	A057036	--------------------------------
package irvine.oeis.a057;
// Generated by gen_seq4.pl A057036/parm4 at 2022-01-27 21:17

import irvine.oeis.a000.A000292;

/**
 * A057055 Let R(i,j) be the rectangle with antidiagonals 1; 2,3; 4,5,6; ...; each k is an R(i(k),j(k)) and A057055(n)=i(C(n,3)).
 * @author Georg Fischer
 */
public class A057055 extends A057036 {

  /** Construct the sequence. */
  public A057055() {
    super(new A000292(), 1, 1);
  }
}
#!queue	A057056	1	->	3	A057036	--------------------------------
package irvine.oeis.a057;
// Generated by gen_seq4.pl A057036/parm4 at 2022-01-27 21:17

import irvine.oeis.a000.A000292;

/**
 * A057056 Let R(i,j) be the rectangle with antidiagonals 1; 2,3; 4,5,6; ...; each k is an R(i(k),j(k)) and A057056(n)=j(C(n,3)).
 * @author Georg Fischer
 */
public class A057056 extends A057036 {

  /** Construct the sequence. */
  public A057056() {
    super(new A000292(), 2, 1);
  }
}
#!queue	A057057	1	->	3	A057036	--------------------------------
package irvine.oeis.a057;
// Generated by gen_seq4.pl A057036/parm4 at 2022-01-27 21:17

import irvine.oeis.a000.A000292;

/**
 * A057057 Let R(i,j) be the rectangle with antidiagonals 1; 2,3; 4,5,6; ...; C(n,3) is in antidiagonal a(n).
 * @author Georg Fischer
 */
public class A057057 extends A057036 {

  /** Construct the sequence. */
  public A057057() {
    super(new A000292(), 3, 1);
  }
}
#!queue	A057106	0	->	1	A000567	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a000.A000567;
import irvine.util.string.StringUtils;

/**
 * A057106 Numbers k such that k(3k-2) is an octagonal palindrome.
 * @author Sean A. Irvine
 */
public class A057106 extends A000567 {

  @Override
  public Z next() {
    while (!StringUtils.isPalindrome(super.next().toString())) {
      // do nothing
    }
    return mN;
  }
}
#!queue	A057152	1	->	0	A057149	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057152 Limiting number of m X m binary matrices with m+n ones, with no zero rows or columns, up to row and column permutations, as m tends to infinity.
 * @author Sean A. Irvine
 */
public class A057152 extends A057149 {

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : t(3 * mN, 4 * mN);
  }
}
#!queue	A057332	1	->	0	A056525	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a056.A056525;

/**
 * A057332 a(n) is the number of (2n+1)-digit palindromic primes that undulate.
 * @author Sean A. Irvine
 */
public class A057332 extends A056525 {

  private Z mPalin = super.next();
  private Z mLimit = Z.ONE;

  @Override
  public Z next() {
    mLimit = mLimit.multiply(100);
    long cnt = 0;
    while (mPalin.compareTo(mLimit) < 0) {
      if (mPalin.isProbablePrime() && ZUtils.isUndulate(mPalin)) {
        ++cnt;
      }
      mPalin = super.next();
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A057517	0	->	1	A014486	--------------------------------
package irvine.oeis.a057;

import irvine.lisp.SExpression;
import irvine.math.z.Z;
import irvine.oeis.a014.A014486;

/**
 * A057517 Binary encodings of the Catalan mountain ranges with exactly one sea-level valley, i.e., the rooted plane trees with root degree = 2.
 * @author Sean A. Irvine
 */
public class A057517 extends A014486 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final SExpression s = SExpression.binexp2pars(super.next());
    final SExpression t = new SExpression();
    t.add(s.car());
    t.add(s.cdr());
    return t.toZ();
  }
}
#!queue	A057518	0	->	1	A057517	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057518 The global ranks of each term of A057517, i.e., tells that A057515(A057518(n)) = 2 for all n.
 * @author Sean A. Irvine
 */
public class A057518 extends A057517 {

  @Override
  public Z next() {
    return A057120.catalanGlobalRank(super.next());
  }
}
#!queue	A057519	0	->	1	A057517	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057519 The local ranks of each term of A057517.
 * @author Sean A. Irvine
 */
public class A057519 extends A057517 {

  @Override
  public Z next() {
    final Z n = super.next();
    return A057121.catalanRank(n.bitLength() / 2, n);
  }
}
#!queue	A057596	-2	->	0	A039834	--------------------------------
package irvine.oeis.a057;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a039.A039834;

/**
 * A057596 E.g.f. is 1/E(x) where E(x) is e.g.f. for [1,0,1,1,2,3,5,8,...] with o.g.f. (1-x)/(1-x-x^2).
 * @author Sean A. Irvine
 */
public class A057596 extends A039834 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  {
    super.next();
  }
  private final Polynomial<Q> mE = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    mE.add(new Q(super.next().abs(), MemoryFactorial.SINGLETON.factorial(++mN)));
    return RING.coeff(RING.one(), mE, mN).multiply(MemoryFactorial.SINGLETON.factorial(mN)).toZ();
  }
}
#!queue	A057650	1	->	2	A056004	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a056.A056004;

/**
 * A057650 Second step in Goodstein sequences, i.e., g(4) if g(2)=n: (first step) write g(2)=n in hereditary representation base 2, bump to base 3, then subtract 1 to produce g(3)=A056004(n), then (second step) write g(3) in hereditary representation base 3, bump to base 4, then subtract 1 to produce g(4).
 * @author Sean A. Irvine
 */
public class A057650 extends A056004 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return code(super.next(), 3);
  }
}
#!queue	A057718	0	->	1	A036917	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a036.A036917;

/**
 * A057718 A036917/8 (omitting leading term of A036917).
 * @author Sean A. Irvine
 */
public class A057718 extends A036917 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(8);
  }
}
#!queue	A057752	0	->	1	A006880	--------------------------------
package irvine.oeis.a057;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a006.A006880;

/**
 * A057752 Difference between nearest integer to Li(10^n) and pi(10^n), where Li(x) = integral of log(x) and pi(10^n) = number of primes &lt;= 10^n (A006880).
 * @author Sean A. Irvine
 */
public class A057752 extends A006880 {

  private Z mA = Z.ONE;
  {
    super.next();
  }

  @Override
  public Z next() {
    mA = mA.multiply(10);
    return CR.valueOf(mA).li().subtract(CR.valueOf(super.next())).round();
  }
}
#!queue	A057766	0	->	1	A000105	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a000.A000105;

/**
 * A057766 Total area of all n-celled polyominoes.
 * @author Sean A. Irvine
 */
public class A057766 extends A000105 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(mN);
  }
}

#!queue	A057835	0	->	1	A006880	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006880;

/**
 * A057835 Difference between pi(10^n) and the integer nearest to 10^n / log(10^n).
 * @author Sean A. Irvine
 */
public class A057835 extends A006880 {

  private final Sequence mA = new A057834();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A057924	0	->	1	A057923	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057924 Sequence b(n) mentioned in A057923.
 * @author Sean A. Irvine
 */
public class A057924 extends A057923 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return t.or(mA);
  }
}
#!queue	A057927	0	->	1	A057926	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057927 Sequence b(n) mentioned in A057926.
 * @author Sean A. Irvine
 */
public class A057927 extends A057926 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return t.or(mA);
  }
}
#!queue	A057930	0	->	1	A057929	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057930 Sequence b(n) mentioned in A057929.
 * @author Sean A. Irvine
 */
public class A057930 extends A057929 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return t.or(mA);
  }
}
#!queue	A057970	0	->	1	A057968	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057970 5 x n binary matrices with 1 unit column up to row and column permutations.
 * @author Sean A. Irvine
 */
public class A057970 extends A057968 {

  private int mN = 0;

  @Override
  public Z next() {
    return b(++mN, 1);
  }
}
#!queue	A057971	0	->	2	A057968	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057971 Number of 5 x n binary matrices with 2 unit columns up to row and column permutations.
 * @author Sean A. Irvine
 */
public class A057971 extends A057968 {

  private int mN = 1;

  @Override
  public Z next() {
    return b(++mN, 2);
  }
}
#!queue	A057972	0	->	3	A057968	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;

/**
 * A057972 Number of 5 X n binary matrices with 3 unit columns up to row and column permutations.
 * @author Sean A. Irvine
 */
public class A057972 extends A057968 {

  private int mN = 2;

  @Override
  public Z next() {
    return b(++mN, 3);
  }
}
#!queue	A057980	1	->	4	A005114	--------------------------------
package irvine.oeis.a057;

import irvine.math.group.MatrixField;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a005.A005114;

/**
 * A057980 Let n be a positive integer, n&gt;3. Define a tournament on the vertex set {2,3,..,n} by: for i &lt; j, i is adjacent to j if i divides j, else j is adjacent to i. If T(n) denotes its adjacency matrix, then the above sequence is det(T(n))for n=4,5,6....42.
 * @author Sean A. Irvine
 */
public class A057980 extends A005114 {

  private int mN = 2;

  @Override
  public Z next() {
    final DefaultMatrix<Q> mat = new DefaultMatrix<>(++mN, mN, Q.ZERO);
    for (int k = 2; k < mN + 2; ++k) {
      for (int j = 2; j < k; ++j) {
        if (k % j == 0) {
          mat.set(j - 2, k - 2, Q.ONE);
        } else {
          mat.set(k - 2, j - 2, Q.ONE);
        }
      }
    }
    return new MatrixField<>(mN, Rationals.SINGLETON).det(mat).toZ();
  }
}
#!queue	A057999	1	->	0	A036012	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.a036.A036012;

/**
 * A057999 a(n) is smallest prime such that a(n)-1 is a proper multiple of a(n-1)-1, with a(0) = 2.
 * @author Sean A. Irvine
 */
public class A057999 extends A036012 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply(super.next());
    return mA.add(1);
  }
}
#!queue	A058048	0	->	1	A058047	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.util.string.StringUtils;

/**
 * A058048 For each prime P consider the generalized Collatz sequence of each integer N &gt; 1 defined by c(0) = N, c(m+1) = c(m) * P + 1 if F &gt; P, else c(m+1) = c(m) / F, where F is the smallest factor of c(m), until the sequence cycles. If all c(i) &gt; 1 for some starting number N then P belongs to the sequence (and vice versa).
 * @author Sean A. Irvine
 */
public class A058048 extends A058047 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.TWO;
    }
    while (true) {
      mP = mPrime.nextPrime(mP);
      if (mVerbose) {
        StringUtils.message("Testing: " + mP);
      }
      if (!is(mP)) {
        return mP;
      }
    }
  }
}
#!queue	A058085	0	->	5	A058057	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058085 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058085 extends A058057 {

  private int mN = 4;

  @Override
  public Z next() {
    return t(++mN, mN - 5);
  }
}

#!queue	A058086	0	->	6	A058057	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058086 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058086 extends A058057 {

  private int mN = 5;

  @Override
  public Z next() {
    return t(++mN, mN - 6);
  }
}

#!queue	A058089	0	->	6	A058087	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058089 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058089 extends A058087 {

  private int mN = 5;

  @Override
  public Z next() {
    return t(++mN, mN - 6);
  }
}

#!queue	A058090	0	->	7	A058087	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058090 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058090 extends A058087 {

  private int mN = 6;

  @Override
  public Z next() {
    return t(++mN, mN - 7);
  }
}

#!queue	A058164	0	->	1	A055512	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a055.A055512;

/**
 * A058164 Number of labeled lattices with a fixed bottom.
 * @author Sean A. Irvine
 */
public class A058164 extends A055512 {

  @Override
  public Z next() {
    if (mN < 0) {
      super.next();
    }
    return super.next().divide(mN);
  }
}
#!queue	A058165	0	->	2	A058164	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;

/**
 * A058165 Number of labeled lattices with fixed a fixed bottom and top.
 * @author Sean A. Irvine
 */
public class A058165 extends A058164 {

  @Override
  public Z next() {
    if (mN <= 0) {
      super.next();
    }
    return super.next().divide(mN - 1);
  }
}
#!queue	A058193	0	->	1	A000230	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a000.A000230;

/**
 * A058193 Smallest prime p such that there is a gap of 6n between p and the next prime.
 * @author Sean A. Irvine
 */
public class A058193 extends A000230 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    super.next();
    return super.next();
  }
}
#!queue	A058194	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058194 Number of n-rowed matrices with entries {0,1,2,3} and all row sums 3, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058194 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(++mN, 3 * mN, 3);
  }
}
#!queue	A058204	-1	->	0	A007253	--------------------------------
package irvine.oeis.a058;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.a007.A007253;

/**
 * A058204 McKay-Thompson series of class 10c for Monster.
 * @author Sean A. Irvine
 */
public class A058204 extends A007253 {

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final Polynomial<Q> mA = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    final Q t = new Q(super.next());
    mA.add(++mN == 1 ? t.subtract(Q.FOUR) : t);
    return RING.sqrt(mA, mN).coeff(mN).toZ();
  }
}

#!queue	A058209	1	->	2	A000203	--------------------------------
package irvine.oeis.a058;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.a000.A000203;

/**
 * A058209 a(n) = floor( exp(gamma) n log log n ) - sigma(n), where gamma is Euler's constant (A001620) and sigma(n) is sum of divisors of n (A000203).
 * @author Sean A. Irvine
 */
public class A058209 extends A000203 {

  private static final CR EXP_GAMMA = CR.GAMMA.exp();
  private long mN = 1;
  {
    super.next();
  }

  @Override
  public Z next() {
    return EXP_GAMMA.multiply(++mN).multiply(CR.valueOf(mN).log().log()).floor().subtract(super.next());
  }
}

#!queue	A058261	1	->	0	A006577	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a006.A006577;

/**
 * A058261 a(n) = n times the Collatz number of n (as given in A006577).
 * @author Sean A. Irvine
 */
public class A058261 extends A006577 {

  @Override
  public Z next() {
    return super.next().multiply(mN);
  }
}
#!queue	A058314	0	->	1	A006882	--------------------------------
package irvine.oeis.a058;

import irvine.math.ContinuedFractionUtils;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A058314 Sum of terms in simple continued fraction for n!!/(n-1)!!, where n!! is a double factorial, n(n-2)(n-4)....
 * @author Sean A. Irvine
 */
public class A058314 extends A006882 {

  private Z mA = super.next();

  @Override
  public Z next() {
    final Z t = mA;
    mA = super.next();
    return ContinuedFractionUtils.continuedFractionSum(new Q(mA, t));
  }
}
#!queue	A058320	1	->	0	A014320	--------------------------------
package irvine.oeis.a058;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a014.A014320;

/**
 * A058320 Distinct even prime-gap lengths (number of composites between primes), from 3+2, 7+4, 23+6,...
 * @author Georg Fischer
 */
public class A058320 extends A014320 {

  /** Construct the sequence. */
  public A058320() {
    skip(1);
  }
}
#!queue	A058352	1	->	0	A000084	--------------------------------
package irvine.oeis.a058;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000084;

/**
 * A058352 a(n) Sum_{d|n, 1&lt;=d&lt;n} d*A000084(d).
 * @author Sean A. Irvine
 */
public class A058352 extends A000084 {

  protected final ArrayList<Z> mS = new ArrayList<>();
  {
    mS.add(Z.ZERO);
  }
  private int mN = 0;

  protected boolean accept(final int d) {
    return d < mN;
  }

  @Override
  public Z next() {
    mS.add(super.next());
    Z sum = Z.ZERO;
    if (++mN > 0) {
      for (final Z d : Jaguar.factor(mN).divisors()) {
        final int dd = d.intValueExact();
        if (accept(dd)) {
          sum = sum.add(mS.get(dd).multiply(d));
        }
      }
    }
    return sum;
  }
}

#!queue	A058389	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058389 Number of 3 X 3 matrices with nonnegative integer entries and all row sums equal to n, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058389 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(3, 3, ++mN);
  }
}

#!queue	A058390	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058390 Number of 4 X 4 matrices with nonnegative integer entries and all row sums equal to n, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058390 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(4, 4, ++mN);
  }
}

#!queue	A058391	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058391 Number of 5 X 5 matrices with nonnegative integer entries and all row sums equal to n, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058391 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(5, 5, ++mN);
  }
}

#!queue	A058392	1	->	0	A318951	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a318.A318951;

/**
 * A058392 Number of 6 X 6 matrices with nonnegative integer entries and all row sums equal to n, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A058392 extends A318951 {

  private int mN = -1;

  @Override
  public Z next() {
    return rowSumMats(6, 6, ++mN);
  }
}

#!queue	A058552	1	->	0	A013963	--------------------------------
package irvine.oeis.a058;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.a013.A013963;

/**
 * A058552 Numerators of q-expansion of Eisenstein series E_16(q).
 * @author Sean A. Irvine
 */
public class A058552 extends A013963 {

  private static final Q C = new Q(16320, 3617);
  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return C.multiply(super.next()).num();
  }
}
#!queue	A058723	0	->	-1	A003114	--------------------------------
package irvine.oeis.a058;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a003.A003106;
import irvine.oeis.a003.A003114;

/**
 * A058723 McKay-Thompson series of class 58a for the Monster group.
 * @author Sean A. Irvine
 */
public class A058723 extends A003114 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final Sequence mHSeq = new A003106();
  private final Polynomial<Z> mG = RING.empty();
  private final Polynomial<Z> mH = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mG.add(super.next());
    mH.add(mHSeq.next());
    return RING.multiply(mG, mG.substitutePower(29, mN), mN).coeff(mN)
      .add(mN < 6 ? Z.ZERO : RING.multiply(mH, mH.substitutePower(29, mN - 6), mN - 6).coeff(mN - 6));
  }
}
#!queue	A058737	1	->	2	A000669	--------------------------------
package irvine.oeis.a058;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a000.A000669;

/**
 * A058737 Main diagonal of A058735.
 * @author Sean A. Irvine
 */
public class A058737 extends A000669 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final Polynomial<Z> mB = RING.empty();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    mB.add(super.next());
    return RING.pow(mB, 2, mN).coeff(mN).add(mB.substitutePower(2, mN).coeff(mN)).divide2();
  }
}
#!queue	A058756	1	->	0	A000084	--------------------------------
package irvine.oeis.a058;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a000.A000084;

/**
 * A058756 G.f. is (1-S)/(1+S), where S = g.f. for A000084.
 * @author Sean A. Irvine
 */
public class A058756 extends A000084 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final Polynomial<Z> mA = RING.empty();
  private final Polynomial<Z> mB = RING.empty();
  private int mN = -1;
  {
    mA.add(Z.ONE);
    mB.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z s = super.next();
    mA.add(s.negate());
    mB.add(s);
    return RING.coeff(mA, mB, ++mN);
  }
}
#!queue	A058786	1	->	5	A342053	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a342.A342053;

/**
 * A058786 Number of n-hedra with 2n-5 vertices or 3n-7 edges (the vertices of these are all of degree 3, except one which is of degree 4). Alternatively, the number of polyhedra with n vertices whose faces are all triangular, except one which is tetragonal.
 * @author Sean A. Irvine
 */
public class A058786 extends A342053 {

  private int mN = 0;

  @Override
  public Z next() {
    return a342053ColSeq(++mN, 4).coeff(mN);
  }
}
#!queue	A058802	0	->	3	A006966	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006966;

/**
 * A058802 Vertically decomposable lattices on n unlabeled nodes.
 * @author Sean A. Irvine
 */
public class A058802 extends A006966 {

  private final Sequence mA = new A058800();
  {
    super.next();
    super.next();
    super.next();
    mA.next();
    mA.next();
    mA.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}
#!queue	A058814	0	->	1	A034886	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a034.A034886;

/**
 * A058814 Numbers k such that k divides the number of digits of k!.
 * @author Sean A. Irvine
 */
public class A058814 extends A034886 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A058851	0	->	1	A005843	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a005.A005843;
import irvine.util.string.StringUtils;

/**
 * A058851 Sum of even composites up to n is palindromic.
 * @author Sean A. Irvine
 */
public class A058851 extends A005843 {

  private Z mN = Z.ZERO;
  {
    super.next(); // skip 0
    super.next(); // skip 2
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      mN = mN.add(t);
      if (StringUtils.isPalindrome(mN.toString())) {
        return t;
      }
    }
  }
}
#!queue	A058868	1	->	0	A006562	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a006.A006562;

/**
 * A058868 Maximal distances of equidistant lonely primes shown in A058867.
 * @author Sean A. Irvine
 */
public class A058868 extends A006562 {

  private int mDelta = -1;

  @Override
  public Z next() {
    if (mDelta == -1) {
      super.next(); // handle 5
      mDelta = 0;
      return Z.TWO;
    }
    while (true) {
      final Z p = super.next();
      final Z q = mPrime.nextPrime(p);
      final int delta = q.subtract(p).intValueExact();
      if (delta % 6 == 0) {
        final int d = delta / 6;
        if (d > mDelta) {
          mDelta = d;
          return Z.valueOf(delta);
        }
      }
    }
  }
}
#!queue	A058886	0	->	2	A000700	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.a000.A000700;

/**
 * A058886 Sum of the row of the character table of S_n corresponding to the partition 2,1^{n-2}.
 * @author Sean A. Irvine
 */
public class A058886 extends A000700 {

  private Z mSum = super.next().add(super.next());
  private Z mPrev = Z.ZERO;

  @Override
  public Z next() {
    mSum = mSum.add(mPrev.multiply2());
    mPrev = super.next();
    mSum = mSum.subtract(mPrev);
    return mSum;
  }
}
#!queue	A058894	1	->	0	A006881	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a006.A006881;
import irvine.oeis.a007.A007304;

/**
 * A058894 |A006881(m)-A007304(m)| = 1, sequence gives A006881(m).
 * @author Sean A. Irvine
 */
public class A058894 extends A006881 {

  private final Sequence mA = new A007304();

  @Override
  public Z next() {
    while (true) {
      final Z s = super.next();
      final Z t = mA.next();
      if (s.subtract(t).abs().equals(Z.ONE)) {
        return s;
      }
    }
  }
}
#!queue	A058909	0	->	1	A058760	--------------------------------
package irvine.oeis.a058;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A058909 Integers whose set of prime factors (taken with multiplicity) uses each digit exactly once (i.e., is pandigital) in base 10.
 * @author Sean A. Irvine
 */
public class A058909 extends A058760 {

  private long mN = 15618089;

  private boolean is(final long n) {
    final FactorSequence fs = Jaguar.factor(n);
    if (!fs.isSquareFree()) {
      return false;
    }
    final long[] p = ZUtils.toLong(fs.toZArray());
    return is(p, 10);
  }

  @Override
  public Z next() {
    if (mN == 8439563243L) {
      return null;
    }
    while (true) {
      if (is(++mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A059146	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059146 A hierarchical sequence (W'2{2} - see A059126).
 * @author Sean A. Irvine
 */
public class A059146 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 3)) {
      case 0:
        mA = super.next().square();
        return mA;
      case 1:
        return mA.multiply2();
      case 2:
      default:
        return mA;
    }
  }
}

#!queue	A059147	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059147 A hierarchical sequence (W'2{3} - see A059126).
 * @author Sean A. Irvine
 */
public class A059147 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 7)) {
      case 0:
        mA = super.next().pow(3);
        return mA;
      case 2:
      case 4:
      case 6:
        return mA;
      case 3:
        return mA.multiply(4);
      case 1:
      case 5:
      default:
        return mA.multiply2();
    }
  }
}

#!queue	A059148	1	->	0	A059146	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059148 A hierarchical sequence (W'3{2,2} - see A059126).
 * @author Sean A. Irvine
 */
public class A059148 extends A059146 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 3)) {
      case 0:
        mA = super.next().square();
        return mA;
      case 1:
        return mA.multiply2();
      case 2:
      default:
        return mA;
    }
  }
}

#!queue	A059149	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059149 A hierarchical sequence (W'2{2}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059149 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 3)) {
      case 0:
        do {
          mA = super.next();
        } while (Z.ONE.equals(mA));
        return mA.divide2();
      case 1:
        return mA;
      case 2:
      default:
        return mA.divide2();
    }
  }
}

#!queue	A059150	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059150 A hierarchical sequence (W'2{3}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059150 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 7)) {
      case 0:
        do {
          mA = super.next();
        } while (mA.compareTo(Z.TWO) <= 0);
        return mA.shiftRight(2);
      case 3:
        return mA;
      case 2:
      case 4:
      case 6:
        return mA.shiftRight(2);
      case 1:
      case 5:
      default:
        return mA.divide2();
    }
  }
}

#!queue	A059151	1	->	0	A006519	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a006.A006519;

/**
 * A059151 A hierarchical sequence (W'3{2,2}* - see A059126).
 * @author Sean A. Irvine
 */
public class A059151 extends A006519 {

  private Z mA = null;
  private long mN = -1;

  @Override
  public Z next() {
    switch ((int) (++mN % 9)) {
      case 0:
        mA = super.next();
        return mA;
      case 4:
        return mA.multiply(4);
      case 2:
      case 6:
      case 8:
        return mA;
      case 1:
      case 3:
      case 5:
      case 7:
      default:
        return mA.multiply2();
    }
  }
}

#!queue	A059152	1	->	0	A059146	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059152 A hierarchical sequence (W'2{2}c - see A059126).
 * @author Sean A. Irvine
 */
public class A059152 extends A059146 {

  @Override
  public Z next() {
    return super.next().add(super.next()).add(super.next());
  }
}

#!queue	A059154	1	->	0	A059147	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059154 A hierarchical sequence (W'2{3}c - see A059126).
 * @author Sean A. Irvine
 */
public class A059154 extends A059147 {

  @Override
  public Z next() {
    return super.next().add(super.next()).add(super.next()).add(super.next()).add(super.next()).add(super.next()).add(super.next());
  }
}

#!queue	A059156	1	->	0	A059148	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059156 A hierarchical sequence (W'3{2,2}c - see A059126).
 * @author Sean A. Irvine
 */
public class A059156 extends A059148 {

  @Override
  public Z next() {
    return super.next().add(super.next()).add(super.next());
  }
}

#!queue	A059157	1	->	0	A059156	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059157 A hierarchical sequence (W'3{2,2}cc - see A059126).
 * @author Sean A. Irvine
 */
public class A059157 extends A059156 {

  @Override
  public Z next() {
    return super.next().add(super.next()).add(super.next());
  }
}

#!queue	A059158	1	->	0	A059157	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059158 A hierarchical sequence (S(W'3{2,2}cc) - see A059126).
 * @author Sean A. Irvine
 */
public class A059158 extends A059157 {

  private int mN = -1;
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    long m = 0;
    final long lim = 1L << mN;
    while (m < lim) {
      mSum = mSum.add(super.next());
      ++m;
    }
    return mSum;
  }
}

#!queue	A059161	1	->	0	A059150	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059161 A hierarchical sequence (W'2{3}*c - see A059126).
 * @author Sean A. Irvine
 */
public class A059161 extends A059150 {

  @Override
  public Z next() {
    return super.next().add(super.next()).add(super.next()).add(super.next()).add(super.next()).add(super.next()).add(super.next());
  }
}

#!queue	A059163	1	->	0	A059151	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059163 A hierarchical sequence (W'3{2,2}*c - see A059126).
 * @author Sean A. Irvine
 */
public class A059163 extends A059151 {

  @Override
  public Z next() {
    return super.next().add(super.next()).add(super.next());
  }
}

#!queue	A059164	1	->	0	A059163	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059164 A hierarchical sequence (W'3{2,2}*cc - see A059126).
 * @author Sean A. Irvine
 */
public class A059164 extends A059163 {

  @Override
  public Z next() {
    return super.next().add(super.next()).add(super.next());
  }
}

#!queue	A059220	0	->	1	A059219	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059220 The array in A059219 read by antidiagonals in 'up' direction.
 * @author Sean A. Irvine
 */
public class A059220 extends A059219 {

  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A059229	0	->	1	A059226	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059229 A diagonal of triangle defined in A059226.
 * @author Sean A. Irvine
 */
public class A059229 extends A059226 {

  private int mN = 0;

  @Override
  public Z next() {
    return get(++mN, mN - 1);
  }
}
#!queue	A059235	0	->	1	A059219	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059235 The array in A059219 read by antidiagonals in the direction in which it was constructed.
 * @author Sean A. Irvine
 */
public class A059235 extends A059219 {

  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, (mN & 1) == 1 ? mM : mN - mM);
  }
}
#!queue	A059249	0	->	1	A004489	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a004.A004489;

/**
 * A059249 Tersum n + (n-1); write n and n-1 in base 3 and add mod 3 with no carries.
 * @author Sean A. Irvine
 */
public class A059249 extends A004489 {

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    final Z m = mN;
    mN = mN.add(1);
    return tersum(mN, m);
  }
}

#!queue	A059251	7	->	1	A000580	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000027;
import irvine.oeis.a000.A000292;
import irvine.oeis.a000.A000580;

/**
 * A059251 A sequence related to numeric partitions and Fermat Coefficients.
 * @author Sean A. Irvine
 */
public class A059251 extends A000580 {

  private final Sequence mM2 = new A000292(); // C(n,3)
  private final Sequence mM4 = new A000027(); // C(n,1)
  private int mN = -1;
  {
    mM2.next();
  }

  @Override
  public Z next() {
    Z t = super.next();
    if ((++mN & 1) == 0) {
      t = t.add(mM2.next());
    }
    if ((mN & 3) == 0) {
      t = t.add(mM4.next().multiply(6));
    }
    return t.divide(8);
  }
}

#!queue	A059355	2	->	3	A008826	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a008.A008826;

/**
 * A059355 Number of chains of n-3 partitions in the reduced partition lattice on n elements.
 * @author Sean A. Irvine
 */
public class A059355 extends A008826 {

  private int mN = 0;

  @Override
  public Z next() {
    return get(++mN + 2).get(mN);
  }
}
#!queue	A059356	1	->	2	A008298	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a008.A008298;

/**
 * A059356 A diagonal of triangle in A008298.
 * @author Sean A. Irvine
 */
public class A059356 extends A008298 {

  private int mN = 1;

  @Override
  public Z next() {
    return get(++mN).get(2);
  }
}
#!queue	A059357	1	->	3	A008298	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a008.A008298;

/**
 * A059357 A diagonal of triangle in A008298.
 * @author Sean A. Irvine
 */
public class A059357 extends A008298 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN).get(3);
  }
}
#!queue	A059360	1	->	0	A059333	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059360 a(n) = A059333(2^n).
 * @author Sean A. Irvine
 */
public class A059360 extends A059333 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply2();
    return f(mA);
  }
}
#!queue	A059439	1	->	0	A059438	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059439 A diagonal of A059438.
 * @author Sean A. Irvine
 */
public class A059439 extends A059438 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, 2);
  }
}
#!queue	A059440	1	->	3	A059438	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059440 A diagonal of A059438.
 * @author Sean A. Irvine
 */
public class A059440 extends A059438 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3);
  }
}
#!queue	A059443	0	->	2	A060052	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Integers;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.a060.A060052;

/**
 * A059443 Triangle T(n,k) (n &gt;= 2, k = 3..n+floor(n/2)) giving number of bicoverings of an n-set with k blocks.
 * @author Sean A. Irvine
 */
public class A059443 extends A060052 {

  @Override
  protected Z t(final int n, final int m) {
    return Integers.SINGLETON.sum(0, n, k -> Stirling.secondKind(n, k).multiply(super.t(k, m)));
  }
}
#!queue	A059451	0	->	1	A059010	--------------------------------
package irvine.oeis.a059;

import java.util.TreeSet;

import irvine.math.z.Z;

/**
 * A059451 Number of ways n can be written as the sum of two numbers whose binary expansions have even numbers of zeros; also number of ways n can be written as the sum of two numbers whose binary expansions have odd numbers of zeros.
 * @author Sean A. Irvine
 */
public class A059451 extends A059010 {

  private final TreeSet<Long> mA = new TreeSet<>();
  private long mN = 0;
  {
    mA.add(super.next().longValueExact()); // Avoid need for isEmpty check later
  }

  @Override
  public Z next() {
    ++mN;
    while (mN > mA.last()) {
      mA.add(super.next().longValueExact());
    }
    long cnt = 0;
    for (final long v : mA) {
      if (2 * v > mN) {
        break;
      }
      if (mA.contains(mN - v)) {
        ++cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}

#!queue	A059510	0	->	1	A059219	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059510 Main diagonal of the array A059220.
 * @author Sean A. Irvine
 */
public class A059510 extends A059219 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(2 * ++mN, mN);
  }
}
#!queue	A059529	1	->	0	A058377	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a058.A058377;

/**
 * A059529 For 1 &lt; x, each c(i) is "multiply" (*) or "divide" (/); a(n) is number of choices for c(0),...,c(n-1) so that 1 c(0) x^1 c(1) x^2,.., c(n-1) x^n is an integer.
 * @author Sean A. Irvine
 */
public class A059529 extends A058377 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return super.next().add(Z.ONE.shiftLeft(mN - 1));
  }
}
#!queue	A059724	0	->	2	A059720	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059724 Second diagonal of A059720.
 * @author Sean A. Irvine
 */
public class A059724 extends A059720 {

  private int mN = 1;

  @Override
  public Z next() {
    return step(++mN)[2];
  }
}

#!queue	A059730	0	->	3	A059922	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059730 Third diagonal of A059922.
 * @author Sean A. Irvine
 */
public class A059730 extends A059922 {

  private int mN = -1;

  @Override
  public Z next() {
    return get(++mN, mN + 3);
  }
}

#!queue	A059793	1	->	0	A005574	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a005.A005574;

/**
 * A059793 Stationary value of quotient in the continued fraction expansion of sqrt(prime) when the quotient-cycle-length = 1.
 * @author Sean A. Irvine
 */
public class A059793 extends A005574 {

  @Override
  public Z next() {
    return super.next().multiply2();
  }
}
#!queue	A059853	1	->	2	A003285	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A059853 Period of continued fraction for sqrt(n^2+3), n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A059853 extends A003285 {

  {
    mN = 1;
  }

  @Override
  public Z next() {
    return period(Z.valueOf(++mN).square().add(3));
  }
}
#!queue	A059854	1	->	3	A003285	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A059854 Period of continued fraction for sqrt(n^2+5), n &gt;= 3.
 * @author Sean A. Irvine
 */
public class A059854 extends A003285 {

  {
    mN = 2;
  }

  @Override
  public Z next() {
    return period(Z.valueOf(++mN).square().add(5));
  }
}
#!queue	A059866	1	->	2	A003285	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A059866 Period length of the continued fraction for sqrt(2^n-1).
 * @author Sean A. Irvine
 */
public class A059866 extends A003285 {

  private Z mA = Z.TWO;

  @Override
  public Z next() {
    mA = mA.multiply2();
    return period(mA.subtract(1));
  }
}
#!queue	A059878	1	->	0	A059876	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a014.A014437;

/**
 * A059878 a(n) = bin_prime_sum(fibonacci(A001651[n])), where fibonacci(A001651[n]) is A014437[n].
 * @author Sean A. Irvine
 */
public class A059878 extends A059876 {

  private final Sequence mA = new A014437();
  {
    mA.next();
  }

  @Override
  public Z next() {
    return binPrimeSum(mA.next());
  }
}
#!queue	A059902	1	->	0	A059884	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.Sequence;

/**
 * A059902 Partitions encoded by interleaving bits in parts. The partition [P1+P2+P3+...] with P1&gt;=P2&gt;=P3&gt;=... is encoded in binary by recursively interleaving the bits of P1 with the (recursively interleaved bits of P2 with the (recursively...)).
 * @author Sean A. Irvine
 */
public class A059902 extends A059884 {

  private final Sequence mA = new A059901();

  @Override
  public Z next() {
    return encode(mA.next());
  }
}
#!queue	A059926	1	->	4	A003285	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A059926 Length of period of the continued fraction expansion of sqrt(2^n+1).
 * @author Sean A. Irvine
 */
public class A059926 extends A003285 {

  private int mN = 3;

  @Override
  public Z next() {
    return period(Z.ONE.shiftLeft(++mN).add(1));
  }
}
#!queue	A059927	1	->	0	A003285	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A059927 Period length of the continued fraction for sqrt(2^(2n+1)).
 * @author Sean A. Irvine
 */
public class A059927 extends A003285 {

  private int mN = -1;

  @Override
  public Z next() {
    mN += 2;
    return period(Z.ONE.shiftLeft(mN));
  }
}
#!queue	A059934	1	->	2	A057650	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a057.A057650;

/**
 * A059934 Third step in Goodstein sequences, i.e., g(5) if g(2)=n: write g(4)=A057650(n) in hereditary representation base 4, bump to base 5, then subtract 1 to produce g(5).
 * @author Sean A. Irvine
 */
public class A059934 extends A057650 {

  @Override
  public Z next() {
    return code(super.next(), 4);
  }
}
#!queue	A059935	1	->	3	A059934	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059935 Fourth step in Goodstein sequences, i.e., g(6) if g(2)=n: write g(5)=A059934(n) in hereditary representation base 5, bump to base 6, then subtract 1 to produce g(6).
 * @author Sean A. Irvine
 */
public class A059935 extends A059934 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return code(super.next(), 5);
  }
}
#!queue	A059936	1	->	3	A059935	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059936 Fifth step in Goodstein sequences, i.e., g(7) if g(2)=n: write g(6)=A059935(n) in hereditary representation base 6, bump to base 7, then subtract 1 to produce g(7).
 * @author Sean A. Irvine
 */
public class A059936 extends A059935 {

  @Override
  public Z next() {
    return code(super.next(), 6);
  }
}
#!queue	A059947	0	->	1	A059443	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059947 Number of 6-block bicoverings of an n-set.
 * @author Sean A. Irvine
 */
public class A059947 extends A059443 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 6);
  }
}
#!queue	A059948	0	->	1	A059443	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059948 Number of 7-block bicoverings of an n-set.
 * @author Sean A. Irvine
 */
public class A059948 extends A059443 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 7);
  }
}
#!queue	A059949	0	->	1	A059443	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059949 Number of 8-block bicoverings of an n-set.
 * @author Sean A. Irvine
 */
public class A059949 extends A059443 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 8);
  }
}
#!queue	A059950	0	->	1	A059443	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059950 Number of 9-block bicoverings of an n-set.
 * @author Sean A. Irvine
 */
public class A059950 extends A059443 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 9);
  }
}
#!queue	A059951	0	->	1	A059443	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;

/**
 * A059951 Number of 10-block bicoverings of an n-set.
 * @author Sean A. Irvine
 */
public class A059951 extends A059443 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 10);
  }
}
#!queue	A059954	0	->	1	A051775	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a051.A051775;

/**
 * A059954 Number of 2 X 2 matrices with elements from {0,1,2,...,n} and with Nim-Determinant 1. (The Nim-Determinant of the 2 X 2 matrix [a,b; c,d] is defined to be a*d xor b*c, where * denotes Nim-Multiplication.).
 * @author Sean A. Irvine
 */
public class A059954 extends A051775 {

  // This could me made incremental (i.e., avoid recomputing < mN cases)

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    long cnt = 0;
    for (long h = 0; h <= mN; ++h) {
      for (long i = 0; i <= mN; ++i) {
        final Z a = nimMultiply(h, i);
        for (long j = 0; j <= mN; ++j) {
          for (long k = 0; k <= mN; ++k) {
            final Z b = nimMultiply(j, k);
            final Z det = nimSum(a, b);
            if (Z.ONE.equals(det)) {
              ++cnt;
            }
          }
        }
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A059970	0	->	1	A051775	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.a051.A051775;

/**
 * A059970 Nim-factorials: a(1)=1 and, for n&gt;1, a(n)=n*a(n-1), where * denotes Nim multiplication.
 * @author Sean A. Irvine
 */
public class A059970 extends A051775 {

  private Z mF = Z.ONE;
  private long mN = 0;

  @Override
  public Z next() {
    mF = get(mF, Z.valueOf(++mN));
    return mF;
  }
}
#!queue	A060012	0	->	1	A000928	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a000.A000928;

/**
 * A060012 Lesser of irregular twin primes.
 * @author Sean A. Irvine
 */
public class A060012 extends A000928 {

  private Z mA = super.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mA;
      mA = super.next();
      if (mA.subtract(t).equals(Z.TWO)) {
        return t;
      }
    }
  }
}
#!queue	A060052	0	->	2	A276640	--------------------------------
package irvine.oeis.a060;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.a276.A276640;

/**
 * A060052 Triangle read by rows: T(n,k) gives number of r-bicoverings of an n-set with k blocks, n &gt;= 2, k = 3..n+floor(n/2).
 * @author Sean A. Irvine
 */
public class A060052 extends A276640 {

  private int mN = 1;
  private int mM = 1;

  @Override
  protected Z t(final int n, final int m) {
    return super.t(m, n).multiply(MemoryFactorial.SINGLETON.factorial(n)).divide(MemoryFactorial.SINGLETON.factorial(m));
  }

  @Override
  public Z next() {
    if (++mM > mN + mN / 2) {
      ++mN;
      mM = 3;
    }
    return t(mN, mM);
  }
}
#!queue	A060056	1	->	0	A059419	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a059.A059419;

/**
 * A060056 Nonzero numbers in expansion of ((tan(x))^4)/4! in (x^n)/n!.
 * @author Sean A. Irvine
 */
public class A060056 extends A059419 {

  private long mN = 2;

  @Override
  public Z next() {
    mN += 2;
    return get(mN, 4L);
  }
}
#!queue	A060057	1	->	0	A059419	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a059.A059419;

/**
 * A060057 Nonzero numbers in expansion of ((tan(x))^5)/5! in (x^n)/n!.
 * @author Sean A. Irvine
 */
public class A060057 extends A059419 {

  private long mN = 3;

  @Override
  public Z next() {
    mN += 2;
    return get(mN, 5L);
  }
}
#!queue	A060216	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060216 Number of orbits of length n under the full 13-shift (whose periodic points are counted by A001022).
 * @author Georg Fischer
 */
public class A060216 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 13;
  }
}
#!queue	A060217	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060217 Number of orbits of length n under the full 14-shift (whose periodic points are counted by A001023).
 * @author Georg Fischer
 */
public class A060217 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 14;
  }
}
#!queue	A060218	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060218 Number of orbits of length n under the full 15-shift (whose periodic points are counted by A001024).
 * @author Georg Fischer
 */
public class A060218 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 15;
  }
}
#!queue	A060219	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060219 Number of orbits of length n under the full 16-shift (whose periodic points are counted by A001025).
 * @author Georg Fischer
 */
public class A060219 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 16;
  }
}
#!queue	A060220	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060220 Number of orbits of length n under the full 17-shift (whose periodic points are counted by A001026).
 * @author Georg Fischer
 */
public class A060220 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 17;
  }
}
#!queue	A060221	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060221 Number of orbits of length n under the full 18-shift (whose periodic points are counted by A001027).
 * @author Georg Fischer
 */
public class A060221 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 18;
  }
}
#!queue	A060222	0	->	1	A001692	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl A001692/colors at 2022-02-13 22:54

import irvine.oeis.a001.A001692;

/**
 * A060222 Number of orbits of length n under the full 19-shift (whose periodic points are counted by A001029).
 * @author Georg Fischer
 */
public class A060222 extends A001692 {

  {
    next(); // skip 0th
  }

  @Override
  protected int colors() {
    return 19;
  }
}
#!queue	A060335	1	->	3	A058876	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a058.A058876;

/**
 * A060335 Number of n-node labeled acyclic digraphs with 3 out-points.
 * @author Sean A. Irvine
 */
public class A060335 extends A058876 {

  private int mN = 2;

  @Override
  public Z next() {
    return get(++mN, 3);
  }
}
#!queue	A060369	0	->	1	A060240	--------------------------------
package irvine.oeis.a060;

import java.util.HashMap;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;

/**
 * A060369 a(n) is the maximum number of occurrences of a degree in the sequence of the degrees of the irreducible representations of the symmetric group S_n.
 * @author Sean A. Irvine
 */
public class A060369 extends A060240 {

  private int mN = 0;

  @Override
  public Z next() {
    final IntegerPartition partitions = new IntegerPartition(++mN);
    final HashMap<Z, Long> counts = new HashMap<>();
    int[] p;
    while ((p = partitions.next()) != null) {
      final Z deg = degree(mN, p);
      counts.merge(deg, 1L, Long::sum);
    }
    long max = 0;
    for (final Long v : counts.values()) {
      if (v > max) {
        max = v;
      }
    }
    return Z.valueOf(max);
  }
}
#!queue	A060379	1	->	2	A002931	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a002.A002931;
import irvine.util.Point;

/**
 * A060379 Number of self-avoiding polygons on the 2-dimensional square lattice with perimeter 2n with at most 4 horizontal edges in each vertical cross-section.
 * @author Sean A. Irvine
 */
public class A060379 extends A002931 {

  {
    super.next();
  }

  private boolean isAcceptable(final Polygon polygon) {
    final int[] cnts = new int[100];
    Point prev = null;
    for (final Point pt : polygon) {
      if (prev == null) {
        prev = pt;
      } else {
        if (pt.right().equals(prev.right())) {
          // Horizontal line
          final int x = Math.min(pt.left(), prev.left());
          if (++cnts[x] > 4) {
            return false;
          }
        }
        prev = pt;
      }
    }
    return true;
  }

  protected Z postFilter() {
    long count = 0;
    for (final Polygon p : mPolygons) {
      if (isAcceptable(p)) {
        ++count;
      }
    }
    return Z.valueOf(count);
  }
}

#!queue	A060426	0	->	1	A060240	--------------------------------
package irvine.oeis.a060;

import java.util.HashMap;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;

/**
 * A060426 a(n) is the number of degrees in the sequence of the degrees of the irreducible representations of the symmetric group S_n that appear only once.
 * @author Sean A. Irvine
 */
public class A060426 extends A060240 {

  private int mN = 0;

  @Override
  public Z next() {
    final IntegerPartition partitions = new IntegerPartition(++mN);
    final HashMap<Z, Long> counts = new HashMap<>();
    int[] p;
    while ((p = partitions.next()) != null) {
      final Z deg = degree(mN, p);
      counts.merge(deg, 1L, Long::sum);
    }
    long uniqueCount = 0;
    for (final Long v : counts.values()) {
      if (v == 1) {
        ++uniqueCount;
      }
    }
    return Z.valueOf(uniqueCount);
  }
}
#!queue	A060437	0	->	1	A060240	--------------------------------
package irvine.oeis.a060;

import java.util.HashSet;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;

/**
 * A060437 a(n) is the number of different degrees in the sequence of the degrees of the irreducible representations of the symmetric group S_n, i.e., count each degree only once.
 * @author Sean A. Irvine
 */
public class A060437 extends A060240 {

  private int mN = 0;

  @Override
  public Z next() {
    final IntegerPartition partitions = new IntegerPartition(++mN);
    final HashSet<Z> seen = new HashSet<>();
    int[] p;
    while ((p = partitions.next()) != null) {
      final Z deg = degree(mN, p);
      seen.add(deg);
    }
    return Z.valueOf(seen.size());
  }
}
#!queue	A060465	1	->	0	A060464	--------------------------------
package irvine.oeis.a060;

import irvine.math.LongUtils;
import irvine.math.z.Z;

/**
 * A060465 Value of x of the solution to x^3 + y^3 + z^3 = A060464(n) (numbers not 4 or 5 mod 9) with smallest |z| and smallest |y|, 0 &lt;= |x| &lt;= |y| &lt;= |z|.
 * @author Sean A. Irvine
 */
public class A060465 extends A060464 {

  static Z check(final Z x3, final long y, final long z, final Z n) {
    final Z x = x3.root(3);
    if (x3.auxiliary() != 1 || x.bitLength() > 63) {
      return null;
    }
    final long lx = x.longValue();
    if (Math.abs(lx) > y) {
      return null;
    }
    final long d = Math.abs(LongUtils.gcd(lx, y, z));
    return d == 1 || n.mod(d) != 0 ? x : null;
  }

  @Override
  public Z next() {
    final Z n = super.next();
    if (n.isZero()) {
      return Z.ZERO;
    }
    long z = 0;
    while (true) {
      final Z z3 = Z.valueOf(++z).pow(3);
      final Z nz3 = n.subtract(z3);
      if (nz3.isZero()) {
        return Z.ZERO;
      }
      final Z pz3 = n.add(z3);
      for (long y = 0; y <= z; ++y) {
        final Z y3 = Z.valueOf(y).pow(3);
        final Z x1 = check(nz3.subtract(y3), y, z, n);
        Z res = null;
        if (x1 != null) {
          res = x1;
        }
        final Z x2 = check(nz3.add(y3), y, z, n);
        if (x2 != null && (res == null || x2.abs().compareTo(res.abs()) < 0)) {
          res = x2;
        }
        final Z x3 = check(pz3.subtract(y3), y, z, n);
        if (x3 != null && (res == null || x3.abs().compareTo(res.abs()) < 0)) {
          res = x3;
        }
        final Z x4 = check(pz3.add(y3), y, z, n);
        if (x4 != null && (res == null || x4.abs().compareTo(res.abs()) < 0)) {
          res = x4;
        }
        if (res != null) {
          return res;
        }
      }
    }
  }
}
#!queue	A060466	1	->	0	A060464	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;

/**
 * A060466 Value of y of the solution to x^3 + y^3 + z^3 = A060464(n) (numbers not 4 or 5 mod 9) with smallest |z| and smallest |y|, 0 &lt;= |x| &lt;= |y| &lt;= |z|.
 * @author Sean A. Irvine
 */
public class A060466 extends A060464 {

  @Override
  public Z next() {
    final Z n = super.next();
    if (n.isZero()) {
      return Z.ZERO;
    }
    long z = 0;
    while (true) {
      final Z z3 = Z.valueOf(++z).pow(3);
      final Z nz3 = n.subtract(z3);
      if (nz3.isZero()) {
        return Z.ZERO;
      }
      final Z pz3 = n.add(z3);
      for (long y = 0; y <= z; ++y) {
        final Z y3 = Z.valueOf(y).pow(3);
        final Z x1 = A060465.check(nz3.subtract(y3), y, z, n);
        if (x1 != null) {
          return Z.valueOf(y);
        }
        final Z x2 = A060465.check(nz3.add(y3), y, z, n);
        if (x2 != null) {
          return Z.valueOf(-y);
        }
        final Z x3 = A060465.check(pz3.subtract(y3), y, z, n);
        if (x3 != null) {
          return Z.valueOf(y);
        }
        final Z x4 = A060465.check(pz3.add(y3), y, z, n);
        if (x4 != null) {
          return Z.valueOf(-y);
        }
      }
    }
  }
}
#!queue	A060467	1	->	0	A060464	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;

/**
 * A060467 Value of z of the solution to x^3 + y^3 + z^3 = A060464(n) (numbers not 4 or 5 mod 9) with smallest |z| and smallest |y|, 0 &lt;= |x| &lt;= |y| &lt;= |z|.
 * @author Sean A. Irvine
 */
public class A060467 extends A060464 {

  @Override
  public Z next() {
    final Z n = super.next();
    if (n.isZero()) {
      return Z.ZERO;
    }
    long z = 0;
    while (true) {
      final Z zz = Z.valueOf(++z);
      final Z z3 = zz.pow(3);
      final Z nz3 = n.subtract(z3);
      if (nz3.isZero()) {
        return zz;
      }
      final Z pz3 = n.add(z3);
      for (long y = 0; y <= z; ++y) {
        final Z y3 = Z.valueOf(y).pow(3);
        final Z x1 = A060465.check(nz3.subtract(y3), y, z, n);
        if (x1 != null) {
          return Z.valueOf(z);
        }
        final Z x2 = A060465.check(nz3.add(y3), y, z, n);
        if (x2 != null) {
          return Z.valueOf(z);
        }
        final Z x3 = A060465.check(pz3.subtract(y3), y, z, n);
        if (x3 != null) {
          return Z.valueOf(-z);
        }
        final Z x4 = A060465.check(pz3.add(y3), y, z, n);
        if (x4 != null) {
          return Z.valueOf(-z);
        }
      }
    }
  }
}
#!queue	A060688	0	->	1	A006156	--------------------------------
package irvine.oeis.a060;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a006.A006156;

/**
 * A060688 Number of dissimilar ternary squarefree words of length n+1.
 * @author Georg Fischer
 */
public class A060688 extends A006156 {

  protected int mN;
  
  /** Construct the sequence. */
  public A060688() {
    mN = 0;
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(6);
  }
}
#!queue	A060701	1	->	0	A008302	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a008.A008302;

/**
 * A060701 Table by antidiagonals of Mahonian numbers T(n,k): permutations of n letters with k inversions.
 * @author Sean A. Irvine
 */
public class A060701 extends A008302 {

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mM, mN + 1 - mM);
  }
}
#!queue	A060974	0	->	1	A000367	--------------------------------
package irvine.oeis.a060;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A060974 Irregular primes with irregularity &gt; 1.
 * @author Sean A. Irvine
 */
public class A060974 extends A000367 {

  private final ArrayList<Z> mB = new ArrayList<>();
  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      int c = 0;
      final long q = mP / 2;
      while (mB.size() < q) {
        mB.add(super.next());
      }
      for (int k = 1; k <= (mP - 3) / 2; ++k) {
        if (mB.get(k).mod(mP) == 0 && ++c > 1) {
          return Z.valueOf(mP);
        }
      }
    }
  }
}
#!queue	A060975	0	->	1	A000367	--------------------------------
package irvine.oeis.a060;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A060975 Irregular primes with irregularity index three.
 * @author Sean A. Irvine
 */
public class A060975 extends A000367 {

  private final ArrayList<Z> mB = new ArrayList<>();
  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      int c = 0;
      final long q = mP / 2;
      while (mB.size() < q) {
        mB.add(super.next());
      }
      for (int k = 1; k <= (mP - 3) / 2; ++k) {
        if (mB.get(k).mod(mP) == 0 && ++c > 3) {
          break;
        }
      }
      if (c == 3) {
        return Z.valueOf(mP);
      }
    }
  }
}
#!queue	A060976	0	->	1	A000367	--------------------------------
package irvine.oeis.a060;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A060976 Odd nonprimes c which divide Bernoulli(2*c).
 * @author Sean A. Irvine
 */
public class A060976 extends A000367 {

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      mN += 2;
      super.next();
      if (super.next().mod(mN) == 0 && !mPrime.isPrime(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A060982	1	->	0	A061870	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.a061.A061870;

/**
 * A060982 a(n) = Smallest nontrivial number k &gt; 9 such that |first (leftmost) decimal digit of k - second digit + third digit - fourth digit ...| = n.
 * @author Georg Fischer
 */
public class A060982 extends A061870 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    long k = 9;
    while (true) {
      ++k;
      if (Math.abs(alternatingDigitSum(String.valueOf(k))) == mN) {
        return Z.valueOf(k);
      }
    }
  }
}
#!queue	A061358	1	->	0	A045917	--------------------------------
package irvine.oeis.a061;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.a045.A045917;

/**
 * A061358 Number of ways of writing n = p+q with p, q primes and p &gt;= q.
 * @author Sean A. Irvine
 */
public class A061358 extends A045917 {

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    if (mN == 0 || (mN & 1) == 1) {
      return mPrime.isPrime(mN - 2) ? Z.ONE : Z.ZERO;
    } else {
      return super.next();
    }
  }
}

#!queue	A061460	0	->	1	A000578	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;

/**
 * A061460 Cubes which produce cubes when the leading digit is moved to the end.
 * @author Sean A. Irvine
 */
public class A061460 extends A000578 {

  {
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      final String s = t.toString();
      if (ZUtils.isCube(new Z(s.substring(1) + s.charAt(0)))) {
        return t;
      }
    }
  }
}

#!queue	A061479	1	->	0	A061870	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;

/**
 * A061479 Smallest number m such that first digit - second digit + third digit - fourth digit ... (of m) = n.
 * @author Georg Fischer
 */
public class A061479 extends A061870 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    long k = -1;
    while (true) {
      ++k;
      if (alternatingDigitSum(String.valueOf(k)) == mN) {
        return Z.valueOf(k);
      }
    }
  }
}
#!queue	A061490	1	->	0	A003285	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;
import irvine.util.string.StringUtils;

/**
 * A061490 Smallest number which when iterated n times under A003285 gives a square.
 * @author Sean A. Irvine
 */
public class A061490 extends A003285 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private int mN = -1;

  private boolean is(final long k, final int n) {
    Z t = Z.valueOf(k);
    for (int j = 0; j < n; ++j) {
      if (t.isSquare()) {
        return false;
      }
      t = period(t);
    }
    return t.isSquare();
  }

  @Override
  public Z next() {
    ++mN;
    long k = 0;
    while (true) {
      if (is(++k, mN)) {
        return Z.valueOf(k);
      }
      if (mVerbose && k % 100000 == 0) {
        StringUtils.message("n=" + mN + " search completed to " + k);
      }
    }
  }
}

#!queue	A061682	1	->	2	A003285	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A061682 Length of period of continued fraction expansion of square root of (2^(2n+1)+1).
 * @author Sean A. Irvine
 */
public class A061682 extends A003285 {

  private int mN = 1;

  @Override
  public Z next() {
    return period(Z.ONE.shiftLeft(2 * ++mN + 1).add(1));
  }
}

#!queue	A061769	1	->	0	A011778	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;
import irvine.oeis.a011.A011778;

/**
 * A061769 The least number k = a(n) &gt; a(n-1) for which k!/(k+1)^m for increasing m's.
 * @author Sean A. Irvine
 */
public class A061769 extends A011778 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A061882	1	->	0	A061870	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;

/**
 * A061882 a(n) = Smallest nontrivial number k &gt; 9 such that first (leftmost) digit - second digit + third digit - fourth digit ... of k = n.
 * @author Georg Fischer
 */
public class A061882 extends A061870 {

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    long k = 9;
    while (true) {
      ++k;
      if (alternatingDigitSum(String.valueOf(k)) == mN) {
        return Z.valueOf(k);
      }
    }
  }
}
#!queue	A061885	1	->	0	A004201	--------------------------------
package irvine.oeis.a061;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a004.A004201;

/**
 * A061885 n + largest triangular number less than or equal to n.
 * @author Georg Fischer
 */
public class A061885 extends A004201 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A062018	0	->	1	A000312	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000312;

/**
 * A062018 a(n) = n^n written backwards.
 * @author Sean A. Irvine
 */
public class A062018 extends A000312 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return ZUtils.reverse(super.next());
  }
}
#!queue	A062320	1	->	0	A013929	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.oeis.a013.A013929;

/**
 * A062320 Nonsquarefree numbers squared. A013929(n)^2.
 * @author Sean A. Irvine
 */
public class A062320 extends A013929 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A062322	1	->	0	A013929	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.oeis.a013.A013929;

/**
 * A062322 Factorials of nonsquarefree numbers, or A013929(n)!, (including 1).
 * @author Sean A. Irvine
 */
public class A062322 extends A013929 {

  private Z mF = null;
  private long mN = 2;

  @Override
  public Z next() {
    if (mF == null) {
      mF = Z.ONE;
      return Z.ONE;
    }
    final long t = super.next().longValueExact();
    while (mN <= t) {
      mF = mF.multiply(mN);
      ++mN;
    }
    return mF;
  }
}
#!queue	A062328	1	->	0	A003285	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A062328 Length of period of continued fraction expansion of square root of 3^n+1.
 * @author Sean A. Irvine
 */
public class A062328 extends A003285 {

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply(3);
    return period(mA.add(1));
  }
}
#!queue	A062556	0	->	1	A000578	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.oeis.a000.A000578;

/**
 * A062556 Cubes that are the concatenation of three numbers, one of which is the sum of the other two.
 * @author Sean A. Irvine
 */
public class A062556 extends A000578 {

  @Override
  public Z next() {
    while (true) {
      final Z sq = super.next();
      final String s = sq.toString();
      for (int k = 1; k < s.length() - 1; ++k) {
        final Z a = new Z(s.substring(0, k));
        if (s.charAt(k) != '0') {
          for (int j = k + 1; j < s.length(); ++j) {
            if (s.charAt(j) != '0') {
              final Z b = new Z(s.substring(k, j));
              final Z c = new Z(s.substring(j));
              if (a.equals(b.add(c)) || b.equals(a.add(c)) || c.equals(a.add(b))) {
                return sq;
              }
            }
          }
        }
      }
    }
  }
}
#!queue	A062686	0	->	1	A000578	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000578;
import irvine.util.array.LongDynamicArray;

/**
 * A062686 Smallest cube with digit sum n (or 0 if no such cube exists).
 * @author Sean A. Irvine
 */
public class A062686 extends A000578 {

  private final LongDynamicArray<Z> mFirsts = new LongDynamicArray<>();
  private long mN = 0;
  {
    super.next();
  }

  @Override
  public Z next() {
    final long r = ++mN % 9;
    if (r >= 2 && r <= 7) {
      return Z.ZERO;
    }
    while (mFirsts.get(mN) == null) {
      final Z cube = super.next();
      final long d = ZUtils.digitSum(cube);
      if (mFirsts.get(d) == null) {
        mFirsts.set(d, cube);
      }
    }
    return mFirsts.get(mN);
  }
}
#!queue	A062950	2	->	3	A023022	--------------------------------
package irvine.oeis.a062;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a023.A023022;

/**
 * A062950 C(H(n)), where C(n) is Chowla's function (A048050) and H(n) is the half-totient function (A023022).
 * @author Sean A. Irvine
 */
public class A062950 extends A023022 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z n = super.next();
    return Jaguar.factor(n).sigma().subtract(n).subtract(1);
  }
}

#!queue	A062963	2	->	3	A023022	--------------------------------
package irvine.oeis.a062;

import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.oeis.a023.A023022;

/**
 * A062963 Mu(n) * H(n) where H(n) is A023022.
 * @author Sean A. Irvine
 */
public class A062963 extends A023022 {

  private long mN = 2;
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().multiply(Mobius.mobius(++mN));
  }
}

#!queue	A062976	2	->	3	A023022	--------------------------------
package irvine.oeis.a062;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a023.A023022;

/**
 * A062976 Half-totient function of n is divisible by the number of divisors of n.
 * @author Sean A. Irvine
 */
public class A062976 extends A023022 {

  private long mN = 1;

  @Override
  public Z next() {
    while (true) {
      if (super.next().mod(Jaguar.factor(++mN).sigma0AsLong()) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A063079	0	->	1	A001790	--------------------------------
package irvine.oeis.a063;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001790;


/**
 * A063079 Bisection of A001790.
 * @author Georg Fischer
 */
public class A063079 extends A001790 {

  /** Construct the sequence. */
  public A063079() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A063535	1	->	0	A000040	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;
import irvine.oeis.a000.A000040;

/**
 * A063535 Primes prime(n) such that prime(n+1)^2 &lt; prime(n)*prime(n+2).
 * @author Sean A. Irvine
 */
public class A063535 extends A000040 {

  private Z mP = super.next();
  private Z mQ = super.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mP;
      mP = mQ;
      mQ = super.next();
      if (mP.square().compareTo(t.multiply(mQ)) < 0) {
        return t;
      }
    }
  }
}
#!queue	A063603	0	->	1	A063115	--------------------------------
package irvine.oeis.a063;
// Generated by gen_seq4.pl parm3 at 2021-05-31 07:18
// DO NOT EDIT here!

/**
 * A063603 Smallest k such that 6^k has exactly n 7's in its decimal representation.
 * @author Georg Fischer
 */
public class A063603 extends A063115 {

  /** Construct the sequence. */
  public A063603() {
    super(6, 7);
  }
}
#!queue	A063686	1	->	0	A048887	--------------------------------
package irvine.oeis.a063;

import irvine.math.api.Matrix;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.z.Euler;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a048.A048887;

/**
 * A063686 Triangular array: a(n,k) is the number of binary necklaces (no turning over) of length n whose longest run of 1's has length k. Table begins at n=0, k=0.
 * @author Sean A. Irvine
 */
public class A063686 extends A048887 {

  // After Andrew Howroyd

  private int mN = -1;
  private int mM = 0;
  private Matrix<Z> mT;

  private Matrix<Z> r(final int n) {
    final Matrix<Z> mat = new DefaultMatrix<>(n, n, Z.ZERO);
    for (long r = 0; r < mat.rows(); ++r) {
      for (long k = 0; k < mat.cols(); ++k) {
        mat.set(r, k, get(r + 1, k + 1));
      }
    }
    return mat;
  }

  private Z sum(final Matrix<Z> m, final long n, final int k) {
    return Integers.SINGLETON.sum(1, k, j -> m.get(n - j - 1, k).subtract(m.get(n - j - 1, k - 1L)).multiply(j));
  }

  private Matrix<Z> s(final Matrix<Z> m) {
    final Matrix<Z> mat = new DefaultMatrix<>(m.rows() - 1, m.cols() - 1, Z.ZERO);
    for (int n = 1; n <= mat.rows(); ++n) {
      for (int k = 1; k <= mat.cols(); ++k) {
        if (k < n - 1) {
          mat.set(n - 1, k - 1, m.get(n - k - 2, k).multiply(k + 1).add(sum(m, n, k)));
        } else if (k < n) {
          mat.set(n - 1, k - 1, Z.valueOf(n));
        }
      }
    }
    return mat;
  }

  private Matrix<Z> t(final int n) {
    final Matrix<Z> m = s(r(n + 1));
    final Matrix<Z> mat = new DefaultMatrix<>(n, n, Z.ZERO);
    for (int row = 1; row <= n; ++row) {
      final int r = row;
      for (int col = 1; col <= n; ++col) {
        final int c = col;
        final Z s = Integers.SINGLETON.sumdiv(r, d -> c < d ? m.get(d - 1, c - 1).multiply(Euler.phi((long) r / d)) : Z.ZERO).divide(r);
        mat.set(row - 1, col - 1, row == col ? s.add(1) : s);
      }
    }
    return mat;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
      mT = t(mN);
    }
    return mM == 0 ? Z.ONE : mT.get(mN - 1, mM - 1);
  }
}
#!queue	A063688	0	->	1	A063687	--------------------------------
package irvine.oeis.a063;

import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.polynomial.PolynomialUtils;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a058.A058870;

/**
 * A063688 Number of 2-trees rooted at a triangle.
 * @author Sean A. Irvine
 */
public class A063688 extends A063687 {

  private static final CycleIndex Z3 = SymmetricGroup.create(3).cycleIndex();
  private int mN = -1;
  private final Polynomial<Z> mM = RING.empty();
  private final Sequence mXSeq = new A058870();
  private final Polynomial<Z> mX = RING.empty();

  @Override
  public Z next() {
    ++mN;
    mM.add(super.next());
    mX.add(mN > 0 ? mXSeq.next() : Z.ZERO);
    final Polynomial<Z> a = RING.add(mM, RING.multiply(mX, Z.TWO));
    final Polynomial<Z> b = RING.add(mM.substitutePower(2, mN), RING.multiply(mX.substitutePower(2, mN), Z.TWO));
    final Polynomial<Z> c = RING.multiply(b, mX, mN);
    return Z3.apply(PolynomialUtils.zToQ(a), mN).coeff(mN).toZ().subtract(c.coeff(mN));
  }
}

#!queue	A063689	0	->	1	A063687	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a058.A058870;

/**
 * A063689 Number of 2-trees rooted at a triangle with 3 similar edges.
 * @author Sean A. Irvine
 */
public class A063689 extends A063687 {

  private int mN = -1;
  private final Sequence mXSeq = new A058870();

  @Override
  public Z next() {
    ++mN;
    return super.next().add(mN > 0 ? mXSeq.next() : Z.ZERO);
  }
}

#!queue	A063748	1	->	2	A051953	--------------------------------
package irvine.oeis.a063;

import java.util.HashMap;

import irvine.math.z.Z;
import irvine.oeis.a051.A051953;

/**
 * A063748 Greatest x that is a solution to x-phi(x)=n or zero if there is no solution, where phi(x) is Euler's totient function.
 * @author Sean A. Irvine
 */
public class A063748 extends A051953 {

  private final HashMap<Long, Long> mSeen = new HashMap<>();
  private long mM = 1;

  @Override
  public Z next() {
    ++mM;
    for (int k = 0; k < 2 * mM; ++k) {
      mSeen.put(super.next().longValueExact(), mN);
    }
    final Long res = mSeen.remove(mM);
    return res == null ? Z.ZERO : Z.valueOf(res);
  }
}
#!queue	A063761	1	->	0	A000052	--------------------------------
package irvine.oeis.a063;

import irvine.oeis.a000.A000052;
import irvine.util.string.Italian;

/**
 * A063761 Arrange 1-digit numbers in alphabetical order in Italian, then the 2-digit numbers, then the 3-digit numbers, etc.
 * @author Sean A. Irvine
 */
public class A063761 extends A000052 {

  /** Construct the sequence. */
  public A063761() {
    super(Italian.SINGLETON);
  }
}
#!queue	A063904	0	->	1	A063884	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;

/**
 * A063904 a(1) = 2, a(2) = 3 and a(k+1) is the least prime not already chosen that divides some a(i)*a(j)+1, where 1&lt;=i&lt;j&lt;=k.
 * @author Sean A. Irvine
 */
public class A063904 extends A063884 {

  @Override
  protected Z computeNext() {
    final Z t = mA.pollFirst();
    mUsed.add(t);
    for (final Z v : this) {
      update(v.multiply(t).add(1));
    }
    return t;
  }
}
#!queue	A063907	1	->	0	A045704	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;
import irvine.oeis.a045.A045704;

/**
 * A063907 Lesser of twin numbers (differing by 1) of the form F(i)^2 + F(j)^3 (A045704), where F() are Fibonacci numbers.
 * @author Sean A. Irvine
 */
public class A063907 extends A045704 {

  private Z mA = super.next();

  @Override
  public Z next() {
    while (true) {
      final Z t = mA;
      mA = super.next();
      if (mA.subtract(t).equals(Z.ONE)) {
        return t;
      }
    }
  }
}
#!queue	A064025	1	->	2	A003285	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;
import irvine.oeis.a003.A003285;

/**
 * A064025 Length of period of the continued fraction for sqrt(n!).
 * @author Sean A. Irvine
 */
public class A064025 extends A003285 {

  private Z mF = Z.ONE;
  private long mN = 1;

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    return period(mF);
  }
}
#!queue	A064032	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064032 Product of unitary divisors of central binomial coefficients.
 * @author Sean A. Irvine
 */
public class A064032 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z f = super.next();
    return f.pow(Jaguar.factor(f).unitarySigma0().divide2());
  }
}
#!queue	A064033	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064033 Product of non-unitary divisors of central binomial coefficients or a(n)=1 if all divisors are unitary. See A046098.
 * @author Sean A. Irvine
 */
public class A064033 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z f = super.next();
    final FactorSequence fs = Jaguar.factor(f);
    return f.pow(fs.sigma0().subtract(fs.unitarySigma0()).divide2());
  }
}
#!queue	A064039	0	->	1	A060117	--------------------------------
package irvine.oeis.a064;

import irvine.math.set.IntegerPermutation;
import irvine.math.z.Z;
import irvine.oeis.a060.A060117;
import irvine.oeis.a060.A060496;

/**
 * A064039 Reversed inversion vectors for the permutations of A060117, presented as pseudo-decimal numbers.
 * @author Sean A. Irvine
 */
public class A064039 extends A060117 {

  private int mN = -1;

  private int[] inversionVector(final IntegerPermutation p) {
    final int n = p.size();
    final int[] a = new int[n];
    for (int i = 1; i < n; ++i) {
      int c = 0;
      for (int j = 0; j < i; ++j) {
        if (p.image(j) > p.image(i)) {
          ++c;
        }
      }
      a[i - 1] = c;
    }
    return a;
  }

  @Override
  public Z next() {
    return A060496.toZ(inversionVector(permUnrank3R(++mN)));
  }
}
#!queue	A064068	1	->	0	A000233	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000233;

/**
 * A064068 Generalized Euler number c(7,n).
 * @author Sean A. Irvine
 */
public class A064068 extends A000233 {

  @Override
  protected int getA() {
    return 7;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A064069	1	->	0	A000233	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000233;

/**
 * A064069 Generalized Euler number c(8,n).
 * @author Sean A. Irvine
 */
public class A064069 extends A000233 {

  @Override
  protected int getA() {
    return 8;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A064070	1	->	0	A000233	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000233;

/**
 * A064070 Generalized Euler number c(9,n).
 * @author Sean A. Irvine
 */
public class A064070 extends A000233 {

  @Override
  protected int getA() {
    return 9;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A064071	1	->	0	A000233	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000233;

/**
 * A064071 Generalized Euler number c(10,n).
 * @author Sean A. Irvine
 */
public class A064071 extends A000233 {

  @Override
  protected int getA() {
    return 10;
  }

  @Override
  protected int getN() {
    return mT++;
  }
}
#!queue	A064106	2	->	3	A064105	--------------------------------
package irvine.oeis.a064;

import irvine.oeis.a000.A000930;

/**
 * A064106 3rd column of 3rd-order Zeckendorf array.
 * @author Sean A. Irvine
 */
public class A064106 extends A064105 {

  /** Construct the sequence. */
  public A064106() {
    super(new A000930().skip(4), 3);
  }
}
#!queue	A064110	1	->	0	A007510	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;
import irvine.oeis.a007.A007510;

/**
 * A064110 Let s(n) = n-th single prime (cf. A007510). Sequence is defined by recurrence a(n+1) = s(a(n)), n = 0,1,2,..., a(0)=1.
 * @author Sean A. Irvine
 */
public class A064110 extends A007510 {

  private long mA = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (mA == 0) {
      mA = 1;
    } else {
      while (++mM < mA) {
        super.next();
      }
      mA = super.next().longValueExact();
    }
    return Z.valueOf(mA);
  }
}
#!queue	A064139	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064139 Sum of divisors of central binomial coefficient C(n, floor(n/2)).
 * @author Georg Fischer
 */
public class A064139 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A064140	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064140 Sum of unitary divisors of central binomial coefficient C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A064140 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).unitarySigma();
  }
}
#!queue	A064141	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064141 Sum of non-unitary divisors of central binomial coefficient C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A064141 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final FactorSequence fs = Jaguar.factor(super.next());
    return fs.sigma().subtract(fs.unitarySigma());
  }
}
#!queue	A064142	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064142 Sum of all distinct primes dividing central binomial coefficient C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A064142 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sopf();
  }
}
#!queue	A064143	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064143 Sum of unitary prime divisors (A056169, A034444) of central binomial coefficient C(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A064143 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z sum = Z.ZERO;
    final FactorSequence fs = Jaguar.factor(super.next());
    for (final Z p : fs.toZArray()) {
      if (fs.getExponent(p) == 1) {
        sum = sum.add(p);
      }
    }
    return sum;
  }
}
#!queue	A064146	0	->	1	A001405	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a001.A001405;

/**
 * A064146 Sum of non-unitary prime divisors (A034444, A056169) of central binomial coefficient C(n,floor(n/2)) (A001405). If A001405(n) is squarefree (A046098) then a(n)=0.
 * @author Sean A. Irvine
 */
public class A064146 extends A001405 {

  {
    super.next();
  }

  @Override
  public Z next() {
    Z sum = Z.ZERO;
    final FactorSequence fs = Jaguar.factor(super.next());
    for (final Z p : fs.toZArray()) {
      if (fs.getExponent(p) != 1) {
        sum = sum.add(p);
      }
    }
    return sum;
  }
}
#!queue	A064166	1	->	0	A002808	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.factor.prime.Fast;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a002.A002808;

/**
 * A064166 Composite numbers the sum of the digits in the prime factors of which, with repetition, is prime.
 * @author Sean A. Irvine
 */
public class A064166 extends A002808 {

  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    while (true) {
      final Z c = super.next();
      final FactorSequence fs = Jaguar.factor(c);
      long sum = 0;
      for (final Z p : fs.toZArray()) {
        sum += ZUtils.digitSum(p) * fs.getExponent(p);
      }
      if (mPrime.isPrime(sum)) {
        return c;
      }
    }
  }
}

#!queue	A064192	0	->	1	A008282	--------------------------------
package irvine.oeis.a064;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a008.A008282;

/**
 * A064192 Triangle in which rows are permutations of the rows of A008282.
 * @author Sean A. Irvine
 */
public class A064192 extends A008282 {

  private Z[] mRow = new Z[0];
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM >= mRow.length) {
      mRow = Arrays.copyOf(mRow, mRow.length + 1);
      for (int k = 0; k < mRow.length; ++k) {
        mRow[k] = super.next();
      }
      mM = 0;
    }
    // Alternate picking elements from left and right of row in A008282
    return mRow[(mM & 1) == 0 ? mRow.length - 1 - mM / 2 : mM / 2];
  }
}

#!queue	A064237	0	->	1	A000142	--------------------------------
package irvine.oeis.a064;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000142;

/**
 * A064237 Numbers k such that k! + 1 is divisible by a square.
 * @author Sean A. Irvine
 */
public class A064237 extends A000142 {

  @Override
  public Z next() {
    while (true) {
      if (Jaguar.factor(super.next().add(1)).maxExponent() > 1) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A064309	1	->	0	A064308	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;

/**
 * A064309 Row sums of triangle A064308.
 * @author Sean A. Irvine
 */
public class A064309 extends A064308 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.add(super.next());
    }
    return sum;
  }
}
#!queue	A064369	0	->	1	A064284	--------------------------------
package irvine.oeis.a064;

import irvine.math.z.Z;
import irvine.util.array.DynamicLongArray;

/**
 * A064369 Smallest integer in Recam\u00e1n's sequence (A005132) to appear n times.
 * @author Sean A. Irvine
 */
public class A064369 extends A064284 {

  private final DynamicLongArray mA = new DynamicLongArray();
  private long mM = -1;
  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ZERO;
    }
    while (mA.get(mN) == 0) {
      final int cnt = super.next().intValueExact();
      ++mM;
      if (mA.get(cnt) == 0) {
        mA.set(cnt, mM);
      }
    }
    return Z.valueOf(mA.get(mN));
  }
}

#!queue	A064447	0	->	1	A000312	--------------------------------
package irvine.oeis.a064;
// Generated by gen_seq4.pl knest/eulphi at 2023-03-01 20:54

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000312;

/**
 * A064447 a(n) = EulerPhi(n^n).
 * @author Georg Fischer
 */
public class A064447 extends A000312 {

  {
    super.next();
  }


  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A065144	0	->	1	A029948	--------------------------------
package irvine.oeis.a065;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a029.A029948;

/**
 * A065144 Smallest prime containing the n-th square in decimal notation.
 * @author Georg Fischer
 */
public class A065144 extends A029948 {

  /** Construct the sequence. */
  public A065144() {
    skip(1);
  }
}
#!queue	A065205	0	->	1	A033630	--------------------------------
package irvine.oeis.a065;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a033.A033630;

/**
 * A065205 Number of subsets of proper divisors of n that sum to n.
 * @author Georg Fischer
 */
public class A065205 extends A033630 {

  protected int mN;
  
  /** Construct the sequence. */
  public A065205() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(1);
  }
}
#!queue	A065362	0	->	1	A037454	--------------------------------
package irvine.oeis.a065;
// Generated by gen_seq4.pl rebase at 2020-11-30 22:51
// DO NOT EDIT here!

import irvine.oeis.a037.A037454;

/**
 * A065362 Rebase n from 4 to 2. Replace 4^k with 2^k in quaternary expansion of n.
 * @author Georg Fischer
 */
public class A065362 extends A037454 {

  /** Construct the sequence. */
  public A065362() {
    super(1, 4, 2);
  }
}
#!queue	A065451	1	->	0	A000010	--------------------------------
package irvine.oeis.a065;
// manually knest at 2023-03-02 11:48

import irvine.math.z.Fibonacci;
import irvine.math.z.Z;
import irvine.oeis.a000.A000010;

/**
 * A065451 a(n) = Fibonacci(phi(n)), a(0) = 0.
 * @author Georg Fischer
 */
public class A065451 extends A000010 {

  private int mN = -1;

  @Override
  public Z next() {
    return (++mN == 0) ? Z.ZERO : Fibonacci.fibonacci(super.next().intValue());
  }
}

#!queue	A066221	1	->	0	A001189	--------------------------------
package irvine.oeis.a066;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001189;


/**
 * A066221 Bisection of A001189.
 * @author Georg Fischer
 */
public class A066221 extends A001189 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A066222	1	->	0	A001189	--------------------------------
package irvine.oeis.a066;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001189;


/**
 * A066222 Bisection of A001189.
 * @author Georg Fischer
 */
public class A066222 extends A001189 {

  /** Construct the sequence. */
  public A066222() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A066481	0	->	3	A004396	--------------------------------
package irvine.oeis.a066;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a004.A004396;

/**
 * A066481 Largest anti-divisor of n.
 * @author Georg Fischer
 */
public class A066481 extends A004396 {

  /** Construct the sequence. */
  public A066481() {
    skip(3);
  }
}
#!queue	A066973	0	->	1	A000984	--------------------------------
package irvine.oeis.a066;
// Generated by gen_seq4.pl knest/eulphi at 2023-03-01 20:54

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A066973 a(n) = phi(binomial(2n, n)).
 * @author Georg Fischer
 */
public class A066973 extends A000984 {

  {
    super.next();
  }


  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A067063	0	->	2	A002275	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A067063 Smallest prime factor of repunit(n) = (10^n-1)/9 (A002275).
 * @author Georg Fischer
 */
public class A067063 extends A002275 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A067113	0	->	1	A067112	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A105501/parm2 at 2022-02-28 21:03

import irvine.oeis.a000.A000290;

/**
 * A067113 Let N = 0.149162536496481100121... = A001191, the concatenation of the squares. Then a(n) = sum of first n digits of N.
 * @author Georg Fischer
 */
public class A067113 extends A067112 {

  /** Construct the sequence. */
  public A067113() {
    super(new A000290());
  }
}
#!queue	A067114	0	->	1	A067112	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A105501/parm2 at 2022-02-28 21:03

import irvine.oeis.a005.A005843;

/**
 * A067114 Let N = 24681012141618202224262830..., the concatenation of the even numbers. Then a(n) = sum of first n digits of N.
 * @author Georg Fischer
 */
public class A067114 extends A067112 {

  /** Construct the sequence. */
  public A067114() {
    super(new A005843());
  }
}
#!queue	A067115	0	->	1	A067112	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A105501/parm2 at 2022-02-28 21:03

import irvine.oeis.a005.A005408;

/**
 * A067115 Let N = 1357911131517192123252729... = concatenation of odd numbers. Then a(n) = sum of first n digits of N.
 * @author Georg Fischer
 */
public class A067115 extends A067112 {

  /** Construct the sequence. */
  public A067115() {
    super(new A005408());
  }
}
#!queue	A067390	0	->	1	A062709	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a062.A062709;

/**
 * A067390 Number of distinct prime factors in 2^n + 3.
 * @author Georg Fischer
 */
public class A067390 extends A062709 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A067434	0	->	1	A000984	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A067434 Number of distinct prime factors in binomial(2*n,n).
 * @author Georg Fischer
 */
public class A067434 extends A000984 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A067469	0	->	1	A067497	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

/**
 * A067469 Numbers k such that 2 is the first digit of 2^k.
 * @author Georg Fischer
 */
public class A067469 extends A067497 {

  /** Construct the sequence. */
  public A067469() {
    super(2);
  }
}
#!queue	A067474	2	->	1	A067472	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parmof2 at 2022-03-15 21:27

/**
 * A067474 Smallest n-digit square starting with 4.
 * @author Georg Fischer
 */
public class A067474 extends A067472 {

  /** Construct the sequence. */
  public A067474() {
    super(1, 4);
  }
}
#!queue	A067475	2	->	3	A067472	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parmof2 at 2022-03-15 21:27

/**
 * A067475 Smallest n-digit square starting with 5.
 * @author Georg Fischer
 */
public class A067475 extends A067472 {

  /** Construct the sequence. */
  public A067475() {
    super(3, 5);
  }
}
#!queue	A067477	2	->	3	A067472	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parmof2 at 2022-03-15 21:27

/**
 * A067477 Smallest n-digit square starting with 7.
 * @author Georg Fischer
 */
public class A067477 extends A067472 {

  /** Construct the sequence. */
  public A067477() {
    super(3, 7);
  }
}
#!queue	A067479	2	->	1	A067472	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parmof2 at 2022-03-15 21:27

/**
 * A067479 Smallest n-digit square starting with 9, or 0 if no such number exists.
 * @author Georg Fischer
 */
public class A067479 extends A067472 {

  /** Construct the sequence. */
  public A067479() {
    super(1, 9);
  }
}
#!queue	A067480	0	->	1	A008952	--------------------------------
package irvine.oeis.a067;

import irvine.math.z.Z;
import irvine.oeis.a008.A008952;

/**
 * A067480 Powers of 2 with initial digit 2.
 * @author Georg Fischer
 */
public class A067480 extends A008952 {

  protected int mN;
  protected Z mDigit;

  /** Construct the sequence. */
  public A067480() {
    this(2);
  }

  /**
   * Generic constructor with parameters
   * @param digit leading digit
   */
  public A067480(final int digit) {
    super(1);
    mN = -1;
    mDigit = Z.valueOf(digit);
  }

  @Override
  public Z next() {
    ++mN;
    while (!super.next().equals(mDigit)) {
      ++mN;
    }
    return Z.ONE.shiftLeft(mN);
  }
}
#!queue	A067488	0	->	1	A067480	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

/**
 * A067488 Powers of 2 with initial digit 1.
 * @author Georg Fischer
 */
public class A067488 extends A067480 {

  /** Construct the sequence. */
  public A067488() {
    super(1, 1);
  }
}
#!queue	A067501	1	->	0	A067499	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

/**
 * A067501 Powers of 4 with digit sum also a power of 4.
 * @author Georg Fischer
 */
public class A067501 extends A067499 {

  /** Construct the sequence. */
  public A067501() {
    super(4);
  }
}
#!queue	A067509	0	->	1	A067508	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

/**
 * A067509 Powers of 5 with digit sum divisible by 5.
 * @author Georg Fischer
 */
public class A067509 extends A067508 {

  /** Construct the sequence. */
  public A067509() {
    super(5);
  }
}
#!queue	A067510	0	->	1	A067508	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

/**
 * A067510 Powers of 6 with digit sum divisible by 6.
 * @author Georg Fischer
 */
public class A067510 extends A067508 {

  /** Construct the sequence. */
  public A067510() {
    super(6);
  }
}
#!queue	A067570	0	->	1	A067553	--------------------------------
package irvine.oeis.a067;

import irvine.math.z.Z;
import irvine.oeis.a000.A000009;

/**
 * A067570 Numbers n such that A000009(n) divides A067553(n).
 * @author Sean A. Irvine
 */
public class A067570 extends A067553 {

  private final A000009 mS = new A000009();
  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().mod(mS.next()).isZero()) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A067689	0	->	1	A005249	--------------------------------
package irvine.oeis.a067;
// manually n2/n2add1

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000984;
import irvine.oeis.a005.A005249;

/**
 * A067689 Inverse of determinant of n X n matrix whose (i,j)-th element is 1/(i+j).
 * Equals A005249 * A000984.
 * @author Georg Fischer
 */
public class A067689 extends A005249 {

  private final Sequence mSeq = new A000984();

  {
    next();
  }

  @Override
  public Z next() {
    return super.next().multiply(mSeq.next());
  }
}
#!queue	A067819	0	->	1	A000984	--------------------------------
package irvine.oeis.a067;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A067819 Sum of the divisors of binomial(2n,n).
 * @author Georg Fischer
 */
public class A067819 extends A000984 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A068945	1	->	0	A068943	--------------------------------
package irvine.oeis.a068;

import irvine.math.z.Z;

/**
 * A068945 Number of ones in the binary expansion of A068943(n).
 * @author Sean A. Irvine
 */
public class A068945 extends A068943 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return Z.valueOf(super.next().bitCount());
  }
}

#!queue	A068954	0	->	2	A007781	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007781;

/**
 * A068954 Smallest prime factor of n^n-(n-1)^(n-1).
 * @author Georg Fischer
 */
public class A068954 extends A007781 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A068955	0	->	2	A007781	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007781;

/**
 * A068955 Greatest prime factor of n^n - (n-1)^(n-1).
 * @author Georg Fischer
 */
public class A068955 extends A007781 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A068956	0	->	2	A007781	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007781;

/**
 * A068956 Number of distinct prime factors of n^n - (n-1)^(n-1).
 * @author Georg Fischer
 */
public class A068956 extends A007781 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A068957	0	->	2	A007781	--------------------------------
package irvine.oeis.a068;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007781;

/**
 * A068957 Number of prime divisors of n^n - (n-1)^(n-1), counted with multiplicity.
 * @author Georg Fischer
 */
public class A068957 extends A007781 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A069060	0	->	1	A000051	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl knest at 2023-03-02 20:46

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000051;

/**
 * A069060 Product of divisors of 2^n + 1.
 * @author Georg Fischer
 */
public class A069060 extends A000051 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).pod();
  }
}
#!queue	A069061	0	->	1	A000051	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000051;

/**
 * A069061 Sum of divisors of 2^n+1.
 * @author Georg Fischer
 */
public class A069061 extends A000051 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A069112	0	->	1	A000225	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl knest at 2023-03-02 20:46

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A069112 Squarefree part of 2^n-1 : the smallest number such that a(n)*(2^n-1) is a square.
 * @author Georg Fischer
 */
public class A069112 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).core();
  }
}
#!queue	A069594	1	->	2	A069588	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl build/parm2 at 2022-05-28 00:05

/**
 * A069594 Smallest prime in which the n-th significant digit is a 4.
 * @author Georg Fischer
 */
public class A069594 extends A069588 {

  /** Construct the sequence. */
  public A069594() {
    super(4);
  }
}
#!queue	A069595	1	->	2	A069588	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl build/parm2 at 2022-05-28 00:05

/**
 * A069595 Smallest prime in which the n-th significant digit is a 6.
 * @author Georg Fischer
 */
public class A069595 extends A069588 {

  /** Construct the sequence. */
  public A069595() {
    super(6);
  }
}
#!queue	A069596	1	->	2	A069588	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl build/parm2 at 2022-05-28 00:05

/**
 * A069596 Smallest prime in which the n-th significant digit is an 8.
 * @author Georg Fischer
 */
public class A069596 extends A069588 {

  /** Construct the sequence. */
  public A069596() {
    super(8);
  }
}
#!queue	A069597	1	->	2	A069588	--------------------------------
package irvine.oeis.a069;
// Generated by gen_seq4.pl build/parm2 at 2022-05-28 00:05

/**
 * A069597 Smallest prime in which the n-th significant digit is a 0.
 * @author Georg Fischer
 */
public class A069597 extends A069588 {

  /** Construct the sequence. */
  public A069597() {
    super(0);
  }
}
#!queue	A070834	0	->	1	A004086	--------------------------------
package irvine.oeis.a070;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a004.A004086;

/**
 * A070834 Reverse(n)^n.
 * @author Georg Fischer
 */
public class A070834 extends A004086 {

  protected int mN;
  
  /** Construct the sequence. */
  public A070834() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().pow(mN);
  }
}
#!queue	A071750	0	->	1	A237276	--------------------------------
package irvine.oeis.a071;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

import irvine.oeis.a237.A237276;

/**
 * A071750 Numbers k such that 13 divides p(k), the k-th partition number, A000041(k).
 * @author Georg Fischer
 */
public class A071750 extends A237276 {

  /** Construct the sequence. */
  public A071750() {
    super(0, 13);
  }
}
#!queue	A072670	1	->	0	A038548	--------------------------------
package irvine.oeis.a072;
// Generated by gen_seq4.pl dersimple at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a038.A038548;

/**
 * A072670 Number of ways to write n as i*j + i + j, 0 &lt; i &lt;= j.
 * @author Georg Fischer
 */
public class A072670 extends A038548 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A073219	0	->	1	A073211	--------------------------------
package irvine.oeis.a073;
// manually 2021-10-19

import irvine.math.z.Z;

/**
 * A073219 The terms of A073211 (sums of two powers of 11) divided by 2. 
 * @author Georg Fischer
 */
public class A073219 extends A073211 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A073331	1	->	2	A002034	--------------------------------
package irvine.oeis.a073;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002034;

/**
 * A073331 Smallest k such that S(n) = d(n+k), where S(n) is the Kempner function (A002034) and d(n) is the number of divisors of n (A000005).
 * @author Sean A. Irvine
 */
public class A073331 extends A002034 {

  {
    super.next();
  }

  @Override
  public Z next() {
    final long v = super.next().longValue();
    long k = 0;
    while (true) {
      ++k;
      if (v == Jaguar.factor(mN + k).sigma0AsLong()) {
        return Z.valueOf(k);
      }
    }
  }
}

#!queue	A075708	0	->	1	A000225	--------------------------------
package irvine.oeis.a075;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000225;

/**
 * A075708 Sum of the divisors of 2^n - 1.
 * @author Georg Fischer
 */
public class A075708 extends A000225 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A075754	0	->	5	A008300	--------------------------------
package irvine.oeis.a075;

import irvine.math.z.Z;
import irvine.oeis.a008.A008300;

/**
 * A075754 Number of n X n (0,1) matrices containing exactly five 1's in each row and in each column.
 * @author Sean A. Irvine
 */
public class A075754 extends A008300 {

  private int mN = 4;

  @Override
  public Z next() {
    return t(++mN, 5);
  }
}
#!queue	A076791	1	->	0	A208509	--------------------------------
package irvine.oeis.a076;
// Generated by gen_seq4.pl uvpolx at 2021-09-04 15:09

import irvine.math.polynomial.Polynomial;
import irvine.oeis.a208.A208509;

/**
 * A076791 Triangle a(n,k) giving number of binary sequences of length n containing k subsequences 00.
 * (a,b,c,d,e,f) = (x, 1, 0, 1, 1, 0)
 * @author Georg Fischer
 */
public class A076791 extends A208509 {

  /** Construct the sequence. */
  public A076791() {
    super(1, Polynomial.create(0, 1), Polynomial.create(1), Polynomial.create(0), Polynomial.create(1), Polynomial.create(1), Polynomial.create(0));
  }
}
#!queue	A077008	1	->	2	A070750	--------------------------------
package irvine.oeis.a077;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a070.A070750;

/**
 * A077008 Legendre symbol (-1,p) where p is the n-th prime.
 *
 * @author Georg Fischer
 */
public class A077008 extends A070750 {

  /** Construct the sequence. */
  public A077008() {
    skip(1);
  }
}
#!queue	A077020	0	->	3	A001607	--------------------------------
package irvine.oeis.a077;
// manually deris/essent at 2022-04-27 19:28

import irvine.math.z.Z;
import irvine.oeis.a001.A001607;

/**
 * A077020 a(n) is the unique odd positive solution x of 2^n = 7x^2+y^2.
 * @author Georg Fischer
 */
public class A077020 extends A001607 {

  /** Construct the sequence. */
  public A077020() {
    skip(1);
  }

  @Override
  public Z next() {
    return super.next().abs();
  }
}
#!queue	A077805	0	->	1	A007088	--------------------------------
package irvine.oeis.a077;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A077805 Smallest prime factor of numbers containing in their decimal representation only the digits 0 and 1.
 * @author Georg Fischer
 */
public class A077805 extends A007088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A077807	0	->	1	A007088	--------------------------------
package irvine.oeis.a077;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A077807 Number of distinct prime factors of numbers containing in their decimal representation only the digits 0 and 1.
 * @author Georg Fischer
 */
public class A077807 extends A007088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A077808	0	->	1	A007088	--------------------------------
package irvine.oeis.a077;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A077808 Number of prime factors of numbers containing in their decimal representation only the digits 0 and 1 (counted with multiplicity).
 * @author Georg Fischer
 */
public class A077808 extends A007088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A077811	0	->	1	A007088	--------------------------------
package irvine.oeis.a077;
// manually knest/eulphi at 2023-03-01 16:41

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A077811 Euler's totient of numbers containing in their decimal representation only the digits 0 and 1.
 * @author Georg Fischer
 */
public class A077811 extends A007088 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A079313	0	->	1	A080032	--------------------------------
package irvine.oeis.a079;

import irvine.math.z.Z;
import irvine.oeis.a080.A080032;

/**
 * A079313 a(n) is taken to be the smallest positive integer not already present which is consistent with the condition "n is a member of the sequence if and only if a(n) is odd".
 * @author Georg Fischer
 */
public class A079313 extends A080032 {

  @Override
  public Z next() {
    return super.next().add(1);
  }
}
#!queue	A079500	1	->	0	A048888	--------------------------------
package irvine.oeis.a079;
// manually dersimple at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a048.A048888;

/**
 * A079500 Number of compositions of the integer n in which the first part is &gt;= the other parts.
 * @author Georg Fischer
 */
public class A079500 extends A048888 {

  private int mN = 0;
  
  @Override
  public Z next() {
    ++mN;
    return mN <= 1 ? Z.ONE : super.next().add(1);
  }
}
#!queue	A079686	1	->	0	A055187	--------------------------------
package irvine.oeis.a079;
// Generated by gen_seq4.pl cumulcnt at 2022-01-14 18:19

import irvine.oeis.a055.A055187;

/**
 * A079686 Start with 0; at n-th step, write down what is in the sequence so far.
 * @author Georg Fischer
 */
public class A079686 extends A055187 {

  /** Construct the sequence. */
  public A079686() {
    super(0, "A", 0, 2, 3, 0, 3, 0);
  }
}
#!queue	A080036	2	->	0	A003057	--------------------------------
package irvine.oeis.a080;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a003.A003057;

/**
 * A080036 a(n) = n + round(sqrt(2*n)) + 1.
 * @author Georg Fischer
 */
public class A080036 extends A003057 {

  protected int mN;
  
  /** Construct the sequence. */
  public A080036() {
    mN = -1;
  }

  @Override
  public Z next() {
    ++mN;
    return mN == 0 ? Z.ONE : super.next().add(mN);
  }
}
#!queue	A080757	1	->	0	A007538	--------------------------------
package irvine.oeis.a080;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a007.A007538;

/**
 * A080757 First differences of Beatty sequence A022838(n) = floor(n sqrt(3)).
 * @author Georg Fischer
 */
public class A080757 extends A007538 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A080798	1	->	2	A074477	--------------------------------
package irvine.oeis.a080;
// manually A074476/parm3

import irvine.oeis.a074.A074477;

/**
 * A080798 Largest prime factor of 3^n-2.
 * @author Georg Fischer
 */
public class A080798 extends A074477 {

  /** Construct the sequence. */
  public A080798() {
    super(3, -2);
    next();
  }
}
#!queue	A081256	-1	->	1	A001093	--------------------------------
package irvine.oeis.a081;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001093;

/**
 * A081256 Greatest prime factor of n^3 + 1.
 * @author Georg Fischer
 */
public class A081256 extends A001093 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A081259	3	->	1	A151799	--------------------------------
package irvine.oeis.a081;
// manually n2/n3add1 at 2023-05-02 19:56

import irvine.math.z.Z;
import irvine.oeis.a151.A151799;

/**
 * A081259 a(n) is the smallest k such that C(3n,n) divides k!.
 * @author Georg Fischer
 */
public class A081259 extends A151799 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A081689	1	->	0	A005228	--------------------------------
package irvine.oeis.a081;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;
import irvine.oeis.a005.A005228;

/**
 * A081689 A005228 - 1.
 * @author Georg Fischer
 */
public class A081689 extends A005228 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A083214	0	->	1	A237276	--------------------------------
package irvine.oeis.a083;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

import irvine.oeis.a237.A237276;

/**
 * A083214 Numbers k for which 3 | p(k), where p(k) = A000041(k) is the k-th partition number.
 * @author Georg Fischer
 */
public class A083214 extends A237276 {

  /** Construct the sequence. */
  public A083214() {
    super(0, 3);
  }
}
#!queue	A083309	0	->	1	A022897	--------------------------------
package irvine.oeis.a083;

import irvine.math.z.Z;
import irvine.oeis.a022.A022897;

/**
 * A083309 a(n) is the number of times that sums 3+-5+-7+-11+-...+-prime(2n+1) of the first 2n odd primes is zero. There are 2^(2n-1) choices for the sign patterns.
 * @author Sean A. Irvine
 */
public class A083309 extends A022897 {

  private long mN = 0;

  @Override
  public Z next() {
    mN += 2;
    return get(3L, mN);
  }
}
#!queue	A084270	0	->	1	A047864	--------------------------------
package irvine.oeis.a084;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a047.A047864;

/**
 * A084270 Number of labeled 2-chromatic (i.e., chromatic number = 2) graphs on n nodes.
 * @author Georg Fischer
 */
public class A084270 extends A047864 {

  /** Construct the sequence. */
  public A084270() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A085588	1	->	3	A085587	--------------------------------
package irvine.oeis.a085;

import irvine.math.z.Z;

/**
 * A085588 Maximal cycle lengths in a certain class of one-dimensional cellular automata.
 * @author Sean A. Irvine
 */
public class A085588 extends A085587 {

  {
    super.next();
    super.next();
  }

  @Override
  protected Z step(final Z state) {
    final Z a = state.divide2().or(state.and(Z.ONE).shiftLeft(mN - 1));
    final Z b = state.clearBit(mN - 1).multiply2().add(state.testBit(mN - 1) ? 1 : 0);
    return a.xor(b).xor(state);
  }
}
#!queue	A085719	1	->	0	A085244	--------------------------------
package irvine.oeis.a085;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Z;

/**
 * A085719 Permanent of n X n matrix whose rows are cyclic permutations of 1..n.
 * @author Georg Fischer
 */
public class A085719 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Z.valueOf(1 + (j + i) % n));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A086221	0	->	1	A086652	--------------------------------
package irvine.oeis.a086;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;


/**
 * A086221 Bisection of A086652.
 * @author Georg Fischer
 */
public class A086221 extends A086652 {

  /** Construct the sequence. */
  public A086221() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A086325	0	->	1	A000166	--------------------------------
package irvine.oeis.a086;
// manually 2021-09-25

import irvine.math.z.Z;
import irvine.oeis.a000.A000166;

/**
 * A086325 Let u(1)=0, u(2)=1, u(k)=u(k-1)+u(k-2)/(k-2); then a(n)=n!*u(n). 
 * @author Georg Fischer
 */
public class A086325 extends A000166 {

  /** Construct the sequence. */
  public A086325() {
    super.next(); // skip A000166(0)
  }

  @Override
  public Z next() {
    return super.next().multiply(mN);
  }
}
#!queue	A087173	0	->	1	A000041	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A087173 Smallest prime factor of n-th partition number.
 * @author Georg Fischer
 */
public class A087173 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A087175	0	->	1	A000041	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A087175 Number of distinct primes dividing the n-th partition number.
 * @author Georg Fischer
 */
public class A087175 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A087512	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087512 Primes consisting only of digits 1 and 4 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087512 extends A087511 {

  /** Construct the sequence. */
  public A087512() {
    super('1', '4');
  }
}
#!queue	A087513	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087513 Primes consisting only of digits 1 and 6 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087513 extends A087511 {

  /** Construct the sequence. */
  public A087513() {
    super('1', '6');
  }
}
#!queue	A087514	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087514 Primes consisting only of digits 1 and 7 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087514 extends A087511 {

  /** Construct the sequence. */
  public A087514() {
    super('1', '7');
  }
}
#!queue	A087515	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087515 Primes consisting only of digits 1 and 9 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087515 extends A087511 {

  /** Construct the sequence. */
  public A087515() {
    super('1', '9');
  }
}
#!queue	A087531	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087531 Primes consisting only of digits 3 and 7 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087531 extends A087511 {

  /** Construct the sequence. */
  public A087531() {
    super('3', '7');
  }
}
#!queue	A087532	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087532 Primes consisting only of digits 3 and 8 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087532 extends A087511 {

  /** Construct the sequence. */
  public A087532() {
    super('3', '8');
  }
}
#!queue	A087533	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087533 Primes consisting only of digits 4 and 7 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087533 extends A087511 {

  /** Construct the sequence. */
  public A087533() {
    super('4', '7');
  }
}
#!queue	A087534	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087534 Primes consisting only of digits 4 and 9 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087534 extends A087511 {

  /** Construct the sequence. */
  public A087534() {
    super('4', '9');
  }
}
#!queue	A087535	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087535 Primes consisting only of digits 5 and 9 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087535 extends A087511 {

  /** Construct the sequence. */
  public A087535() {
    super('5', '9');
  }
}
#!queue	A087536	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087536 Primes consisting only of digits 6 and 7 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087536 extends A087511 {

  /** Construct the sequence. */
  public A087536() {
    super('6', '7');
  }
}
#!queue	A087537	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087537 Primes consisting only of digits 7 and 9 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087537 extends A087511 {

  /** Construct the sequence. */
  public A087537() {
    super('7', '9');
  }
}
#!queue	A087538	1	->	0	A087511	--------------------------------
package irvine.oeis.a087;
// Generated by gen_seq4.pl A087510/parm3 at 2022-01-11 22:01

/**
 * A087538 Primes consisting only of digits 8 and 9 occurring with equal frequency.
 * @author Georg Fischer
 */
public class A087538 extends A087511 {

  /** Construct the sequence. */
  public A087538() {
    super('8', '9');
  }
}
#!queue	A089626	0	->	1	A057863	--------------------------------
package irvine.oeis.a089;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a057.A057863;

/**
 * A089626 a(n) = 1/h(n) where {h(n)} is the Hankel transform of {t(n)}; t(n) is defined by the expansion of tan(x)= Sum_n&gt;0, t(n)*x^(2*n-1); |x|&lt;Pi/2.
 * @author Georg Fischer
 */
public class A089626 extends A057863 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A090001	1	->	0	A090000	--------------------------------
package irvine.oeis.a090;
// Generated by gen_seq4.pl A090000/parm3 at 2022-04-08 22:28

import irvine.oeis.a000.A000290;

/**
 * A090001 Length of longest contiguous block of 1's in binary expansion of n^2.
 * @author Georg Fischer
 */
public class A090001 extends A090000 {

  /** Construct the sequence. */
  public A090001() {
    super(new A000290(), 1);
  }
}
#!queue	A090002	1	->	0	A090000	--------------------------------
package irvine.oeis.a090;
// Generated by gen_seq4.pl A090000/parm3 at 2022-04-08 22:28

import irvine.oeis.a000.A000217;

/**
 * A090002 Length of longest contiguous block of 1's in binary expansion of n-th triangular number.
 * @author Georg Fischer
 */
public class A090002 extends A090000 {

  /** Construct the sequence. */
  public A090002() {
    super(new A000217(), 1);
  }
}
#!queue	A090003	1	->	0	A090000	--------------------------------
package irvine.oeis.a090;
// Generated by gen_seq4.pl A090000/parm3 at 2022-04-08 22:28

import irvine.oeis.a000.A000578;

/**
 * A090003 Length of longest contiguous block of 1's in binary expansion of n^3.
 * @author Georg Fischer
 */
public class A090003 extends A090000 {

  /** Construct the sequence. */
  public A090003() {
    super(new A000578(), 1);
  }
}
#!queue	A090047	1	->	0	A090000	--------------------------------
package irvine.oeis.a090;
// Generated by gen_seq4.pl A090000/parm3 at 2022-04-08 22:28

import irvine.oeis.a000.A000290;

/**
 * A090047 Length of longest contiguous block of 0's in binary expansion of n^2.
 * @author Georg Fischer
 */
public class A090047 extends A090000 {

  /** Construct the sequence. */
  public A090047() {
    super(new A000290(), 0);
  }
}
#!queue	A090048	1	->	0	A090000	--------------------------------
package irvine.oeis.a090;
// Generated by gen_seq4.pl A090000/parm3 at 2022-04-08 22:28

import irvine.oeis.a000.A000217;

/**
 * A090048 Length of longest contiguous block of 0's in binary expansion of n-th triangular number.
 * @author Georg Fischer
 */
public class A090048 extends A090000 {

  /** Construct the sequence. */
  public A090048() {
    super(new A000217(), 0);
  }
}
#!queue	A090049	1	->	0	A090000	--------------------------------
package irvine.oeis.a090;
// Generated by gen_seq4.pl A090000/parm3 at 2022-04-08 22:28

import irvine.oeis.a000.A000578;

/**
 * A090049 Length of longest contiguous block of 0's in binary expansion of n^3.
 * @author Georg Fischer
 */
public class A090049 extends A090000 {

  /** Construct the sequence. */
  public A090049() {
    super(new A000578(), 0);
  }
}
#!queue	A091224	1	->	2	A091223	--------------------------------
package irvine.oeis.a091;
// Generated by gen_seq4.pl seqop a091 A091223 divide2() 1 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;

/**
 * A091224 Differences between consecutive irreducible GF(2)[X]-polynomials, divided by 2.
 *
 * @author Georg Fischer
 */
public class A091224 extends A091223 {
  private int mN = 1;

  /** Construct the sequence. */
  public A091224() {
    super();
    int bOffset = 0;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A091696	0	->	1	A000029	--------------------------------
package irvine.oeis.a091;

import irvine.math.z.Z;
import irvine.oeis.a000.A000029;

/**
 * A091696 Number of classes of compositions of n equivalent under reflection or cycling.
 * @author Sean A. Irvine
 */
public class A091696 extends A000029 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}

#!queue	A091711	0	->	1	A088020	--------------------------------
package irvine.oeis.a091;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a088.A088020;

/**
 * A091711 Exponent of 2 in (n^2)!.
 * @author Georg Fischer
 */
public class A091711 extends A088020 {

  /** Construct the sequence. */
  public A091711() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.TWO));
  }
}
#!queue	A091828	0	->	1	A000254	--------------------------------
package irvine.oeis.a091;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000254;

/**
 * A091828 a(n)=n-2*valuation(A000254(n),3).
 * @author Georg Fischer
 */
public class A091828 extends A000254 {

  private int mN;

  /** Construct the sequence. */
  public A091828() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(mN - 2 * ZUtils.valuation(super.next(), Z.THREE));
  }
}
#!queue	A092607	1	->	0	A090000	--------------------------------
package irvine.oeis.a092;
// Generated by gen_seq4.pl A090000/parm3 at 2022-04-08 22:28

import irvine.oeis.a000.A000142;
import irvine.oeis.a090.A090000;

/**
 * A092607 Length of longest contiguous block of ones in binary representation of n!.
 * @author Georg Fischer
 */
public class A092607 extends A090000 {

  /** Construct the sequence. */
  public A092607() {
    super(new A000142(), 1);
  }
}
#!queue	A093810	0	->	2	A036563	--------------------------------
package irvine.oeis.a093;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a036.A036563;

/**
 * A093810 Smallest prime factor of 2^n-3.
 * @author Georg Fischer
 */
public class A093810 extends A036563 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A093817	1	->	2	A074477	--------------------------------
package irvine.oeis.a093;
// manually A074476/parm3

import irvine.oeis.a074.A074477;

/**
 * A093817 Largest prime factor of 2^n-3.
 * @author Georg Fischer
 */
public class A093817 extends A074477 {

  /** Construct the sequence. */
  public A093817() {
    super(2, -3);
    next();
  }
}
#!queue	A093952	0	->	1	A000041	--------------------------------
package irvine.oeis.a093;

import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A093952 Partition number A000041(n) mod n.
 * @author Georg Fischer
 */
public class A093952 extends A000041 {

  private Z mN = Z.ZERO;

  {
    super.next();
  }

  @Override
  public Z next() {
    mN = mN.add(1);
    return super.next().mod(mN);
  }
}
#!queue	A094155	1	->	2	A000939	--------------------------------
package irvine.oeis.a094;
// Generated by gen_seq4.pl bisect at 2021-07-05 13:13
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000939;


/**
 * A094155 Bisection of A000939.
 * @author Georg Fischer
 */
public class A094155 extends A000939 {

  /** Construct the sequence. */
  public A094155() {
    super.next();
    super.next();
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A094156	3	->	1	A000940	--------------------------------
package irvine.oeis.a094;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000940;


/**
 * A094156 Bisection of A000940.
 * @author Georg Fischer
 */
public class A094156 extends A000940 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A094157	3	->	2	A000940	--------------------------------
package irvine.oeis.a094;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000940;


/**
 * A094157 Bisection of A000940.
 * @author Georg Fischer
 */
public class A094157 extends A000940 {

  /** Construct the sequence. */
  public A094157() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A094203	0	->	1	A095437	--------------------------------
package irvine.oeis.a094;
// manually modified 2021-05-14 23:57

import irvine.oeis.a095.A095437;

/**
 * A094203 a(n) = 24 written in base 13-n.
 * @author Georg Fischer
 */
public class A094203 extends A095437 {

  /** Construct the sequence. */
  public A094203() {
    super(24, 13);
    ++super.mN;
  }
}
#!queue	A094437	1	->	0	A208509	--------------------------------
package irvine.oeis.a094;
// Generated by gen_seq4.pl uvpolx at 2021-09-04 15:09

import irvine.math.polynomial.Polynomial;
import irvine.oeis.a208.A208509;

/**
 * A094437 Triangular array T(n,k) = Fibonacci(k+2)*C(n,k), k=0..n, n&gt;=0.
 * (a,b,c,d,e,f) = (1,x, 0,x,x+1, 0)
 * @author Georg Fischer
 */
public class A094437 extends A208509 {

  /** Construct the sequence. */
  public A094437() {
    super(1, Polynomial.create(1), Polynomial.create(0, 1), Polynomial.create(0), Polynomial.create(0, 1), Polynomial.create(1, 1), Polynomial.create(0));
  }
}
#!queue	A094442	1	->	0	A208509	--------------------------------
package irvine.oeis.a094;
// Generated by gen_seq4.pl uvpolx at 2021-09-04 15:09

import irvine.math.polynomial.Polynomial;
import irvine.oeis.a208.A208509;

/**
 * A094442 Triangular array T(n,k) = Fibonacci(n+2-k)*C(n,k), 0 &lt;= k &lt;= n.
 * (a,b,c,d,e,f) = (x, 1, 0, 1,x+1, 0)
 * @author Georg Fischer
 */
public class A094442 extends A208509 {

  /** Construct the sequence. */
  public A094442() {
    super(1, Polynomial.create(0, 1), Polynomial.create(1), Polynomial.create(0), Polynomial.create(1), Polynomial.create(1, 1), Polynomial.create(0));
  }
}
#!queue	A095250	0	->	1	A002275	--------------------------------
package irvine.oeis.a095;
// Generated by gen_seq4.pl seqop a002 A002275 mod(Z.valueOf(mN)) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A095250 a(n) = 11111111... (n times) = (10^n-1)/9 reduced mod n.
 * @author Georg Fischer
 */
public class A095250 extends A002275 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A095250() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A095370	0	->	1	A002275	--------------------------------
package irvine.oeis.a095;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A095370 Number of distinct prime factors of the repunit (-1 + 10^n)/9.
 * @author Georg Fischer
 */
public class A095370 extends A002275 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A096010	0	->	1	A000016	--------------------------------
package irvine.oeis.a096;
// Generated by gen_seq4.pl seqop a000 A000016 add(1) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000016;

/**
 * A096010 Number of different cycles computed with the generalized 3x+1 problem using C=2, B=Cn+m, A=C^m.
 * @author Georg Fischer
 */
public class A096010 extends A000016 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A096010() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().add(1);
  }
}
#!queue	A097412	1	->	0	A097408	--------------------------------
package irvine.oeis.a097;
// Generated by gen_seq4.pl inidig/parmof2 at 2021-12-28 15:51

/**
 * A097412 Initial decimal digit of n^8.
 * @author Georg Fischer
 */
public class A097412 extends A097408 {

  /** Construct the sequence. */
  public A097412() {
    super(0, 8);
  }
}
#!queue	A097415	0	->	1	A067497	--------------------------------
package irvine.oeis.a097;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067497;

/**
 * A097415 Values of k such that the first digit of 2^k is 9.
 * @author Georg Fischer
 */
public class A097415 extends A067497 {

  /** Construct the sequence. */
  public A097415() {
    super(9);
  }
}
#!queue	A097509	1	->	0	A006337	--------------------------------
package irvine.oeis.a097;
// manually knestm/knest at 2023-03-02 19:24

import irvine.math.z.Z;
import irvine.oeis.a006.A006337;

/**
 * A097509 a(n) is the number of times that n occurs as floor(k * sqrt(2)) - k.
 * @author Georg Fischer
 */
public class A097509 extends A006337 {

  private int mN = -1;

  @Override
  public Z next() {
    return (++mN <= 0) ? Z.THREE : super.next().add(1);
  }
}
#!queue	A099057	1	->	0	A000396	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000396;


/**
 * A099057 A bisection of A000396.
 * @author Georg Fischer
 */
public class A099057 extends A000396 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099058	1	->	0	A000396	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000396;


/**
 * A099058 A bisection of A000396.
 * @author Georg Fischer
 */
public class A099058 extends A000396 {

  /** Construct the sequence. */
  public A099058() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099061	1	->	0	A000960	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000960;


/**
 * A099061 A bisection of A000960.
 * @author Georg Fischer
 */
public class A099061 extends A000960 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099062	1	->	0	A000960	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000960;


/**
 * A099062 A bisection of A000960.
 * @author Georg Fischer
 */
public class A099062 extends A000960 {

  /** Construct the sequence. */
  public A099062() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099076	1	->	0	A000960	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl seqop a000 A000960 mod(Z.THREE) 1 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000960;

/**
 * A099076 a(n) = A000960(n) mod 3.
 * @author Georg Fischer
 */
public class A099076 extends A000960 {
  private int mN = -1;
  
  /** Construct the sequence. */
  public A099076() {
    super();
    int bOffset = 0;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.THREE);
  }
}
#!queue	A099198	0	->	1	A002807	--------------------------------
package irvine.oeis.a099;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a002.A002807;

/**
 * A099198 A bisection of A002807.
 * @author Georg Fischer
 */
public class A099198 extends A002807 {

  /** Construct the sequence. */
  public A099198() {
    super.next();
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099774	0	->	1	A005408	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl sigman0/sigma0 at 2023-02-28 21:57

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a005.A005408;

/**
 * A099774 Number of divisors of 2*n-1.
 * @author Georg Fischer
 */
public class A099774 extends A005408 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A099821	0	->	1	A007088	--------------------------------
package irvine.oeis.a099;
// manually (bisect) 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a007.A007088;

/**
 * A099821 Odd positive integers in base 2 (bisection of A007088).
 * @author Georg Fischer
 */
public class A099821 extends A007088 {

  /** Construct the sequence. */
  public A099821() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099980	1	->	0	A001358	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001358;


/**
 * A099980 Bisection of A001358.
 * @author Georg Fischer
 */
public class A099980 extends A001358 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099981	1	->	0	A001358	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001358;


/**
 * A099981 Bisection of A001358.
 * @author Georg Fischer
 */
public class A099981 extends A001358 {

  /** Construct the sequence. */
  public A099981() {
    super.next();
  }

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099982	1	->	0	A000043	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000043;


/**
 * A099982 Bisection of A000043.
 * @author Georg Fischer
 */
public class A099982 extends A000043 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A099983	1	->	0	A000043	--------------------------------
package irvine.oeis.a099;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000043;


/**
 * A099983 Bisection of A000043.
 * @author Georg Fischer
 */
public class A099983 extends A000043 {
  
  /** Construct the sequence. */
  public A099983() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A100031	1	->	0	A005384	--------------------------------
package irvine.oeis.a100;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a005.A005384;


/**
 * A100031 Bisection of A005384.
 * @author Georg Fischer
 */
public class A100031 extends A005384 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A100032	1	->	0	A005384	--------------------------------
package irvine.oeis.a100;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a005.A005384;


/**
 * A100032 Bisection of A005384.
 * @author Georg Fischer
 */
public class A100032 extends A005384 {

  /** Construct the sequence. */
  public A100032() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A100430	1	->	0	A002417	--------------------------------
package irvine.oeis.a100;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a002.A002417;


/**
 * A100430 Bisection of A002417.
 * @author Georg Fischer
 */
public class A100430 extends A002417 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A100637	1	->	0	A000720	--------------------------------
package irvine.oeis.a100;
// manually at 2021-07-04

import irvine.math.z.Z;
import irvine.oeis.a000.A000720;

/**
 * A100637 Trisection of A000720.
 * @author Georg Fischer
 */
public class A100637 extends A000720 {

  /** Construct the sequence. */
  public A100637() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A100868	0	->	1	A050946	--------------------------------
package irvine.oeis.a100;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a050.A050946;

/**
 * A100868 a(n) = Sum_{k&gt;0} k^(2n-1)/phi^(2k) where phi = (1+sqrt(5))/2 = A001622.
 * @author Georg Fischer
 */
public class A100868 extends A050946 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A101987	0	->	1	A067067	--------------------------------
package irvine.oeis.a101;
// Generated by gen_seq4.pl A067067/parm2 at 2022-02-28 21:02

import irvine.oeis.a000.A000040;
import irvine.oeis.a067.A067067;

/**
 * A101987 Product of nonzero digits of n-th prime.
 * @author Georg Fischer
 */
public class A101987 extends A067067 {

  /** Construct the sequence. */
  public A101987() {
    super(new A000040());
  }
}
#!queue	A102146	0	->	1	A002283	--------------------------------
package irvine.oeis.a102;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002283;

/**
 * A102146 a(n) = sigma(10^n - 1), where sigma(n) is the sum of positive divisors of n.
 * @author Georg Fischer
 */
public class A102146 extends A002283 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A102347	0	->	1	A002283	--------------------------------
package irvine.oeis.a102;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002283;

/**
 * A102347 Number of distinct prime factors of 10^n - 1.
 * @author Georg Fischer
 */
public class A102347 extends A002283 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A102360	0	->	1	A023000	--------------------------------
package irvine.oeis.a102;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a023.A023000;

/**
 * A102360 a(n) = sigma((7^n - 1)/6), where sigma(n) is the sum of positive divisors of n.
 * @author Georg Fischer
 */
public class A102360 extends A023000 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A102445	0	->	1	A002426	--------------------------------
package irvine.oeis.a102;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002426;

/**
 * A102445 Number of prime divisors (counted with multiplicity) of the central trinomial coefficients (A002426).
 * @author Georg Fischer
 */
public class A102445 extends A002426 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A103759	0	->	1	A002275	--------------------------------
package irvine.oeis.a103;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A103759 a(n) = sigma((10^n - 1)/9), where sigma(n) is the sum of positive divisors of n.
 * @author Georg Fischer
 */
public class A103759 extends A002275 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A103968	0	->	1	A023001	--------------------------------
package irvine.oeis.a103;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a023.A023001;

/**
 * A103968 Sigma((8^n - 1)/7), where sigma(n) is the sum of positive divisors of n.
 * @author Georg Fischer
 */
public class A103968 extends A023001 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A104411	0	->	3	A000078	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000078;

/**
 * A104411 Number of prime factors, with multiplicity, of the tetranacci numbers A000078.
 * @author Georg Fischer
 */
public class A104411 extends A000078 {
  {
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A104412	0	->	4	A001591	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001591;

/**
 * A104412 Number of prime factors, with multiplicity, of the pentanacci numbers A001591.
 * @author Georg Fischer
 */
public class A104412 extends A001591 {

  {
    for (int i = 0; i < 4; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A104413	0	->	5	A001592	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001592;

/**
 * A104413 Number of prime factors, with multiplicity, of the hexanacci numbers A001592.
 * @author Georg Fischer
 */
public class A104413 extends A001592 {
  {
    for (int i = 0; i < 5; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A104415	0	->	1	A079262	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a079.A079262;

/**
 * A104415 Number of prime factors, with multiplicity, of the nonzero octanacci numbers A079262.
 * @author Georg Fischer
 */
public class A104415 extends A079262 {

  {
    for (int i = 0; i < 7; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A104418	0	->	1	A104144	--------------------------------
package irvine.oeis.a104;
// manually knest/jaguarz at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A104418 Number of prime factors, with multiplicity, of the nonzero 9-acci numbers.
 * @author Georg Fischer
 */
public class A104418 extends A104144 {

  {
    for (int i = 0; i < 8; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A104483	1	->	0	A173766	--------------------------------
package irvine.oeis.a104;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a173.A173766;

/**
 * A104483 Number of distinct prime divisors of 33...337 (with n 3s).
 * @author Georg Fischer
 */
public class A104483 extends A173766 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A104524	0	->	1	A178769	--------------------------------
package irvine.oeis.a104;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a178.A178769;

/**
 * A104524 Number of distinct prime divisors of 55...557 (with n 5s).
 * @author Georg Fischer
 */
public class A104524 extends A178769 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A104742	0	->	6	A269920	--------------------------------
package irvine.oeis.a104;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A104742 Number of rooted maps of (orientable) genus 3 containing n edges.
 * @author Sean A. Irvine
 */
public class A104742 extends A269920 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 3, k));
    }
    return sum;
  }
}
#!queue	A105248	1	->	0	A173812	--------------------------------
package irvine.oeis.a105;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a173.A173812;

/**
 * A105248 Number of distinct prime divisors of 88...887 (with n 8's).
 * @author Georg Fischer
 */
public class A105248 extends A173812 {
  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A105259	1	->	0	A170955	--------------------------------
package irvine.oeis.a105;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a170.A170955;

/**
 * A105259 Number of distinct prime divisors of 99..91 (with n 9's).
 * @author Georg Fischer
 */
public class A105259 extends A170955 {
  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A105972	1	->	0	A173810	--------------------------------
package irvine.oeis.a105;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a173.A173810;

/**
 * A105972 Number of distinct prime divisors of 88...881 (with n 8's).
 * @author Georg Fischer
 */
public class A105972 extends A173810 {
  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A105973	1	->	0	A173811	--------------------------------
package irvine.oeis.a105;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a173.A173811;

/**
 * A105973 Number of distinct prime divisors of 88...883 (with n 8's).
 * @author Georg Fischer
 */
public class A105973 extends A173811 {
  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A106640	1	->	0	A244530	--------------------------------
package irvine.oeis.a106;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a244.A244530;

/**
 * A106640 Row sums of A059346.
 * @author Georg Fischer
 */
public class A106640 extends A244530 {

  private int mN = 1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 0);
  }
}

#!queue	A106737	1	->	0	A005940	--------------------------------
package irvine.oeis.a106;
// Generated by gen_seq4.pl sigman0/sigma0 at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a005.A005940;

/**
 * A106737 a(n) = Sum_{k=0..n} ({binomial(n+k,n-k)*binomial(n,k)} mod 2).
 * @author Georg Fischer
 */
public class A106737 extends A005940 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A107647	0	->	2	A000073	--------------------------------
package irvine.oeis.a107;
// manually knest/eulphi at 2023-03-01 16:41

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000073;

/**
 * A107647 Euler's totient function applied to tribonacci numbers.
 * @author Georg Fischer
 */
public class A107647 extends A000073 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A108235	1	->	0	A002849	--------------------------------
package irvine.oeis.a108;
// manually n2 at 2023-05-02 19:56

import irvine.math.z.Z;
import irvine.oeis.a002.A002849;

/**
 * A108235 Number of partitions of {1,2,...,3n} into n triples (X,Y,Z) each satisfying X+Y=Z.
 * <code>a(n) = 0 unless n == 0 or 1 (mod 4). For n == 0 or 1 (mod 4), a(n) = A002849(3n).</code>
 * @author Georg Fischer
 */
public class A108235 extends A002849 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    if (mN == 0) {
      return Z.ONE;
    }
    if (mN % 4 <= 1) {
      super.next();
      super.next();
      return super.next();
    } else {
      super.next();
      super.next();
      super.next();
      return Z.ZERO;
    }
  }
}
#!queue	A108572	0	->	1	A018783	--------------------------------
package irvine.oeis.a108;
// manually knestm/knest at 2023-03-02 16:06

import irvine.math.z.Z;
import irvine.oeis.a018.A018783;

/**
 * A108572 Number of partitions of n which, as multisets, are nontrivial repetitions of a multiset.
 * @author Georg Fischer
 */
public class A108572 extends A018783 {

  private int mN = 0;

  {
    super.next();
  }

  @Override
  public Z next() {
    final Z t = super.next().subtract(1);
    return (++mN == 1) ? Z.ZERO : t;
  }
}
#!queue	A109607	2	->	0	A023896	--------------------------------
package irvine.oeis.a109;
// manually dersimple at 2021-08-25 19:44

import irvine.math.z.Z;
import irvine.oeis.a023.A023896;

/**
 * A109607 Sum of coprimes of n greater than 1.
 * @author Georg Fischer
 */
public class A109607 extends A023896 {

  private int mN = 0;
  
  @Override
  public Z next() {
    ++mN;
    return mN <= 1 ? Z.ZERO : super.next().subtract(1);
  }
}
#!queue	A110369	0	->	1	A002275	--------------------------------
package irvine.oeis.a110;
// Generated by gen_seq4.pl seqop a002 A002275 add(mN) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a002.A002275;

/**
 * A110369 (Digit 1 repeated n times) + n.
 * @author Georg Fischer
 */
public class A110369 extends A002275 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A110369() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().add(mN);
  }
}
#!queue	A110953	0	->	1	A003683	--------------------------------
package irvine.oeis.a110;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a003.A003683;

/**
 * A110953 Starting a priori with the fraction 1/1, the denominators of fractions built according to the rule: add top and bottom to get the new bottom, add top and 9 times the bottom to get the new top.
 * @author Georg Fischer
 */
public class A110953 extends A003683 {

  /** Construct the sequence. */
  public A110953() {
    skip(2);
  }
}
#!queue	A112351	1	->	0	A208509	--------------------------------
package irvine.oeis.a112;
// Generated by gen_seq4.pl uvpolx at 2021-09-04 15:09

import irvine.math.polynomial.Polynomial;
import irvine.oeis.a208.A208509;

/**
 * A112351 Triangle read by rows, generated from (..., 5, 3, 1).
 * (a,b,c,d,e,f) = (x, 1, 0, 2x,x+1, 0)
 * @author Georg Fischer
 */
public class A112351 extends A208509 {

  /** Construct the sequence. */
  public A112351() {
    super(1, Polynomial.create(0, 1), Polynomial.create(1), Polynomial.create(0), Polynomial.create(0, 2), Polynomial.create(1, 1), Polynomial.create(0));
  }
}
#!queue	A112362	1	->	2	A006967	--------------------------------
package irvine.oeis.a112;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a006.A006967;

/**
 * A112362 A006967(n)/2.
 * @author Georg Fischer
 */
public class A112362 extends A006967 {

  /** Construct the sequence. */
  public A112362() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A113773	0	->	1	A008352	--------------------------------
package irvine.oeis.a113;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a008.A008352;

/**
 * A113773 Number of distinct prime factors of A008352.
 * @author Sean A. Irvine
 */
public class A113773 extends A008352 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));

  {
    super.next(); // skip 0th term
  }

  @Override
  public Z next() {
    final Z n = super.next();
    if (mVerbose) {
      System.err.println("[" + n + "]");
    }
    return Z.valueOf(Jaguar.factor(n).omega());
  }
}


#!queue	A115000	1	->	5	A007434	--------------------------------
package irvine.oeis.a115;

import irvine.math.z.Z;
import irvine.oeis.a007.A007434;

/**
 * A115000 a(n) = J_2(n) / 24.
 * @author Sean A. Irvine
 */
public class A115000 extends A007434 {

  {
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(24);
  }
}
#!queue	A115322	0	->	1	A053117	--------------------------------
package irvine.oeis.a115;
// manually deris/essent at 2022-04-27 19:28

import irvine.math.z.Z;
import irvine.oeis.a053.A053117;

/**
 * A115322 Triangle of coefficients of Pell polynomials.
 * @author Georg Fischer
 */
public class A115322 extends A053117 {

  @Override
  public Z next() {
    return super.next().abs();
  }
}
#!queue	A115793	0	->	1	A115422	--------------------------------
package irvine.oeis.a115;
// Generated by gen_seq4.pl A115422/parmof4 at 2021-11-16 20:37

/**
 * A115793 Integers i such that i XOR 10i = 11i.
 * @author Georg Fischer
 */
public class A115793 extends A115422 {

  /** Construct the sequence. */
  public A115793() {
    super(1, 1, 10, 11);
  }
}
#!queue	A115795	0	->	1	A115422	--------------------------------
package irvine.oeis.a115;
// Generated by gen_seq4.pl A115422/parmof4 at 2021-11-16 20:37

/**
 * A115795 Integers k such that 2*k XOR 9*k = 11*k.
 * @author Georg Fischer
 */
public class A115795 extends A115422 {

  /** Construct the sequence. */
  public A115795() {
    super(1, 2, 9, 11);
  }
}
#!queue	A115796	0	->	1	A115795	--------------------------------
package irvine.oeis.a115;
// Generated by gen_seq4.pl inbase2 at 2022-04-08 22:28

import irvine.math.z.Z;

/**
 * A115796 Sequence A115795 in binary.
 * @author Georg Fischer
 */
public class A115796 extends A115795 {

  @Override
  public Z next() {
    return new Z(super.next().toString(2));
  }
}
#!queue	A115819	0	->	1	A115422	--------------------------------
package irvine.oeis.a115;
// Generated by gen_seq4.pl A115422/parmof4 at 2021-11-16 20:37

/**
 * A115819 Integers n such that 4*n XOR 15*n = 19*n.
 * @author Georg Fischer
 */
public class A115819 extends A115422 {

  /** Construct the sequence. */
  public A115819() {
    super(1, 4, 15, 19);
  }
}
#!queue	A116931	0	->	1	A218698	--------------------------------
package irvine.oeis.a116;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a218.A218698;

/**
 * A116931 Number of partitions of n in which each part, with the possible exception of the largest, occurs at least twice.
 * @author Georg Fischer
 */
public class A116931 extends A218698 {

  private int mN = 0;

  @Override
  public Z next() {
    return super.compute(++mN, 2);
  }
}

#!queue	A116932	0	->	1	A218698	--------------------------------
package irvine.oeis.a116;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a218.A218698;

/**
 * A116932 Number of partitions of n in which each part, with the possible exception of the largest, occurs at least three times.
 * @author Georg Fischer
 */
public class A116932 extends A218698 {

  private int mN = 0;

  @Override
  public Z next() {
    return super.compute(++mN, 3);
  }
}

#!queue	A116941	1	->	0	A074147	--------------------------------
package irvine.oeis.a116;
// Generated by gen_seq4.pl dersimple at 2022-12-15 23:30

import irvine.math.z.Z;
import irvine.oeis.a074.A074147;

/**
 * A116941 Permutation of the natural numbers in conjunction with A116939 and A003056.
 * @author Georg Fischer
 */
public class A116941 extends A074147 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A117142	0	->	1	A194621	--------------------------------
package irvine.oeis.a117;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a194.A194621;

/**
 * A117142 Number of partitions of n in which any two parts differ by at most 2.
 * @author Georg Fischer
 */
public class A117142 extends A194621 {

  private int mN = 1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A117143	0	->	1	A194621	--------------------------------
package irvine.oeis.a117;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a194.A194621;

/**
 * A117143 Number of partitions of n in which any two parts differ by at most 3.
 * @author Georg Fischer
 */
public class A117143 extends A194621 {

  private int mN = 1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A117601	0	->	1	A000931	--------------------------------
package irvine.oeis.a117;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a000.A000931;

/**
 * A117601 Padovan numbers which are divisible by the sum of their digits.
 * @author Georg Fischer
 */
public class A117601 extends A000931 {
    
  protected int mN;
  
  /** Construct the sequence. */
  public A117601() {
    mN = 0;
    for (int n = 0; n <= 12; ++n) { // skip leading terms with duplicates
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    if (mN <= 5) {
      return Z.valueOf(mN); // fixed terms
    }
    Z result = super.next();
    while (! result.remainder(Z.valueOf(ZUtils.digitSum(result))).equals(Z.ZERO)) {
      result = super.next();
    }
    return result;
  }
}
#!queue	A120503	0	->	1	A007844	--------------------------------
package irvine.oeis.a120;
// Generated by gen_seq4.pl seqop a007 A007844 divide(3) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a007.A007844;

/**
 * A120503 Generalized meta-Fibonacci sequence a(n) with parameters s=0 and k=3.
 * @author Georg Fischer
 */
public class A120503 extends A007844 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A120503() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(3);
  }
}
#!queue	A121355	0	->	1	A121357	--------------------------------
package irvine.oeis.a121;

import java.util.ArrayList;

import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A121355 Number of transitive PSL_2(ZZ) actions on a finite labeled set of size n.
 * @author Sean A. Irvine
 */
public class A121355 extends A121357 {

  private final ArrayList<Q> mA = new ArrayList<>();

  {
    super.next();
    mA.add(Q.ZERO);
  }

  @Override
  public Z next() {
    mA.add(super.nextQ());
    return RING.log1p(RING.create(mA), mN).coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A121356	0	->	1	A121355	--------------------------------
package irvine.oeis.a121;
// Generated by gen_seq4.pl seqop a121 A121355 multiply(mN) 1 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;

/**
 * A121356 Number of transitive PSL_2(ZZ) actions on a finite dotted and labeled set of size n.
 * @author Georg Fischer
 */
public class A121356 extends A121355 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A121356() {
    super();
    int bOffset = 0;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().multiply(mN);
  }
}
#!queue	A121358	0	->	1	A000292	--------------------------------
package irvine.oeis.a121;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000292;

/**
 * A121358 Least prime factor of pyramidal number A000292(n), a(1) = 1.
 * @author Georg Fischer
 */
public class A121358 extends A000292 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A123467	0	->	1	A000081	--------------------------------
package irvine.oeis.a123;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a000.A000081;

/**
 * A123467 Number of trivially-perfect graphs on n nodes.
 * @author Georg Fischer
 */
public class A123467 extends A000081 {

  /** Construct the sequence. */
  public A123467() {
    skip(2);
  }
}
#!queue	A123864	1	->	0	A035143	--------------------------------
package irvine.oeis.a123;
// Generated by gen_seq4.pl diriprod at 2020-09-02 21:31
// DO NOT EDIT here!

import irvine.oeis.a035.A035143;

/**
 * A123864 Expansion of (eta(q^3) * eta(q^5))^2 / (eta(q) * eta(q^15)) in powers of q.
 * @author Georg Fischer
 */
public class A123864 extends A035143 {

  /** Construct the sequence. */
  public A123864() {
    super(-15);
    mN = -1;
  }
}
#!queue	A124574	0	->	1	A052179	--------------------------------
package irvine.oeis.a124;
// Generated by gen_seq4.pl parm3 at 2021-10-25 21:44

import irvine.oeis.a052.A052179;
/**
 * A124574 Triangle read by rows: row n is the first row of the matrix M[n]^(n-1), where M[n] is the n X n tridiagonal matrix with main diagonal (3,4,4,...) and super- and subdiagonals (1,1,1,...).
 * @author Georg Fischer
 */
public class A124574 extends A052179 {

  /** Construct the sequence. */
  public A124574() {
    super(3, 4);
  }
}
#!queue	A124576	0	->	1	A052179	--------------------------------
package irvine.oeis.a124;
// Generated by gen_seq4.pl parm3 at 2021-10-25 21:44

import irvine.oeis.a052.A052179;
/**
 * A124576 Triangle read by rows: row n is the first row of the matrix M[n]^(n-1), where M[n] is the n X n tridiagonal matrix with main diagonal (1,4,4,...) and super- and subdiagonals (1,1,1,...).
 * @author Georg Fischer
 */
public class A124576 extends A052179 {

  /** Construct the sequence. */
  public A124576() {
    super(1, 4);
  }
}
#!queue	A124733	0	->	1	A052179	--------------------------------
package irvine.oeis.a124;
// Generated by gen_seq4.pl parm3 at 2021-10-25 21:44

import irvine.oeis.a052.A052179;
/**
 * A124733 Triangle read by rows: row n is the first row of the matrix M[n]^(n-1), where M[n] is the n X n tridiagonal matrix with main diagonal (2,3,3,...) and super- and subdiagonals (1,1,1,...).
 * @author Georg Fischer
 */
public class A124733 extends A052179 {

  /** Construct the sequence. */
  public A124733() {
    super(2, 3);
  }
}
#!queue	A125811	1	->	0	A023536	--------------------------------
package irvine.oeis.a125;
// manually dersimple at 2021-08-25 19:44

import irvine.math.z.Z;
import irvine.oeis.a023.A023536;

/**
 * A125811 Number of coefficients in the n-th q-Bell number as a polynomial in q.
 * @author Georg Fischer
 */
public class A125811 extends A023536 {

  private int mN = 0;
  
  @Override
  public Z next() {
    ++mN;
    return mN <= 3 ? Z.ONE : super.next().add(1);
  }
}
#!queue	A126772	0	->	1	A000931	--------------------------------
package irvine.oeis.a126;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A126772 Padovan factorials: a(n) is the product of the first n terms of the Padovan sequence. Similar to the Fibonacci factorial.
 * @author Georg Fischer
 */
public class A126772 extends A000931 {

  protected Z mFact;

  /** Construct the sequence. */
  public A126772() {
    for (int i = 0; i <= 4; ++i) {
      super.next();
    }
    mFact = Z.ONE;
  }

  @Override
  public Z next() {
    mFact = mFact.multiply(super.next());
    return mFact;
  }
}
#!queue	A127224	0	->	1	A127223	--------------------------------
package irvine.oeis.a127;

/**
 * A127224 a(n) = (n^3)!/n!.
 * @author Georg Fischer
 */
public class A127224 extends A127223 {

  /** Construct the sequence. */
  public A127224() {
    super(1, 3);
  }
}
#!queue	A128897	0	->	1	A083062	--------------------------------
package irvine.oeis.a128;
// Generated by gen_seq4.pl n2/n2sub1 at 2023-05-02 19:56

import irvine.math.z.Z;
import irvine.oeis.a083.A083062;

/**
 * A128897 a(n) = ((2n)^(2n-1)+1)/(2n+1).
 * @author Georg Fischer
 */
public class A128897 extends A083062 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A129112	0	->	1	A033308	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl parm2 at 2021-07-21 10:28

import irvine.oeis.a001.A001358;
import irvine.oeis.a033.A033308;

/**
 * A129112 Decimal expansion of constant equal to concatenated semiprimes.
 * @author Georg Fischer
 */
public class A129112 extends A033308 {

  /** Construct the sequence. */
  public A129112() {
    super(1, new A001358());
  }
}
#!queue	A129135	0	->	5	A000449	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

import irvine.oeis.a000.A000449;

/**
 * A129135 Number of permutations of [n] with exactly 5 fixed points.
 * @author Georg Fischer
 */
public class A129135 extends A000449 {

  /** Construct the sequence. */
  public A129135() {
    super(5);
  }
}
#!queue	A129136	0	->	6	A000449	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

import irvine.oeis.a000.A000449;

/**
 * A129136 Permutations with exactly 6 fixed points.
 * @author Georg Fischer
 */
public class A129136 extends A000449 {

  /** Construct the sequence. */
  public A129136() {
    super(6);
  }
}
#!queue	A129149	0	->	7	A000449	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

import irvine.oeis.a000.A000449;

/**
 * A129149 Permutations with exactly 7 fixed points.
 * @author Georg Fischer
 */
public class A129149 extends A000449 {

  /** Construct the sequence. */
  public A129149() {
    super(7);
  }
}
#!queue	A129153	0	->	8	A000449	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

import irvine.oeis.a000.A000449;

/**
 * A129153 Rencontres numbers: permutations with exactly 8 fixed points.
 * @author Georg Fischer
 */
public class A129153 extends A000449 {

  /** Construct the sequence. */
  public A129153() {
    super(8);
  }
}
#!queue	A129184	0	->	1	A010054	--------------------------------
package irvine.oeis.a129;
// manually transpose at 2021-11-10

import irvine.oeis.a010.A010054;

/**
 * A129184 Shift operator, right.
 * @author Georg Fischer
 */
public class A129184 extends A010054 {

  /** Construct the sequence. */
  public A129184() {
    super.next();
    super.next();
  }
}
#!queue	A129217	0	->	9	A000449	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

import irvine.oeis.a000.A000449;

/**
 * A129217 Permutations with exactly 9 fixed points.
 * @author Georg Fischer
 */
public class A129217 extends A000449 {

  /** Construct the sequence. */
  public A129217() {
    super(9);
  }
}
#!queue	A129218	0	->	10	A000449	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

import irvine.oeis.a000.A000449;

/**
 * A129218 Permutations with exactly 10 fixed points.
 * @author Georg Fischer
 */
public class A129218 extends A000449 {

  /** Construct the sequence. */
  public A129218() {
    super(10);
  }
}
#!queue	A129238	0	->	11	A000449	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

import irvine.oeis.a000.A000449;

/**
 * A129238 Permutations with exactly 11 fixed points.
 * @author Georg Fischer
 */
public class A129238 extends A000449 {

  /** Construct the sequence. */
  public A129238() {
    super(11);
  }
}
#!queue	A129255	0	->	12	A000449	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl A000449/parm2 at 2022-01-19 20:17

import irvine.oeis.a000.A000449;

/**
 * A129255 Permutations with exactly 12 fixed points.
 * @author Georg Fischer
 */
public class A129255 extends A000449 {

  /** Construct the sequence. */
  public A129255() {
    super(12);
  }
}
#!queue	A129335	0	->	1	A006882	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl knest/eulphi at 2023-03-01 20:54

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A129335 a(n) = phi(n!!) where phi is the Euler totient function. In other words, a(n) = A000010(A006882(n)).
 * @author Georg Fischer
 */
public class A129335 extends A006882 {

  {
    super.next();
  }


  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A129527	1	->	0	A000265	--------------------------------
package irvine.oeis.a129;

import irvine.math.z.Z;
import irvine.oeis.a000.A000265;

/**
 * A129527 a(2n) = a(n) + 2n, a(2n+1) = 2n + 1.
 * @author Georg Fischer
 */
public class A129527 extends A000265 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return mN == 0 ? Z.ZERO : Z.TWO.multiply(mN).subtract(super.next());
  }
}
#!queue	A129759	0	->	1	A000793	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000793;

/**
 * A129759 For the Landau function L(n), A000793, this sequence gives the largest prime which is a factor of L(n).
 * @author Georg Fischer
 */
public class A129759 extends A000793 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A129808	0	->	1	A033308	--------------------------------
package irvine.oeis.a129;
// Generated by gen_seq4.pl parm2 at 2021-07-21 10:28

import irvine.oeis.a018.A018252;
import irvine.oeis.a033.A033308;

/**
 * A129808 Decimal expansion of constant equal to concatenated nonprimes.
 * @author Georg Fischer
 */
public class A129808 extends A033308 {

  /** Construct the sequence. */
  public A129808() {
    super(1, new A018252());
  }
}
#!queue	A130328	1	->	0	A204890	--------------------------------
package irvine.oeis.a130;
// Generated by gen_seq4.pl A204892/parm3 at 2022-05-03 21:51

import irvine.oeis.a000.A000079;
import irvine.oeis.a204.A204890;
/**
 * A130328 Triangle of differences between powers of 2, read by rows.
 * @author Georg Fischer
 */
public class A130328 extends A204890 {

  /** Construct the sequence. */
  public A130328() {
    super(new A000079(), 1);
  }
}
#!queue	A131535	1	->	0	A131541	--------------------------------
package irvine.oeis.a131;

/**
 * A131535 Least power of 2 having exactly n consecutive 1's in its decimal representation.
 * @author Sean A. Irvine
 */
public class A131535 extends A131541 {

  @Override
  protected long start() {
    return -1;
  }

  @Override
  protected int getSpecialDigit() {
    return 1;
  }
}

#!queue	A131536	1	->	0	A131541	--------------------------------
package irvine.oeis.a131;

/**
 * A131536 Least power of 2 having exactly n consecutive 2's in its decimal representation.
 * @author Sean A. Irvine
 */
public class A131536 extends A131541 {

  @Override
  protected long start() {
    return -1;
  }

  @Override
  protected int getSpecialDigit() {
    return 2;
  }
}

#!queue	A131621	0	->	1	A000129	--------------------------------
package irvine.oeis.a131;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000129;

/**
 * A131621 Sum of all n-digit Pell numbers.
 * @author Georg Fischer
 */
public class A131621 extends A000129 {

  protected Z mPell; // next Pell number
  protected Z mSum; // current sum
  protected Z mPow10; // least power of 10 > Pell number

  /** Construct the sequence. */
  public A131621() {
    mPell = super.next();
    mSum = Z.ZERO;
    mPow10 = Z.TEN;
  }

  @Override
  public Z next() {
    while (mPell.compareTo(mPow10) < 0) {
      mSum = mSum.add(mPell);
      mPell = super.next();
    }
    final Z result = mSum;
    mSum = Z.ZERO;
    mPow10 = mPow10.multiply(Z.TEN);
    return result;
  }
}
#!queue	A133457	0	->	1	A048793	--------------------------------
package irvine.oeis.a133;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a048.A048793;

/**
 * A133457 Irregular triangle read by rows: row n gives exponents in expression for n as a sum of powers of 2.
 * @author Georg Fischer
 */
public class A133457 extends A048793 {

  protected int mN;
  
  /** Construct the sequence. */
  public A133457() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(1);
  }
}
#!queue	A133687	1	->	0	A227061	--------------------------------
package irvine.oeis.a133;

import irvine.math.z.Z;
import irvine.oeis.a227.A227061;
import irvine.util.Permutation;

/**
 * A133687 Triangle with number of equivalence classes of n X n matrices over {0,1} with rows and columns summing to k (0&lt;=k&lt;=n), where equivalence is defined by row and column permutations.
 * @author Sean A. Irvine
 */
public class A133687 extends A227061 {

  private int mN = -1;
  private int mM = -1;

  private static int[] transpose(final int[] m) {
    final int[] r = new int[m.length];
    for (int v : m) {
      for (int j = m.length - 1; j >= 0; --j) {
        r[j] <<= 1;
        r[j] += v & 1;
        v >>= 1;
      }
    }
    return r;
  }

  private static int findMin(final int[] m, final int j) {
    int r = 0;
    for (int k = 1; k < j; ++k) {
      if (m[k] < m[r]) {
        r = k;
      }
    }
    return r;
  }

  @Override
  protected boolean accept(final int[] matrix, final int[] transpose) {
    // Note both matrices are already sorted
    final int[] pm = new int[transpose.length];
    // Generate all row permutations of the transpose
    final Permutation perm = new Permutation(transpose.length);
    int[] p;
    while ((p = perm.next()) != null) {
      for (int k = 0; k < pm.length; ++k) {
        pm[k] = transpose[p[k]];
      }
      final int[] t = transpose(pm);

      // Notionally now want to sort t by rows and compare to matrix.
      // If they are the same, then matrix was canonical.  But doing
      // the whole sort is slow, so we do it as we go.

      // Simultaneous sort and compare
      for (int k = 0, j = matrix.length; k < matrix.length; ++k) {
        final int h = findMin(t, j);
        final int u = t[h];
        final int c = matrix[k];
        if (u < c) {
          return false;
        } else if (u > c) {
          break;
        }
        t[h] = t[--j]; // ignore already processed entry
      }
    }
    return true;
  }

  @Override
  public Long get(final Integer n, final Integer m) {
    if (m > n) {
      return 0L;
    }
    return m <= n / 2 ? super.get(n, m) : super.get(n, n - m);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return Z.valueOf(get(mN, mM));
  }
}

#!queue	A133689	1	->	2	A048671	--------------------------------
package irvine.oeis.a133;
// Generated by gen_seq4.pl seqop a048 A048671 add(mN) 1 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a048.A048671;

/**
 * A133689 a(n) = smallest integer that is &gt; n and is a multiple of every proper divisor of n.
 *
 * @author Georg Fischer
 */
public class A133689 extends A048671 {
  private int mN = 1;

  /** Construct the sequence. */
  public A133689() {
    super();
    int bOffset = 0;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().add(mN);
  }
}
#!queue	A133798	0	->	1	A002467	--------------------------------
package irvine.oeis.a133;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a002.A002467;

/**
 * A133798 a(n) = A002467(n) - 1.
 * @author Georg Fischer
 */
public class A133798 extends A002467 {

  /** Construct the sequence. */
  public A133798() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A134719	0	->	1	A000931	--------------------------------
package irvine.oeis.a134;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A134719 Odd Padovan numbers.
 * @author Georg Fischer
 */
public class A134719 extends A000931 {

  @Override
  public Z next() {
    Z result = super.next();
    while (result.isEven()) {
      result = super.next();
    }
    return result;
  }
}
#!queue	A134720	0	->	1	A000931	--------------------------------
package irvine.oeis.a134;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A134720 Even Padovan numbers.
 * @author Georg Fischer
 */
public class A134720 extends A000931 {

  @Override
  public Z next() {
    Z result = super.next();
    while (! result.isEven()) {
      result = super.next();
    }
    return result;
  }
}
#!queue	A134727	0	->	1	A000931	--------------------------------
package irvine.oeis.a134;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A134727 Successive digits of members of the Padovan sequence A000931(n).
 * @author Georg Fischer
 */
public class A134727 extends A000931 {

  protected String mPadov = ""; // current Padovan number
  protected int mPos = 1; // position in mPadov
  
  @Override
  public Z next() {
    if (mPos >= mPadov.length()) {
      mPadov = super.next().toString();
      mPos = 0;
    }
    return Z.valueOf(Character.digit(mPadov.charAt(mPos++), 10));
  }
}
#!queue	A134732	0	->	1	A000931	--------------------------------
package irvine.oeis.a134;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a000.A000931;

/**
 * A134732 Concatenation of first n members of the Padovan sequence A000931, starting at (1, 1, 1, 2,).
 * @author Georg Fischer
 */
public class A134732 extends A000931 {

  protected final StringBuilder mConc = new StringBuilder();

  /** Construct the sequence. */
  public A134732() {
    for (int i = 0; i <= 4; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    mConc.append(super.next());
    return new Z(mConc);
  }

}
#!queue	A135521	0	->	1	A135416	--------------------------------
package irvine.oeis.a135;
// Generated by gen_seq4.pl A135416/parm3 at 2022-12-20 16:28

/**
 * A135521 a(n) = 2^(A091090(n)) - 1.
 * @author Georg Fischer
 */
public class A135521 extends A135416 {

  /** Construct the sequence. */
  public A135521() {
    super($(OFFSET), 2, 6);
  }
}
#!queue	A135529	0	->	1	A135416	--------------------------------
package irvine.oeis.a135;
// Generated by gen_seq4.pl A135416/parm3 at 2022-12-20 16:28

/**
 * A135529 Guy Steele's sequence GS(4,5) (see A135416).
 * @author Georg Fischer
 */
public class A135529 extends A135416 {

  /** Construct the sequence. */
  public A135529() {
    super($(OFFSET), 4, 5);
  }
}
#!queue	A135533	0	->	1	A135416	--------------------------------
package irvine.oeis.a135;
// Generated by gen_seq4.pl A135416/parm3 at 2022-12-20 16:28

/**
 * A135533 Guy Steele's sequence GS(4,6) (see A135416).
 * @author Georg Fischer
 */
public class A135533 extends A135416 {

  /** Construct the sequence. */
  public A135533() {
    super($(OFFSET), 4, 6);
  }
}
#!queue	A135540	0	->	1	A135416	--------------------------------
package irvine.oeis.a135;
// Generated by gen_seq4.pl A135416/parm3 at 2022-12-20 16:28

/**
 * A135540 a(n) = 2^(A000523(n) - A000120(n) + 2) - 1.
 * @author Georg Fischer
 */
public class A135540 extends A135416 {

  /** Construct the sequence. */
  public A135540() {
    super($(OFFSET), 6, 3);
  }
}
#!queue	A135542	0	->	1	A135416	--------------------------------
package irvine.oeis.a135;
// Generated by gen_seq4.pl A135416/parm3 at 2022-12-20 16:28

/**
 * A135542 Guy Steele's sequence GS(6,4) (see A135416).
 * @author Georg Fischer
 */
public class A135542 extends A135416 {

  /** Construct the sequence. */
  public A135542() {
    super($(OFFSET), 6, 4);
  }
}
#!queue	A135619	0	->	1	A134720	--------------------------------
package irvine.oeis.a135;
// manually 2021-01-20

import irvine.math.z.Z;
import irvine.oeis.a134.A134720;

/**
 * A135619 Even Padovan numbers divided by 2.
 * @author Georg Fischer
 */
public class A135619 extends A134720 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A137290	0	->	1	A105471	--------------------------------
package irvine.oeis.a137;
// Generated by gen_seq4.pl parm2 at 2021-08-15 21:15

import irvine.oeis.a105.A105471;

/**
 * A137290 Fibonacci(n) mod 30.
 * @author Georg Fischer
 */
public class A137290 extends A105471 {

  /** Construct the sequence. */
  public A137290() {
    super(30);
    next(); // offset 1
  }
}
#!queue	A137327	0	->	1	A000215	--------------------------------
package irvine.oeis.a137;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a000.A000215;

/**
 * A137327 Fermat(n) modulo n.
 * @author Georg Fischer
 */
public class A137327 extends A000215 {

  protected int mN;
  
  /** Construct the sequence. */
  public A137327() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A137345	0	->	1	A014068	--------------------------------
package irvine.oeis.a137;
// Generated by gen_seq4.pl seqop a014 A014068 mod(Z.valueOf(mN)) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a014.A014068;

/**
 * A137345 a(n) = binomial( n(n+1)/2, n) mod n.
 * @author Georg Fischer
 */
public class A137345 extends A014068 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A137345() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A138107	1	->	0	A333361	--------------------------------
package irvine.oeis.a138;

import irvine.math.IntegerUtils;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a333.A333361;

/**
 * A138107 Infinite square array: T(n,k) = number of directed multigraphs with loops with n arcs and k vertices; read by falling antidiagonals.
 * @author Sean A. Irvine
 */
public class A138107 extends A333361 {

  // After Andrew Howroyd

  @Override
  protected Polynomial<Z> edgesPoly(final int[] v, final int degree) {
    Polynomial<Z> prod = RING.one();
    for (int i = 1; i < v.length; ++i) {
      for (int j = 0; j < i; ++j) {
        final int g = IntegerUtils.gcd(v[i], v[j]);
        final int u = v[i] * v[j] / g;
        prod = RING.multiply(prod, RING.pow(RING.oneMinusXToTheN(u), 2 * g, degree), degree);
      }
    }
    for (final int j : v) {
      prod = RING.multiply(prod, RING.pow(RING.oneMinusXToTheN(j), j, degree), degree);
    }
    return prod;
  }
}
#!queue	A138464	0	->	1	Transpose	--------------------------------
package irvine.oeis.a138;
// Generated by gen_seq4.pl A105599/trimirror at 2023-07-12 19:21

import irvine.oeis.a105.A105599;
import irvine.oeis.triangle.Transpose;

/**
 * A138464 Triangle read by rows: T(n, k) is the number of forests on n labeled nodes with k edges. T(n, k) for n &gt;= 1 and 0 &lt;= k &lt;= n-1.
 * @author Georg Fischer
 */
public class A138464 extends Transpose {

  /** Construct the sequence. */
  public A138464() {
    super(1, new A105599());
  }
}
#!queue	A139041	0	->	1	A000041	--------------------------------
package irvine.oeis.a139;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000041;

/**
 * A139041 Sum of divisors of the number of partitions of n.
 * @author Georg Fischer
 */
public class A139041 extends A000041 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A139421	0	->	1	A006882	--------------------------------
package irvine.oeis.a139;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a006.A006882;

/**
 * A139421 a(1)=1; for n&gt;1, a(n) = largest prime divisor of n!!.
 * @author Georg Fischer
 */
public class A139421 extends A006882 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A139480	1	->	2	A000043	--------------------------------
package irvine.oeis.a139;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a000.A000043;

/**
 * A139480 a(n) = A000043(n) - 3.
 * @author Georg Fischer
 */
public class A139480 extends A000043 {

  /** Construct the sequence. */
  public A139480() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(3);
  }
}
#!queue	A139481	1	->	2	A139480	--------------------------------
package irvine.oeis.a139;
// Generated by gen_seq4.pl dersimple at 2021-08-25 22:45

import irvine.math.z.Z;

/**
 * A139481 a(n) = A139480(n)/2.
 * @author Georg Fischer
 */
public class A139481 extends A139480 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A142590	2	->	0	A061037	--------------------------------
package irvine.oeis.a142;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061037;

/**
 * A142590 First trisection of A061037 (Balmer line series of the hydrogen atom).
 * @author Georg Fischer
 */
public class A142590 extends A061037 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A142599	2	->	1	A061037	--------------------------------
package irvine.oeis.a142;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061037;

/**
 * A142599 Second trisection of A061037.
 * @author Georg Fischer
 */
public class A142599 extends A061037 {

  /** Construct the sequence. */
  public A142599() {
    super.next();
  }

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A142600	2	->	1	A061037	--------------------------------
package irvine.oeis.a142;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061037;

/**
 * A142600 Third trisection of A061037.
 * @author Georg Fischer
 */
public class A142600 extends A061037 {

  /** Construct the sequence. */
  public A142600() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A142883	2	->	0	A142590	--------------------------------
package irvine.oeis.a142;
// Generated by gen_seq4.pl seqop a142 A142590 divide(3) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;

/**
 * A142883 a(n) = A142590(n)/3.
 * @author Georg Fischer
 */
public class A142883 extends A142590 {
  private int mN = -1;

  /** Construct the sequence. */
  public A142883() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(3);
  }
}
#!queue	A143492	2	->	3	A143491	--------------------------------
package irvine.oeis.a143;
// manually trecpas/trecpas1

/**
 * A143492 Unsigned 3-Stirling numbers of the first kind.
 * @author Georg Fischer
 */
public class A143492 extends A143491 {

  /** Construct the sequence. */
  public A143492() {
    super(3);
  }
}
#!queue	A143493	2	->	4	A143491	--------------------------------
package irvine.oeis.a143;
// manually trecpas/trecpas1

/**
 * A143493 Unsigned 4-Stirling numbers of the first kind.
 * @author Georg Fischer
 */
public class A143493 extends A143491 {

  /** Construct the sequence. */
  public A143493() {
    super(4);
  }
}
#!queue	A143495	2	->	3	A143494	--------------------------------
package irvine.oeis.a143;
// manually trecpas/trecpas1

/**
 * A143495 Triangle read by rows: 3-Stirling numbers of the second kind.
 * @author Georg Fischer
 */
public class A143495 extends A143494 {

  /** Construct the sequence. */
  public A143495() {
    super(3);
  }
}
#!queue	A143496	2	->	4	A143494	--------------------------------
package irvine.oeis.a143;
// manually trecpas/trecpas1

/**
 * A143496 4-Stirling numbers of the second kind.
 * @author Georg Fischer
 */
public class A143496 extends A143494 {

  /** Construct the sequence. */
  public A143496() {
    super(4);
  }
}
#!queue	A143498	2	->	3	A143497	--------------------------------
package irvine.oeis.a143;

/**
 * A143498 Triangle of unsigned 3-Lah numbers.
 * Recurrence: <code>T(n,k) = (n+k-1)*T(n-1,k) + T(n-1,k-1) for n,k &gt;= 3</code>.
 * @author Georg Fischer
 */
public class A143498 extends A143497 {

  /** Construct the sequence. */
  public A143498() {
    super(3);
  }
}
#!queue	A143499	2	->	4	A143497	--------------------------------
package irvine.oeis.a143;

/**
 * A143499 Triangle of unsigned 4-Lah numbers.
 * Recurrence: <code>T(n,k) = (n+k-1)*T(n-1,k) + T(n-1,k-1) for n,k &gt;= 4</code>.
 * @author Georg Fischer
 */
public class A143499 extends A143497 {

  /** Construct the sequence. */
  public A143499() {
    super(4);
  }
}
#!queue	A144448	3	->	1	A061039	--------------------------------
package irvine.oeis.a144;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a061.A061039;


/**
 * A144448 First bisection of A061039.
 * @author Georg Fischer
 */
public class A144448 extends A061039 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A144450	3	->	1	A061039	--------------------------------
package irvine.oeis.a144;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a061.A061039;


/**
 * A144450 Second bisection of A061039.
 * @author Georg Fischer
 */
public class A144450 extends A061039 {

  /** Construct the sequence. */
  public A144450() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A144527	0	->	4	A000055	--------------------------------
package irvine.oeis.a144;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a000.A000055;

/**
 * A144527 a(n) = A000055(n) - 2.
 * @author Georg Fischer
 */
public class A144527 extends A000055 {

  protected int mN;
  
  /** Construct the sequence. */
  public A144527() {
    mN = 4 - 1;
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(2);
  }
}
#!queue	A145200	1	->	0	A282019	--------------------------------
package irvine.oeis.a145;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000521;
import irvine.oeis.a013.A013973;
import irvine.oeis.a282.A282019;

/**
 * A145200 Coefficients of expansion of Phi(tau) = E_2*E_4/(E_6*j).
 * @author Sean A. Irvine
 */
public class A145200 extends A282019 {

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private final Polynomial<Z> mA = RING.empty(); // effectively x * A282019
  private final Polynomial<Z> mE6 = RING.empty();
  private final Polynomial<Z> mA521 = RING.empty();
  private final Sequence mE6Seq = new A013973();
  private final Sequence mA521Seq = new A000521();
  private int mN = -2;

  @Override
  public Z next() {
    if (++mN == -1) {
      return Z.ZERO;
    }
    mA.add(super.next());
    mE6.add(mE6Seq.next());
    mA521.add(mA521Seq.next());
    return RING.coeff(mA, RING.multiply(mE6, mA521, mN), mN);
  }
}

#!queue	A145341	0	->	1	A030101	--------------------------------
package irvine.oeis.a145;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a030.A030101;

/**
 * A145341 Convert 2n-1 to binary. Reverse its digits. Convert back to decimal to get a(n).
 * @author Georg Fischer
 */
public class A145341 extends A030101 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A145830	0	->	1	A145768	--------------------------------
package irvine.oeis.a145;

import irvine.math.z.Z;

/**
 * A145830 Indices for which A145768 (XOR of squares of the numbers 1...n) is a power of 2.
 * @author Sean A. Irvine
 */
public class A145830 extends A145768 {

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));

  @Override
  public Z next() {
    while (super.next().bitCount() != 1) {
      if (mVerbose && (mN & 0xFFFFFF) == 0) {
        System.err.println("[" + mN + "]");
      }
    }
    return Z.valueOf(mN);
  }

}

#!queue	A145874	0	->	1	A147681	--------------------------------
package irvine.oeis.a145;
// manually deris/essent at 2022-10-26 11:22

import irvine.oeis.a147.A147681;

/**
 * A145874 Number of permutations of the numbers 1, 2, ..., n such that for all 1 &lt;= k &lt;= n the average of the first k numbers is at least the average of all n numbers.
 * @author Georg Fischer
 */
public class A145874 extends A147681 {

  /** Construct the sequence. */
  public A145874() {
    skip(1);
  }
}
#!queue	A145909	3	->	0	A061039	--------------------------------
package irvine.oeis.a145;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061039;

/**
 * A145909 First 6-fold decimation of A061039. First bisection of A144454.
 * @author Georg Fischer
 */
public class A145909 extends A061039 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A145911	3	->	0	A145909	--------------------------------
package irvine.oeis.a145;
// Generated by gen_seq4.pl divmul at 2021-08-20 23:57

import irvine.math.z.Z;

/**
 * A145911 a(n) = A145909(n)/8.
 * @author Georg Fischer
 */
public class A145911 extends A145909 {

  @Override
  public Z next() {
    return super.next().divide(8);
  }
}
#!queue	A146539	1	->	0	A061045	--------------------------------
package irvine.oeis.a146;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061045;

/**
 * A146539 A061045 mod 9.
 * @author Georg Fischer
 */
public class A146539 extends A061045 {

  /** Construct the sequence. */
  public A146539() {
    for (int i = 1; i <= 5; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    return super.next().mod(Z.NINE);
  }

}
#!queue	A146975	5	->	0	A061043	--------------------------------
package irvine.oeis.a146;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061043;

/**
 * A146975 First quintisection of A061043: A061043(5n).
 * @author Georg Fischer
 */
public class A146975 extends A061043 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A147650	3	->	1	A061040	--------------------------------
package irvine.oeis.a147;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061040;

/**
 * A147650 First trisection of A061040.
 * @author Georg Fischer
 */
public class A147650 extends A061040 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A147661	0	->	1	A000312	--------------------------------
package irvine.oeis.a147;
// manually knest at 2023-06-02 20:44

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000312;

/**
 * A147661 a(n) = squarefree part of n^n.
 * @author Georg Fischer
 */
public class A147661 extends A000312 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).core();
  }
}
#!queue	A147792	4	->	0	A061042	--------------------------------
package irvine.oeis.a147;
// manually at 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061042;

/**
 * A147792 A quadrisection of A061042.
 * @author Georg Fischer
 */
public class A147792 extends A061042 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A151577	0	->	4	A334218	--------------------------------
package irvine.oeis.a151;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a334.A334218;

/**
 * A151577 Number of permutations of 1..n arranged in a circle with exactly 4 adjacent element pairs in decreasing order.
 * @author Georg Fischer
 */
public class A151577 extends A334218 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A151578	0	->	5	A334218	--------------------------------
package irvine.oeis.a151;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a334.A334218;

/**
 * A151578 Number of permutations of 1..n arranged in a circle with exactly 5 adjacent element pairs in decreasing order.
 * @author Georg Fischer
 */
public class A151578 extends A334218 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A151579	0	->	6	A334218	--------------------------------
package irvine.oeis.a151;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a334.A334218;

/**
 * A151579 Number of permutations of 1..n arranged in a circle with exactly 6 adjacent element pairs in decreasing order.
 * @author Georg Fischer
 */
public class A151579 extends A334218 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A151580	0	->	7	A334218	--------------------------------
package irvine.oeis.a151;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a334.A334218;

/**
 * A151580 Number of permutations of 1..n arranged in a circle with exactly 7 adjacent element pairs in decreasing order.
 * @author Georg Fischer
 */
public class A151580 extends A334218 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A151581	0	->	8	A334218	--------------------------------
package irvine.oeis.a151;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a334.A334218;

/**
 * A151581 Number of permutations of 1..n arranged in a circle with exactly 8 adjacent element pairs in decreasing order.
 * @author Georg Fischer
 */
public class A151581 extends A334218 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A151582	0	->	9	A334218	--------------------------------
package irvine.oeis.a151;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a334.A334218;

/**
 * A151582 Number of permutations of 1..n arranged in a circle with exactly 9 adjacent element pairs in decreasing order.
 * @author Georg Fischer
 */
public class A151582 extends A334218 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A152024	0	->	3	A000166	--------------------------------
package irvine.oeis.a152;
// manually knest/jaguar at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000166;

/**
 * A152024 Largest prime factor in the subfactorial of n.
 * @author Georg Fischer
 */
public class A152024 extends A000166 {

  {
    for (int i = 0; i < 3; ++i) {
      super.next();
    }
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A152179	1	->	0	A008865	--------------------------------
package irvine.oeis.a152;
// Generated by gen_seq4.pl moderiv at 2020-07-25 14:53
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a008.A008865;


/**
 * A152179 (n^2-2=A008865) mod 9. Period 9:repeat 8,2,7,5,5,7,2,8,7.
 * @author Georg Fischer
 */
public class A152179 extends A008865 {

  /** Construct the sequence. */
  public A152179() {
    super();
  }

  @Override
  public Z next() {
    return super.next().mod(Z.NINE);
  }
}
#!queue	A152612	0	->	1	A160449	--------------------------------
package irvine.oeis.a152;

import irvine.math.z.Z;
import irvine.oeis.a160.A160449;

/**
 * A152612 Number of isomorphism classes of n-fold coverings of a connected graph with Betti number 3.
 * @author Sean A. Irvine
 */
public class A152612 extends A160449 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 3);
  }
}
#!queue	A153002	0	->	1	A153000	--------------------------------
package irvine.oeis.a153;

import irvine.math.z.Z;

/**
 * A153002 Primes in toothpick sequence A153000.
 * @author Sean A. Irvine
 */
public class A153002 extends A153000 {

  @Override
  public Z next() {
    while (true) {
      final Z p = super.next();
      if (p.isPrime()) {
        return p;
      }
    }
  }
}

#!queue	A153733	1	->	0	A000265	--------------------------------
package irvine.oeis.a153;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a000.A000265;

/**
 * A153733 Remove all trailing 1's in the binary representation of n.
 * @author Georg Fischer
 */
public class A153733 extends A000265 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A156177	1	->	0	A000436	--------------------------------
package irvine.oeis.a156;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000436;


/**
 * A156177 A bisection of A000436.
 * @author Georg Fischer
 */
public class A156177 extends A000436 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A156178	1	->	0	A000436	--------------------------------
package irvine.oeis.a156;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a000.A000436;


/**
 * A156178 A bisection of A000436.
 * @author Georg Fischer
 */
public class A156178 extends A000436 {

  /** Construct the sequence. */
  public A156178() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A156625	1	->	2	A050504	--------------------------------
package irvine.oeis.a156;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a050.A050504;

/**
 * A156625 Floor(integral of log(x) from 1 to n).
 * @author Georg Fischer
 */
public class A156625 extends A050504 {

  protected int mN;
  
  /** Construct the sequence. */
  public A156625() {
    mN = 1;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(mN).add(1);
  }
}
#!queue	A156769	0	->	1	A049606	--------------------------------
package irvine.oeis.a156;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a049.A049606;

/**
 * A156769 a(n) = denominator(2^(2*n-2)/factorial(2*n-1)).
 * @author Georg Fischer
 */
public class A156769 extends A049606 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A158270	8	->	1	A061049	--------------------------------
package irvine.oeis.a158;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061049;

/**
 * A158270 Single-digit numbers in A061049.
 * @author Georg Fischer
 */
public class A158270 extends A061049 {

  @Override
  public Z next() {
    while (true) {
      final Z term = super.next();
      if (term.compareTo(Z.TEN) < 0) {
        return term;
      }
    }
  }
}
#!queue	A158273	8	->	1	A061049	--------------------------------
package irvine.oeis.a158;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061049;

/**
 * A158273 Indices of single-digit numbers in A061049.
 * @author Georg Fischer
 */
public class A158273 extends A061049 {

  private int mN;
  
  /** Construct the sequence. */
  public A158273() {
    mN = 7;
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().compareTo(Z.TEN) < 0) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A158280	1	->	0	A145511	--------------------------------
package irvine.oeis.a158;

import irvine.math.z.Z;
import irvine.oeis.a145.A145511;

/**
 * A158280 Octosection: A145511(8n+4) or A145501(8n+4).
 * @author Georg Fischer
 */
public class A158280 extends A145511 {

  /** Construct the sequence. */
  public A158280() {
  }

  @Override
  public Z next() {
    super.next();
    super.next();
    super.next();
    final Z result = super.next();
    super.next();
    super.next();
    super.next();
    super.next();
    return result;
  }
}
#!queue	A158315	1	->	0	A158280	--------------------------------
package irvine.oeis.a158;
// Generated by gen_seq4.pl dersimple at 2022-12-15 23:30

import irvine.math.z.Z;

/**
 * A158315 A158280(n)/7.
 * @author Georg Fischer
 */
public class A158315 extends A158280 {

  @Override
  public Z next() {
    return super.next().divide(7);
  }
}
#!queue	A158622	1	->	2	A046163	--------------------------------
package irvine.oeis.a158;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a046.A046163;

/**
 * A158622 Numerator of the reduced fraction A158620(n)/A158621(n).
 * @author Georg Fischer
 */
public class A158622 extends A046163 {

  /** Construct the sequence. */
  public A158622() {
    skip(1);
  }
}
#!queue	A158650	4	->	1	A061041	--------------------------------
package irvine.oeis.a158;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.a061.A061041;

/**
 * A158650 Indices of single-digit numbers in A061041.
 * @author Georg Fischer
 */
public class A158650 extends A061041 {

  private int mN;
  
  /** Construct the sequence. */
  public A158650() {
    mN = 3;
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (super.next().compareTo(Z.TEN) < 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A158907	0	->	1	A032741	--------------------------------
package irvine.oeis.a158;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a032.A032741;

/**
 * A158907 Row sums of triangle A158906.
 * @author Georg Fischer
 */
public class A158907 extends A032741 {

  protected int mN;
  
  /** Construct the sequence. */
  public A158907() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().add(mN);
  }
}
#!queue	A160446	0	->	1	A160449	--------------------------------
package irvine.oeis.a160;

import irvine.math.z.Z;

/**
 * A160446 Number of isomorphism classes of n-fold coverings of a connected graph with Betti number 4.
 * @author Sean A. Irvine
 */
public class A160446 extends A160449 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 4);
  }
}
#!queue	A160503	0	->	1	A006880	--------------------------------
package irvine.oeis.a160;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a006.A006880;

/**
 * A160503 Least prime divisor of pi(10^n).
 * @author Georg Fischer
 */
public class A160503 extends A006880 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A160793	0	->	1	A160792	--------------------------------
package irvine.oeis.a160;

import irvine.math.z.Z;

/**
 * A160793 Natural numbers and the sum of first n primes interleaved.
 * @author Sean A. Irvine
 */
public class A160793 extends A160792 {

  private Z mPrev = super.next();

  @Override
  public Z next() {
    final Z t = super.next();
    final Z r = t.subtract(mPrev);
    mPrev = t;
    return r;
  }
}

#!queue	A160797	0	->	1	A160796	--------------------------------
package irvine.oeis.a160;

import irvine.math.z.Z;

/**
 * A160797 First differences of A160796.
 * @author Sean A. Irvine
 */
public class A160797 extends A160796 {

  private Z mPrev = super.next();

  @Override
  public Z next() {
    final Z t = super.next();
    final Z r = t.subtract(mPrev);
    mPrev = t;
    return r;
  }
}

#!queue	A161116	1	->	0	A070824	--------------------------------
package irvine.oeis.a161;
// manually n2 at 2023-05-02 19:36

import irvine.math.z.Z;
import irvine.oeis.a070.A070824;

/**
 * A161116 a(n) is the number of nontrivial positive divisors of 2n+3.
 * @author Georg Fischer
 */
public class A161116 extends A070824 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A161736	0	->	2	A001902	--------------------------------
package irvine.oeis.a161;
// Generated by gen_seq4.pl n2/n2add1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a001.A001902;

/**
 * A161736 Denominators of the column sums of the BG2 matrix.
 * @author Georg Fischer
 */
public class A161736 extends A001902 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A161981	0	->	1	A006128	--------------------------------
package irvine.oeis.a161;
// manually 2021-06-23

import irvine.math.z.Z;
import irvine.oeis.a006.A006128;

/**
 * A161981 A006128(n) mod n.
 * @author Georg Fischer
 */
public class A161981 extends A006128 {
    
  protected int mN;

  /** Construct the sequence. */
  public A161981() {
    mN = 0;
    super.next();
  }
  
  @Override
  public Z next() {
    return super.next().mod(Z.valueOf(++mN));
  }
}
#!queue	A163176	0	->	1	A001898	--------------------------------
package irvine.oeis.a163;
// manually 2021-06-23

import irvine.math.z.Z;
import irvine.oeis.a001.A001898;

/**
 * A163176 The n-th Minkowski number divided by the n-th factorial: a(n) = A053657(n)/n!.
 * a(n) = A001898(n-1)/n.
 * @author Georg Fischer
 */
public class A163176 extends A001898 {
    
  @Override
  public Z next() {
    return super.next().divide(mN + 1);
  }
}
#!queue	A164314	1	->	2	A008865	--------------------------------
package irvine.oeis.a164;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a008.A008865;

/**
 * A164314 Largest prime factor of n^2 - 2.
 * @author Georg Fischer
 */
public class A164314 extends A008865 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A165342	2	->	0	A061037	--------------------------------
package irvine.oeis.a165;
// manually 2021-07-05

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000265;
import irvine.oeis.a061.A061037;

/**
 * A165342 a(n) = A061037(n+2)/A000265(n+4).
 * @author Georg Fischer
 */
public class A165342 extends A061037 {

  private Sequence mA265;
  
  /** Construct the sequence. */
  public A165342() {
    mA265 = new A000265();
    mA265.next();
    mA265.next();
    mA265.next();
  }

  @Override
  public Z next() {
    return super.next().divide(mA265.next());
  }

}
#!queue	A166280	1	->	0	A008277	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl moderiv at 2020-07-25 14:53
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a008.A008277;


/**
 * A166280 Stirling2 triangle mod 2, T(n,k) = A008277(n,k) mod 2.
 * @author Georg Fischer
 */
public class A166280 extends A008277 {

  /** Construct the sequence. */
  public A166280() {
    super();
  }

  @Override
  public Z next() {
    return super.next().mod(Z.TWO);
  }
}
#!queue	A166375	1	->	2	A014817	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a014.A014817;

/**
 * A166375 a(n) = sum (floor (j^2/n)) taken over 1 &lt;= j &lt;= n-1.
 * @author Georg Fischer
 */
public class A166375 extends A014817 {

  protected int mN;
  
  /** Construct the sequence. */
  public A166375() {
    mN = 1;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(mN);
  }
}
#!queue	A166472	0	->	1	A166470	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;

/**
 * A166472 2^F(n+2)*3^F(n+1)/12, where F(n) is the n-th Fibonacci number (A000045(n)).
 * @author Georg Fischer
 */
public class A166472 extends A166470 {

  protected int mN;
  
  /** Construct the sequence. */
  public A166472() {
    mN = 0;
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(12);
  }
}
#!queue	A167028	0	->	1	A002370	--------------------------------
package irvine.oeis.a167;
// manually deris2/essent at 2021-11-04

import irvine.math.z.Z;
import irvine.oeis.a002.A002370;

/**
 * A167028 Number of terms in the expansion of the determinant of a skew-symmetric matrix of order n.
 * Essentially a duplicate of A002370.
 * @author Georg Fischer
 */
public class A167028 extends A002370 {

  private int mN = 0;

  /** Construct the sequence. */
  public A167028() {
    super.next();
  }

  @Override
  public Z next() {
    return (++mN & 1) == 1 ? Z.ZERO : super.next();
  }
}
#!queue	A172404	0	->	1	A067497	--------------------------------
package irvine.oeis.a172;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067497;

/**
 * A172404 Numbers k such that 3 is the first digit of 2^k.
 * @author Georg Fischer
 */
public class A172404 extends A067497 {

  /** Construct the sequence. */
  public A172404() {
    super(3);
  }
}
#!queue	A172541	0	->	1	A008300	--------------------------------
package irvine.oeis.a172;

import irvine.math.z.Z;
import irvine.oeis.a008.A008300;

/**
 * A172541 Number of n X n 0..1 arrays with row sums 7 and column sums 7.
 * @author Sean A. Irvine
 */
public class A172541 extends A008300 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 7);
  }
}
#!queue	A172544	0	->	1	A008300	--------------------------------
package irvine.oeis.a172;

import irvine.math.z.Z;
import irvine.oeis.a008.A008300;

/**
 * A172544 Number of n X n 0..1 arrays with row sums 6 and column sums 6.
 * @author Sean A. Irvine
 */
public class A172544 extends A008300 {

  private int mN = 0;

  @Override
  public Z next() {
    return t(++mN, 6);
  }
}
#!queue	A174621	0	->	2	A046145	--------------------------------
package irvine.oeis.a174;
// manually deris/essent at 2022-04-28 12:39

import irvine.math.z.Z;
import irvine.oeis.a046.A046145;

/**
 * A174621 a(n) is the smallest generator for the group of numbers relatively prime to n under multiplication mod n; a(n) = -1 if n is not a power of a prime or twice a power of a prime.
 * @author Georg Fischer
 */
public class A174621 extends A046145 {

  /** Construct the sequence. */
  public A174621() {
    skip(2);
  }

  @Override
  public Z next() {
    final Z t = super.next();
    return t.isZero() ? Z.NEG_ONE : t;
  }
}
#!queue	A176271	0	->	1	A005408	--------------------------------
package irvine.oeis.a176;
// manually 2021-10-19

import irvine.oeis.a005.A005408;

/**
 * A176271 The odd numbers as a triangle read by rows. 
 * @author Georg Fischer
 */
public class A176271 extends A005408 {
}
#!queue	A176767	1	->	0	A176772	--------------------------------
package irvine.oeis.a176;

import irvine.math.z.Z;

/**
 * A176767 Smallest power of 7 whose decimal expansion contains n.
 * @author Sean A. Irvine
 */
public class A176767 extends A176772 {

  /** Default constructor. */
  public A176767() {
    super(-1);
  }

  @Override
  protected Z base() {
    return Z.SEVEN;
  }
}

#!queue	A176768	1	->	0	A176772	--------------------------------
package irvine.oeis.a176;

import irvine.math.z.Z;

/**
 * A176768 Smallest power of 8 whose decimal expansion contains n.
 * @author Sean A. Irvine
 */
public class A176768 extends A176772 {

  /** Construct the sequence. */
  public A176768() {
    super(-1);
  }

  @Override
  protected Z base() {
    return Z.EIGHT;
  }
}

#!queue	A178361	0	->	1	A004427	--------------------------------
package irvine.oeis.a178;

import irvine.math.z.Z;
import irvine.oeis.Sequence1;
import irvine.oeis.a004.A004427;

/**
 * A178361 Numbers with rounded up arithmetic mean of digits = 1.
 * @author Georg Fischer
 */
public class A178361 extends Sequence1 {

  private int mN;
  private int mDigit;
  private final A004427 mSeq = new A004427();

  /** Construct the sequence. */
  public A178361() {
    this(1);
  }

  /**
   * Generic constructor with parameters
   * @param digit
   */
  public A178361(final int digit) {
    mN = 0;
    mDigit = digit;
    mSeq.next(); // skip A004427(0) = 0
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (mSeq.next().intValue() == mDigit) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A178362	0	->	1	A178361	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl build/parm2 at 2022-05-25 22:52

/**
 * A178362 Numbers with rounded up arithmetic mean of digits = 2.
 * @author Georg Fischer
 */
public class A178362 extends A178361 {

  /** Construct the sequence. */
  public A178362() {
    super(2);
  }
}
#!queue	A178363	0	->	1	A178361	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl build/parm2 at 2022-05-25 22:52

/**
 * A178363 Numbers with rounded up arithmetic mean of digits = 3.
 * @author Georg Fischer
 */
public class A178363 extends A178361 {

  /** Construct the sequence. */
  public A178363() {
    super(3);
  }
}
#!queue	A178364	0	->	1	A178361	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl build/parm2 at 2022-05-25 22:52

/**
 * A178364 Numbers with rounded up arithmetic mean of digits = 4.
 * @author Georg Fischer
 */
public class A178364 extends A178361 {

  /** Construct the sequence. */
  public A178364() {
    super(4);
  }
}
#!queue	A178365	0	->	1	A178361	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl build/parm2 at 2022-05-25 22:52

/**
 * A178365 Numbers with rounded up arithmetic mean of digits = 5.
 * @author Georg Fischer
 */
public class A178365 extends A178361 {

  /** Construct the sequence. */
  public A178365() {
    super(5);
  }
}
#!queue	A178366	0	->	1	A178361	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl build/parm2 at 2022-05-25 22:52

/**
 * A178366 Numbers with rounded up arithmetic mean of digits = 6.
 * @author Georg Fischer
 */
public class A178366 extends A178361 {

  /** Construct the sequence. */
  public A178366() {
    super(6);
  }
}
#!queue	A178367	0	->	1	A178361	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl build/parm2 at 2022-05-25 22:52

/**
 * A178367 Numbers with rounded up arithmetic mean of digits = 7.
 * @author Georg Fischer
 */
public class A178367 extends A178361 {

  /** Construct the sequence. */
  public A178367() {
    super(7);
  }
}
#!queue	A178368	0	->	1	A178361	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl build/parm2 at 2022-05-25 22:52

/**
 * A178368 Numbers with rounded up arithmetic mean of digits = 8.
 * @author Georg Fischer
 */
public class A178368 extends A178361 {

  /** Construct the sequence. */
  public A178368() {
    super(8);
  }
}
#!queue	A178369	0	->	1	A178361	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl build/parm2 at 2022-05-25 22:52

/**
 * A178369 Numbers with rounded up arithmetic mean of digits = 9.
 * @author Georg Fischer
 */
public class A178369 extends A178361 {

  /** Construct the sequence. */
  public A178369() {
    super(9);
  }
}
#!queue	A178925	0	->	1	A000088	--------------------------------
package irvine.oeis.a178;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000088;
import irvine.oeis.a006.A006608;

/**
 * A178925 Number of n-node simple graphs that are determined by spectrum.
 * @author Sean A. Irvine
 */
public class A178925 extends A000088 {

  private final Sequence mA = new A006608();
  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().subtract(mA.next());
  }
}

#!queue	A178978	3	->	0	A144448	--------------------------------
package irvine.oeis.a178;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a144.A144448;

/**
 * A178978 a(n) = A144448(n+1)/8.
 * @author Georg Fischer
 */
public class A178978 extends A144448 {

  @Override
  public Z next() {
    return super.next().divide(8);
  }
}
#!queue	A181572	0	->	1	A104745	--------------------------------
package irvine.oeis.a181;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a104.A104745;

/**
 * A181572 Number of distinct prime divisors of 5^n + n.
 * @author Georg Fischer
 */
public class A181572 extends A104745 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A182725	0	->	1	A005291	--------------------------------
package irvine.oeis.a182;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a005.A005291;


/**
 * A182725 Bisection of A005291.
 * @author Georg Fischer
 */
public class A182725 extends A005291 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A182726	0	->	1	A005291	--------------------------------
package irvine.oeis.a182;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a005.A005291;


/**
 * A182726 Bisection of A005291.
 * @author Georg Fischer
 */
public class A182726 extends A005291 {

  /** Construct the sequence. */
  public A182726() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A183559	0	->	2	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183559 Number of partitions of n containing a clique of size 2.
 * @author Georg Fischer
 */
public class A183559 extends A183568 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A183560	0	->	3	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183560 Number of partitions of n containing a clique of size 3.
 * @author Georg Fischer
 */
public class A183560 extends A183568 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A183561	0	->	4	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183561 Number of partitions of n containing a clique of size 4.
 * @author Georg Fischer
 */
public class A183561 extends A183568 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A183562	0	->	5	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183562 Number of partitions of n containing a clique of size 5.
 * @author Georg Fischer
 */
public class A183562 extends A183568 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A183563	0	->	6	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183563 Number of partitions of n containing a clique of size 6.
 * @author Georg Fischer
 */
public class A183563 extends A183568 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A183564	0	->	7	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183564 Number of partitions of n containing a clique of size 7.
 * @author Georg Fischer
 */
public class A183564 extends A183568 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A183565	0	->	8	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183565 Number of partitions of n containing a clique of size 8.
 * @author Georg Fischer
 */
public class A183565 extends A183568 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A183566	0	->	9	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183566 Number of partitions of n containing a clique of size 9.
 * @author Georg Fischer
 */
public class A183566 extends A183568 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A183567	0	->	10	A183568	--------------------------------
package irvine.oeis.a183;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A183567 Number of partitions of n containing a clique of size 10.
 * @author Georg Fischer
 */
public class A183567 extends A183568 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A185828	0	->	1	A100886	--------------------------------
package irvine.oeis.a185;
// Generated by gen_seq4.pl n2/n2add1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a100.A100886;

/**
 * A185828 Half the number of n X 2 binary arrays with every element equal to exactly one or two of its horizontal and vertical neighbors.
 * @author Georg Fischer
 */
public class A185828 extends A100886 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A187570	0	->	1	A045749	--------------------------------
package irvine.oeis.a187;
// manually deris/essent at 2022-04-28 12:39

import irvine.oeis.a045.A045749;

/**
 * A187570 Rank transform of the sequence ceiling(n/3); complement of A187571.
 * @author Georg Fischer
 */
public class A187570 extends A045749 {

  /** Construct the sequence. */
  public A187570() {
    skip(1);
  }
}
#!queue	A187571	0	->	1	A045750	--------------------------------
package irvine.oeis.a187;
// manually deris/essent at 2022-04-28 15:40

import irvine.oeis.a045.A045750;

/**
 * A187571 Complement of A187570.
 * @author Georg Fischer
 */
public class A187571 extends A045750 {

  /** Construct the sequence. */
  public A187571() {
    skip(1);
  }
}
#!queue	A190297	2	->	1	A013697	--------------------------------
package irvine.oeis.a190;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a013.A013697;


/**
 * A190297 Bisection of A013697.
 * @author Georg Fischer
 */
public class A190297 extends A013697 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A190584	2	->	1	A013697	--------------------------------
package irvine.oeis.a190;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a013.A013697;


/**
 * A190584 Bisection of A013697.
 * @author Georg Fischer
 */
public class A190584 extends A013697 {

  /** Construct the sequence. */
  public A190584() {
    super.next();
  }
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A190815	0	->	1	A049690	--------------------------------
package irvine.oeis.a190;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a049.A049690;


/**
 * A190815 A bisection of A049690.
 * @author Georg Fischer
 */
public class A190815 extends A049690 {
  
  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A190839	0	->	1	A066138	--------------------------------
package irvine.oeis.a190;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a066.A066138;

/**
 * A190839 a(n) is the maximal prime divisor of 10^(2*n)+10^n+1.
 * @author Georg Fischer
 */
public class A190839 extends A066138 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A191101	1	->	5	A007678	--------------------------------
package irvine.oeis.a191;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a007.A007678;

/**
 * A191101 Number of regions in a complete but borderless regular polygon.
 * @author Georg Fischer
 */
public class A191101 extends A007678 {

  protected int mN;
  
  /** Construct the sequence. */
  public A191101() {
    mN = 5 - 1;
    super.next();
    super.next();
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().subtract(mN);
  }
}
#!queue	A191871	1	->	0	A000265	--------------------------------
package irvine.oeis.a191;
// manually knestm/knest at 2023-03-02 15:17

import irvine.math.z.Z;
import irvine.oeis.a000.A000265;

/**
 * A191871 a(n) = numerator(n^2 / 2^n).
 * @author Georg Fischer
 */
public class A191871 extends A000265 {

  private int mN = -1;

  @Override
  public Z next() {
    return (++mN == 0) ? Z.ZERO : super.next().square();
  }
}
#!queue	A194887	0	->	1	A055235	--------------------------------
package irvine.oeis.a194;
// Generated by gen_seq4.pl parm2 at 2021-10-18 12:36

import irvine.oeis.a055.A055235;

/**
 * A194887 Numbers that are the sum of two powers of 12.
 * @author Georg Fischer
 */
public class A194887 extends A055235 {

  /** Construct the sequence. */
  public A194887() {
    super(12);
  }
}
#!queue	A195503	0	->	1	A001353	--------------------------------
package irvine.oeis.a195;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a001.A001353;

/**
 * A195503 Numerators b(n) of Pythagorean approximations b(n)/a(n) to sqrt(3).
 * @author Georg Fischer
 */
public class A195503 extends A001353 {

  /** Construct the sequence. */
  public A195503() {
    skip(2);
  }
}
#!queue	A195531	0	->	1	A120893	--------------------------------
package irvine.oeis.a195;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a120.A120893;

/**
 * A195531 Hypotenuses of Pythagorean triples in A195499 and A195503.
 * @author Georg Fischer
 */
public class A195531 extends A120893 {

  /** Construct the sequence. */
  public A195531() {
    skip(2);
  }
}
#!queue	A202708	0	->	6	A004152	--------------------------------
package irvine.oeis.a202;
// Generated by gen_seq4.pl seqop a004 A004152 divide(9) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a004.A004152;

/**
 * A202708 Sum of digits of n! divided by 9.
 * @author Georg Fischer
 */
public class A202708 extends A004152 {
  private int mN = 6 - 1;
  
  /** Construct the sequence. */
  public A202708() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(9);
  }
}
#!queue	A203463	0	->	1	A020985	--------------------------------
package irvine.oeis.a203;

import irvine.math.z.Z;
import irvine.oeis.a020.A020985;

/**
 * A203463 Where Golay-Rudin-Shapiro sequence A020985 is positive.
 * @author Sean A. Irvine
 */
public class A203463 extends A020985 {

  @Override
  public Z next() {
    while (true) {
      if (super.next().signum() > 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A204021	1	->	0	A203991	--------------------------------
package irvine.oeis.a204;
// Generated by gen_seq4.pl parmof2 at 2021-10-25 20:25

import irvine.oeis.a157.A157454;
import irvine.oeis.a203.A203991;

/**
 * A204021 Triangle read by rows: row n shows the coefficients of the characteristic polynomial of the n-th principal submatrix of min(2i-1,2j-1) (A157454).
 *
 * @author Georg Fischer
 */
public class A204021 extends A203991 {

  /** Construct the sequence. */
  public A204021() {
    super(0, new A157454());
  }
}
#!queue	A204248	1	->	0	A085244	--------------------------------
package irvine.oeis.a204;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Z;
import irvine.oeis.a085.A085244;

/**
 * A204248 Permanent of the n-th principal submatrix of A002024.
 * @author Georg Fischer
 */
public class A204248 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Z.valueOf(i + j + 1));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A204249	1	->	0	A085244	--------------------------------
package irvine.oeis.a204;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Z;
import irvine.oeis.a085.A085244;

/**
 * A204249 Permanent of the n-th principal submatrix of A003057.
 * @author Georg Fischer
 */
public class A204249 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Z.valueOf(i + j + 2));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A204262	1	->	0	A085244	--------------------------------
package irvine.oeis.a204;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Z;
import irvine.oeis.a085.A085244;

/**
 * A204262 Permanent of the n-th principal submatrix of A003983.
 * @author Georg Fischer
 */
public class A204262 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Z.valueOf(i < j ? i + 1 : j + 1));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A205382	0	->	1	A109049	--------------------------------
package irvine.oeis.a205;
// manually deris2/essent at 2021-11-04

import irvine.oeis.a109.A109049;

/**
 * A205382 s(k)-s(j), where (s(k),s(j)) is the least such pair for which n divides their difference, and s(j)=(2j-1)^2.
 * @author Georg Fischer
 */
public class A205382 extends A109049 {

  /** Construct the sequence. */
  public A205382() {
    skip(1);
  }
}
#!queue	A205505	0	->	1	A000045	--------------------------------
package irvine.oeis.a205;

import irvine.math.z.Fibonacci;
import irvine.math.z.Z;
import irvine.oeis.Sequence1;
import irvine.oeis.a000.A000045;

/**
 * A205505 Fibonacci(n*(n+1)) / Fibonacci(n).
 * @author Georg Fischer
 */
public class A205505 extends Sequence1 {

  private int mN = 0;
  private final A000045 mSeq = new A000045().skip();
  
  @Override
  public Z next() {
    ++mN;
    return Fibonacci.fibonacci(mN * (mN + 1)).divide(mSeq.next());
  }
}
#!queue	A206295	0	->	1	A007188	--------------------------------
package irvine.oeis.a206;

import irvine.math.z.Z;
import irvine.oeis.a007.A007188;

/**
 * A206295 (1/6)*A007188(n).
 * @author Georg Fischer
 */
public class A206295 extends A007188 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(6);
  }
}
#!queue	A207982	0	->	1	A000984	--------------------------------
package irvine.oeis.a207;

import java.util.ArrayList;
import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.a000.A000984;

/**
 * A207982 Least m&gt;1 such that all central binomial coefficients C(2k,k), k&lt;=n, are pairwise not congruent mod m.
 * @author Sean A. Irvine
 */
public class A207982 extends A000984 {

  private final ArrayList<Z> mCentral = new ArrayList<>();
  private int mN = -1;
  private int mLast = 1;

  @Override
  public Z next() {
    mCentral.add(super.next());
    if (++mN == 0) {
      mCentral.add(super.next());
      return Z.TWO;
    }
    int k = mLast;
    final HashSet<Long> seen = new HashSet<>();
    while (true) {
      boolean ok = true;
      seen.clear();
      for (int j = 1; j < mCentral.size(); ++j) {
        if (!seen.add(mCentral.get(j).mod(k))) {
          ok = false;
          break;
        }
      }
      if (ok) {
        mLast = k;
        return Z.valueOf(k);
      }
      ++k;
    }
  }
}

#!queue	A208649	0	->	1	A073617	--------------------------------
package irvine.oeis.a208;

import irvine.math.z.Z;
import irvine.oeis.a073.A073617;

/**
 * A208649 (1/n)*A073617(n+1).
 * @author Georg Fischer
 */
public class A208649 extends A073617 {

  private int mN = 0;

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(++mN);
  }
}
#!queue	A209190	0	->	1	A004086	--------------------------------
package irvine.oeis.a209;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a004.A004086;

/**
 * A209190 Least prime factor of reversal of digits of n.
 * @author Georg Fischer
 */
public class A209190 extends A004086 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A210026	0	->	1	A210025	--------------------------------
package irvine.oeis.a210;

import irvine.math.z.Z;

/**
 * A210026 List of successive digits in A210025.
 * @author Sean A. Irvine
 */
public class A210026 extends A210025 {

  private final StringBuilder mDigits = new StringBuilder();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN >= mDigits.length()) {
      mDigits.append(super.next().toString());
    }
    return Z.valueOf(mDigits.charAt(mN) - '0');
  }
}
#!queue	A210437	0	->	1	A004086	--------------------------------
package irvine.oeis.a210;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a004.A004086;

/**
 * A210437 Greatest prime factor of reversal of digits of n.
 * @author Georg Fischer
 */
public class A210437 extends A004086 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A210657	1	->	0	A002114	--------------------------------
package irvine.oeis.a210;
// manually egfsi at 2022-04-29 12:55

import irvine.math.z.Z;
import irvine.oeis.a002.A002114;

/**
 * A210657 a(0)=1; thereafter a(n) = -2*Sum_{k=1..n} binomial(2n,2k)*a(n-k).
 * @author Georg Fischer
 */
public class A210657 extends A002114 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    if (mN == 0) {
      return Z.ONE;
    }
    return (((mN & 1) == 0) ? super.next() : super.next().negate()).multiply2();
  }
}
#!queue	A210986	0	->	1	A001168	--------------------------------
package irvine.oeis.a210;
// manually n2/n2add1 at 2022-04-08 11:54

import irvine.math.z.Z;
import irvine.oeis.a001.A001168;

/**
 * A210986 Number of fixed polyominoes with 2n cells.
 * @author Georg Fischer
 */
public class A210986 extends A001168 {

  {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A210987	0	->	1	A001168	--------------------------------
package irvine.oeis.a210;
// Generated by gen_seq4.pl n2/n2sub1 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a001.A001168;

/**
 * A210987 Number of fixed polyominoes with 2n-1 cells.
 * @author Georg Fischer
 */
public class A210987 extends A001168 {

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A211004	0	->	1	A001840	--------------------------------
package irvine.oeis.a211;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a001.A001840;

/**
 * A211004 Number of distinct regions in the set of partitions of n.
 * @author Georg Fischer
 */
public class A211004 extends A001840 {

  /** Construct the sequence. */
  public A211004() {
    skip(1);
  }
}
#!queue	A213179	0	->	1	A052001	--------------------------------
package irvine.oeis.a213;
// Generated by gen_seq4.pl seqop a052 A052001 divide2() 1 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a052.A052001;

/**
 * A213179 Numbers k such that 2*k is a partition number.
 *
 * @author Georg Fischer
 */
public class A213179 extends A052001 {
  private int mN = 0;

  /** Construct the sequence. */
  public A213179() {
    super();
    int bOffset = 0;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A213439	1	->	2	A000136	--------------------------------
package irvine.oeis.a213;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a000.A000136;

/**
 * A213439 A000136(n)/2.
 * @author Georg Fischer
 */
public class A213439 extends A000136 {

  /** Construct the sequence. */
  public A213439() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A213594	0	->	1	A048784	--------------------------------
package irvine.oeis.a213;
// manually valuation/valuat at 2022-03-16 13:50

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a048.A048784;

/**
 * A213594 Greatest number k such that A048784(n) / 2^k is an integer.
 * @author Georg Fischer
 */
public class A213594 extends A048784 {

  /** Construct the sequence. */
  public A213594() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.TWO));
  }
}
#!queue	A213595	0	->	1	A048784	--------------------------------
package irvine.oeis.a213;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a048.A048784;

/**
 * A213595 A048784(n) / 2^A213594(n).
 * @author Georg Fischer
 */
public class A213595 extends A048784 {

  private final Sequence mSeq = new A213594();

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide(Z.ONE.shiftLeft(mSeq.next().longValue()));
  }
}
#!queue	A214271	1	->	3	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214271 Number of compositions of n where the difference between largest and smallest parts equals 2 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214271 extends A214269 {

  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A214272	1	->	4	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214272 Number of compositions of n where the difference between largest and smallest parts equals 3 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214272 extends A214269 {

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A214273	1	->	5	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214273 Number of compositions of n where the difference between largest and smallest parts equals 4 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214273 extends A214269 {

  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A214274	1	->	6	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214274 Number of compositions of n where the difference between largest and smallest parts equals 5 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214274 extends A214269 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A214275	1	->	7	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214275 Number of compositions of n where the difference between largest and smallest parts equals 6 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214275 extends A214269 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A214276	1	->	8	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214276 Number of compositions of n where the difference between largest and smallest parts equals 7 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214276 extends A214269 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A214277	1	->	9	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214277 Number of compositions of n where the difference between largest and smallest parts equals 8 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214277 extends A214269 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A214278	1	->	10	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214278 Number of compositions of n where the difference between largest and smallest parts equals 9 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214278 extends A214269 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A214279	1	->	11	A214269	--------------------------------
package irvine.oeis.a214;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A214279 Number of compositions of n where the difference between largest and smallest parts equals 10 and adjacent parts are unequal.
 * @author Georg Fischer
 */
public class A214279 extends A214269 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A214817	0	->	1	A214823	--------------------------------
package irvine.oeis.a214;

import irvine.math.z.Z;

/**
 * A214817 Number of genus 2 rooted hypermaps with n darts.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A214817 extends A214823 {

  private int mN = 0;

  @Override
  public Z next() {
    hypermapCount(0, ++mN, 1, mN + 1, false);
    return Z.valueOf(mSum[2]);
  }
}
#!queue	A214818	0	->	1	A214823	--------------------------------
package irvine.oeis.a214;

import irvine.math.z.Z;

/**
 * A214818 Number of genus 3 rooted hypermaps with n darts.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A214818 extends A214823 {

  private int mN = 0;

  @Override
  public Z next() {
    hypermapCount(0, ++mN, 1, mN + 1, false);
    return Z.valueOf(mSum[3]);
  }
}
#!queue	A214819	0	->	1	A214823	--------------------------------
package irvine.oeis.a214;

import irvine.math.z.Z;

/**
 * A214819 Number of genus 2 sensed hypermaps with n darts.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A214819 extends A214823 {

  private int mN = 0;

  @Override
  public Z next() {
    hypermapCount(1, ++mN, 1, mN + 1, false);
    return Z.valueOf(mSumSensed[2]);
  }
}
#!queue	A214820	0	->	1	A214823	--------------------------------
package irvine.oeis.a214;

import irvine.math.z.Z;

/**
 * A214820 Number of genus 3 sensed hypermaps with n darts.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A214820 extends A214823 {

  private int mN = 0;

  @Override
  public Z next() {
    hypermapCount(1, ++mN, 1, mN + 1, false);
    return Z.valueOf(mSumSensed[3]);
  }
}
#!queue	A214821	0	->	1	A214823	--------------------------------
package irvine.oeis.a214;

import irvine.math.z.Z;

/**
 * A214821 Number of genus 0 unsensed hypermaps with n darts.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A214821 extends A214823 {

  /**
   * Count planar hypermaps.
   * @param rt mode
   * @param e number of edges
   * @param vmn minimum number of vertices
   * @param vmx maximum number of vertices
   * @param lehman true to print the Lehman code
   * @return count
   */
  private long hypermapPlanarCount(final int rt, final int e, final int vmn, final int vmx, final boolean lehman) {
    assert e >= 0 && e <= MAX_EDGES;
    assert vmx >= 1 && vmx <= e + 1;
    assert vmn >= 1 && vmn <= vmx;

    final int[] vert = new int[DIM];
    final int[] next = new int[DIM];
    final int[] code = new int[DIM];
    final int[] prev = new int[DIM];
    final long[] root = new long[DIM];
    final long[][] sensed = new long[DIM][DIM];
    final long[][] unsensed = new long[DIM][DIM];
    long sum = 0;
    long sums = 0;
    long sumu = 0;

    if (mVerbose) {
      System.out.printf("%nNumber of rooted planar hypermaps with d darts, v vertices and e edges.%n");
      System.out.printf("  d   v   e%n");
    }
    for (int v = vmn; v <= vmx; ++v) {
      final int np = v - 1;
      final int nq = e - np;
      for (int i = 0; i <= vmx; ++i) {
        root[i] = 0;
      }
      long ct = 0;
      firstParenthesis(np);
      do {
        if (parenthesisPairs(np)) {
          throw new RuntimeException("Invalid parenthesis system.");
        }
        minPos(np);
        final int nw = colour(np);
        final int nb = v - nw;
        firstBracket(nq);
        do {
          if (bracketPairs(nq)) {
            throw new RuntimeException("Invalid bracket system.");
          }

          boolean flag = hFirstMix(nq, np); /* Mixing these two words in all possible ways. */
          while (!flag) {
            makeWord(nq, np);
            ++ct;
            ++root[nw];
            ++sum;
            if (lehman) {
              System.out.printf("nw=%3d, nb=%3d, ct=%5d:", nw, nb, ct);
              System.out.print(lehman(e));
            }
            if (rt > 0) {
              sPairs(e, 0);
              decode(e, vert, next);
              boolean max = true;
              for (int r = 2; r <= 2 * e; ++r) {
                if (mCol[vert[r]]) {
                  if (alfred(e, v, vert, next, r, code, 1)) {
                    max = false;
                    break;
                  }
                }
              }
              if (max) {
                sensed[v][nw]++;
                sums++;
                if (lehman) {
                  System.out.printf("  Sensed map #%d.", sensed[v][nw]);
                }
                if (rt > 1) {
                  for (int i = 1; i <= 2 * e; ++i) {
                    prev[next[i]] = i;
                  }
                  for (int r = 1; r <= 2 * e; ++r) {
                    if (mCol[vert[r]]) {
                      if (alfred(e, v, vert, prev, r, code, 1)) {
                        max = false;
                        break;
                      }
                    }
                  }
                  if (max) {
                    ++unsensed[v][nw];
                    ++sumu;
                    if (lehman) {
                      System.out.printf(" Unsensed map #%d.", unsensed[v][nw]);
                    }
                  }
                }
              }
            }
            if (lehman) {
              System.out.println();
            }
            flag = hNextMix(nq, np);
          }
        } while (nextBracket(nq));
      } while (nextParenthesis(np));
      if (mVerbose) {
        for (int nw = 1; nw < v; ++nw) {
          System.out.printf("%3d%4d%4d", e, nw, v - nw);
          System.out.printf("%12d%n", root[nw]);
        }
      }
    }
    if (mVerbose) {
      System.out.printf("%3d     mSum", e);
      System.out.printf("%12d%n", sum);
      if (rt > 0) {
        System.out.printf("%nNumber of sensed planar hypermaps with d darts, v vertices and e edges.%n");
        System.out.printf("  d   v   e%n");
        for (int v = vmn; v <= vmx; ++v) {
          for (int nw = 1; nw < v; ++nw) {
            System.out.printf("%3d%4d%4d", e, nw, v - nw);
            System.out.printf("%12d%n", sensed[v][nw]);
          }
        }
        System.out.printf("%3d     mSum", e);
        System.out.printf("%12d%n", sums);
      }
      if (rt > 1) {
        System.out.printf("%nNumber of unsensed planar hypermaps with d darts, v vertices and e edges.%n");
        System.out.printf("  d   v   e%n");
        for (int v = vmn; v <= vmx; ++v) {
          for (int nw = 1; nw < v; ++nw) {
            System.out.printf("%3d%4d%4d", e, nw, v - nw);
            System.out.printf("%12d%n", unsensed[v][nw]);
          }
        }
        System.out.printf("%3d     mSum", e);
        System.out.printf("%12d%n", sumu);
      }
    }
    return sumu;
  }

  private int mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(hypermapPlanarCount(2, ++mN, 1, mN + 1, false));
  }
}
#!queue	A214822	0	->	1	A214823	--------------------------------
package irvine.oeis.a214;

import irvine.math.z.Z;

/**
 * A214822 Number of genus 1 unsensed hypermaps with n darts.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A214822 extends A214823 {

  private int mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(hypermapCount(2, ++mN, 1, mN + 1, false)[1]);
  }
}
#!queue	A214823	0	->	1	A006387	--------------------------------
package irvine.oeis.a214;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.a006.A006387;

/**
 * A214823 Number of genus 2 unsensed hypermaps with n darts.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A214823 extends A006387 {

  protected final boolean[] mCol = new boolean[EMAXP1];
  private final int[] mWall = new int[DIM];
  private final int[] mQPos = new int[DIM];

  /* Stack space for minPos */
  private final int[] mStk = new int[EMAXP1];

  protected void minPos(final int np) {
    mStk[0] = 0;
    int ist = 0;
    mWall[2 * np] = 0;
    for (int i = 2 * np; i > 0; i--) {
      if (mP[i] < 0)  {
        // right parenthesis
        mStk[++ist] = mPMate[i]; // push
      } else {
        ist--; // pop
      }
      mWall[i - 1] = mStk[ist];
    }
  }

  protected int colour(final int np) {
    mCol[1] = true; // true = white, false = black
    boolean cl = true; // colour of current vertex
    int iv = 1; // index of current new vertex
    int nw = 1; // number of white vertices
    for (int i = 1; i <= 2 * np; ++i) {
      cl = !cl; // change colour
      if (mP[i] == 0) {
        // left parenthesis, new vertex
        mCol[++iv] = cl;
        if (cl) {
          nw++;
        }
      }
    }
    return nw;
  }

  private boolean hPlace(final int i, final int nq, final int np) {
    final int pl;
    if (mQMate[i] > i) {
      // first occurrence
      if ((mQPos[mQMate[i]] - mQPos[i + 1]) % 2 == 0) {
        pl = mQPos[i + 1] - 1;
      } else {
        // There must be an odd number of parentheses between matching brackets or integers.
        pl = mQPos[i + 1];
      }
      if (pl < mWall[mQPos[mQMate[i]]]) {
        return true; // It would make the forbidden subword.
      }
    } else {
      if (i == 2 * nq - 1) {
        pl = 2 * np; // Put the rightmost bracket or integer in the rightmost slot.
      } else {
        pl = mQPos[i + 1];
      }
      if (pl < 2) {
        return true;
      }
    }
    mQPos[i] = pl;
    return false;
  }

  private boolean hMove(final int i) {
    if (mQMate[i] > i)  {
      // first occurrence
      if (mQPos[i] > mWall[mQPos[mQMate[i]]] + 1) {
        mQPos[i] -= 2;
      } else {
        return true;
      }
    } else {
      if (mQPos[i] > 2) {
        --mQPos[i];
      } else {
        return true;
      }
    }
    return false;
  }

  protected boolean hFirstMix(final int nq, final int np) {
    if (nq == 0) {
      return false;
    }
    int i = 2 * nq - 1;
    boolean flag = hPlace(i, nq, np);
    while (true) {
      if (flag) {
        if (++i >= 2 * nq) {
          return true;
        }
        flag = hMove(i);
      } else {
        if (--i < 0) {
          return false;
        }
        flag = hPlace(i, nq, np);
      }
    }
  }

  protected boolean hNextMix(final int nq, final int np) {
    if (nq == 0) {
      return true;
    }
    int i = 0;
    boolean flag = hMove(i);
    while (true) {
      if (flag) {
        if (++i >= 2 * nq) {
          return true;
        }
        flag = hMove(i);
      } else {
        if (--i < 0) {
          return false;
        }
        flag = hPlace(i, nq, np);
      }
    }
  }

  /* makes a shuffle of parentheses and brackets or integers */
  protected void makeWord(final int nq, final int np) {
    if (nq <= 0) {
      System.arraycopy(mP, 1, mS, 1, 2 * np);
    } else {
      int ip = 1;
      int iq = 0;
      for (int i = 1; i <= 2 * (nq + np); ++i) {
        if (iq < 2 * nq && mQPos[iq] < ip) {
          mS[i] = mQ[iq++];
        } else {
          mS[i] = mP[ip++];
        }
      }
    }
  }

  private final int[] mStk1 = new int[DIM];
  private final int[] mStk2 = new int[DIM];

  /* Finds the position mSMate[i] of the mate of mS[i]  */
  protected void sPairs(final int e, final int g) {
    mStk1[0] = 0;
    mStk2[0] = 0;
    int ind1 = 0;
    int ind2 = 0;
    if (g > 0) {
      for (int i = 1; i <= e; ++i) {
        mStk2[i] = 0;
      }
    }
    for (int i = 1; i <= 2 * e; ++i) {
      if (mS[i] == OPEN_PAREN) {
        // left parenthesis; push
        mStk1[++ind1] = i;
      } else if (mS[i] == CLOSE_PAREN) {
        // right parenthesis; pop
        mSMate[i] = mStk1[ind1];
        mSMate[mStk1[ind1--]] = i;
      } else {
        // bracket or integer
        if (g == 0) {
          // parenthesis-bracket system
          if (mS[i] == OPEN_BRACKET) {
            // left bracket; push
            mStk2[++ind2] = i;
          } else {
            // right bracket; pop
            mSMate[i] = mStk2[ind2];
            mSMate[mStk2[ind2--]] = i;
          }
        } else {
          // parenthesis-integer system
          if (mStk2[mS[i]] == OPEN_PAREN) {
            mStk2[mS[i]] = i; // first occurrence
          } else {
            // second occurrence
            mSMate[i] = mStk2[mS[i]];
            mSMate[mStk2[mS[i]]] = i;
          }
        }
      }
    }
  }

  protected final long[] mSumSensed = new long[MAX_GENUS];
  protected final long[] mSum = new long[MAX_GENUS];

  /**
   * Count.
   * @param rt mode
   * @param e number of edges
   * @param vmn minimum number of vertices
   * @param vmx maximum number of vertices
   * @param lehman true to print the Lehman code
   * @return count
   */
  protected long[] hypermapCount(final int rt, final int e, final int vmn, final int vmx, final boolean lehman) {
    assert e >= 0 && e <= MAX_EDGES;
    assert vmx >= 1 && vmx <= e + 1;
    assert vmn >= 1 && vmn <= vmx;

    final int[] vert = new int[DIM];
    final int[] next = new int[DIM];
    final int[] code = new int[DIM];
    final int[] prev = new int[DIM];
    final long[][] cts = new long[DIM][DIM];
    final long[][] ctu = new long[DIM][DIM];
    final long[][] root = new long[MAX_GENUS][DIM];
    final long[][][] sensed = new long[DIM][MAX_GENUS][DIM];
    final long[][][] unsensed = new long[DIM][MAX_GENUS][DIM];
    long sumsum = 0;
    long sumsums = 0;
    final long[] sumu = new long[MAX_GENUS];
    final long[] ctr = new long[DIM];
    Arrays.fill(mSum, 0);
    Arrays.fill(mSumSensed, 0);
    mSumSumU = 0;

    printHeader(e);
    for (int v = vmn; v <= vmx; v++) {
      final int np = v - 1;
      final int nq = e - np;
      long ct = 0;
      firstParenthesis(np);
      do {
        if (parenthesisPairs(np)) {
          throw new RuntimeException("Invalid parenthesis system.");
        }
        minPos(np);
        final int nw = colour(np);
        final int nb = v - nw;
        firstInt(nq);
        do {
          qPairs(nq);
          final int g = genus(nq);
          boolean flag = hFirstMix(nq, np); // Mixing these two words in all possible ways.
          while (!flag) {
            makeWord(nq, np);
            ++ct;
            ++ctr[nw];
            ++root[g][nw];
            ++mSum[g];
            ++sumsum;
            if (lehman) {
              System.out.printf("nw=%3d, nb=%3d, ct=%5d:", nw, nb, ct);
              printLehman(e, g);
            }
            if (rt > 0) {
              sPairs(e, 1);
              decode(e, vert, next);
              boolean max = true;
              for (int r = 2; r <= 2 * e; r++) {
                if (mCol[vert[r]]) {
                  if (lehman(e, vert, next, r, code, 1) > 0) {
                    max = false;
                    break;
                  }
                }
              }
              if (max) {
                ++cts[v][nw];
                ++sensed[v][g][nw];
                ++mSumSensed[g];
                ++sumsums;
                if (lehman) {
                  System.out.printf("  Sensed map #%d.", sensed[v][g][nw]);
                }
                if (rt > 1) {
                  for (int i = 1; i <= 2 * e; ++i) {
                    prev[next[i]] = i;
                  }
                  for (int r = 1; r <= 2 * e; r++) {
                    if (mCol[vert[r]]) {
                      if (lehman(e, vert, prev, r, code, 1) > 0) {
                        max = false;
                        break;
                      }
                    }
                  }
                  if (max) {
                    ++ctu[v][nw];
                    ++unsensed[v][g][nw];
                    ++sumu[g];
                    ++mSumSumU;
                    if (lehman) {
                      System.out.printf(" Unsensed map #%d.", unsensed[v][g][nw]);
                    }
                  }
                }
              }
            }
            if (lehman) {
              System.out.println();
            }
            flag = hNextMix(nq, np);
          }
        } while (nextInt(nq));
      } while (nextParenthesis(np));
      if (mVerbose) {
        for (int nw = 1; nw < v; nw++) {
          System.out.printf("%3d%4d%4d", e, nw, v - nw);
          for (int g = 0; g <= (e - 1) / 2; ++g) {
            System.out.printf("%12d", root[g][nw]);
          }
          System.out.printf("%12d%n", ctr[nw]);
        }
      }
    }
    if (mVerbose) {
      System.out.printf("%3d     mSum", e);
      for (int g = 0; g <= (e - 1) / 2; ++g) {
        System.out.printf("%12d", mSum[g]);
      }
      System.out.printf("%12d%n", sumsum);
      if (rt > 0) {
        dumpTable("Number of sensed hypermaps with d darts, v vertices and e edges.", e, vmn, vmx, cts, sensed, mSumSensed, sumsums);
      }
      if (rt > 1) {
        dumpTable("Number of unsensed hypermaps with d darts, v vertices and e edges.", e, vmn, vmx, ctu, unsensed, sumu, mSumSumU);
      }
    }
    return sumu;
  }

  private void dumpTable(final String header, final int e, final int vmn, final int vmx, final long[][] ct, final long[][][] counts, final long[] sums, final long total) {
    System.out.println();
    System.out.println(header);
    System.out.print("  d   v   e");
    for (int g = 0; g <= (e - 1) / 2; ++g) {
      System.out.printf("         g=%1d", g);
    }
    System.out.printf("        all g%n");
    for (int v = vmn; v <= vmx; v++) {
      for (int nw = 1; nw < v; nw++) {
        System.out.printf("%3d%4d%4d", e, nw, v - nw);
        for (int g = 0; g <= (e - 1) / 2; ++g) {
          System.out.printf("%12d", counts[v][g][nw]);
        }
        System.out.printf("%12d%n", ct[v][nw]);
      }
    }
    System.out.printf("%3d     mSum", e);
    for (int g = 0; g <= (e - 1) / 2; ++g) {
      System.out.printf("%12d", sums[g]);
    }
    System.out.printf("%12d%n", total);
  }

  private void printHeader(final int e) {
    if (mVerbose) {
      System.out.printf("%nNumber of darts = %d%n", e);
      System.out.printf("%nNumber of rooted hypermaps with d darts, v vertices and e edges.%n");
      System.out.print("  d   v   e");
      for (int g = 0; g <= (e - 1) / 2; ++g) {
        System.out.printf("         g=%1d", g);
      }
      System.out.printf("       all g%n");
    }
  }

  private int mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(hypermapCount(2, ++mN, 1, mN + 1, false)[2]);
  }
}
#!queue	A215017	0	->	1	A214823	--------------------------------
package irvine.oeis.a215;

import irvine.math.z.Z;
import irvine.oeis.a214.A214823;

/**
 * A215017 Number of genus 3 unsensed hypermaps with n darts.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A215017 extends A214823 {

  private int mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(hypermapCount(2, ++mN, 1, mN + 1, false)[3]);
  }
}
#!queue	A215018	0	->	1	A214823	--------------------------------
package irvine.oeis.a215;

import irvine.math.z.Z;
import irvine.oeis.a214.A214823;

/**
 * A215018 Number of unsensed hypermaps with n darts and any genus.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A215018 extends A214823 {

  private int mN = 0;

  @Override
  public Z next() {
    hypermapCount(2, ++mN, 1, mN + 1, false);
    return Z.valueOf(mSumSumU);
  }
}
#!queue	A215092	0	->	1	A037454	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl rebase at 2020-11-30 22:51
// DO NOT EDIT here!

import irvine.oeis.a037.A037454;

/**
 * A215092 a(n) = Sum_{i=0..m} d(i)*3^i, where Sum_{i=0..m} d(i)*6^i is the base-6 representation of n.
 * @author Georg Fischer
 */
public class A215092 extends A037454 {

  /** Construct the sequence. */
  public A215092() {
    super(1, 6, 3);
  }
}
#!queue	A215339	0	->	1	A001608	--------------------------------
package irvine.oeis.a215;

import irvine.math.z.Z;
import irvine.oeis.a001.A001608;

/**
 * A215339 a(n) = A001608(n) mod n.
 * @author Sean A. Irvine
 */
public class A215339 extends A001608 {

  protected Z mN = Z.ZERO;
  {
    super.next();
  }

  @Override
  public Z next() {
    mN = mN.add(1);
    return super.next().mod(mN);
  }
}
#!queue	A215402	0	->	8	A269920	--------------------------------
package irvine.oeis.a215;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A215402 Number of rooted maps of (orientable) genus 4 containing n edges.
 * @author Sean A. Irvine
 */
public class A215402 extends A269920 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 4, k));
    }
    return sum;
  }
}
#!queue	A215851	0	->	1	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215851 Number of simple labeled graphs on n nodes with exactly 1 connected component that is a tree or a cycle.
 * @author Georg Fischer
 */
public class A215851 extends A215861 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 1);
  }
}

#!queue	A215852	0	->	2	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215852 Number of simple labeled graphs on n nodes with exactly 2 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215852 extends A215861 {

  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A215853	0	->	3	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215853 Number of simple labeled graphs on n nodes with exactly 3 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215853 extends A215861 {

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A215854	0	->	4	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215854 Number of simple labeled graphs on n nodes with exactly 4 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215854 extends A215861 {

  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A215855	0	->	5	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215855 Number of simple labeled graphs on n nodes with exactly 5 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215855 extends A215861 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A215856	0	->	6	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215856 Number of simple labeled graphs on n nodes with exactly 6 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215856 extends A215861 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A215857	0	->	7	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215857 Number of simple labeled graphs on n nodes with exactly 7 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215857 extends A215861 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A215858	0	->	8	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215858 Number of simple labeled graphs on n nodes with exactly 8 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215858 extends A215861 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A215859	0	->	9	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215859 Number of simple labeled graphs on n nodes with exactly 9 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215859 extends A215861 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A215860	0	->	10	A215861	--------------------------------
package irvine.oeis.a215;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A215860 Number of simple labeled graphs on n nodes with exactly 10 connected components that are trees or cycles.
 * @author Georg Fischer
 */
public class A215860 extends A215861 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A224652	3	->	1	A006219	--------------------------------
package irvine.oeis.a224;

import irvine.math.z.Z;
import irvine.oeis.a006.A006219;

/**
 * A224652 Triangle read by rows: T(n,k) is the number of permutations of n elements with k the (smallest) header (first element) of the longest descending subsequence.
 * @author Sean A. Irvine
 */
public class A224652 extends A006219 {

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      mM = 1;
      ++mN;
    }
    return f(mN, mM);
  }
}
#!queue	A225764	1	->	0	A085244	--------------------------------
package irvine.oeis.a225;
// Generated by gen_seq4.pl perman/perman0 at 2022-05-05 22:32

import irvine.math.api.Matrix;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.a085.A085244;

/**
 * A225764 Permanent of the n X n matrix M_n = [m_n(i,j)] with m_n(i,j) = Stirling2(n+i,j) for 1&lt;=i,j&lt;=n.
 * @author Georg Fischer
 */
public class A225764 extends A085244 {

  private int mN = -1;

  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, Stirling.secondKind(n + i + 1, j + 1));
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return super.next();
  }
}

#!queue	A227127	1	->	0	A001223	--------------------------------
package irvine.oeis.a227;
// manually deris/essent at 2022-04-28 15:40

import irvine.math.z.Z;
import irvine.oeis.a001.A001223;

/**
 * A227127 The Akiyama-Tanigawa algorithm applied to 1/(1,2,3,5,... old prime numbers). Reduced numerators of the second row.
 * @author Georg Fischer
 */
public class A227127 extends A001223 {

  private int mN = -1;

  /** Construct the sequence. */
  public A227127() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    if (mN <= 1) {
      return Z.ONE;
    } else if (mN == 2) {
      return Z.TWO;
    }
    return super.next().multiply(mN + 1);
  }
}
#!queue	A227590	2	->	1	A003022	--------------------------------
package irvine.oeis.a227;
// manually knestm/knest at 2023-03-02 16:06

import irvine.math.z.Z;
import irvine.oeis.a003.A003022;

/**
 * A227590 a(n) = A003022(n)+1 with a(1)=1.
 * @author Georg Fischer
 */
public class A227590 extends A003022 {

  private int mN = 0;

  @Override
  public Z next() {
    return (++mN == 1) ? Z.ONE : super.next().add(1);
  }
}
#!queue	A227838	0	->	1	A005132	--------------------------------
package irvine.oeis.a227;
// manually valuation/valuat at 2022-03-16 18:05

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a005.A005132;

/**
 * A227838 2^a(n) is the highest power of 2 dividing A005132(n).
 * @author Georg Fischer
 */
public class A227838 extends A005132 {

  /** Construct the sequence. */
  public A227838() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.TWO));
  }
}
#!queue	A227839	0	->	1	A005132	--------------------------------
package irvine.oeis.a227;
// manually valuation/valuat at 2022-03-16 18:05

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a005.A005132;

/**
 * A227839 3^a(n) is the highest power of 3 dividing A005132(n).
 * @author Georg Fischer
 */
public class A227839 extends A005132 {

  /** Construct the sequence. */
  public A227839() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.THREE));
  }
}
#!queue	A228037	1	->	0	A046094	--------------------------------
package irvine.oeis.a228;
// Generated by gen_seq4.pl n2 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a046.A046094;

/**
 * A228037 Odd-indexed terms of Agoh's congruence A046094: a(n) is conjectured to be 1 iff 2n+1 is prime.
 * @author Georg Fischer
 */
public class A228037 extends A046094 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A228297	0	->	1	A007845	--------------------------------
package irvine.oeis.a228;
// Generated by gen_seq4.pl seqop a007 A007845 divide(5) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a007.A007845;

/**
 * A228297 Generalized meta-Fibonacci sequence a(n) with parameters s=0 and k=5.
 *
 * @author Georg Fischer
 */
public class A228297 extends A007845 {
  private int mN = 0;

  /** Construct the sequence. */
  public A228297() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide(5);
  }
}
#!queue	A229245	1	->	3	A080510	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A229245 Number of set partitions of {1,...,n} with largest set of size 3.
 * @author Georg Fischer
 */
public class A229245 extends A080510 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A229246	1	->	4	A080510	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A229246 Number of set partitions of {1,...,n} with largest set of size 4.
 * @author Georg Fischer
 */
public class A229246 extends A080510 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A229247	1	->	5	A080510	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A229247 Number of set partitions of {1,...,n} with largest set of size 5.
 * @author Georg Fischer
 */
public class A229247 extends A080510 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A229248	1	->	6	A080510	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A229248 Number of set partitions of {1,...,n} with largest set of size 6.
 * @author Georg Fischer
 */
public class A229248 extends A080510 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A229249	1	->	7	A080510	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A229249 Number of set partitions of {1,...,n} with largest set of size 7.
 * @author Georg Fischer
 */
public class A229249 extends A080510 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A229250	1	->	8	A080510	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A229250 Number of set partitions of {1,...,n} with largest set of size 8.
 * @author Georg Fischer
 */
public class A229250 extends A080510 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A229251	1	->	9	A080510	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A229251 Number of set partitions of {1,...,n} with largest set of size 9.
 * @author Georg Fischer
 */
public class A229251 extends A080510 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A229252	1	->	10	A080510	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A229252 Number of set partitions of {1,...,n} with largest set of size 10.
 * @author Georg Fischer
 */
public class A229252 extends A080510 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A229747	1	->	0	A207262	--------------------------------
package irvine.oeis.a229;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a207.A207262;

/**
 * A229747 Largest prime factor of 4^(2*n+1)+1.
 * @author Georg Fischer
 */
public class A229747 extends A207262 {
  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A230059	0	->	1	A340445	--------------------------------
package irvine.oeis.a230;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a340.A340445;

/**
 * A230059 Conjectural number of irreducible zeta values of weight 2*n+1 and depth three.
 *
 * @author Georg Fischer
 */
public class A230059 extends A340445 {

  /** Construct the sequence. */
  public A230059() {
  }
}
#!queue	A230200	0	->	1	A208575	--------------------------------
package irvine.oeis.a230;
// Generated by gen_seq4.pl A067067/parm3 at 2022-02-28 21:02

import irvine.oeis.a002.A002385;
import irvine.oeis.a208.A208575;

/**
 * A230200 Product of digits of n-th palindromic prime.
 * @author Georg Fischer
 */
public class A230200 extends A208575 {

  /** Construct the sequence. */
  public A230200() {
    super(new A002385(), 10);
  }
}
#!queue	A234645	-1	->	0	A001093	--------------------------------
package irvine.oeis.a234;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001093;

/**
 * A234645 Sum of the divisors of n^3+1.
 * @author Georg Fischer
 */
public class A234645 extends A001093 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A237276	0	->	1	A000041	--------------------------------
package irvine.oeis.a237;

import irvine.math.z.Z;
import irvine.oeis.Sequence1;
import irvine.oeis.a000.A000041;

/**
 * A237276 Numbers k such that A000041(k) == 1 (mod 3).
 * @author Georg Fischer
 */
public class A237276 extends Sequence1 {

  private int mN;
  private Z mRes;
  private Z mMod;
  private final A000041 mSeq = new A000041();

  /** Construct the sequence. */
  public A237276() {
    this(1, 3);
  }

  /**
   * Generic constructor with parameters
   * @param res residue
   * @param mod modulus
   */
  public A237276(final int res, final int mod) {
    mN = -1;
    mRes = Z.valueOf(res);
    mMod = Z.valueOf(mod);
    if (res == 1) { // for A237276, A273279:
      ++mN;
      mSeq.next();
    }
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (mSeq.next().mod(mMod).equals(mRes)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A237277	0	->	1	A237276	--------------------------------
package irvine.oeis.a237;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

/**
 * A237277 Numbers k such that A000041(k) == 2 (mod 3).
 * @author Georg Fischer
 */
public class A237277 extends A237276 {

  /** Construct the sequence. */
  public A237277() {
    super(2, 3);
  }
}
#!queue	A237278	0	->	1	A237276	--------------------------------
package irvine.oeis.a237;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

/**
 * A237278 Numbers k such that A000041(k) == 0 (mod 4).
 * @author Georg Fischer
 */
public class A237278 extends A237276 {

  /** Construct the sequence. */
  public A237278() {
    super(0, 4);
  }
}
#!queue	A237279	0	->	1	A237276	--------------------------------
package irvine.oeis.a237;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

/**
 * A237279 Numbers k such that A000041(k) == 1 (mod 4).
 * @author Georg Fischer
 */
public class A237279 extends A237276 {

  /** Construct the sequence. */
  public A237279() {
    super(1, 4);
  }
}
#!queue	A237280	0	->	1	A237276	--------------------------------
package irvine.oeis.a237;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

/**
 * A237280 Numbers k such that A000041(k) == 2 (mod 4).
 * @author Georg Fischer
 */
public class A237280 extends A237276 {

  /** Construct the sequence. */
  public A237280() {
    super(2, 4);
  }
}
#!queue	A237281	0	->	1	A237276	--------------------------------
package irvine.oeis.a237;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

/**
 * A237281 Numbers k such that A000041(k) == 3 (mod 4).
 * @author Georg Fischer
 */
public class A237281 extends A237276 {

  /** Construct the sequence. */
  public A237281() {
    super(3, 4);
  }
}
#!queue	A238355	0	->	10	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238355 Number of rooted maps of genus 5 containing n edges.
 * @author Sean A. Irvine
 */
public class A238355 extends A269920 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 5, k));
    }
    return sum;
  }
}
#!queue	A238356	0	->	12	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238356 Number of rooted maps of genus 6 containing n edges.
 * @author Sean A. Irvine
 */
public class A238356 extends A269920 {

  private int mN = 11;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 6, k));
    }
    return sum;
  }
}
#!queue	A238357	0	->	14	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238357 Number of genus-7 rooted maps with n edges.
 * @author Sean A. Irvine
 */
public class A238357 extends A269920 {

  private int mN = 13;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 7, k));
    }
    return sum;
  }
}
#!queue	A238358	0	->	16	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238358 Number of genus-8 rooted maps with n edges.
 * @author Sean A. Irvine
 */
public class A238358 extends A269920 {

  private int mN = 15;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 8, k));
    }
    return sum;
  }
}
#!queue	A238359	0	->	18	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238359 Number of rooted maps with n edges of genus 9.
 * @author Sean A. Irvine
 */
public class A238359 extends A269920 {

  private int mN = 17;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 9, k));
    }
    return sum;
  }
}
#!queue	A238360	0	->	20	A269920	--------------------------------
package irvine.oeis.a238;

import irvine.math.z.Z;
import irvine.oeis.a269.A269920;

/**
 * A238360 Number of genus-10 rooted maps with n edges.
 * @author Sean A. Irvine
 */
public class A238360 extends A269920 {

  private int mN = 19;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(get(mN, 10, k));
    }
    return sum;
  }
}
#!queue	A242538	0	->	1	A004152	--------------------------------
package irvine.oeis.a242;

import irvine.math.z.Z;
import irvine.oeis.a004.A004152;

/**
 * A242538 Squares that are sum of digits of factorials.
 * @author Georg Fischer
 */
public class A242538 extends A004152 {

  private Z mS = Z.ZERO;

  @Override
  public Z next() {
    Z result = super.next();
    while (!result.isSquare() || result.equals(mS)) {
      result = super.next();
    }
    mS = result;
    return result;
  }
}
#!queue	A243097	0	->	1	A031877	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl knest at 2023-03-02 20:46

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a031.A031877;

/**
 * A243097 Digit sums of the nontrivial reversal numbers (numbers which are integer multiples of their reversal), excluding palindromes and multiples of 10.
 * @author Georg Fischer
 */
public class A243097 extends A031877 {
  @Override
  public Z next() {
    return Z.valueOf(ZUtils.digitSum(super.next()));
  }
}
#!queue	A243119	0	->	2	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243119 Number of compositions of n in which the maximal multiplicity of parts equals 2.
 * @author Georg Fischer
 */
public class A243119 extends A242447 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A243120	0	->	3	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243120 Number of compositions of n in which the maximal multiplicity of parts equals 3.
 * @author Georg Fischer
 */
public class A243120 extends A242447 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A243121	0	->	4	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243121 Number of compositions of n in which the maximal multiplicity of parts equals 4.
 * @author Georg Fischer
 */
public class A243121 extends A242447 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A243122	0	->	5	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243122 Number of compositions of n in which the maximal multiplicity of parts equals 5.
 * @author Georg Fischer
 */
public class A243122 extends A242447 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A243123	0	->	6	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243123 Number of compositions of n in which the maximal multiplicity of parts equals 6.
 * @author Georg Fischer
 */
public class A243123 extends A242447 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A243124	0	->	7	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243124 Number of compositions of n in which the maximal multiplicity of parts equals 7.
 * @author Georg Fischer
 */
public class A243124 extends A242447 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A243125	0	->	8	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243125 Number of compositions of n in which the maximal multiplicity of parts equals 8.
 * @author Georg Fischer
 */
public class A243125 extends A242447 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A243126	0	->	9	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243126 Number of compositions of n in which the maximal multiplicity of parts equals 9.
 * @author Georg Fischer
 */
public class A243126 extends A242447 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A243127	0	->	10	A242447	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242447;

/**
 * A243127 Number of compositions of n in which the maximal multiplicity of parts equals 10.
 * @author Georg Fischer
 */
public class A243127 extends A242447 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A243935	0	->	1	A237276	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

import irvine.oeis.a237.A237276;

/**
 * A243935 Numbers m such that 5 divides A000041(m).
 * @author Georg Fischer
 */
public class A243935 extends A237276 {

  /** Construct the sequence. */
  public A243935() {
    super(0, 5);
  }
}
#!queue	A243936	0	->	1	A237276	--------------------------------
package irvine.oeis.a243;
// Generated by gen_seq4.pl A237276/parm3 at 2022-05-06 19:58

import irvine.oeis.a237.A237276;

/**
 * A243936 Numbers m such that 7 divides A000041(m).
 * @author Georg Fischer
 */
public class A243936 extends A237276 {

  /** Construct the sequence. */
  public A243936() {
    super(0, 7);
  }
}
#!queue	A244164	0	->	1	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244164 Number of compositions of n in which the minimal multiplicity of parts equals 1.
 * @author Georg Fischer
 */
public class A244164 extends A242451 {

  private int mN = 1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 1);
  }
}

#!queue	A244165	0	->	2	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244165 Number of compositions of n in which the minimal multiplicity of parts equals 2.
 * @author Georg Fischer
 */
public class A244165 extends A242451 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A244166	0	->	3	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244166 Number of compositions of n in which the minimal multiplicity of parts equals 3.
 * @author Georg Fischer
 */
public class A244166 extends A242451 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A244167	0	->	4	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244167 Number of compositions of n in which the minimal multiplicity of parts equals 4.
 * @author Georg Fischer
 */
public class A244167 extends A242451 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A244168	0	->	5	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244168 Number of compositions of n in which the minimal multiplicity of parts equals 5.
 * @author Georg Fischer
 */
public class A244168 extends A242451 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A244169	0	->	6	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244169 Number of compositions of n in which the minimal multiplicity of parts equals 6.
 * @author Georg Fischer
 */
public class A244169 extends A242451 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A244170	0	->	7	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244170 Number of compositions of n in which the minimal multiplicity of parts equals 7.
 * @author Georg Fischer
 */
public class A244170 extends A242451 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A244171	0	->	8	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244171 Number of compositions of n in which the minimal multiplicity of parts equals 8.
 * @author Georg Fischer
 */
public class A244171 extends A242451 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A244172	0	->	9	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244172 Number of compositions of n in which the minimal multiplicity of parts equals 9.
 * @author Georg Fischer
 */
public class A244172 extends A242451 {

  private int mN = 9 - 1;
  
  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A244173	0	->	10	A242451	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a242.A242451;

/**
 * A244173 Number of compositions of n in which the minimal multiplicity of parts equals 10.
 * @author Georg Fischer
 */
public class A244173 extends A242451 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A244398	1	->	3	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244398 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 2.
 * @author Georg Fischer
 */
public class A244398 extends A244372 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A244399	1	->	4	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244399 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 3.
 * @author Georg Fischer
 */
public class A244399 extends A244372 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A244400	1	->	5	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244400 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 4.
 * @author Georg Fischer
 */
public class A244400 extends A244372 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A244401	1	->	6	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244401 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 5.
 * @author Georg Fischer
 */
public class A244401 extends A244372 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A244402	1	->	7	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244402 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 6.
 * @author Georg Fischer
 */
public class A244402 extends A244372 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A244403	1	->	8	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244403 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 7.
 * @author Georg Fischer
 */
public class A244403 extends A244372 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A244404	1	->	9	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244404 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 8.
 * @author Georg Fischer
 */
public class A244404 extends A244372 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A244405	1	->	10	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244405 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 9.
 * @author Georg Fischer
 */
public class A244405 extends A244372 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A244406	1	->	11	A244372	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244406 Number of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) 10.
 * @author Georg Fischer
 */
public class A244406 extends A244372 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A244410	1	->	0	A244372	--------------------------------
package irvine.oeis.a244;
// manually A244372/trionk

import irvine.math.z.Z;

/**
 * A244410 Number of unlabeled rooted trees with 2n+1 nodes and maximal outdegree (branching factor) n.
 * @author Georg Fischer
 */
public class A244410 extends A244372 {

  private int mN = - 1;
  
  @Override
  public Z next() {
    ++mN;
    // a:= n-> `if`(n=0, 1, b(2*n$2, n$2)-b(2*n$2, n-1$2)):
    return mN == 0 ? Z.ONE : mSeq.b(2 * mN, 2 * mN, mN, mN).subtract(mSeq.b(2 * mN, 2 * mN, mN - 1, mN - 1));
  }
}
#!queue	A244415	0	->	1	A005843	--------------------------------
package irvine.oeis.a244;
// manually valuation/valuat at 2022-03-16 18:05

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a005.A005843;

/**
 * A244415 Exponent of 4 appearing in the 4-adic value of 1/n, n &gt;= 1, given in A240226(n).
 * @author Georg Fischer
 */
public class A244415 extends A005843 {

  /** Construct the sequence. */
  public A244415() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.FOUR));
  }
}
#!queue	A244455	1	->	2	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244455 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 1.
 * @author Georg Fischer
 */
public class A244455 extends A244454 {

  private int mN = 1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 0);
  }
}

#!queue	A244456	1	->	3	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244456 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 2.
 * @author Georg Fischer
 */
public class A244456 extends A244454 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 1);
  }
}

#!queue	A244457	1	->	4	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244457 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 3.
 * @author Georg Fischer
 */
public class A244457 extends A244454 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A244458	1	->	5	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244458 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 4.
 * @author Georg Fischer
 */
public class A244458 extends A244454 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A244459	1	->	6	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244459 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 5.
 * @author Georg Fischer
 */
public class A244459 extends A244454 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A244460	1	->	7	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244460 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 6.
 * @author Georg Fischer
 */
public class A244460 extends A244454 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A244461	1	->	8	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244461 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 7.
 * @author Georg Fischer
 */
public class A244461 extends A244454 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A244462	1	->	9	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244462 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 8.
 * @author Georg Fischer
 */
public class A244462 extends A244454 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A244463	1	->	10	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244463 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 9.
 * @author Georg Fischer
 */
public class A244463 extends A244454 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A244464	1	->	11	A244454	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244464 Number of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 10.
 * @author Georg Fischer
 */
public class A244464 extends A244454 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A244531	1	->	3	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244531 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 2.
 * @author Georg Fischer
 */
public class A244531 extends A244530 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 1);
  }
}

#!queue	A244532	1	->	4	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244532 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 3.
 * @author Georg Fischer
 */
public class A244532 extends A244530 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A244533	1	->	5	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244533 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 4.
 * @author Georg Fischer
 */
public class A244533 extends A244530 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A244534	1	->	6	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244534 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 5.
 * @author Georg Fischer
 */
public class A244534 extends A244530 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A244535	1	->	7	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244535 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 6.
 * @author Georg Fischer
 */
public class A244535 extends A244530 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A244536	1	->	8	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244536 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 7.
 * @author Georg Fischer
 */
public class A244536 extends A244530 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A244537	1	->	9	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244537 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 8.
 * @author Georg Fischer
 */
public class A244537 extends A244530 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A244538	1	->	10	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244538 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 9.
 * @author Georg Fischer
 */
public class A244538 extends A244530 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A244539	1	->	11	A244530	--------------------------------
package irvine.oeis.a244;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A244539 Number of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals 10.
 * @author Georg Fischer
 */
public class A244539 extends A244530 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A246189	0	->	2	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246189 Number of endofunctions on [n] where the smallest cycle length equals 2.
 * @author Georg Fischer
 */
public class A246189 extends A246049 {

  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A246190	0	->	3	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246190 Number of endofunctions on [n] where the smallest cycle length equals 3.
 * @author Georg Fischer
 */
public class A246190 extends A246049 {

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A246191	0	->	4	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246191 Number of endofunctions on [n] where the smallest cycle length equals 4.
 * @author Georg Fischer
 */
public class A246191 extends A246049 {

  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A246192	0	->	5	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246192 Number of endofunctions on [n] where the smallest cycle length equals 5.
 * @author Georg Fischer
 */
public class A246192 extends A246049 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A246193	0	->	6	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246193 Number of endofunctions on [n] where the smallest cycle length equals 6.
 * @author Georg Fischer
 */
public class A246193 extends A246049 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A246194	0	->	7	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246194 Number of endofunctions on [n] where the smallest cycle length equals 7.
 * @author Georg Fischer
 */
public class A246194 extends A246049 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A246195	0	->	8	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246195 Number of endofunctions on [n] where the smallest cycle length equals 8.
 * @author Georg Fischer
 */
public class A246195 extends A246049 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A246196	0	->	9	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246196 Number of endofunctions on [n] where the smallest cycle length equals 9.
 * @author Georg Fischer
 */
public class A246196 extends A246049 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A246197	0	->	10	A246049	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A246197 Number of endofunctions on [n] where the smallest cycle length equals 10.
 * @author Georg Fischer
 */
public class A246197 extends A246049 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A246213	0	->	3	A241981	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a241.A241981;

/**
 * A246213 Number of endofunctions on [n] where the largest cycle length equals 3.
 * @author Georg Fischer
 */
public class A246213 extends A241981 {

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A246214	0	->	4	A241981	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a241.A241981;

/**
 * A246214 Number of endofunctions on [n] where the largest cycle length equals 4.
 * @author Georg Fischer
 */
public class A246214 extends A241981 {

  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A246215	0	->	5	A241981	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a241.A241981;

/**
 * A246215 Number of endofunctions on [n] where the largest cycle length equals 5.
 * @author Georg Fischer
 */
public class A246215 extends A241981 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A246216	0	->	6	A241981	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a241.A241981;

/**
 * A246216 Number of endofunctions on [n] where the largest cycle length equals 6.
 * @author Georg Fischer
 */
public class A246216 extends A241981 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A246217	0	->	7	A241981	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a241.A241981;

/**
 * A246217 Number of endofunctions on [n] where the largest cycle length equals 7.
 * @author Georg Fischer
 */
public class A246217 extends A241981 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A246218	0	->	8	A241981	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a241.A241981;

/**
 * A246218 Number of endofunctions on [n] where the largest cycle length equals 8.
 * @author Georg Fischer
 */
public class A246218 extends A241981 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A246219	0	->	9	A241981	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a241.A241981;

/**
 * A246219 Number of endofunctions on [n] where the largest cycle length equals 9.
 * @author Georg Fischer
 */
public class A246219 extends A241981 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A246220	0	->	10	A241981	--------------------------------
package irvine.oeis.a246;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a241.A241981;

/**
 * A246220 Number of endofunctions on [n] where the largest cycle length equals 10.
 * @author Georg Fischer
 */
public class A246220 extends A241981 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A246556	0	->	2	A000129	--------------------------------
package irvine.oeis.a246;

import java.util.Arrays;
import java.util.HashSet;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000129;

/**
 * A246556 a(n) = smallest prime which divides Pell(n) = A000129(n) but does not divide any Pell(k) for k&lt;n, or -1 if no such prime exists.
 * @author Sean A. Irvine
 */
public class A246556 extends A000129 {

  private final HashSet<Z> mPrimitives = new HashSet<>();
  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z[] factors = Jaguar.factor(super.next()).toZArray();
    for (final Z p : factors) {
      if (!mPrimitives.contains(p)) {
        mPrimitives.addAll(Arrays.asList(factors));
        return p;
      }
    }
    return Z.NEG_ONE;
  }
}
#!queue	A246724	1	->	0	A176053	--------------------------------
package irvine.oeis.a246;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a176.A176053;

/**
 * A246724 Decimal expansion of r_2, the second smallest radius for which a compact packing of the plane exists, with disks of radius 1 and r_2.
 * @author Georg Fischer
 */
public class A246724 extends A176053 {

  /** Construct the sequence. */
  public A246724() {
    skip(1);
  }
}
#!queue	A246725	1	->	0	A188934	--------------------------------
package irvine.oeis.a246;
// Generated by patch_prepend.pl 2023-06-19 07:07

import irvine.oeis.a188.A188934;

/**
 * A246725 Decimal expansion of r_3, the third smallest radius for which a compact packing of the plane exists, with disks of radius 1 and r_3.
 * @author Georg Fischer
 */
public class A246725 extends A188934 {

  /** Construct the sequence. */
  public A246725() {
    skip(1);
  }
}
#!queue	A248928	1	->	0	A027434	--------------------------------
package irvine.oeis.a248;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a027.A027434;

/**
 * A248928 Interleave (2*n+2)^2 with (2*n+3)^2, both listed n+1 times.
 * @author Georg Fischer
 */
public class A248928 extends A027434 {

  @Override
  public Z next() {
    return super.next().square();
  }
}
#!queue	A249784	-1	->	1	A002488	--------------------------------
package irvine.oeis.a249;
// manually sigman0/sigma0 at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a002.A002488;

/**
 * A249784 Number of divisors of n^(n^n).
 * @author Georg Fischer
 */
public class A249784 extends A002488 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A250292	0	->	1	A000129	--------------------------------
package irvine.oeis.a250;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a000.A000129;

/**
 * A250292 Numbers k such that Pell(k) is a semiprime.
 * @author Sean A. Irvine
 */
public class A250292 extends A000129 {

  private long mN = 1;
  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final FactorSequence fs = Jaguar.factorAllowIncomplete(super.next());
      final int semi = fs.isSemiprime();
      if (semi == FactorSequence.YES) {
        return Z.valueOf(mN);
      } else if (semi == FactorSequence.UNKNOWN) {
        throw new UnsupportedOperationException("Unknown status, Pell(" + mN + ")=" + fs);
      }
    }
  }
}
#!queue	A253103	0	->	2	A001045	--------------------------------
package irvine.oeis.a253;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a001.A001045;

/**
 * A253103 A001045(n)^3.
 * @author Georg Fischer
 */
public class A253103 extends A001045 {

  /** Construct the sequence. */
  public A253103() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return super.next().pow(3);
  }
}
#!queue	A253254	0	->	2	A051682	--------------------------------
package irvine.oeis.a253;
// manually knest/jaguar at 2023-03-01 16:41

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a051.A051682;

/**
 * A253254 Largest prime factor of the n-th 11-gonal number.
 * @author Georg Fischer
 */
public class A253254 extends A051682 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A253885	1	->	0	A003961	--------------------------------
package irvine.oeis.a253;
// Generated by gen_seq4.pl dersimple at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a003.A003961;

/**
 * A253885 Permutation of even numbers: a(n) = A003961(n+1) - 1.
 * @author Georg Fischer
 */
public class A253885 extends A003961 {

  @Override
  public Z next() {
    return super.next().subtract(1);
  }
}
#!queue	A254046	0	->	1	A087289	--------------------------------
package irvine.oeis.a254;
// Generated by gen_seq4.pl valuation/valuat at 2022-03-17 22:13

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a087.A087289;

/**
 * A254046 Column index of n in A191450: a(3n) = 1, a(3n+1) = 1, a(3n+2) = 1 + a(n+1).
 * @author Georg Fischer
 */
public class A254046 extends A087289 {

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.THREE));
  }
}
#!queue	A255165	2	->	1	A043000	--------------------------------
package irvine.oeis.a255;
// manually dersimpln at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a043.A043000;

/**
 * A255165 a(n) = Sum_{k=2..n} floor(log(n)/log(k)), n &gt;= 1.
 * @author Georg Fischer
 */
public class A255165 extends A043000 {

  protected int mN;
  
  /** Construct the sequence. */
  public A255165() {
    mN = 0;
  }

  @Override
  public Z next() {
    ++mN;
    return mN == 1 ? Z.ZERO : super.next().subtract(mN).add(1);
  }
}
#!queue	A255311	0	->	1	A033308	--------------------------------
package irvine.oeis.a255;
// Generated by gen_seq4.pl parm2 at 2021-07-21 10:28

import irvine.oeis.a001.A001223;
import irvine.oeis.a033.A033308;

/**
 * A255311 Decimal expansion of the prime gap constant (concatenate the sizes of prime gaps, A001223).
 * @author Georg Fischer
 */
public class A255311 extends A033308 {

  /** Construct the sequence. */
  public A255311() {
    super(1, new A001223());
  }
}
#!queue	A255705	1	->	0	A318754	--------------------------------
package irvine.oeis.a255;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a318.A318754;

/**
 * A255705 Number of 2n+1-node rooted trees in which the maximal number of nodes in paths starting at a leaf and ending at the first branching node or at the root equals n+1.
 * @author Georg Fischer
 */
public class A255705 extends A318754 {

  private int mN = 0 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(2 * mN + 2, mN + 1);
  }
}

#!queue	A255832	0	->	1	A255852	--------------------------------
package irvine.oeis.a255;
// Generated by gen_seq4.pl n2/n2add1 at 2022-10-25 22:41

import irvine.math.z.Z;

/**
 * A255832 Least m &gt; 0 such that gcd(m^(2n+1)+2, (m+1)^(2n+1)+2) &gt; 1.
 * @author Georg Fischer
 */
public class A255832 extends A255852 {

  {
    next();
  }

  @Override
  public Z next() {
    super.next();
    return super.next();
  }
}
#!queue	A256970	0	->	1	A053755	--------------------------------
package irvine.oeis.a256;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a053.A053755;

/**
 * A256970 Smallest prime divisor of 4*n^2+1.
 * @author Georg Fischer
 */
public class A256970 extends A053755 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A257888	5	->	3	A002055	--------------------------------
package irvine.oeis.a257;
// manually; 2021-05-10

import irvine.math.z.Z;
import irvine.oeis.a002.A002055;

/**
 * A257888 Number of nonintersecting (or self-avoiding) rook paths of length 2n+2 joining opposite corners of an n X n grid.
 * @author Georg Fischer
 */
public class A257888 extends A002055 {

  @Override
  public Z next() {
    return super.next().multiply(4);
  }
}
#!queue	A258416	0	->	2	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258416 Number of partitions of the 2-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258416 extends A255982 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A258417	0	->	3	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258417 Number of partitions of the 3-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258417 extends A255982 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A258418	0	->	4	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258418 Number of partitions of the 4-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258418 extends A255982 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A258419	0	->	5	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258419 Number of partitions of the 5-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258419 extends A255982 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A258420	0	->	6	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258420 Number of partitions of the 6-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258420 extends A255982 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A258421	0	->	7	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258421 Number of partitions of the 7-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258421 extends A255982 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A258422	0	->	8	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258422 Number of partitions of the 8-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258422 extends A255982 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A258423	0	->	9	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258423 Number of partitions of the 9-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258423 extends A255982 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A258424	0	->	10	A255982	--------------------------------
package irvine.oeis.a258;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a255.A255982;

/**
 * A258424 Number of partitions of the 10-dimensional hypercube resulting from a sequence of n bisections, each of which splits any part perpendicular to any of the axes, such that each axis is used at least once.
 * @author Georg Fischer
 */
public class A258424 extends A255982 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A259362	0	->	1	A253641	--------------------------------
package irvine.oeis.a259;
// manually sigman0/sigma0 at 2023-02-28 16:08

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a253.A253641;

/**
 * A259362 a(1) = 1, for n &gt; 1: a(n) is the number of ways to write n as a nontrivial perfect power.
 * @author Georg Fischer
 */
public class A259362 extends A253641 {

  private int mN = 0;

  {
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    final Z result = Jaguar.factor(super.next()).sigma0().subtract(1);
    return (mN == 1) ? Z.ONE : result;
  }
}
#!queue	A259368	0	->	1	A000312	--------------------------------
package irvine.oeis.a259;
// Generated by gen_seq4.pl knest at 2023-03-02 20:46

import irvine.math.z.Z;
import irvine.oeis.a000.A000312;

/**
 * A259368 Number of digits in n^n when written in binary.
 * @author Georg Fischer
 */
public class A259368 extends A000312 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(super.next().bitLength());
  }
}
#!queue	A260233	0	->	2	A000384	--------------------------------
package irvine.oeis.a260;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A260233 Smallest prime factor of the n-th hexagonal number (A000384).
 * @author Georg Fischer
 */
public class A260233 extends A000384 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A260344	0	->	1	A006779	--------------------------------
package irvine.oeis.a260;

import irvine.oeis.a006.A006779;

/**
 * A260344 Sum of squared distances from origin to ends of all n-step spiral self-avoiding walks on simple cubic lattice.
 * @author Sean A. Irvine
 */
public class A260344 extends A006779 {

  {
    super.next();
  }

  @Override
  protected long count(final int point) {
    final int x = x(point);
    final int y = y(point);
    final int z = z(point);
    return 6L * (x * x + y * y + z * z);
  }
}
#!queue	A260345	0	->	1	A006780	--------------------------------
package irvine.oeis.a260;

import irvine.oeis.a006.A006780;

/**
 * A260345 Sum of squared distances from origin to ends of all n-step anisotropic self-avoiding walks on simple cubic lattice.
 * @author Sean A. Irvine
 */
public class A260345 extends A006780 {

  {
    super.next();
  }

  @Override
  protected long count(final int point) {
    final int x = x(point);
    final int y = y(point);
    final int z = z(point);
    return 2L * (x * x + y * y + z * z);
  }
}
#!queue	A260669	0	->	1	A054440	--------------------------------
package irvine.oeis.a260;
// manually dersimple at 2022-12-15 22:48

import irvine.math.z.Z;
import irvine.oeis.a054.A054440;

/**
 * A260669 Number of unordered pairs of partitions of n with no common parts.
 * @author Georg Fischer
 */
public class A260669 extends A054440 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A262543	0	->	1	A002420	--------------------------------
package irvine.oeis.a262;

import irvine.math.z.Z;
import irvine.oeis.a002.A002420;

/**
 * A262543 Number of rooted asymmetrical polyenoids of type U_n* having n edges.
 * @author Sean A. Irvine
 */
public class A262543 extends A002420 {

  {
    super.next();
    super.next();
  }

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().abs();
  }
}

#!queue	A262567	-1	->	3	A002703	--------------------------------
package irvine.oeis.a262;
// Generated by gen_seq4.pl seqop a002 A002703 divide2() 3 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a002.A002703;

/**
 * A262567 a(n) = A002703(n)/2.
 * @author Georg Fischer
 */
public class A262567 extends A002703 {
  private int mN = 3 - 1;
  
  /** Construct the sequence. */
  public A262567() {
    super();
    int bOffset = 3 - 1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A262568	-1	->	3	A178666	--------------------------------
package irvine.oeis.a262;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a178.A178666;

/**
 * A262568 a(n) = A002703(n) + 2.
 * @author Sean A. Irvine
 */
public class A262568 extends A178666 {

  // After R. J. Mathar

  private int kStart(final int n, final int m) {
    return (n * (n + 1) / 2 + m - 1) / m;
  }

  private int kEnd(final int n, final int m) {
    return (3 * n + 1) * (3 * n) / (6 * m);
  }

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    final int s = 2 * mN - 1;
    final Polynomial<Z> row = a178666((s - 1) / 2);
    final int m = 2 * mN + 1;
    Z q = Z.ZERO;
    for (int k = kStart(mN, m); k <= kEnd(mN, m); ++k) {
      final int vi = m * k - (mN + 1) * mN / 2;
      if (vi >= 0 && vi <= row.degree()) {
        q = q.add(row.coeff(vi));
      }
    }
    return q;
  }
}
#!queue	A263112	0	->	1	A007570	--------------------------------
package irvine.oeis.a263;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a007.A007570;

/**
 * A263112 a(n) = F(F(n)) mod n, where F = Fibonacci = A000045.
 * @author Georg Fischer
 */
public class A263112 extends A007570 {

  protected int mN;
  
  /** Construct the sequence. */
  public A263112() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A264137	0	->	2	A000129	--------------------------------
package irvine.oeis.a264;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000129;

/**
 * A264137 Largest prime factor of the n-th Pell number, A000129(n).
 * @author Georg Fischer
 */
public class A264137 extends A000129 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A269921	0	->	2	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269921 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 1.
 * @author Sean A. Irvine
 */
public class A269921 extends A269920 {

  private int mN = 1;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, 1, mM);
  }

}
#!queue	A269922	0	->	4	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269922 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 2.
 * @author Sean A. Irvine
 */
public class A269922 extends A269920 {

  private int mN = 3;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN - 2) {
      ++mN;
      mM = 1;
    }
    return get(mN, 2, mM);
  }

}
#!queue	A269923	0	->	6	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269923 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 3.
 * @author Sean A. Irvine
 */
public class A269923 extends A269920 {

  private int mN = 5;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN - 4) {
      ++mN;
      mM = 1;
    }
    return get(mN, 3, mM);
  }

}
#!queue	A269924	0	->	8	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269924 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 4.
 * @author Sean A. Irvine
 */
public class A269924 extends A269920 {

  private int mN = 7;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN - 6) {
      ++mN;
      mM = 1;
    }
    return get(mN, 4, mM);
  }

}
#!queue	A269925	0	->	10	A269920	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;

/**
 * A269925 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 5.
 * @author Sean A. Irvine
 */
public class A269925 extends A269920 {

  private int mN = 9;
  private int mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN - 8) {
      ++mN;
      mM = 1;
    }
    return get(mN, 5, mM);
  }

}
#!queue	A271319	0	->	2	A060354	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a060.A060354;

/**
 * A271319 Number of distinct prime factors of the n-th n-gonal number (A060354).
 * @author Georg Fischer
 */
public class A271319 extends A060354 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).omega());
  }
}
#!queue	A271320	0	->	2	A060354	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a060.A060354;

/**
 * A271320 Number of prime factors, with multiplicity, of the n-th n-gonal number (A060354).
 * @author Georg Fischer
 */
public class A271320 extends A060354 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A271321	0	->	2	A060354	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a060.A060354;

/**
 * A271321 Smallest prime factor of the n-th n-gonal number (A060354).
 * @author Georg Fischer
 */
public class A271321 extends A060354 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A271322	0	->	2	A060354	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a060.A060354;

/**
 * A271322 Largest prime factor of the n-th n-gonal number (A060354).
 * @author Georg Fischer
 */
public class A271322 extends A060354 {

  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A271731	0	->	2	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271731 Number of set partitions of [n] with maximal block length multiplicity equal to two.
 * @author Georg Fischer
 */
public class A271731 extends A271423 {

  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A271732	0	->	3	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271732 Number of set partitions of [n] with maximal block length multiplicity equal to three.
 * @author Georg Fischer
 */
public class A271732 extends A271423 {

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A271733	0	->	4	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271733 Number of set partitions of [n] with maximal block length multiplicity equal to four.
 * @author Georg Fischer
 */
public class A271733 extends A271423 {

  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A271734	0	->	5	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271734 Number of set partitions of [n] with maximal block length multiplicity equal to five.
 * @author Georg Fischer
 */
public class A271734 extends A271423 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A271735	0	->	6	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271735 Number of set partitions of [n] with maximal block length multiplicity equal to six.
 * @author Georg Fischer
 */
public class A271735 extends A271423 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A271736	0	->	7	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271736 Number of set partitions of [n] with maximal block length multiplicity equal to seven.
 * @author Georg Fischer
 */
public class A271736 extends A271423 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A271737	0	->	8	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271737 Number of set partitions of [n] with maximal block length multiplicity equal to eight.
 * @author Georg Fischer
 */
public class A271737 extends A271423 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A271738	0	->	9	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271738 Number of set partitions of [n] with maximal block length multiplicity equal to nine.
 * @author Georg Fischer
 */
public class A271738 extends A271423 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A271739	0	->	10	A271423	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271739 Number of set partitions of [n] with maximal block length multiplicity equal to ten.
 * @author Georg Fischer
 */
public class A271739 extends A271423 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A271762	0	->	2	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271762 Number of set partitions of [n] with minimal block length multiplicity equal to two.
 * @author Georg Fischer
 */
public class A271762 extends A271424 {

  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A271763	0	->	3	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271763 Number of set partitions of [n] with minimal block length multiplicity equal to three.
 * @author Georg Fischer
 */
public class A271763 extends A271424 {

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A271764	0	->	4	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271764 Number of set partitions of [n] with minimal block length multiplicity equal to four.
 * @author Georg Fischer
 */
public class A271764 extends A271424 {

  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A271765	0	->	5	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271765 Number of set partitions of [n] with minimal block length multiplicity equal to five.
 * @author Georg Fischer
 */
public class A271765 extends A271424 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A271766	0	->	6	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271766 Number of set partitions of [n] with minimal block length multiplicity equal to six.
 * @author Georg Fischer
 */
public class A271766 extends A271424 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A271767	0	->	7	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271767 Number of set partitions of [n] with minimal block length multiplicity equal to seven.
 * @author Georg Fischer
 */
public class A271767 extends A271424 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A271768	0	->	8	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271768 Number of set partitions of [n] with minimal block length multiplicity equal to eight.
 * @author Georg Fischer
 */
public class A271768 extends A271424 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A271769	0	->	9	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271769 Number of set partitions of [n] with minimal block length multiplicity equal to nine.
 * @author Georg Fischer
 */
public class A271769 extends A271424 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A271770	0	->	10	A271424	--------------------------------
package irvine.oeis.a271;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A271770 Number of set partitions of [n] with minimal block length multiplicity equal to ten.
 * @author Georg Fischer
 */
public class A271770 extends A271424 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A272040	0	->	1	A000129	--------------------------------
package irvine.oeis.a272;
// manually knest/eulphi at 2023-03-01 16:41

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a000.A000129;

/**
 * A272040 a(n) = A000010(A000129(n)).
 * @author Georg Fischer
 */
public class A272040 extends A000129 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A272090	0	->	1	A045906	--------------------------------
package irvine.oeis.a272;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a045.A045906;

/**
 * A272090 Number of chiral partitions of n; number of irreducible representations of the symmetric group S_n with nontrivial determinant.
 * @author Sean A. Irvine
 */
public class A272090 extends A045906 {

  // After Michel Marcus

  private long mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ZERO;
    }
    final long e = mN & 1;
    final long m = mN / 2;
    int k1 = 1;
    long r = m;
    assert r != 0;
    while ((r & 1) == 0) {
      ++k1;
      r >>>= 1;
    }
    r >>>= 1;
    int s = 0;
    for (long j = k1 + 1; r != 0; r >>>= 1, ++j) {
      if ((r & 1) == 1) {
        s += j;
      }
    }
    Z sum = Z.ONE.shiftLeft(k1 - 1);
    if (e != 0) {
      sum = sum.add(Z.ONE.shiftLeft(Binomial.binomial(k1, 2).longValueExact()));
    }
    for (long v = 1; v < k1; ++v) {
      sum = sum.add(Z.ONE.shiftLeft((v + 1) * (k1 - 2) - Binomial.binomial(v, 2).longValueExact()));
    }
    return sum.shiftLeft(s);
  }
}
#!queue	A274303	1	->	0	A007346	--------------------------------
package irvine.oeis.a274;
// Generated by gen_seq4.pl bisect at 2021-05-28 14:26
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a007.A007346;


/**
 * A274303 A bisection of A007346.
 * @author Georg Fischer
 */
public class A274303 extends A007346 {
  
  /** Construct the sequence. */
  public A274303() {
    super.next();
  }

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A276639	0	->	1	A084546	--------------------------------
package irvine.oeis.a276;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a084.A084546;

/**
 * A276639 Triangle T(m, n) = the number of point-labeled graphs with n points and m edges, no points isolated. By rows, n &gt;= 0, ceiling(n/2) &lt;= m &lt;= binomial(n,2).
 * @author Sean A. Irvine
 */
public class A276639 extends A084546 {

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z t(final int n, final int m) {
    if (n == 1) {
      return m == 1 ? Z.ONE : Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k <= n; ++k) {
      sum = sum.signedAdd(((n - k) & 1) == 0, Binomial.binomial(n, k).multiply(super.t(k, m)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN * (mN - 1) / 2) {
      ++mN;
      mM = (mN + 1) / 2;
    }
    return t(mN, mM);
  }
}
#!queue	A276640	0	->	1	A276639	--------------------------------
package irvine.oeis.a276;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A276640 Triangle T(n, k) = the number of point-labeled graphs with n points and k edges, no points isolated, no edges isolated. By rows, 0 &lt;= n, ceiling(2*n/3) &lt;= k &lt;= binomial(n, 2).
 * @author Sean A. Irvine
 */
public class A276640 extends A276639 {

  private int mN = 1;
  private int mM = 0;

  @Override
  protected Z t(final int n, final int m) {
    if (n < 2) {
      return Z.ZERO;
    }
    if (n == 2) {
      return m == 2 ? Z.ONE : Z.ZERO;
    }
    if (n == 3) {
      if (m < 2 || m > 3) {
        return Z.ZERO;
      }
      return m == 2 ? Z.THREE : Z.ONE;
    }
    Z sum = Z.ZERO;
    final int lim = Math.min(n / 2, m);
    for (int k = 0; k <= lim; ++k) {
      sum = sum.signedAdd((k & 1) == 0,
        Binomial.binomial(n, 2L * k)
          .multiply(MemoryFactorial.SINGLETON.factorial(2 * k))
          .multiply(super.t(n - 2 * k, m - k))
          .shiftRight(k)
          .divide(MemoryFactorial.SINGLETON.factorial(k)));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN * (mN - 1) / 2) {
      ++mN;
      mM = (2 * mN + 2) / 3;
    }
    return t(mN, mM);
  }
}
#!queue	A276681	0	->	1	A000567	--------------------------------
package irvine.oeis.a276;
// Generated by gen_seq4.pl sigman0/sigma0s at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000567;

/**
 * A276681 Number of divisors of the n-th octagonal number.
 * @author Georg Fischer
 */
public class A276681 extends A000567 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A276682	0	->	1	A001106	--------------------------------
package irvine.oeis.a276;
// Generated by gen_seq4.pl sigman0/sigma0s at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001106;

/**
 * A276682 Number of divisors of the n-th 9-gonal number.
 * @author Georg Fischer
 */
public class A276682 extends A001106 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A276961	1	->	0	A080510	--------------------------------
package irvine.oeis.a276;
// manually A080510/trionk

import irvine.math.z.Z;
import irvine.oeis.a080.A080510;

/**
 * A276961 Number of set partitions of [2n] with largest set of size n.
 * @author Georg Fischer
 */
public class A276961 extends A080510 {

  private int mN = -2;

  @Override
  public Z next() {
    if (++mN == -1) {
      return Z.ONE;
    }
    return super.compute(2 * mN + 1, mN);
  }
}

#!queue	A279081	0	->	1	A000292	--------------------------------
package irvine.oeis.a279;
// Generated by gen_seq4.pl sigman0/sigma0s at 2023-02-28 16:47

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000292;

/**
 * A279081 Number of divisors of the n-th tetrahedral number.
 * @author Georg Fischer
 */
public class A279081 extends A000292 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma0();
  }
}
#!queue	A280509	0	->	1	A057889	--------------------------------
package irvine.oeis.a280;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.a057.A057889;

/**
 * A280509 a(n) = A051064(A246200(n)); 3-adic valuation of A057889(3*n).
 * @author Georg Fischer
 */
public class A280509 extends A057889 {

  /** Construct the sequence. */
  public A280509() {
    super.next();
  }

  @Override
  public Z next() {
    super.next();
    super.next();
    return Z.valueOf(ZUtils.valuation(super.next(), Z.THREE));
  }
}
#!queue	A281648	0	->	1	A000367	--------------------------------
package irvine.oeis.a281;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a000.A000367;

/**
 * A281648 (Numerator of Bernoulli(2*n)) read mod n.
 * @author Georg Fischer
 */
public class A281648 extends A000367 {

  protected int mN;
  
  /** Construct the sequence. */
  public A281648() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A281662	0	->	1	A002445	--------------------------------
package irvine.oeis.a281;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a002.A002445;

/**
 * A281662 (Denominator of Bernoulli(2*n)) read mod n.
 * @author Georg Fischer
 */
public class A281662 extends A002445 {

  protected int mN;
  
  /** Construct the sequence. */
  public A281662() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A282019	1	->	0	A006352	--------------------------------
package irvine.oeis.a282;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a004.A004009;
import irvine.oeis.a006.A006352;

/**
 * A282019 Coefficients in q-expansion of E_2*E_4, where E_2 and E_4 are the Eisenstein series shown in A006352 and A004009, respectively.
 * @author Sean A. Irvine
 */
public class A282019 extends A006352 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);

  private final Polynomial<Z> mE2 = RING.empty();
  private final Polynomial<Z> mE4 = RING.empty();
  private final Sequence mE4Seq = new A004009();
  private int mN = -1;

  @Override
  public Z next() {
    mE2.add(super.next());
    mE4.add(mE4Seq.next());
    return RING.multiply(mE2, mE4, ++mN).coeff(mN);
  }
}

#!queue	A282548	1	->	0	A013959	--------------------------------
package irvine.oeis.a282;

import irvine.math.z.Z;
import irvine.oeis.a013.A013959;

/**
 * A282548 Expansion of phi_{12, 1}(x) where phi_{r, s}(x) = Sum_{n, m&gt;0} m^r * n^s * x^{m*n}.
 * @author Sean A. Irvine
 */
public class A282548 extends A013959 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ZERO;
    }
    return super.next().multiply(mN);
  }
}
#!queue	A286567	0	->	1	A001045	--------------------------------
package irvine.oeis.a286;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a001.A001045;

/**
 * A286567 Smallest prime factor of the n-th Jacobsthal number: a(n) = A020639(A001045(n)), with a(1)=a(2)=1.
 * @author Georg Fischer
 */
public class A286567 extends A001045 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).leastPrimeFactor();
  }
}
#!queue	A286757	0	->	1	A002829	--------------------------------
package irvine.oeis.a286;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.a002.A002829;

/**
 * A286757 Number of labeled connected rooted trivalent graphs with 2n nodes.
 * @author Sean A. Irvine
 */
public class A286757 extends A002829 {

  private final ArrayList<Z> mQ = new ArrayList<>();
  private int mN = 0;
  private Z mA = Z.ZERO;
  private Z mB = Z.ZERO;

  private Z q(final int n) {
    while (n >= mQ.size()) {
      mQ.add(super.next());
    }
    if (n < 0) {
      return Z.ZERO;
    }
    return mQ.get(n);
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      final long p2 = 2L * mN;
      final Z t = mB.multiply(Binomial.binomial(p2, 2)).multiply2()
        .add(mA.multiply(Binomial.binomial(p2, 4)).multiply(12))
        .add(q(mN - 1).multiply(Binomial.binomial(p2, 3)).multiply(6))
        .add(q(mN - 2).multiply(Binomial.binomial(p2, 5)).multiply(60))
        .add(q(mN - 3).multiply(Binomial.binomial(p2, 7)).multiply(1260));
      mA = mB;
      mB = t;
    }
    return mN == 2 ? Z.FOUR : mB;
  }
}

#!queue	A287875	2	->	1	A230627	--------------------------------
package irvine.oeis.a287;

import irvine.math.z.Z;
import irvine.oeis.a230.A230627;

/**
 * A287875 Iterate the map x -&gt; A230625(x) starting at n; sequence gives the first prime (or 1) that is reached, written in base 2, or -1 if no prime is ever reached.
 * @author Sean A. Irvine
 */
public class A287875 extends A230627 {

  private boolean mFirst = true;

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return new Z(super.next().toString(2));
  }
}
#!queue	A289070	0	->	1	A289064	--------------------------------
package irvine.oeis.a289;
// manually A289064/parm3 at 2021-12-05 12:16

import irvine.math.z.Z;
import irvine.oeis.Sequence1;

/**
 * A289070 a(n) = c(2n-1), where c(n+2) = Sum_{k=0..n} binomial(n,k)c(k)c(n+1-k) with c(0)=0, c(1)=3.
 * @author Georg Fischer
 */
public class A289070 extends Sequence1 {

  private final A289064 mSeq = new A289064(0, 3, 0, 0);

  @Override
  public Z next() {
    mSeq.next();
    return mSeq.next();
  }
}
#!queue	A290139	0	->	1	A225984	--------------------------------
package irvine.oeis.a290;
// Generated by gen_seq4.pl seqop a225 A225984 mod(Z.valueOf(mN)) 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a225.A225984;

/**
 * A290139 a(n) = A225984(n) mod n.
 * @author Georg Fischer
 */
public class A290139 extends A225984 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A290139() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A290258	0	->	2	A277335	--------------------------------
package irvine.oeis.a290;
// manually deris2/essent at 2021-11-04

import irvine.oeis.a277.A277335;

/**
 * A290258 Triangle read by rows: row n (&gt;=2) contains in increasing order the integers for which the binary representation has length n and all runs of 1's have even length.
 * Basically the same as A277335.
 * @author Georg Fischer
 */
public class A290258 extends A277335 {

  /** Construct the sequence. */
  public A290258() {
    skip(1);
  }
}
#!queue	A291804	0	->	1	A291789	--------------------------------
package irvine.oeis.a291;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A291804 a(n) = sigma(A291789(n)).
 * @author Sean A. Irvine
 */
public class A291804 extends A291789 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A291805	0	->	1	A291789	--------------------------------
package irvine.oeis.a291;

import irvine.math.z.Euler;
import irvine.math.z.Z;

/**
 * A291805 a(n) = phi(A291789(n)).
 * @author Sean A. Irvine
 */
public class A291805 extends A291789 {

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A292118	1	->	0	A003159	--------------------------------
package irvine.oeis.a292;

import irvine.math.z.Z;
import irvine.oeis.a003.A003159;

/**
 * A292118 G.f.: 1 + 2*Sum_{k &gt;= 1} (-1)^k*q^A003159(k).
 * @author Sean A. Irvine
 */
public class A292118 extends A003159 {

  private long mA = super.next().longValueExact();
  private long mM = -1;
  private boolean mSign = true;

  @Override
  public Z next() {
    if (++mM == 0) {
      return Z.ONE;
    } else if (mM != mA) {
      return Z.ZERO;
    } else {
      mSign = !mSign;
      mA = super.next().longValueExact();
      return Z.valueOf(mSign ? 2 : -2);
    }
  }
}
#!queue	A292603	1	->	0	A005940	--------------------------------
package irvine.oeis.a292;
// Generated by gen_seq4.pl moderiv at 2020-07-25 14:53
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a005.A005940;


/**
 * A292603 Doudna-tree reduced modulo 4: a(n) = A005940(1+n) mod 4.
 * @author Georg Fischer
 */
public class A292603 extends A005940 {

  /** Construct the sequence. */
  public A292603() {
    super();
  }

  @Override
  public Z next() {
    return super.next().mod(Z.FOUR);
  }
}
#!queue	A294614	0	->	1	A017653	--------------------------------
package irvine.oeis.a294;
// manually sigman1/sigma1 at 2023-02-28 22:58

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a017.A017653;

/**
 * A294614 Sum of the divisors of 12*n - 1, divided by 12, minus n.
 * @author Georg Fischer
 */
public class A294614 extends A017653 {

  private int mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma().divide(12).subtract(++mN);
  }
}
#!queue	A294724	0	->	1	A003168	--------------------------------
package irvine.oeis.a294;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a003.A003168;
import irvine.oeis.a003.A003169;

/**
 * A294724 Number of Q graphs with 2*n vertices rooted at an internal edge.
 * @author Sean A. Irvine
 */
public class A294724 extends A003168 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final A003169 mSeqP = new A003169();
  private Polynomial<Z> mP = RING.zero();
  private Polynomial<Z> mB = Polynomial.create(0, -1);
  private int mN = 0;


  @Override
  public Z next() {
    mN += 2;
    mB = RING.add(mB, RING.monomial(super.next(), mN - 1));
    mP = RING.add(mP, RING.monomial(mSeqP.next(), mN));
    return RING.multiply(RING.pow(mB, 2, mN), mP, mN).coeff(mN);
  }
}
#!queue	A294728	0	->	1	A003168	--------------------------------
package irvine.oeis.a294;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.a003.A003168;
import irvine.oeis.a007.A007165;

/**
 * A294728 Number of Q graphs with 2*n vertices symmetrical about a distinguished edge.
 * @author Sean A. Irvine
 */
public class A294728 extends A003168 {

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final A007165 mSeqH = new A007165();
  private Polynomial<Z> mH = RING.zero();
  private Polynomial<Z> mB = Polynomial.create(0, -1);
  private int mN = 0;


  @Override
  public Z next() {
    mN += 2;
    mB = RING.add(mB, RING.monomial(super.next(), mN - 1));
    mH = RING.add(mH, RING.monomial(mSeqH.next(), mN));
    return RING.multiply(mB.substitutePower(2, mN), mH, mN).coeff(mN);
  }
}
#!queue	A295503	0	->	1	A002283	--------------------------------
package irvine.oeis.a295;
// manually knest/eulphi at 2023-03-01 16:41

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.a002.A002283;

/**
 * A295503 a(n) = phi(10^n-1), where phi is Euler's totient function (A000010).
 * @author Georg Fischer
 */
public class A295503 extends A002283 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Euler.phi(super.next());
  }
}
#!queue	A296171	0	->	1	A296170	--------------------------------
package irvine.oeis.a296;

import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;

/**
 * A296171 O.g.f. A(x) satisfies: [x^n] exp( n^2 * A(x) )  =   [x^(n-1)] exp( n^2 * A(x) ) for n&gt;=1.
 * @author Sean A. Irvine
 */
public class A296171 extends A296170 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    stepEgf();
    mA.set(0, Q.ZERO); // so that log1p works
    final Polynomial<Q> log = RING.log1p(RING.create(mA), mN);
    mA.set(0, Q.ONE);
    final Q coeff = log.coeff(mN);
    if (!coeff.isInteger()) {
      throw new UnsupportedOperationException("Sequence is not an integer at n=" + mN);
    }
    return coeff.toZ();
  }

  /**
   * Direct computation to specified number of terms.
   * @param args number of terms
   */
  public static void main(final String[] args) {
    final A296171 seq = new A296171();
    final int limit = Integer.parseInt(args[0]);
    for (int k = 0; k < limit; ++k) {
      System.out.println(String.valueOf(k));
      seq.stepEgf();
    }
    seq.mA.set(0, Q.ZERO);
    System.out.println(RING.log1p(RING.create(seq.mA), limit));
  }
}
#!queue	A300003	4	->	0	A007975	--------------------------------
package irvine.oeis.a300;

import irvine.math.z.Z;
import irvine.oeis.a007.A007975;

/**
 * A300003 Triangle read by rows: T(n, k) = number of permutations that are k "block reversals" away from 12...n, for n &gt;= 0, and (for n&gt;0) 0 &lt;= k &lt;= n-1.
 * @author Sean A. Irvine
 */
public class A300003 extends A007975 {

  private int mM = 0;

  @Override
  protected int start() {
    return -1;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      // Start the next row
      init();
      mM = 0;
    } else {
      step();
    }
    return Z.valueOf(mPrev.size());
  }
}
#!queue	A307935	0	->	1	A007060	--------------------------------
package irvine.oeis.a307;
// Generated by gen_seq4.pl seqop a007 A007060 divide2() 0 at 2020-01-25 22:40
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a007.A007060;

/**
 * A307935 Number of (undirected) Hamiltonian paths in the n-cocktail party graph.
 * @author Georg Fischer
 */
public class A307935 extends A007060 {
  private int mN = 0;
  
  /** Construct the sequence. */
  public A307935() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().divide2();
  }
}
#!queue	A316075	1	->	0	A316074	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A316075 Sequence shifts left three places under Weigh transform with a(n) = signum(n) for n&lt;3.
 * @author Georg Fischer
 */
public class A316075 extends A316074 {

  private int mN = -1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A316076	1	->	0	A316074	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A316076 Sequence shifts left four places under Weigh transform with a(n) = signum(n) for n&lt;4.
 * @author Georg Fischer
 */
public class A316076 extends A316074 {

  private int mN = -1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A316077	1	->	0	A316074	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A316077 Sequence shifts left five places under Weigh transform with a(n) = signum(n) for n&lt;5.
 * @author Georg Fischer
 */
public class A316077 extends A316074 {

  private int mN = -1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A316078	1	->	0	A316074	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A316078 Sequence shifts left six places under Weigh transform with a(n) = signum(n) for n&lt;6.
 * @author Georg Fischer
 */
public class A316078 extends A316074 {

  private int mN = -1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A316079	1	->	0	A316074	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A316079 Sequence shifts left seven places under Weigh transform with a(n) = signum(n) for n&lt;7.
 * @author Georg Fischer
 */
public class A316079 extends A316074 {

  private int mN = -1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A316080	1	->	0	A316074	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A316080 Sequence shifts left eight places under Weigh transform with a(n) = signum(n) for n&lt;8.
 * @author Georg Fischer
 */
public class A316080 extends A316074 {

  private int mN = -1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A316081	1	->	0	A316074	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A316081 Sequence shifts left nine places under Weigh transform with a(n) = signum(n) for n&lt;9.
 * @author Georg Fischer
 */
public class A316081 extends A316074 {

  private int mN = -1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A316082	1	->	0	A316074	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A316082 Sequence shifts left ten places under Weigh transform with a(n) = signum(n) for n&lt;10.
 * @author Georg Fischer
 */
public class A316082 extends A316074 {

  private int mN = -1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A316390	0	->	3	A258829	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a258.A258829;

/**
 * A316390 Number of permutations p of [n] such that the up-down signature of 0,p has nonnegative partial sums with a maximal value of three.
 * @author Georg Fischer
 */
public class A316390 extends A258829 {

  private int mN = 2;

  @Override
  public Z next() {
    return super.compute(++mN, 3);
  }
}

#!queue	A316391	0	->	4	A258829	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a258.A258829;

/**
 * A316391 Number of permutations p of [n] such that the up-down signature of 0,p has nonnegative partial sums with a maximal value of four.
 * @author Georg Fischer
 */
public class A316391 extends A258829 {

  private int mN = 3;

  @Override
  public Z next() {
    return super.compute(++mN, 4);
  }
}

#!queue	A316392	0	->	5	A258829	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a258.A258829;

/**
 * A316392 Number of permutations p of [n] such that the up-down signature of 0,p has nonnegative partial sums with a maximal value of five.
 * @author Georg Fischer
 */
public class A316392 extends A258829 {

  private int mN = 4;

  @Override
  public Z next() {
    return super.compute(++mN, 5);
  }
}

#!queue	A316393	0	->	6	A258829	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a258.A258829;

/**
 * A316393 Number of permutations p of [n] such that the up-down signature of 0,p has nonnegative partial sums with a maximal value of six.
 * @author Georg Fischer
 */
public class A316393 extends A258829 {

  private int mN = 5;

  @Override
  public Z next() {
    return super.compute(++mN, 6);
  }
}

#!queue	A316394	0	->	7	A258829	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a258.A258829;

/**
 * A316394 Number of permutations p of [n] such that the up-down signature of 0,p has nonnegative partial sums with a maximal value of seven.
 * @author Georg Fischer
 */
public class A316394 extends A258829 {

  private int mN = 6;

  @Override
  public Z next() {
    return super.compute(++mN, 7);
  }
}

#!queue	A316395	0	->	8	A258829	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a258.A258829;

/**
 * A316395 Number of permutations p of [n] such that the up-down signature of 0,p has nonnegative partial sums with a maximal value of eight.
 * @author Georg Fischer
 */
public class A316395 extends A258829 {

  private int mN = 7;

  @Override
  public Z next() {
    return super.compute(++mN, 8);
  }
}

#!queue	A316396	0	->	9	A258829	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a258.A258829;

/**
 * A316396 Number of permutations p of [n] such that the up-down signature of 0,p has nonnegative partial sums with a maximal value of nine.
 * @author Georg Fischer
 */
public class A316396 extends A258829 {

  private int mN = 8;

  @Override
  public Z next() {
    return super.compute(++mN, 9);
  }
}

#!queue	A316397	0	->	10	A258829	--------------------------------
package irvine.oeis.a316;
// Generated by gen_seq4.pl tricol

import irvine.math.z.Z;
import irvine.oeis.a258.A258829;

/**
 * A316397 Number of permutations p of [n] such that the up-down signature of 0,p has nonnegative partial sums with a maximal value of ten.
 * @author Georg Fischer
 */
public class A316397 extends A258829 {

  private int mN = 9;

  @Override
  public Z next() {
    return super.compute(++mN, 10);
  }
}

#!queue	A317184	0	->	1	A018193	--------------------------------
package irvine.oeis.a317;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a018.A018193;

/**
 * A317184 Number of "non-connected" chord diagrams of degree n.
 * @author Sean A. Irvine
 */
public class A317184 extends A018193 {

  // After Alexander Stoimenow

  @Override
  protected Z psiTildeBar(final int d) {
    if (d == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k <= d; ++k) {
      sum = sum.signedAdd((k & 1) == 0,
        RING.multiply(
          RING.pow(RING.subtract(psiTildeBarSeries(d - 1), RING.one()), k, d),
          RING.subtract(lambda2Series(k + 1, d), k == 1 ? RING.one() : RING.zero()), d).coeff(d));
    }
    return sum;
  }

  private Polynomial<Z> mPsiTildeBarSeriesCache = null;
  private int mPsiTildeBarSeriesCacheIndex = -1;

  private Polynomial<Z> psiTildeBarSeries(final int n) {
    if (n < 0) {
      return RING.zero();
    }
    if (n > mPsiTildeBarSeriesCacheIndex) {
      final Z[] t = new Z[n + 1];
      for (int k = 0; k <= n; ++k) {
        t[k] = psiTildeBar(k);
      }
      mPsiTildeBarSeriesCache = Polynomial.create(t);
      mPsiTildeBarSeriesCacheIndex = n;
    }
    return mPsiTildeBarSeriesCache;
  }

  @Override
  protected Z xi(final int c, final int d, final int k) {
    if (k > d || k < 0) {
      return Z.ZERO;
    }
    return RING.multiply(RING.pow(RING.subtract(psiTildeBarSeries(d).substitutePower(2, d), RING.one()), k, d),
      lambdaStarSeries(c, k + 1, d), d).coeff(d);
  }

  private Polynomial<Z> xiSeries(final int c, final int k, final int n) {
    final Z[] t = new Z[n + 1];
    for (int d = 0; d <= n; ++d) {
      t[d] = xi(c, d, k);
    }
    return Polynomial.create(t);
  }

  @Override
  protected Z xiBar(final int c, final int d, final int k) {
    final Polynomial<Z> psi2 = psiTildeBarSeries(d).substitutePower(2, d);
    final Polynomial<Z> deriv = RING.diff(psi2.shift(1));
    final Polynomial<Z> a = RING.add(RING.subtract(deriv, RING.multiply(psi2, Z.TWO)), RING.one());
    return RING.multiply(a, xiSeries(c, k - 1, d), d).coeff(d);
  }

  @Override
  protected Z eta(final int c, final int d) {
    Z sum = Z.ZERO;
    for (int k = 1; k <= d; ++k) {
      sum = sum.signedAdd((k & 1) == 1, zeta(c, d, k));
    }
    return sum;
  }

  @Override
  protected Z gammaTilde(final int d, final int c) {
    if (c == 1) {
      return (d & 1) == 0 ? psiTilde(d / 2) : Z.ZERO;
    }
    return eta(c, d);
  }
}

#!queue	A318817	1	->	2	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318817 Number of rooted trees with n nodes such that two equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318817 extends A318754 {

  private int mN = 1 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 1);
  }
}

#!queue	A318818	1	->	3	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318818 Number of rooted trees with n nodes such that three equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318818 extends A318754 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A318819	1	->	4	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318819 Number of rooted trees with n nodes such that four equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318819 extends A318754 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A318820	1	->	5	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318820 Number of rooted trees with n nodes such that five equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318820 extends A318754 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A318821	1	->	6	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318821 Number of rooted trees with n nodes such that six equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318821 extends A318754 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A318822	1	->	7	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318822 Number of rooted trees with n nodes such that seven equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318822 extends A318754 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A318823	1	->	8	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318823 Number of rooted trees with n nodes such that eight equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318823 extends A318754 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A318824	1	->	9	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318824 Number of rooted trees with n nodes such that nine equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318824 extends A318754 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A318825	1	->	10	A318754	--------------------------------
package irvine.oeis.a318;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A318825 Number of rooted trees with n nodes such that ten equals the maximal number of subtrees of the same size extending from the same node.
 * @author Georg Fischer
 */
public class A318825 extends A318754 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A319814	0	->	4	A319797	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319814 Number of partitions of n into exactly four positive triangular numbers.
 * @author Georg Fischer
 */
public class A319814 extends A319797 {

  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A319815	0	->	5	A319797	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319815 Number of partitions of n into exactly five positive triangular numbers.
 * @author Georg Fischer
 */
public class A319815 extends A319797 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A319816	0	->	6	A319797	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319816 Number of partitions of n into exactly six positive triangular numbers.
 * @author Georg Fischer
 */
public class A319816 extends A319797 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A319817	0	->	7	A319797	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319817 Number of partitions of n into exactly seven positive triangular numbers.
 * @author Georg Fischer
 */
public class A319817 extends A319797 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A319818	0	->	8	A319797	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319818 Number of partitions of n into exactly eight positive triangular numbers.
 * @author Georg Fischer
 */
public class A319818 extends A319797 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A319819	0	->	9	A319797	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319819 Number of partitions of n into exactly nine positive triangular numbers.
 * @author Georg Fischer
 */
public class A319819 extends A319797 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A319820	0	->	10	A319797	--------------------------------
package irvine.oeis.a319;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;

/**
 * A319820 Number of partitions of n into exactly ten positive triangular numbers.
 * @author Georg Fischer
 */
public class A319820 extends A319797 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A320203	0	->	2	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320203 Number of sets of nonempty words with a total of n letters over binary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320203 extends A319501 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A320204	0	->	3	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320204 Number of sets of nonempty words with a total of n letters over ternary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320204 extends A319501 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A320205	0	->	4	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320205 Number of sets of nonempty words with a total of n letters over quaternary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320205 extends A319501 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A320206	0	->	5	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320206 Number of sets of nonempty words with a total of n letters over quinary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320206 extends A319501 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A320207	0	->	6	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320207 Number of sets of nonempty words with a total of n letters over senary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320207 extends A319501 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A320208	0	->	7	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320208 Number of sets of nonempty words with a total of n letters over septenary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320208 extends A319501 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A320209	0	->	8	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320209 Number of sets of nonempty words with a total of n letters over octonary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320209 extends A319501 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A320210	0	->	9	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320210 Number of sets of nonempty words with a total of n letters over nonary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320210 extends A319501 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A320211	0	->	10	A319501	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a319.A319501;

/**
 * A320211 Number of sets of nonempty words with a total of n letters over denary alphabet such that all letters occur at least once in the set.
 * @author Georg Fischer
 */
public class A320211 extends A319501 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A320859	0	->	1	A067480	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067480;

/**
 * A320859 Powers of 2 with initial digit 3.
 * @author Georg Fischer
 */
public class A320859 extends A067480 {

  /** Construct the sequence. */
  public A320859() {
    super(1, 3);
  }
}
#!queue	A320860	0	->	1	A067480	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067480;

/**
 * A320860 Powers of 2 with initial digit 4.
 * @author Georg Fischer
 */
public class A320860 extends A067480 {

  /** Construct the sequence. */
  public A320860() {
    super(1, 4);
  }
}
#!queue	A320861	0	->	1	A067480	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067480;

/**
 * A320861 Powers of 2 with initial digit 5.
 * @author Georg Fischer
 */
public class A320861 extends A067480 {

  /** Construct the sequence. */
  public A320861() {
    super(1, 5);
  }
}
#!queue	A320862	0	->	1	A067480	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067480;

/**
 * A320862 Powers of 2 with initial digit 6.
 * @author Georg Fischer
 */
public class A320862 extends A067480 {

  /** Construct the sequence. */
  public A320862() {
    super(1, 6);
  }
}
#!queue	A320863	0	->	1	A067480	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067480;

/**
 * A320863 Powers of 2 with initial digit 7.
 * @author Georg Fischer
 */
public class A320863 extends A067480 {

  /** Construct the sequence. */
  public A320863() {
    super(7);
  }
}
#!queue	A320864	0	->	1	A067480	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067480;

/**
 * A320864 Powers of 2 with initial digit 8.
 * @author Georg Fischer
 */
public class A320864 extends A067480 {

  /** Construct the sequence. */
  public A320864() {
    super(1, 8);
  }
}
#!queue	A320865	0	->	1	A067480	--------------------------------
package irvine.oeis.a320;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067480;

/**
 * A320865 Powers of 2 with initial digit 9.
 * @author Georg Fischer
 */
public class A320865 extends A067480 {

  /** Construct the sequence. */
  public A320865() {
    super(1, 9);
  }
}
#!queue	A323119	1	->	2	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323119 Number of compositions of n where the difference between largest and smallest parts equals two.
 * @author Georg Fischer
 */
public class A323119 extends A214258 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A323120	1	->	3	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323120 Number of compositions of n where the difference between largest and smallest parts equals three.
 * @author Georg Fischer
 */
public class A323120 extends A214258 {

  private int mN = 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A323121	1	->	4	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323121 Number of compositions of n where the difference between largest and smallest parts equals four.
 * @author Georg Fischer
 */
public class A323121 extends A214258 {

  private int mN = 2;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A323122	1	->	5	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323122 Number of compositions of n where the difference between largest and smallest parts equals five.
 * @author Georg Fischer
 */
public class A323122 extends A214258 {

  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A323123	1	->	6	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323123 Number of compositions of n where the difference between largest and smallest parts equals six.
 * @author Georg Fischer
 */
public class A323123 extends A214258 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A323124	1	->	7	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323124 Number of compositions of n where the difference between largest and smallest parts equals seven.
 * @author Georg Fischer
 */
public class A323124 extends A214258 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A323125	1	->	8	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323125 Number of compositions of n where the difference between largest and smallest parts equals eight.
 * @author Georg Fischer
 */
public class A323125 extends A214258 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A323126	1	->	9	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323126 Number of compositions of n where the difference between largest and smallest parts equals nine.
 * @author Georg Fischer
 */
public class A323126 extends A214258 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A323127	1	->	10	A214258	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a214.A214258;

/**
 * A323127 Number of compositions of n where the difference between largest and smallest parts equals ten.
 * @author Georg Fischer
 */
public class A323127 extends A214258 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A323616	0	->	1	A053287	--------------------------------
package irvine.oeis.a323;
// Generated by gen_seq4.pl knest/jaguar at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a053.A053287;

/**
 * A323616 a(n) is the largest prime factor of phi(2^n-1), where phi is Euler's totient.
 * @author Georg Fischer
 */
public class A323616 extends A053287 {
  @Override
  public Z next() {
    return Jaguar.factor(super.next()).largestPrimeFactor();
  }
}
#!queue	A324054	1	->	0	A005940	--------------------------------
package irvine.oeis.a324;
// Generated by gen_seq4.pl sigman1/sigma1 at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a005.A005940;

/**
 * A324054 a(n) = A000203(A005940(1+n)).
 * @author Georg Fischer
 */
public class A324054 extends A005940 {

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A325334	1	->	0	A007862	--------------------------------
package irvine.oeis.a325;
// Generated by gen_seq4.pl dersimple at 2021-08-25 19:44

import irvine.math.z.Z;
import irvine.oeis.a007.A007862;

/**
 * A325334 Number of integer partitions of n with adjusted frequency depth 3 whose parts cover an initial interval of positive integers.
 * @author Georg Fischer
 */
public class A325334 extends A007862 {

  private int mN = 0;
  
  @Override
  public Z next() {
    ++mN;
    return mN <= 1 ? Z.ZERO : super.next().subtract(1);
  }
}
#!queue	A327380	0	->	2	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327380 Number of colored integer partitions of n such that two colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327380 extends A308680 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A327381	0	->	3	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327381 Number of colored integer partitions of n such that three colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327381 extends A308680 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A327382	0	->	4	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327382 Number of colored integer partitions of n such that four colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327382 extends A308680 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A327383	0	->	5	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327383 Number of colored integer partitions of n such that five colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327383 extends A308680 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A327384	0	->	6	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327384 Number of colored integer partitions of n such that six colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327384 extends A308680 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A327385	0	->	7	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327385 Number of colored integer partitions of n such that seven colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327385 extends A308680 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A327386	0	->	8	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327386 Number of colored integer partitions of n such that eight colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327386 extends A308680 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A327387	0	->	9	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327387 Number of colored integer partitions of n such that nine colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327387 extends A308680 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A327388	0	->	10	A308680	--------------------------------
package irvine.oeis.a327;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a308.A308680;

/**
 * A327388 Number of colored integer partitions of n such that ten colors are used and parts differ by size or by color.
 * @author Georg Fischer
 */
public class A327388 extends A308680 {

  private int mN = 10 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A327737	2	->	1	A043000	--------------------------------
package irvine.oeis.a327;
// manually dersimpln at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a043.A043000;

/**
 * A327737 a(n) is the sum of the lengths of the base-b expansions of n for all b with 1 &lt;= b &lt;= n.
 * @author Georg Fischer
 */
public class A327737 extends A043000 {

  protected int mN;
  
  /** Construct the sequence. */
  public A327737() {
    mN = 0;
  }

  @Override
  public Z next() {
    ++mN;
    return mN == 1 ? Z.ONE : super.next().add(mN);
  }
}
#!queue	A329488	0	->	1	A001350	--------------------------------
package irvine.oeis.a329;
// manually divmul at 2021-08-20 23:36

import irvine.math.z.Z;
import irvine.oeis.a001.A001350;

/**
 * A329488 a(n) = A001350(n)^4.
 * @author Georg Fischer
 */
public class A329488 extends A001350 {

  /** Construct the sequence. */
  public A329488() {
    super.next();
  }

  @Override
  public Z next() {
    return super.next().pow(4);
  }
}
#!queue	A330243	0	->	1	A067497	--------------------------------
package irvine.oeis.a330;
// Generated by gen_seq4.pl A067480/parm2 at 2022-03-15 21:27

import irvine.oeis.a067.A067497;

/**
 * A330243 Numbers k such that the first digit of the decimal expansion of 2^k is 7.
 * @author Georg Fischer
 */
public class A330243 extends A067497 {

  /** Construct the sequence. */
  public A330243() {
    super(7);
  }
}
#!queue	A331729	1	->	0	A002858	--------------------------------
package irvine.oeis.a331;

import irvine.math.z.Z;
import irvine.oeis.a002.A002858;

/**
 * A331729 Number of Ulam numbers u (A002858) between powers of 2, 2^n &lt; u &lt;= 2^(n+1).
 * @author Sean A. Irvine
 */
public class A331729 extends A002858 {

  private Z mLim = Z.ONE;
  {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    mLim = mLim.shiftLeft(1);
    long cnt = 1; // start at 1 from value in previous iteration
    while (super.next().compareTo(mLim) <= 0) {
      ++cnt;
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A331759	1	->	0	A115004	--------------------------------
package irvine.oeis.a331;
// Generated by gen_seq4.pl n2 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a115.A115004;

/**
 * A331759 a(n) = A115004(2n+1).
 * @author Georg Fischer
 */
public class A331759 extends A115004 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A333361	1	->	0	A052107	--------------------------------
package irvine.oeis.a333;

import irvine.math.IntegerUtils;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a052.A052107;

/**
 * A333361 Array read by antidiagonals: T(n,k) is the number of directed loopless multigraphs with n arcs and k vertices.
 * @author Sean A. Irvine
 */
public class A333361 extends A052107 {

  // After Andrew Howroyd

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private int mM = 0;

  protected Polynomial<Z> edgesPoly(final int[] v, final int degree) {
    Polynomial<Z> prod = RING.one();
    for (int i = 1; i < v.length; ++i) {
      for (int j = 0; j < i; ++j) {
        final int g = IntegerUtils.gcd(v[i], v[j]);
        final int u = v[i] * v[j] / g;
        prod = RING.multiply(prod, RING.pow(RING.oneMinusXToTheN(u), 2 * g, degree), degree);
      }
    }
    for (final int j : v) {
      prod = RING.multiply(prod, RING.pow(RING.oneMinusXToTheN(j), j - 1, degree), degree);
    }
    return prod;
  }

  protected Polynomial<Z> g(final int n, final int degree) {
    if (n <= 0) {
      return RING.one();
    }
    Polynomial<Z> s = RING.zero();
    final IntegerPartition part = new IntegerPartition(n);
    int[] p;
    while ((p = part.next()) != null) {
      s = RING.add(s, RING.multiply(RING.series(RING.one(), edgesPoly(p, degree), degree), IntegerPartition.permCount(p, 1)));
    }
    return RING.divide(s, mF.factorial(n));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return g(mN - mM, mM).coeff(mM);
  }
}
#!queue	A333415	0	->	1	A145341	--------------------------------
package irvine.oeis.a333;
// Generated by gen_seq4.pl knest at 2023-03-02 20:46

import irvine.math.z.Z;
import irvine.oeis.a145.A145341;

/**
 * A333415 Odd positive integers in base 2 read backwards.
 * @author Georg Fischer
 */
public class A333415 extends A145341 {
  @Override
  public Z next() {
    return new Z(super.next().toString(2));
  }
}
#!queue	A333681	1	->	0	A000519	--------------------------------
package irvine.oeis.a333;
// manually dersimple at 2021-08-25 21:26

import irvine.math.z.Z;
import irvine.oeis.a000.A000519;

/**
 * A333681 Number of non-isomorphic n X n binary matrices with all row and column sums equal up to permutation of rows and columns.
 * @author Georg Fischer
 */
public class A333681 extends A000519 {

  private int mN = 0;
  
  @Override
  public Z next() {
    ++mN;
    return mN <= 1 ? Z.ONE : super.next().add(1);
  }
}
#!queue	A334582	1	->	0	A119682	--------------------------------
package irvine.oeis.a334;
// Generated by gen_seq4.pl A119682/parm3 at 2022-04-29 22:31

import irvine.oeis.a119.A119682;

/**
 * A334582 Denominator of Sum_{k=1..n} (-1)^(k+1)/k^3.
 * @author Georg Fischer
 */
public class A334582 extends A119682 {

  /** Construct the sequence. */
  public A334582() {
    super(false, 3);
  }
}
#!queue	A336759	0	->	1	A010785	--------------------------------
package irvine.oeis.a336;

import java.util.Map;
import java.util.TreeMap;

import irvine.math.z.Z;
import irvine.oeis.a010.A010785;

/**
 * A336759 a(n) is the smallest positive number that is the sum of no fewer than n distinct repdigits.
 * @author Sean A. Irvine
 */
public class A336759 extends A010785 {

  private final TreeMap<Z, Integer> mMap = new TreeMap<>();
  {
    super.next();
  }
  private Z mNextRepDigit = super.next();
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    while (true) {
      for (final Map.Entry<Z, Integer> e : mMap.entrySet()) {
        if (e.getKey().compareTo(mNextRepDigit) >= 0) {
          break; // We need to process another repdigit
        } else if (e.getValue() >= mN) {
          return e.getKey();
        }
      }
      // Process the next repdigit updating the minimal numbers
      final TreeMap<Z, Integer> revised = new TreeMap<>();
      for (final Map.Entry<Z, Integer> e : mMap.entrySet()) {
        final Z s = e.getKey().add(mNextRepDigit);
        final int cnt = e.getValue() + 1;
        final Integer prev = mMap.get(s);
        if (prev == null || cnt < prev) {
          revised.put(s, cnt);
        }
      }
      revised.put(mNextRepDigit, 1);
      mMap.putAll(revised);
      mNextRepDigit = super.next();
    }
  }
}
#!queue	A337171	0	->	1	A004186	--------------------------------
package irvine.oeis.a337;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a004.A004186;

/**
 * A337171 a(n) = A004186(n) mod n.
 * @author Georg Fischer
 */
public class A337171 extends A004186 {

  protected int mN;
  
  /** Construct the sequence. */
  public A337171() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A337884	1	->	2	A003190	--------------------------------
package irvine.oeis.a337;

import irvine.math.polynomial.PalmerSymPowerCycleIndex;
import irvine.math.z.Z;
import irvine.oeis.a003.A003190;

/**
 * A337884 Array read by descending antidiagonals: T(n,k) is the number of unoriented colorings of the triangular faces of a regular n-dimensional simplex using k or fewer colors.
 * @author Sean A. Irvine
 */
public class A337884 extends A003190 {

  private int mN = 3;
  private int mM = 2;

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 3;
    }
    return new PalmerSymPowerCycleIndex().cycleIndex(3, mM).eval(mN - mM).toZ();
  }
}
#!queue	A338736	0	->	1	A005371	--------------------------------
package irvine.oeis.a338;
// Generated by gen_seq4.pl dersimpln at 2021-08-25 22:45

import irvine.math.z.Z;
import irvine.oeis.a005.A005371;

/**
 * A338736 a(n) = L(L(n)) mod n, where L = Lucas numbers = A000032.
 * @author Georg Fischer
 */
public class A338736 extends A005371 {

  protected int mN;
  
  /** Construct the sequence. */
  public A338736() {
    mN = 0;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A339063	1	->	0	A052107	--------------------------------
package irvine.oeis.a339;

import java.util.Arrays;

import irvine.math.IntegerUtils;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.a052.A052107;

/**
 * A339063 Number of unlabeled simple graphs with n edges rooted at two noninterchangeable vertices.
 * @author Sean A. Irvine
 */
public class A339063 extends A052107 {

  // After Andrew Howroyd

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final int[] PREFIX = {1, 1};
  private int mM = -1;

  private Polynomial<Z> edgesPoly(final int[] v, final int degreeLimit) {
    Polynomial<Z> prod = RING.one();
    for (int i = 1; i < v.length; ++i) {
      for (int j = 0; j < i; ++j) {
        final int g = IntegerUtils.gcd(v[i], v[j]);
        final Polynomial<Z> t = RING.pow(RING.onePlusXToTheN(v[i] * v[j] / g), g, degreeLimit);
        prod = RING.multiply(prod, t);
      }
    }
    for (final int c : v) {
      Polynomial<Z> t = RING.pow(RING.onePlusXToTheN(c), (c - 1) / 2, degreeLimit);
      if ((c & 1) == 0) {
        t = RING.multiply(t, RING.onePlusXToTheN(c / 2), degreeLimit);
      }
      prod = RING.multiply(prod, t, degreeLimit);
    }
    return prod;
  }

  private Polynomial<Z> g(final int n, final int[] prefix, final int degreeLimit) {
    Polynomial<Z> sum = RING.zero();
    final IntegerPartition part = new IntegerPartition(n);
    int[] p;
    while ((p = part.next()) != null) {
      final int[] q = Arrays.copyOf(prefix, p.length + prefix.length);
      System.arraycopy(p, 0, q, prefix.length, p.length);
      final Polynomial<Z> t = RING.multiply(edgesPoly(q, degreeLimit), IntegerPartition.permCount(p, 1));
      sum = RING.add(sum, t);
    }
    return RING.divide(sum, mF.factorial(n));
  }

  protected int[] getPrefix() {
    return PREFIX;
  }

  @Override
  public Z next() {
    if (++mM == 0) {
      return Z.ONE;
    }
    final Polynomial<Z> sum = g(2 * mM, getPrefix(), mM);
    return sum.coeff(mM);
  }
}
#!queue	A339812	0	->	1	A339809	--------------------------------
package irvine.oeis.a339;
// Generated by gen_seq4.pl knest/jaguarz at 2023-03-01 20:54

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;

/**
 * A339812 Number of prime divisors of (A019565(n) - 1), counted with multiplicity.
 * @author Georg Fischer
 */
public class A339812 extends A339809 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(Jaguar.factor(super.next()).bigOmega());
  }
}
#!queue	A339813	0	->	1	A339809	--------------------------------
package irvine.oeis.a339;
// manually valuation/valuat at 2022-03-16 13:50

import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A339813 The exponent of the highest power of 2 dividing (A019565(n) - 1).
 * @author Georg Fischer
 */
public class A339813 extends A339809 {

  /** Construct the sequence. */
  public A339813() {
    super.next();
  }

  @Override
  public Z next() {
    return Z.valueOf(ZUtils.valuation(super.next(), Z.TWO));
  }
}
#!queue	A339814	0	->	1	A339809	--------------------------------
package irvine.oeis.a339;
// manually valuation/valuat at 2022-03-16 13:50

import irvine.math.z.Z;
import irvine.math.z.ZUtils;

/**
 * A339814 The exponent of the highest power of 2 dividing (A019565(2n) - 1).
 * @author Georg Fischer
 */
public class A339814 extends A339809 {

  /** Construct the sequence. */
  public A339814() {
    super.next();
    super.next();
  }

  @Override
  public Z next() {
    final Z result = Z.valueOf(ZUtils.valuation(super.next(), Z.TWO));
    super.next();
    return result;
  }
}
#!queue	A340101	1	->	0	A001055	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl n2 at 2022-04-08 22:12

import irvine.math.z.Z;
import irvine.oeis.a001.A001055;

/**
 * A340101 Number of factorizations of 2n + 1 into odd factors &gt; 1.
 * @author Georg Fischer
 */
public class A340101 extends A001055 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A340481	0	->	5	A337165	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a337.A337165;

/**
 * A340481 Number of ways to write n as an ordered sum of 5 squares of positive integers.
 * @author Georg Fischer
 */
public class A340481 extends A337165 {

  private int mN = 4;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A340592	1	->	2	A037276	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl dersimpln at 2021-08-21 22:23

import irvine.math.z.Z;
import irvine.oeis.a037.A037276;

/**
 * A340592 a(n) is the concatenation of the prime factors (with multiplicity) of n mod n.
 * @author Georg Fischer
 */
public class A340592 extends A037276 {

  protected int mN;
  
  /** Construct the sequence. */
  public A340592() {
    mN = 1;
    super.next();
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A340905	0	->	6	A337165	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a337.A337165;

/**
 * A340905 Number of ways to write n as an ordered sum of 6 squares of positive integers.
 * @author Georg Fischer
 */
public class A340905 extends A337165 {

  private int mN = 5;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A340906	0	->	7	A337165	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a337.A337165;

/**
 * A340906 Number of ways to write n as an ordered sum of 7 squares of positive integers.
 * @author Georg Fischer
 */
public class A340906 extends A337165 {

  private int mN = 6;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A340915	0	->	8	A337165	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a337.A337165;

/**
 * A340915 Number of ways to write n as an ordered sum of 8 squares of positive integers.
 * @author Georg Fischer
 */
public class A340915 extends A337165 {

  private int mN = 7;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A340946	0	->	9	A337165	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a337.A337165;

/**
 * A340946 Number of ways to write n as an ordered sum of 9 squares of positive integers.
 * @author Georg Fischer
 */
public class A340946 extends A337165 {

  private int mN = 8;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A340947	0	->	10	A337165	--------------------------------
package irvine.oeis.a340;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a337.A337165;

/**
 * A340947 Number of ways to write n as an ordered sum of 10 squares of positive integers.
 * @author Georg Fischer
 */
public class A340947 extends A337165 {

  private int mN = 9;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 10);
  }
}

#!queue	A340987	1	->	0	A060642	--------------------------------
package irvine.oeis.a340;
// manually build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A340987 Number of colored integer partitions of 2n such that all colors from an n-set are used.
 * @author Georg Fischer
 */
public class A340987 extends A060642 {

  private int mN = -2;

  @Override
  public Z next() {
    ++mN;
    return super.compute(2 * mN + 1, mN);
  }
}

#!queue	A341221	1	->	3	A060642	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A341221 Expansion of (-1 + Product_{k&gt;=1} 1 / (1 - x^k))^3.
 * @author Georg Fischer
 */
public class A341221 extends A060642 {

  private int mN = 2 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 2);
  }
}

#!queue	A341222	1	->	4	A060642	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A341222 Expansion of (-1 + Product_{k&gt;=1} 1 / (1 - x^k))^4.
 * @author Georg Fischer
 */
public class A341222 extends A060642 {

  private int mN = 3 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 3);
  }
}

#!queue	A341223	1	->	5	A060642	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A341223 Expansion of (-1 + Product_{k&gt;=1} 1 / (1 - x^k))^5.
 * @author Georg Fischer
 */
public class A341223 extends A060642 {

  private int mN = 4 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 4);
  }
}

#!queue	A341225	1	->	6	A060642	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A341225 Expansion of (-1 + Product_{k&gt;=1} 1 / (1 - x^k))^6.
 * @author Georg Fischer
 */
public class A341225 extends A060642 {

  private int mN = 5 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 5);
  }
}

#!queue	A341226	1	->	7	A060642	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A341226 Expansion of (-1 + Product_{k&gt;=1} 1 / (1 - x^k))^7.
 * @author Georg Fischer
 */
public class A341226 extends A060642 {

  private int mN = 6 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 6);
  }
}

#!queue	A341227	1	->	8	A060642	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A341227 Expansion of (-1 + Product_{k&gt;=1} 1 / (1 - x^k))^8.
 * @author Georg Fischer
 */
public class A341227 extends A060642 {

  private int mN = 7 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 7);
  }
}

#!queue	A341228	1	->	9	A060642	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A341228 Expansion of (-1 + Product_{k&gt;=1} 1 / (1 - x^k))^9.
 * @author Georg Fischer
 */
public class A341228 extends A060642 {

  private int mN = 8 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 8);
  }
}

#!queue	A341236	1	->	10	A060642	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl build/trionk

import irvine.math.z.Z;
import irvine.oeis.a060.A060642;

/**
 * A341236 Expansion of (-1 + Product_{k&gt;=1} 1 / (1 - x^k))^10.
 * @author Georg Fischer
 */
public class A341236 extends A060642 {

  private int mN = 9 - 1;

  @Override
  public Z next() {
    ++mN;
    return super.compute(mN, 9);
  }
}

#!queue	A341409	0	->	1	A001550	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001550 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001550;

/**
 * A341409 a(n) = (Sum_{k=1..3} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341409 extends A001550 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341409() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341410	0	->	1	A001551	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001551 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001551;

/**
 * A341410 a(n) = (Sum_{k=1..4} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341410 extends A001551 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341410() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341411	0	->	1	A001552	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001552 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001552;

/**
 * A341411 a(n) = (Sum_{k=1..5} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341411 extends A001552 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341411() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341412	0	->	1	A001553	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001553 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001553;

/**
 * A341412 a(n) = (Sum_{k=1..6} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341412 extends A001553 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341412() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A341413	0	->	1	A001554	--------------------------------
package irvine.oeis.a341;
// Generated by gen_seq4.pl seqop a001 A001554 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a001.A001554;

/**
 * A341413 a(n) = (Sum_{k=1..7} k^n) mod n.
 *
 * @author Georg Fischer
 */
public class A341413 extends A001554 {
  private int mN = 0;

  /** Construct the sequence. */
  public A341413() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A342014	0	->	1	A003415	--------------------------------
package irvine.oeis.a342;
// Generated by gen_seq4.pl seqop a003 A003415 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a003.A003415;

/**
 * A342014 Arithmetic derivative of n, taken modulo n: a(n) = A003415(n) mod n.
 *
 * @author Georg Fischer
 */
public class A342014 extends A003415 {
  private int mN = 0;

  /** Construct the sequence. */
  public A342014() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A342122	0	->	1	A030101	--------------------------------
package irvine.oeis.a342;
// Generated by gen_seq4.pl seqop a030 A030101 mod(Z.valueOf(mN)) 0 at 2021-10-28 23:47
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.a030.A030101;

/**
 * A342122 a(n) is the remainder when the binary reverse of n is divided by n.
 *
 * @author Georg Fischer
 */
public class A342122 extends A030101 {
  private int mN = 0;

  /** Construct the sequence. */
  public A342122() {
    super();
    int bOffset = -1;
    while (bOffset < mN) {
      ++bOffset;
      super.next();
    }
  }

  @Override
  public Z next() {
    ++mN;
    return super.next().mod(Z.valueOf(mN));
  }
}
#!queue	A344852	0	->	1	A000120	--------------------------------
package irvine.oeis.a344;
// manually 2021-06-15

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000120;
import irvine.oeis.a001.A001147;

/**
 * A344852 Number of rooted binary trees with n leaves with minimal Symmetry Nodes Index (SNI) or, equivalently, with the maximal number of symmetry nodes.
 * @author Georg Fischer
 */
public class A344852 extends A000120 {

  protected MemorySequence mSeqDF;

  /** Construct the sequence. */
  public A344852() {
    mSeqDF = MemorySequence.cachedSequence(new A001147()); // double factorials of odd numbers
    super.next(); // skip A000120(0)
  }

  @Override
  public Z next() {
    return mSeqDF.a(super.next().intValue() - 1);
  }
}
#!queue	A345444	1	->	0	A344005	--------------------------------
package irvine.oeis.a345;
// manually n2/n2add1 at 2023-05-02 19:56

import irvine.math.z.Z;
import irvine.oeis.a344.A344005;

/**
 * A345444 a(n) = A344005(2*n+1).
 * @author Georg Fischer
 */
public class A345444 extends A344005 {

  @Override
  public Z next() {
    final Z result = super.next();
    super.next();
    return result;
  }
}
#!queue	A346299	0	->	1	A076478	--------------------------------
package irvine.oeis.a346;

import irvine.math.z.Z;
import irvine.oeis.a076.A076478;

/**
 * A346299 Positions of words in A076478 in which #0's &lt; #1's.
 * @author Sean A. Irvine
 */
public class A346299 extends A076478 {

  private long mN = 1;
  private long mMask = 0;
  private long mLim = 2;
  private int mBits = 0; // excluding leading 1

  @Override
  public Z next() {
    while (true) {
      if (++mN == mLim) {
        mLim *= 2;
        mMask = (mMask << 1) + 1;
        ++mBits;
      }
      final int ones = Long.bitCount(mN) - 1; // drop leading one
      final int zeros = mBits - ones;
      if (zeros < ones) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A346300	0	->	1	A076478	--------------------------------
package irvine.oeis.a346;

import irvine.math.z.Z;
import irvine.oeis.a076.A076478;

/**
 * A346300 Positions of words in A076478 in which #0's &gt; #1's.
 * @author Sean A. Irvine
 */
public class A346300 extends A076478 {

  private long mN = 1;
  private long mMask = 0;
  private long mLim = 2;
  private int mBits = 0; // excluding leading 1

  @Override
  public Z next() {
    while (true) {
      if (++mN == mLim) {
        mLim *= 2;
        mMask = (mMask << 1) + 1;
        ++mBits;
      }
      final int ones = Long.bitCount(mN) - 1; // drop leading one
      final int zeros = mBits - ones;
      if (zeros > ones) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A346301	0	->	1	A076478	--------------------------------
package irvine.oeis.a346;

import irvine.math.z.Z;
import irvine.oeis.a076.A076478;

/**
 * A346301 Positions of words in A076478 such that first digit = last digit.
 * @author Sean A. Irvine
 */
public class A346301 extends A076478 {

  private long mN = 1;
  private long mMask = 0;
  private long mLim = 2;
  private int mBits = -1; // excluding leading 1

  @Override
  public Z next() {
    while (true) {
      if (++mN == mLim) {
        mLim *= 2;
        mMask = (mMask << 1) + 1;
        ++mBits;
      }
      if ((mN & 1) == ((mN >>> mBits) & 1)) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A346303	0	->	1	A076478	--------------------------------
package irvine.oeis.a346;

import irvine.math.z.Z;
import irvine.oeis.a076.A076478;

/**
 * A346303 Positions of words in A076478 that start with 0 and end with 0.
 * @author Sean A. Irvine
 */
public class A346303 extends A076478 {

  private long mN = 1;
  private long mMask = 0;
  private long mLim = 2;
  private int mBits = -1; // excluding leading 1

  @Override
  public Z next() {
    while (true) {
      if (++mN == mLim) {
        mLim *= 2;
        mMask = (mMask << 1) + 1;
        ++mBits;
      }
      if ((mN & 1) == 0 && ((mN >>> mBits) & 1) == 0) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A346304	0	->	1	A076478	--------------------------------
package irvine.oeis.a346;

import irvine.math.z.Z;
import irvine.oeis.a076.A076478;

/**
 * A346304 Positions of words in A076478 that start with 1 and end with 0.
 * @author Sean A. Irvine
 */
public class A346304 extends A076478 {

  private long mN = 1;
  private long mMask = 0;
  private long mLim = 2;
  private int mBits = -1; // excluding leading 1

  @Override
  public Z next() {
    while (true) {
      if (++mN == mLim) {
        mLim *= 2;
        mMask = (mMask << 1) + 1;
        ++mBits;
      }
      if ((mN & 1) == 0 && ((mN >>> mBits) & 1) == 1) {
        return Z.valueOf(mN - 1);
      }
    }
  }
}
#!queue	A346865	0	->	1	A000384	--------------------------------
package irvine.oeis.a346;
// Generated by gen_seq4.pl sigman1/sigma1s at 2023-02-28 23:52

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000384;

/**
 * A346865 Sum of divisors of the n-th hexagonal number.
 * @author Georg Fischer
 */
public class A346865 extends A000384 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).sigma();
  }
}
#!queue	A350361	2	->	1	A003057	--------------------------------
package irvine.oeis.a350;
// Generated by gen_seq4.pl dersimple at 2022-12-15 23:30

import irvine.math.z.Z;
import irvine.oeis.a003.A003057;

/**
 * A350361 2-tone chromatic number of a tree with maximum degree n.
 * @author Georg Fischer
 */
public class A350361 extends A003057 {

  @Override
  public Z next() {
    return super.next().add(2);
  }
}
#!queue	A350796	1	->	0	A350795	--------------------------------
package irvine.oeis.a350;

import irvine.math.z.Z;

/**
 * A350796 Number of unlabeled digraphs with n arcs and a global source and sink.
 * @author Sean A. Irvine
 */
public class A350796 extends A350795 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(gfRow(k, mN).coeff(mN).toZ());
    }
    return sum;
  }
}
#!queue	A350798	1	->	0	A350797	--------------------------------
package irvine.oeis.a350;

import irvine.math.z.Z;

/**
 * A350798 Number of unlabeled digraphs with n arcs and a global source (or sink).
 * @author Sean A. Irvine
 */
public class A350798 extends A350797 {

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN + 1; ++k) {
      sum = sum.add(gfRow(k, mN).coeff(mN).toZ());
    }
    return sum;
  }
}
#!queue	A350906	1	->	0	A057278	--------------------------------
package irvine.oeis.a350;

import irvine.math.z.Z;
import irvine.oeis.a057.A057278;

/**
 * A350906 Number of unlabeled initially-finally connected digraphs with n arcs.
 * @author Sean A. Irvine
 */
public class A350906 extends A057278 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      sum = sum.add(gfRow(k, mN - 1).coeff(mN - 1).toZ());
    }
    return sum;
  }
}
#!queue	A350907	1	->	0	A057277	--------------------------------
package irvine.oeis.a350;

import irvine.math.z.Z;
import irvine.oeis.a057.A057277;

/**
 * A350907 Number of unlabeled initially connected digraphs with n arcs.
 * @author Sean A. Irvine
 */
public class A350907 extends A057277 {

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      sum = sum.add(gfRow(k, mN - 1).coeff(mN - 1).toZ());
    }
    return sum;
  }
}
#!queue	A352977	1	->	0	A000192	--------------------------------
package irvine.oeis.a352;
// Generated by gen_seq4.pl dersimple at 2022-12-15 23:30

import irvine.math.z.Z;
import irvine.oeis.a000.A000192;

/**
 * A352977 Expansion of e.g.f. cos(2x) cos(3x) / cos(6x) (even powers only).
 * @author Georg Fischer
 */
public class A352977 extends A000192 {

  @Override
  public Z next() {
    return super.next().divide2();
  }
}
#!queue	A354542	2	->	1	A354543	--------------------------------
package irvine.oeis.a354;

import irvine.math.z.Z;

/**
 * A354542 Primes in A354543.
 * @author Georg Fischer
 */
public class A354542 extends A354543 {

  @Override
  public Z next() {
    while (true) {
      final Z result = super.next();
      if (result.isProbablePrime()) {
        return result;
      }
    }
  }
}
#!queue	A359127	0	->	1	A002378	--------------------------------
package irvine.oeis.a359;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a002.A002378;

/**
 * A359127 Oblong numbers which are products of six distinct primes.
 * @author Sean A. Irvine
 */
public class A359127 extends A002378 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      final FactorSequence fs = Jaguar.factor(t);
      if (fs.bigOmega() == 6 && fs.omega() == 6) {
        return t;
      }
    }
  }
}

#!queue	A359304	0	->	1	A002378	--------------------------------
package irvine.oeis.a359;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.a002.A002378;

/**
 * A359304 Oblong numbers which are products of five distinct primes.
 * @author Sean A. Irvine
 */
public class A359304 extends A002378 {

  @Override
  public Z next() {
    while (true) {
      final Z t = super.next();
      final FactorSequence fs = Jaguar.factor(t);
      if (fs.bigOmega() == 5 && fs.omega() == 5) {
        return t;
      }
    }
  }
}

#!queue	A361671	0	->	1	A000292	--------------------------------
package irvine.oeis.a361;
// manually knest at 2023-06-02 20:44

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.a000.A000292;

/**
 * A361671 Squarefree part of the n-th tetrahedral number.
 * @author Georg Fischer
 */
public class A361671 extends A000292 {

  {
    super.next();
  }

  @Override
  public Z next() {
    return Jaguar.factor(super.next()).core();
  }
}
#!queue	A999999	0	0	0	0
