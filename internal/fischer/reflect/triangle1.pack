#!queue	A070216	0	->	1	Triangle	--------------------------------
package irvine.oeis.a070;
// Generated by gen_seq4.pl trisimple at 2021-11-08 22:02

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A070216 Triangle T(n, k) = n^2 + k^2, 1 &lt;= k &lt;= n, read by rows.
 * @author Georg Fischer
 */
public class A070216 extends Triangle {

  /** Construct the sequence. */
  public A070216() {
    super(1);
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n + 1).square().add(Z.valueOf(k + 1).square());
  }
}
#!queue	A095833	0	->	1	Triangle	--------------------------------
package irvine.oeis.a095;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A095833 Triangle read by rows: T(n,k) = (n-k+1)*n, n&gt;=1, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A095833 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n - k + 1).multiply(n + 1);
  }
}
#!queue	A095834	0	->	1	Triangle	--------------------------------
package irvine.oeis.a095;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A095834 Triangle read by rows: T(n,k) = (n-k)*n, n&gt;=1, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A095834 extends Triangle {

  /** Construct the sequence. */
  public A095834() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf((n - k) * (n + 1));
  }
}
#!queue	A095884	0	->	1	Triangle	--------------------------------
package irvine.oeis.a095;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A095884 Triangle read by rows: T(n,k) = (n-k)^k, n&gt;=1, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A095884 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n - k).pow(k + 1);
  }
}
#!queue	A095886	0	->	1	Triangle	--------------------------------
package irvine.oeis.a095;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A095886 Triangle read by rows: T(n,k) = (n-k)^n, n&gt;=1, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A095886 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n - k).pow(n + 1);
  }
}
#!queue	A095887	0	->	1	Triangle	--------------------------------
package irvine.oeis.a095;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A095887 Triangle read by rows: T(n,k) = (n-k+1)^n, n&gt;=1, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A095887 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n - k + 1).pow(n + 1);
  }
}
#!queue	A096037	0	->	1	Triangle	--------------------------------
package irvine.oeis.a096;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A096037 Triangle T(n,m) = (3*n+3*m-2)*(n+1-m)/2 read by rows.
 * @author Georg Fischer
 */
public class A096037 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf(3 * n + 3 * k - 2).multiply(Z.valueOf(n + 1 - k)).divide2();
  }
}
#!queue	A096038	0	->	1	Triangle	--------------------------------
package irvine.oeis.a096;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A096038 Triangle T(n,m) = (3*n^2-3*m^2+5*m-4+n)/2 read by rows.
 * @author Georg Fischer
 */
public class A096038 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf(3 * n * n - 3 * k * k + 5 * k - 4 + n).divide2();
  }
}
#!queue	A096133	0	->	1	Triangle	--------------------------------
package irvine.oeis.a096;
// Generated by gen_seq4.pl triman/trian1 at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A096133 Triangle T(j,k) = (j^k) mod (j*k) for 1 &lt;= k &lt;= j, read by rows.
 * @author Georg Fischer
 */
public class A096133 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf(n).pow(k).mod(Z.valueOf(n * k));
  }
}
#!queue	A101598	0	->	1	Triangle	--------------------------------
package irvine.oeis.a101;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.triangle.Triangle;

/**
 * A101598 Triangle read by rows: T(n,k) = number of distinct digits in decimal representation of binomial(n,k), 0&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A101598 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    final int[] counts = ZUtils.digitCounts(Binomial.binomial(n, k));
    int num = 0;
    for (int i = counts.length - 1; i >= 0; --i) {
      if (counts[i] != 0) {
        ++num;
      }
    }
    return Z.valueOf(num);
  }
}
#!queue	A104567	0	->	1	Triangle	--------------------------------
package irvine.oeis.a104;
// Generated by gen_seq4.pl triman/trian1 at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A104567 Triangle read by rows: T(i,j) = i-j+1 if j is odd; T(i,j) = 2(i-j+1) if j is even (1 &lt;= j &lt;= i).
 * @author Georg Fischer
 */
public class A104567 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf((k & 1) == 1 ? n - k + 1 : 2 * (n - k + 1));
  }
}
#!queue	A104633	0	->	1	Triangle	--------------------------------
package irvine.oeis.a104;
// Generated by gen_seq4.pl modpas2/trian at 2021-11-12 23:48

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A104633 Triangle T(n,k) = k*(k-n-1)*(k-n-2)/2 read by rows, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A104633 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return Z.valueOf(k - n - 1).multiply(k - n - 2).multiply(k + 1).divide2();
  }
}
#!queue	A104713	0	->	3	Triangle	--------------------------------
package irvine.oeis.a104;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A104713 Triangle T(n,k) = binomial(n,k), read by rows, 3 &lt;= k &lt;=n .
 *
 * @author Georg Fischer
 */
public class A104713 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Binomial.binomial(n + 3, k + 3);
  }
}
#!queue	A104796	0	->	1	Triangle	--------------------------------
package irvine.oeis.a104;

import irvine.math.z.Fibonacci;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A104796 Triangle read by rows: T(n,k) = (n+1-k)*Fibonacci(n+2-k), for n&gt;=1, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A104796 extends Triangle {

  /** Construct the sequence. */
  public A104796() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return n == 1 ? Z.ONE : Fibonacci.fibonacci(n + 2 - k).multiply(n + 1 - k);
  }
}
#!queue	A105599	0	->	1	Triangle	--------------------------------
package irvine.oeis.a105;

import irvine.math.MemoryFunctionInt2;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A105599 Triangle read by rows: T(n, m) = number of forests with n nodes and m labeled trees. Also number of forests with exactly n - m edges on n labeled nodes.
 * Also number of forests with exactly n - m edges on n labeled nodes.
 * @author Georg Fischer
 */
public class A105599 extends Triangle {

  /** Construct the sequence. */
  public A105599() {
    super(1);
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    T:= proc(n,m) option remember;
          if n<0 then 0
        elif n=m then 1
        elif m<1 or m>n then 0
        else add(binomial(n-1,j-1)*j^(j-2)*T(n-j,m-1), j=1..n-m+1)
          fi
        end:
    seq(seq(T(n, m), m=1..n), n=1..12);
  */
  private final MemoryFunctionInt2<Z> mB = new MemoryFunctionInt2<Z>() {
    @Override
    protected Z compute(final int n, final int m) {
      if (n < 0) {
        return Z.ZERO;
      }
      if (n == m) {
        return Z.ONE;
      }
      if (m < 1 || m > n) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int jmax = n - m + 1;
      for (int j = 1; j <= jmax; ++j) {
        sum = sum.add(Binomial.binomial(n - 1, j - 1).multiply(Z.valueOf(j).pow(j - 2)).multiply(get(n - j, m - 1)));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return mB.get(n, k);
  }
}
#!queue	A105728	0	->	1	Triangle	--------------------------------
package irvine.oeis.a105;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A105728 Triangle read by rows: T(n,1) = 1, T(n,n) = n and for 1 &lt; k &lt; n: T(n,k) = T(n-1,k-1) + 2*T(n-1,k).
 * @author Georg Fischer
 */
public class A105728 extends Triangle {

  /** Construct the sequence. */
  public A105728() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 ? Z.ONE : (k == n ? Z.valueOf(n) : get(n - 2, k - 2).add(get(n - 2, k - 1).multiply2()));
  }
}
#!queue	A111577	0	->	1	Triangle	--------------------------------
package irvine.oeis.a111;
// manually A225466/tripas

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A111577 Galton triangle T(n, k) = T(n-1, k-1) + (3k-2)*T(n-1, k) read by rows.
 * @author Georg Fischer
 */
public class A111577 extends Triangle {

  /** Construct the sequence. */
  public A111577() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return n == 0 || k == 0 ? Z.ONE : get(n - 1, k - 1).add(get(n - 1, k).multiply(3 * k + 1));
  }
}
#!queue	A111578	0	->	1	Triangle	--------------------------------
package irvine.oeis.a111;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A111578 Triangle T(n, m) = T(n-1, m-1) + (4m-3)*T(n-1, m) read by rows 1&lt;=m&lt;=n.
 * @author Georg Fischer
 */
public class A111578 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return n == 0 ? Z.ONE : get(n - 1, k - 1).add(get(n - 1, k).multiply(4 * k + 1));
  }
}
#!queue	A111650	0	->	1	Triangle	--------------------------------
package irvine.oeis.a111;
// manually 2021-10-13

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A111650 2n appears n times (n&gt;0). 
 * @author Georg Fischer
 */
public class A111650 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return Z.valueOf(n + 1).multiply2();
  }
}
#!queue	A119725	0	->	1	Triangle	--------------------------------
package irvine.oeis.a119;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A119725 Triangular array read by rows: T(n,1) = T(n,n) = 1, T(n,k) = 3*T(n-1,k-1) + 2*T(n-1,k).
 * @author Georg Fischer
 */
public class A119725 extends Triangle {

  /** Construct the sequence. */
  public A119725() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 || k == n ? Z.ONE : get(n - 2, k - 2).multiply(3).add(get(n - 2, k - 1).multiply2());
  }
}
#!queue	A119726	0	->	1	Triangle	--------------------------------
package irvine.oeis.a119;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A119726 Triangular array read by rows: T(n,1) = T(n,n) = 1, T(n,k) = 4*T(n-1, k-1) + 2*T(n-1, k).
 * @author Georg Fischer
 */
public class A119726 extends Triangle {

  /** Construct the sequence. */
  public A119726() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 || k == n ? Z.ONE : get(n - 2, k - 2).multiply(4).add(get(n - 2, k - 1).multiply2());
  }
}
#!queue	A119727	0	->	1	Triangle	--------------------------------
package irvine.oeis.a119;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A119727 Triangular array: T(n,k) = T(n,n) = 1, T(n,k) = 5*T(n-1, k-1) + 2*T(n-1, k), read by rows.
 * @author Georg Fischer
 */
public class A119727 extends Triangle {

  /** Construct the sequence. */
  public A119727() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 || k == n ? Z.ONE : get(n - 2, k - 2).multiply(5).add(get(n - 2, k - 1).multiply2());
  }
}
#!queue	A120434	0	->	2	Triangle	--------------------------------
package irvine.oeis.a120;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A120434 Triangle read by rows: counts permutations by number of big descents.
 * @author Georg Fischer
 */
public class A120434 extends Triangle {

  /** Construct the sequence. */
  public A120434() {
    super(2);
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return n == k ? Z.TWO : get(n - 1, k - 1).multiply(n + 1 - k).add(get(n - 1, k).multiply(k + 2));
  }
}
#!queue	A122758	0	->	1	Triangle	--------------------------------
package irvine.oeis.a122;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A122758 Triangle read by rows: T(n,m) = 2*n^2*A084221(n) (n&gt;=0, 0 &lt;= m &lt;= n).
 * @author Georg Fischer
 */
public class A122758 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return k == 0 ? Z.TWO.multiply(n * (long) n) : (k == 1 ? Z.SIX.multiply(n * (long) n) : get(n, k - 2).multiply(4));
  }
}
#!queue	A123229	0	->	1	Triangle	--------------------------------
package irvine.oeis.a123;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A123229 Triangle read by rows: T(n, m) = n - (n mod m).
 * @author Georg Fischer
 */
public class A123229 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf(n).subtract(Z.valueOf(n).mod(Z.valueOf(k)));
  }
}
#!queue	A125172	0	->	1	Triangle	--------------------------------
package irvine.oeis.a125;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001906;
import irvine.oeis.triangle.Triangle;

/**
 * A125172 Triangle T(n,k) with partial column sums of the even indexed Fibonacci numbers.
 * @author Georg Fischer
 */
public class A125172 extends Triangle {

  private Sequence mSeq;

  /** Construct the sequence. */
  public A125172() {
    setOffset($(OFFSET));
    hasRAM(false);
    mSeq = new A001906();
    mSeq.next(); // skip 0
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 ? mSeq.next() : (k == n ? Z.ONE : get(n - 2, k - 2).add(get(n - 2, k - 1)));
  }
}
#!queue	A125235	0	->	1	Triangle	--------------------------------
package irvine.oeis.a125;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A125235 Triangle with the partial column sums of the octagonal numbers.
 * @author Georg Fischer
 */
public class A125235 extends Triangle {

  /** Construct the sequence. */
  public A125235() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /* PARI:
    t(n, k) = if (n <0, 0, if (k==1, n*(3*n-2), if (k > 1, t(n-1, k-1) + t(n-1, k))));
    tabl(nn) = {for (n = 1, nn, for (k = 1, n, print1(t(n, k), ", "); ); print(); ); }
  */
  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    if (n < 0) {
      return Z.ZERO;
    }
    if (k == 1) {
      return Z.valueOf(n).multiply(3 * n - 2);
    }
    return get(n - 2, k - 2).add(get(n - 2, k - 1));
  }
}
#!queue	A128064	0	->	1	Triangle	--------------------------------
package irvine.oeis.a128;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A128064 Triangle T with T(n,n)=n, T(n,n-1)=-(n-1) and otherwise T(n,k)=0; 0&lt;k&lt;=n.
 * @author Georg Fischer
 */
public class A128064 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    if (n == 1) {
      return Z.ONE;
    } else if (k == n) {
      return Z.valueOf(n);
    } else if (k == n - 1) {
      return Z.valueOf(-k);
    } else {
      return Z.ZERO;
    }
  }
}
#!queue	A130296	0	->	1	Triangle	--------------------------------
package irvine.oeis.a130;
// manually triprod at 2021-10-10 19:58

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A130296 Triangle read by rows: T[i,1]=i, T[i,j]=1 for 1 &lt; j &lt;= i = 1,2,3,...
 * @author Georg Fischer
 */
public class A130296 extends Triangle {

  /** Construct the sequence */
  public A130296() {
    super();
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    final Z result;
    if (k < 0 || k > n) {
      result = Z.ZERO;
    } else if (n == 0) { 
      result = Z.ONE;
    } else if (k == 0) { 
      result = Z.valueOf(n + 1);
    } else {
      result = Z.ONE;
    }
    return result;
  }
}
#!queue	A131818	0	->	1	Triangle	--------------------------------
package irvine.oeis.a131;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A131818 A130296 + A002260 - A000012. Triangle read by rows: row n consists of n, 2, 3, 4, ..., n.
 * T(n, 1) = n, T(n, k) = k for k &gt; 1.
 * @author Georg Fischer
 */
public class A131818 extends Triangle {

  /** Construct the sequence. */
  public A131818() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(k == 0 ? n + 1 : k + 1);
  }
}
#!queue	A136124	0	->	2	Triangle	--------------------------------
package irvine.oeis.a136;

import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A136124 Triangle read by rows: T(n,k) = (-1)^(n+k)*Sum_{j=1..k} s(n,j), where s(n,j) are the signed Stirling numbers of the first kind (n &gt;= 2; 1 &lt;= k &lt;= n-1; s(n,j) = A008275(n,j)).
 * @author Georg Fischer
 */
public class A136124 extends Triangle {

  /** Construct the sequence. */
  public A136124() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    A136124_row := proc(n) local k, j; 
    `if`(n=0, 1, seq((-1)^(n+1-k)*add(stirling1(n+1, j), j=1..k), k=1..n)) end: 
    seq(print(A136124_row(r)), r=1..6);
  */
  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    Z sum = Z.ZERO;
    for (int j = 1; j <= k; ++j) {
      sum = sum.add(Stirling.firstKind(n + 1, j).multiply((((n + 1 - k) & 1) == 0) ? 1 : -1));
    }
    return sum;
  }
}
#!queue	A136125	0	->	1	Triangle	--------------------------------
package irvine.oeis.a136;
// manually trecpas/trecpas1

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A136125 Triangle read by rows: T(n,k) is the number of permutations of {1,2,...,n} in which the size of the last cycle is k (the cycles are ordered by increasing smallest elements; 1 &lt;= k &lt;=n).
 * @author Georg Fischer
 */
public class A136125 extends Triangle {

  /** Construct the sequence. */
  public A136125() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* T:=proc(n, k) if k < n then factorial(n)/(k*(k+1)) elif k = n then factorial(n-1) else 0 end if end proc: */
  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return k < n ? MemoryFactorial.SINGLETON.factorial(n).divide(k * (k + 1)) : (k == n ? MemoryFactorial.SINGLETON.factorial(n - 1) : Z.ZERO);
  }
}
#!queue	A137651	0	->	1	Triangle	--------------------------------
package irvine.oeis.a137;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A137651 Triangle read by rows: T(n,k) is the number of primitive (aperiodic) word structures of length n using exactly k different symbols.
 * T(n,k) = Sum{d|n} mu(n/d) * Stirling2(d, k).
 * @author Georg Fischer
 */
public class A137651 extends Triangle {

  /** Construct the sequence. */
  public A137651() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    if (n == 0) {
      return Z.ONE;
    }
    ++n;
    ++k;
    Z sum = Z.ZERO;
    for (final Z zd : Jaguar.factor(n).divisors()) {
      final int d = zd.intValue();
      sum = sum.add(Stirling.secondKind(d, k).multiply(Mobius.mobius(n / d)));
    }
    return sum;
  }
}
#!queue	A140978	0	->	1	Triangle	--------------------------------
package irvine.oeis.a140;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A140978 Repeat (n+1)^2 n times.
 * @author Georg Fischer
 */
public class A140978 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return Z.valueOf(n + 2).square();
  }
}
#!queue	A141432	0	->	1	Triangle	--------------------------------
package irvine.oeis.a141;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A141432 Triangle T(n,k) = (k+1)*(n-k-1) read by rows.
 * @author Georg Fischer
 */
public class A141432 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(k + 2).multiply(n - k - 1);
  }
}
#!queue	A142596	0	->	1	Triangle	--------------------------------
package irvine.oeis.a142;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A142596 Triangle T(n, k) = T(n-1, k-1) + 3*T(n-1, k) + 2*T(n-1, k-1), with T(n,1) = T(n, n) = 1, read by rows.
 * @author Georg Fischer
 */
public class A142596 extends Triangle {

  /** Construct the sequence. */
  public A142596() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 || k == n ? Z.ONE : (get(n - 2, k - 2).add(get(n - 2, k - 1))).multiply(3);
  }
}
#!queue	A142963	0	->	1	Triangle	--------------------------------
package irvine.oeis.a142;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A142963 Triangle read by rows, coefficients of the polynomials P(k, x) = (1/2) Sum_{p=0..k-1} Stirling2(k, p+1)*x^p*(1-4*x)^(k-1-p)*(2*p+2)!/(p+1)!.
 * @author Georg Fischer
 */
public class A142963 extends Triangle {

  /** Construct the sequence. */
  public A142963() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /* T(n,m) = (m+1)*T(n-1,m) + (4*n-4*m-2)*T(n-1,m-1) with T(n,m=0) = 1 and T(n,m=n-1) = 2^(n-1), n >= 1 and 0 <= m <= n-1. */
  @Override
  protected Z compute(int n, final int k) {
    ++n;
    return k == 0 ? Z.ONE : (k == n - 1 ? Z.ONE.shiftLeft(n - 1) : get(n - 2, k - 1).multiply(4 * (n - k) - 2).add(get(n - 2, k).multiply(k + 1)));
  }
}
#!queue	A143218	0	->	1	Triangle	--------------------------------
package irvine.oeis.a143;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A143218 Triangle read by rows, A127775 * A000012 * A127775; 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A143218 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(2 * n + 1).multiply(Z.valueOf(2 * k + 1));
  }
}
#!queue	A143267	0	->	1	Triangle	--------------------------------
package irvine.oeis.a143;

import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000010;
import irvine.oeis.triangle.Triangle;

/**
 * A143267 Triangle read by rows, A130207 * A000012 * A127648.
 * @author Georg Fischer
 */
public class A143267 extends Triangle {

  protected Sequence mSeq;
  
  /** Construct the sequence. */
  public A143267() {
    setOffset($(OFFSET));
    hasRAM(false);
    mSeq = new A000010();
  }

  @Override
  public Z compute(final int n, final int k) {
    return k == 0 ? mSeq.next() : get(n, 0).multiply(k + 1);
  }
}
#!queue	A143491	0	->	2	Triangle	--------------------------------
package irvine.oeis.a143;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A143491 Unsigned 2-Stirling numbers of the first kind.
 * @author Georg Fischer
 */
public class A143491 extends Triangle {

  private int mStir;

  /** Construct the sequence. */
  public A143491() {
    this(2);
  }

  /**
   * Generic constructor with parameter.
   * @param stir unsigned <code>stir</code>-stirling numbers
   */
  public A143491(final int stir) {
    setOffset($(OFFSET));
    hasRAM(false);
    mStir = stir;
  }

  @Override
  protected Z compute(int n, int k) {
    n += mStir;
    k += mStir;
    return n == mStir ? Z.ONE : get(n - 1 - mStir, k - 1 - mStir).add(get(n - 1 - mStir, k - mStir).multiply(n - 1));
  }
}
#!queue	A143494	0	->	2	Triangle	--------------------------------
package irvine.oeis.a143;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A143494 Triangle read by rows: 2-Stirling numbers of the second kind.
 * @author Georg Fischer
 */
public class A143494 extends Triangle {

  private int mStir;

  /** Construct the sequence. */
  public A143494() {
    this(2);
  }

  /**
   * Generic constructor with parameter.
   * @param stir unsigned <code>stir</code>-stirling numbers
   */
  public A143494(final int stir) {
    setOffset($(OFFSET));
    hasRAM(false);
    mStir = stir;
  }

  @Override
  protected Z compute(int n, int k) {
    n += mStir;
    k += mStir;
    return n == mStir ? Z.ONE : get(n - 1 - mStir, k - 1 - mStir).add(get(n - 1 - mStir, k - mStir).multiply(k));
  }
}
#!queue	A143497	0	->	2	Triangle	--------------------------------
package irvine.oeis.a143;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A143497 Triangle of unsigned 2-Lah numbers.
 * Recurrence: <code>T(n,k) = (n+k-1)*T(n-1,k) + T(n-1,k-1) for n,k &gt;= 2</code>.
 * @author Georg Fischer
 */
public class A143497 extends Triangle {

  protected int mLah2;

  /** Construct the sequence. */
  public A143497() {
    this(2);
  }

  /**
   * Generic constructor with parameter
   * @param lah Lah number
   */
  public A143497(final int lah) {
    setOffset($(OFFSET));
    hasRAM(false);
    mLah2 = 2 * lah - 1;
  }

  @Override
  public Z compute(final int n, final int k) {
    return n == 0 ? Z.ONE : get(n - 1, k).multiply(n + k + mLah2).add(get(n - 1, k - 1));
  }
}
#!queue	A145324	0	->	1	Triangle	--------------------------------
package irvine.oeis.a145;
// Generated by gen_seq4.pl trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A145324 Triangle read by rows: coefficients of 1; 1(X+2); 1(X+2)(X+3); 1(X+2)(X+3)(X+4); ....
 * @author Georg Fischer
 */
public class A145324 extends Triangle {

  /** Construct the sequence. */
  public A145324() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n == 1 ? Z.ONE : get(n - 2, k - 2).multiply(n).add(get(n - 2, k - 1));
  }
}
#!queue	A156289	0	->	1	Triangle	--------------------------------
package irvine.oeis.a156;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A156289 Triangle read by rows: T(n,k) is the number of end rhyme patterns of a poem of an even number of lines (2n) with 1&lt;=k&lt;=n evenly rhymed sounds.
 * @author Georg Fischer
 */
public class A156289 extends Triangle {

  /** Construct the sequence. */
  public A156289() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /* T(n, 1)=1 for 1<=n; T(n,k)=0 for 1<=n<k; T(n,k) = (2k-1)*T(n-1,k-1) + k^2*T(n-1,k) 1<k<=n. */
  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 ? Z.ONE : get(n - 2, k - 2).multiply(2 * k - 1).add(get(n - 2, k - 1).multiply(k * k));
  }
}
#!queue	A157013	0	->	1	Triangle	--------------------------------
package irvine.oeis.a157;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A157013 Riordan's general Eulerian recursion: T(n, k) = (k+2)*T(n-1, k) + (n-k-1) * T(n-1, k-1) with T(n,1) = 1, T(n,n) = (-1)^(n-1).
 * @author Georg Fischer
 */
public class A157013 extends Triangle {

  /** Construct the sequence. */
  public A157013() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /* T(n, k) = (k+2)*T(n-1, k) + (n-k-1)*T(n-1, k-1) with T(n, 1) = 1, T(n,n) = (-1)^(n-1) */
  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 ? Z.ONE : (k == n ? (((n - 1) & 1) == 0 ? Z.ONE : Z.NEG_ONE)
      : get(n - 2, k - 2).multiply(n - k - 1).add(get(n - 2, k - 1).multiply(k + 2)));
  }
}
#!queue	A159798	0	->	1	Triangle	--------------------------------
package irvine.oeis.a159;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A159798 Triangle read by rows in which row n lists n terms, starting with 1, such that the difference between successive terms is equal to n-3.
 * @author Georg Fischer
 */
public class A159798 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.ONE : get(n, k - 1).add(n - 2);
  }
}
#!queue	A162245	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162245 Triangle T(n,m) = 6*m*n + 3*m + 3*n + 1 read by rows.
 * @author Georg Fischer
 */
public class A162245 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(6 * k * n + 9 * k + 9 * n + 13);
  }
}
#!queue	A162508	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162508 A binomial sum of powers related to the Bernoulli numbers, triangular array, read by rows.
 * T(n,k) = (k + 1)*T(n-1,k) - k*T(n-1,k-1)
 * @author Georg Fischer
 */
public class A162508 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return n == 0 ? Z.NEG_ONE : get(n - 1, k).multiply(k + 2).subtract(get(n - 1, k - 1).multiply(k + 1));
  }
}
#!queue	A162609	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162609 Triangle read by rows in which row n lists n terms, starting with 1, with gaps = n-2 between successive terms.
 * @author Georg Fischer
 */
public class A162609 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.ONE : get(n, k - 1).add(n - 1);
  }
}
#!queue	A162610	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162610 Triangle read by rows in which row n lists n terms, starting with 2n-1, with gaps = n-1 between successive terms.
 * @author Georg Fischer
 */
public class A162610 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(2L * n + 1) : get(n, k - 1).add(n);
  }
}
#!queue	A162612	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162612 Triangle read by rows in which row n lists n terms, starting with n^2+n-1, with gaps = n^2-1 between successive terms.
 * @author Georg Fischer
 */
public class A162612 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(n + 1).square().add(n) : get(n, k - 1).add(Z.valueOf(n + 1).square()).subtract(1);
  }
}
#!queue	A162613	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162613 Triangle read by rows in which row n lists n terms, starting with n, with gaps = n^2-1 between successive terms.
 * @author Georg Fischer
 */
public class A162613 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(n + 1) : get(n, k - 1).add(n * (n + 2L));
  }
}
#!queue	A162615	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162615 Triangle read by rows in which row n lists n terms, starting with n, such that the difference between successive terms is equal to n^3 - 1 = A068601(n).
 * @author Georg Fischer
 */
public class A162615 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(n + 1) : get(n, k - 1).add(Z.valueOf(n + 1).pow(3)).subtract(1);
  }
}
#!queue	A162616	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162616 Triangle read by rows in which row n lists n terms, starting with n^3 + n - 1, such that the difference between successive terms is equal to n^3 - 1 = A068601(n).
 * @author Georg Fischer
 */
public class A162616 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(n + 1).pow(3).add(n) : get(n, k - 1).add(Z.valueOf(n + 1).pow(3)).subtract(1);
  }
}
#!queue	A162623	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162623 Triangle read by rows in which row n lists n terms, starting with n, such that the difference between successive terms is equal to n^4 - 1 = A123865(n).
 * @author Georg Fischer
 */
public class A162623 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(n + 1) : get(n, k - 1).add(Z.valueOf(n + 1).pow(4)).subtract(1);
  }
}
#!queue	A162624	0	->	1	Triangle	--------------------------------
package irvine.oeis.a162;
// Generated by gen_seq4.pl triman/trian at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A162624 Triangle read by rows in which row n lists n terms, starting with n^4 + n - 1, such that the difference between successive terms is equal to n^4 - 1 = A123865(n).
 * @author Georg Fischer
 */
public class A162624 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(n + 1).pow(4).add(n) : get(n, k - 1).add(Z.valueOf(n + 1).pow(4)).subtract(1);
  }
}
#!queue	A163676	0	->	1	Triangle	--------------------------------
package irvine.oeis.a163;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A163676 Triangle T(n,m) = 4mn + 2m + 2n - 1 read by rows.
 * @author Georg Fischer
 */
public class A163676 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(4 * (n + 1) * (k + 1) + 2 * (k + 1) + 2 * (n + 1) - 1);
  }
}
#!queue	A166350	0	->	1	Triangle	--------------------------------
package irvine.oeis.a166;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A166350 Table T(n,m) = m! read by rows.
 * @author Georg Fischer
 */
public class A166350 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return k == 0 ? Z.ONE : get(n, k - 1).multiply(k + 1);
  }
}
#!queue	A166960	0	->	1	Triangle	--------------------------------
package irvine.oeis.a166;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A166960 Triangle T(n, k) read by rows: T(n, k)= (m*n-m*k+1)*T(n-1, k-1) + k*(m*k-(m-1))*T(n-1, k) where m = 1.
 * @author Georg Fischer
 */
public class A166960 extends Triangle {

  private int mM;

  /** Construct the sequence. */
  public A166960() {
    this(1);
  }

  /**
   * Generic constructor with parameter.
   * @param m constant (0, 1, 2, 3)
   */
  public A166960(final int m) {
    mM = m;
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 || k == n ? Z.ONE : get(n - 2, k - 2).multiply(mM * (n - k) + 1).add(get(n - 2, k - 1).multiply(k * (mM * k - (mM - 1))));
  }
}
#!queue	A166973	0	->	1	Triangle	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A166973 Triangle T(n,k) read by rows: T(n, k) = (m*n - m*k + 1)*T(n - 1, k - 1) + (5*k - 4)*(m*k - (m - 1))*T(n - 1, k) where m = 0.
 * @author Georg Fischer
 */
public class A166973 extends Triangle {

  /** Construct the sequence. */
  public A166973() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n == 1 ? Z.ONE : get(n - 2, k - 2).add(get(n - 2, k - 1).multiply(5 * k - 4));
  }
}
#!queue	A166979	0	->	1	Triangle	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A166979 Triangle T(n,k) read by rows: T(n, k) = (m*n - m*k + 1)*T(n - 1, k - 1) + (9*k - 8)*(m*k - (m - 1))*T(n - 1, k) where m = 0.
 * @author Georg Fischer
 */
public class A166979 extends Triangle {

  /** Construct the sequence. */
  public A166979() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n == 1 ? Z.ONE : get(n - 2, k - 2).add(get(n - 2, k - 1).multiply(9 * k - 8));
  }
}
#!queue	A167192	0	->	1	Triangle	--------------------------------
package irvine.oeis.a167;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A167192 Triangle read by rows: T(n,k) = (n-k)/gcd(n,k), 1 &lt;= k &lt;= n.
 * @author Georg Fischer
 */
public class A167192 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n - k).divide(LongUtils.gcd(n + 1, k + 1));
  }
}
#!queue	A168281	0	->	1	Triangle	--------------------------------
package irvine.oeis.a168;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A168281 Triangle T(n,m) = 2*(min(n - m + 1, m))^2 read by rows.
 * @author Georg Fischer
 */
public class A168281 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(LongUtils.min(n - k + 1, k + 1)).square().multiply2();
  }
}
#!queue	A177990	0	->	1	Triangle	--------------------------------
package irvine.oeis.a177;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A177990 Triangle read by rows, variant of A070909, a cellular automaton.
 * @author Georg Fischer
 */
public class A177990 extends Triangle {

  /** Construct the sequence. */
  public A177990() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return n == k ? Z.ONE : ((k & 1) == 0) ? Z.ZERO : Z.ONE;
  }
}
#!queue	A186695	0	->	1	Triangle	--------------------------------
package irvine.oeis.a186;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A186695 A Galton triangle: T(n,k) = (2k-1)*(T(n-1,k) + T(n-1,k-1)): a type B analog of the ordered Bell numbers A019538.
 * @author Georg Fischer
 */
public class A186695 extends Triangle {

  /** Construct the sequence. */
  public A186695() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 ? Z.ONE : get(n - 2, k - 2).add(get(n - 2, k - 1)).multiply(2 * k - 1);
  }
}
#!queue	A187075	0	->	1	Triangle	--------------------------------
package irvine.oeis.a187;
// Generated by gen_seq4.pl trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A187075 A Galton triangle: T(n,k) = 2*k*T(n-1,k) + (2*k-1)*T(n-1,k-1).
 * @author Georg Fischer
 */
public class A187075 extends Triangle {

  /** Construct the sequence. */
  public A187075() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n == 1 ? Z.ONE : get(n - 2, k - 2).multiply(2 * k - 1).add(get(n - 2, k - 1).multiply(2 * k));
  }
}
#!queue	A195916	0	->	1	Triangle	--------------------------------
package irvine.oeis.a195;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A195916 Table with T(n,n) = n, T(n,k) = xor(T(n-1,k-1), T(n-1,k)).
 * @author Georg Fischer
 */
public class A195916 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return k == 0 ? Z.ONE : (k == n ? Z.valueOf(n + 1) : get(n - 1, k - 1).xor(get(n - 1, k)));
  }
}
#!queue	A202451	0	->	1	Triangle	--------------------------------
package irvine.oeis.a202;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A202451 Upper triangular Fibonacci matrix, by SW antidiagonals.
 * @author Georg Fischer
 */
public class A202451 extends Triangle {

  private Z mFib0;
  private Z mFib1;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    final int nh = n / 2;
    if ((n & 1) == 0) { // even row 4: 0 0 1 2 5
      if (k < nh) {
        return Z.ZERO;
      } else if (k == nh) {
        mFib0 = Z.ZERO;
        mFib1 = Z.ONE;
        return mFib1;
      } else {
        Z fib2 = mFib0.add(mFib1);
        mFib0 = mFib1;
        mFib1 = fib2;
        fib2 = mFib0.add(mFib1);
        mFib0 = mFib1;
        mFib1 = fib2;
        return mFib1;
      }
    } else { // odd row 5: 0 0 0 1 3 8
      if (k <= nh) {
        return Z.ZERO;
      } else if (k == nh + 1) {
        mFib0 = Z.ONE;
        mFib1 = Z.ONE;
        return mFib1;
      } else {
        Z fib2 = mFib0.add(mFib1);
        mFib0 = mFib1;
        mFib1 = fib2;
        fib2 = mFib0.add(mFib1);
        mFib0 = mFib1;
        mFib1 = fib2;
        return mFib1;
      }
    }
  }
}
#!queue	A204579	0	->	1	Triangle	--------------------------------
package irvine.oeis.a204;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A204579 Triangle read by rows: matrix inverse of A036969.
 * @author Georg Fischer
 */
public class A204579 extends Triangle {

  /** Construct the sequence. */
  public A204579() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /* T(n,k) = T(n-1,k-1) - (n-1)^2*T(n-1,k). */
  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n == k ? Z.ONE : get(n - 2, k - 2).add(get(n - 2, k - 1).multiply(-(n - 1) * (n - 1)));
  }
}
#!queue	A208656	0	->	1	Triangle	--------------------------------
package irvine.oeis.a208;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A208656 Triangle T(n, k) = n*C(n,k) - C(n-1,k-1), 1 &lt;= k &lt;= n, read by rows.
 * @author Georg Fischer
 */
public class A208656 extends Triangle {

  /** Construct the sequence. */
  public A208656() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Binomial.binomial(n + 1, k + 1).multiply(n + 1).subtract(Binomial.binomial(n, k));
  }
}
#!queue	A208657	0	->	1	Triangle	--------------------------------
package irvine.oeis.a208;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A208657 Triangular array read by rows: n*binomial(n,n-k+1)-binomial(n-1,n-k) with k = 1..n, n &gt;= 1.
 * @author Georg Fischer
 */
public class A208657 extends Triangle {

  /** Construct the sequence. */
  public A208657() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Binomial.binomial(n + 1, n - k + 1).multiply(n + 1).subtract(Binomial.binomial(n, n - k));
  }
}
#!queue	A210874	0	->	1	Triangle	--------------------------------
package irvine.oeis.a210;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A210874 Triangular array U(n,k) of coefficients of polynomials defined in Comments.
 * @author Georg Fischer
 */
public class A210874 extends Triangle {

  /** Construct the sequence. */
  public A210874() {
    this(1, 2, 3);
  }

  /**
   * Generic constructor with parameters.
   * @param inits initial terms
   */
  public A210874(final long... inits) {
    super(inits);
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    if (n <= 1) {
      return super.compute(n, k);
    } else if (k == 0) {
      return Z.valueOf(n + 1);
    } else if (k == 1) {
      return Z.valueOf(n + 1).add(get(n - 1, 0));
    } else {
      return get(n - 1, k - 1).add(get(n - 2, k - 2));
    }
  }
}
#!queue	A213081	0	->	1	Triangle	--------------------------------
package irvine.oeis.a213;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A213081 Exclusive-or based Pascal triangle, read by rows: T(n,1)=T(n,n)=n and T(n,k) = T(n-1,k-1) XOR T(n-1,k), where XOR is the bitwise exclusive-or operator.
 * T(n, 1)=T(n,n)=n and T(n,k) = T(n-1,k-1) XOR T(n-1,k), where XOR is the bitwise exclusive-or operator.
 * @author Georg Fischer
 */
public class A213081 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return k == 0 || k == n ? Z.valueOf(n + 1) : get(n - 1, k - 1).xor(get(n - 1, k));
  }
}
#!queue	A214258	0	->	1	Triangle	--------------------------------
package irvine.oeis.a214;

import irvine.math.MemoryFunctionInt2;
import irvine.math.MemoryFunctionInt4;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A214258 Number T(n,k) of compositions of n where the difference between largest and smallest parts equals k; triangle T(n,k), n&gt;=1, 0&lt;=k&lt;n, read by rows.
 * @author Georg Fischer
 */
public class A214258 extends Triangle {

  /** Construct the sequence. */
  public A214258() {
    super(1);
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple: # similar to A214269
    b:= proc(n, k, s, t) option remember;
          `if`(n<0, 0, `if`(n=0, 1, add(b(n-j, k,
           min(s,j), max(t,j)), j=max(1, t-k+1)..s+k-1)))
        end:
    A:= proc(n, k) option remember;
          `if`(n=0, 1, add(b(n-j, k+1, j, j), j=1..n))
        end:
    T:= (n, k)-> A(n, k) -`if`(k=0, 0, A(n, k-1)):
    seq(seq(T(n,k), k=0..n-1), n=1..15);
  */
  private static final MemoryFunctionInt4<Z> B = new MemoryFunctionInt4<Z>() {
    @Override
    protected Z compute(final int n, final int k, final int s, final int t) {
      if (n < 0) {
        return Z.ZERO;
      }
      if (n == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      final int jmax = s + k - 1;
      for (int j = Math.max(1, t - k + 1); j <= jmax; ++j) {
        sum = sum.add(get(n - j, k, Math.min(s, j), Math.max(t, j)));
      }
      return sum;
    }
  };

  protected static final MemoryFunctionInt2<Z> A = new MemoryFunctionInt2<Z>() {  // used in A214257
    @Override
    protected Z compute(final int n, final int k) {
      if (n == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (int j = 1; j <= n; ++j) {
        sum = sum.add(B.get(n - j, k + 1, j, j));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, final int k) {
    ++n;
    Z result = A.get(n, k);
    if (k != 0) {
      result = result.subtract(A.get(n, k - 1));
    }
    return result;
  }
}
#!queue	A214269	0	->	1	Triangle	--------------------------------
package irvine.oeis.a214;

import irvine.math.MemoryFunctionInt2;
import irvine.math.MemoryFunctionInt5;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A214269 Number T(n,k) of compositions of n where the difference between largest and smallest parts equals k and adjacent parts are unequal; triangle T(n,k), n&gt;=1, 0&lt;=k&lt;n, read by rows.
 * @author Georg Fischer
 */
public class A214269 extends Triangle {

  /** Construct the sequence. */
  public A214269() {
    super(1);
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    b:= proc(n, k, s, t, l) option remember;
          `if`(n<0, 0, `if`(n=0, 1, add(`if`(j=l, 0, b(n-j, k,
           min(s, j), max(t, j), j)), j=max(1, t-k+1)..s+k-1)))
        end:
    A:= proc(n, k) option remember;
          `if`(n=0, 1, add(b(n-j, k+1, j, j, j), j=1..n))
        end:
    T:= (n, k)-> A(n, k) -`if`(k=0, 0, A(n, k-1)):
    seq(seq(T(n, k), k=0..n-1), n=1..14);
  */
  private static final MemoryFunctionInt5<Z> B = new MemoryFunctionInt5<Z>() {
    @Override
    protected Z compute(final int n, final int k, final int s, final int t, final int l) {
      if (n < 0) {
        return Z.ZERO;
      }
      if (n == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      final int jmax = s + k - 1;
      for (int j = Math.max(1, t - k + 1); j <= jmax; ++j) {
        if (j != l) {
          sum = sum.add(get(n - j, k, Math.min(s, j), Math.max(t, j), j));
        }
      }
      return sum;
    }
  };

  protected static final MemoryFunctionInt2<Z> A = new MemoryFunctionInt2<Z>() { // used in A214268
    @Override
    protected Z compute(final int n, final int k) {
      if (n == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (int j = 1; j <= n; ++j) {
        sum = sum.add(B.get(n - j, k + 1, j, j, j));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, final int k) {
    ++n;
    Z result = A.get(n, k);
    if (k != 0) {
      result = result.subtract(A.get(n, k - 1));
    }
    return result;
  }
}
#!queue	A227041	0	->	1	Triangle	--------------------------------
package irvine.oeis.a227;

import irvine.math.LongUtils;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A227041 Triangle of numerators of harmonic mean of n and m, 1 &lt;= m &lt;= n.
 * a(n,m) = 2*n*m/gcd(n+m, 2*n*m)
 * @author Georg Fischer
 */
public class A227041 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int m) {
    ++n;
    ++m;
    return n == 1 ? Z.ONE : new Q(2 * m * n, LongUtils.gcd(n + m, 2 * n * m)).num();
  }
}
#!queue	A228576	0	->	1	Triangle	--------------------------------
package irvine.oeis.a228;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A228576 A triangle formed like generalized Pascal's triangle. The rule is T(n,k) = 2*T(n-1,k-1) + T(n-1,k), the left border is n and the right border is n^2 instead of 1.
 * @author Georg Fischer
 */
public class A228576 extends Triangle {

  /** Construct the sequence. */
  public A228576() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /* T(n, k) = 2*T(n-1, k-1) + T(n-1, k) for n,k >=0, with T(n, 0) = n, T(n,n) = n^2. */
  @Override
  protected Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(n) : (k == n ? Z.valueOf((long) n * n) : get(n - 1, k - 1).multiply2().add(get(n - 1, k)));
  }
}
#!queue	A234575	0	->	1	Triangle	--------------------------------
package irvine.oeis.a234;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A234575 Triangle T(n,k) read by rows: T(n,k) = floor(n/k) + n mod k, with 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A234575 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf(n / k + n % k);
  }
}
#!queue	A236532	0	->	1	Triangle	--------------------------------
package irvine.oeis.a236;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A236532 Triangle T(n,k) read by rows: T(n,k) = floor(n*k/(n+k)), with 1 &lt;= k &lt;= n.
 * @author Georg Fischer
 */
public class A236532 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf(n * (long) k / (n + k));
  }
}
#!queue	A237587	0	->	1	Triangle	--------------------------------
package irvine.oeis.a237;
// Generated by gen_seq4.pl triman/trian1 at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A237587 Triangle read by rows in which row n lists the first n odd squares in decreasing order.
 * @author Georg Fischer
 */
public class A237587 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf(2 * (n - k + 1) - 1).square();
  }
}
#!queue	A244372	0	->	1	Triangle	--------------------------------
package irvine.oeis.a244;

import irvine.math.z.Z;
import irvine.oeis.a299.A299038;
import irvine.oeis.triangle.Triangle;

/**
 * A244372 Number T(n,k) of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) k; triangle T(n,k), n&gt;=1, 0&lt;=k&lt;=n-1, read by rows.
 * @author Georg Fischer
 */
public class A244372 extends Triangle {

  /* Maple: 
    b:= proc(n, i, t, k) as in A299038:
    T:= (n, k)-> b(n-1$2, k$2) -`if`(k=0, 0, b(n-1$2, k-1$2)):
    seq(seq(T(n, k), k=0..n-1), n=1..14);
  */
  protected final A299038 mSeq = new A299038();

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, final int k) {
    ++n;
    Z result = mSeq.b(n - 1, n - 1, k, k);
    if (k > 0) {
      result = result.subtract(mSeq.b(n - 1, n - 1, k - 1, k - 1));
    }
    return result;
  }
}
#!queue	A244454	0	->	1	Triangle	--------------------------------
package irvine.oeis.a244;

import irvine.math.MemoryFunctionInt4;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A244454 Number T(n,k) of unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals k; triangle T(n,k), n&gt;=1, 0&lt;=k&lt;=n-1, read by rows.
 * @author Georg Fischer
 */
public class A244454 extends Triangle {

  private int mN = 0;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    b:= proc(n, i, t, k) option remember; `if`(n=0, `if`(t in [0, k],
          1, 0), `if`(i<1, 0, add(binomial(b((i-1)$2, k$2)+j-1, j)*
          b(n-i*j, i-1, max(0, t-j), k), j=0..n/i)))
        end:
    T:= (n, k)-> b(n-1$2, k$2) -`if`(n=1 and k=0, 0, b(n-1$2, k+1$2)):
    seq(seq(T(n, k), k=0..n-1), n=1..14);
  */
  private final MemoryFunctionInt4<Z> mB = new MemoryFunctionInt4<Z>() {
    @Override
    protected Z compute(final int n, final int i, final int t, final int k) {
      if (n == 0) {
        return t == 0 || t == k ? Z.ONE : Z.ZERO;
      }
      if (i < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int jmax = n / i;
      for (int j = 0; j <= jmax; ++j) {
        sum = sum.add(Binomial.binomial(get(i - 1, i - 1, k, k).add(j - 1), Z.valueOf(j)).multiply(get(n - i * j, i - 1, t - j > 0 ? t - j : 0, k)));
      }
      return sum;
    }
  };

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    Z result = mB.get(n - 1, n - 1, k, k);
    if (n != 0 || k != 0) {
      result = result.subtract(mB.get(n - 1, n - 1, k + 1, k + 1));
    }
    return result;
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return super.next();
  }
}
#!queue	A244530	0	->	1	Triangle	--------------------------------
package irvine.oeis.a244;

import irvine.math.MemoryFunctionInt3;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A244530 Number T(n,k) of ordered unlabeled rooted trees with n nodes such that the minimal outdegree of inner nodes equals k; triangle T(n,k), n&gt;=1, 0&lt;=k&lt;=n-1, read by rows.
 * @author Georg Fischer
 */
public class A244530 extends Triangle {

  private int mN = 0;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    b:= proc(n, t, k) option remember; `if`(n=0, `if`(t in [0, k],
           1, 0), `if`(t>n, 0, add(b(j-1, k$2)*
           b(n-j, max(0, t-1), k), j=1..n)))
        end:
    T:= (n, k)-> b(n-1, k$2) -`if`(n=1 and k=0, 0, b(n-1, k+1$2)):
    seq(seq(T(n, k), k=0..n-1), n=1..14);
  */
  private final MemoryFunctionInt3<Z> mB = new MemoryFunctionInt3<Z>() {
    @Override
    protected Z compute(final int n, final int t, final int k) {
      if (n == 0) {
        return t == 0 || t == k ? Z.ONE : Z.ZERO;
      }
      if (t > n) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      for (int j = 1; j <= n; ++j) {
        sum = sum.add(get(j - 1, k, k).multiply(get(n - j, t - 1 > 0 ? t - 1 : 0, k)));
      }
      return sum;
    }
  };

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    Z result = mB.get(n - 1, k, k);
    if (n != 1 || k != 0) {
      result = result.subtract(mB.get(n - 1, k + 1, k + 1));
    }
    return result;
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return super.next();
  }
}
#!queue	A253184	0	->	1	Triangle	--------------------------------
package irvine.oeis.a253;

import irvine.math.MemoryFunctionInt2;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A253184 Triangle T(n,m) = Sum_{k=1..(n-m)/2} C(m, k)*T((n-m)/2, k), T(n,n)=1.
 * A253190 Triangle T(n, m)=Sum_{k=1..(n-m)/2} C(m+k-1, k)*T((n-m)/2, k)), T(n,n)=1.
 * @author Georg Fischer
 */
public class A253184 extends Triangle {

  /** Construct the sequence. */
  public A253184() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  private final MemoryFunctionInt2<Z> mB = new MemoryFunctionInt2<Z>() {
    @Override
    protected Z compute(final int n, final int m) {
      if (n == m) {
        return Z.ONE;
      }
      if (((n - m) & 1) == 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int kmax = (n - m) / 2;
      for (int k = 1; k <= kmax; ++k) {
        sum = sum.add(Binomial.binomial(m, k).multiply(get(kmax, k)));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return mB.get(n, k);
  }
}
#!queue	A253189	0	->	1	Triangle	--------------------------------
package irvine.oeis.a253;

import irvine.math.MemoryFunctionInt2;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A253189 Triangle T(n, m)=Sum_{k=1..(n-m)/3} C(m, k)*T((n-m)/3, k)), T(n,n)=1.
 * @author Georg Fischer
 */
public class A253189 extends Triangle {

  /** Construct the sequence. */
  public A253189() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  private final MemoryFunctionInt2<Z> mB = new MemoryFunctionInt2<Z>() {
    @Override
    protected Z compute(final int n, final int m) {
      if (n == m) {
        return Z.ONE;
      }
      if ((n - m) % 3 != 0) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int kmax = (n - m) / 3;
      for (int k = 1; k <= kmax; ++k) {
        sum = sum.add(Binomial.binomial(m, k).multiply(get(kmax, k)));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return mB.get(n, k);
  }
}
#!queue	A253190	0	->	1	Triangle	--------------------------------
package irvine.oeis.a253;

import irvine.math.MemoryFunctionInt2;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A253190 Triangle T(n, m)=Sum_{k=1..(n-m)/2} C(m+k-1, k)*T((n-m)/2, k)), T(n,n)=1.
 * @author Georg Fischer
 */
public class A253190 extends Triangle {

  /** Construct the sequence. */
  public A253190() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    A253190 := proc(n,m)
        option remember;
        if n = m then
            1;
        elif type(n-m,'odd') then
            0 ;
        else
            add(binomial(m+k-1,k)*procname((n-m)/2,k),k=1..(n-m)/2) ;
        end if;
    end proc: # _R. J. Mathar_, Dec 16 2015
  */
  private final MemoryFunctionInt2<Z> mB = new MemoryFunctionInt2<Z>() {
    @Override
    protected Z compute(final int n, final int m) {
      if (n == m) {
        return Z.ONE;
      }
      if (((n - m) & 1) == 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int kmax = (n - m) / 2;
      for (int k = 1; k <= kmax; ++k) {
        sum = sum.add(Binomial.binomial(m + k - 1, k).multiply(get(kmax, k)));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return mB.get(n, k);
  }
}
#!queue	A264396	0	->	1	Triangle	--------------------------------
package irvine.oeis.a264;

import irvine.math.MemoryFunctionInt2;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A264396 Number of partitions of n such that the part sizes occurring in it form an interval that does not start at 1.
 * @author Georg Fischer
 */
public class A264396 extends Triangle {

  private int mN = 0;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    b:= proc(n, i) option remember; `if`(n=0, `if`(i=0, 0, 1),
          `if`(i<1 or n<i, 0, add(b(n-i*j, i-1), j=1..n/i)))
        end:
    a:= n-> add(b(n, i), i=2..n):
    seq(a(n), n=1..70);  # _Alois P. Heinz_, Nov 29 2015
  */
  private final MemoryFunctionInt2<Z> mB = new MemoryFunctionInt2<Z>() {
    @Override
    protected Z compute(final int n, final int i) {
      if (n == 0) {
        return i == 0 ? Z.ZERO : Z.ONE;
      }
      if (i < 1 || n < i) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int jmax = n / i;
      for (int j = 1; j <= jmax; ++j) {
        sum = sum.add(get(n - i * j, i - 1));
      }
      return sum;
    }
  };

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int i = 2; i <= mN; ++i) {
      sum = sum.add(mB.get(mN, i));
    }
    return sum;
  }
}
#!queue	A265129	0	->	1	Triangle	--------------------------------
package irvine.oeis.a265;
// manually 2021-10-13

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A265129 Triangle read by rows, formed as the sum of the two versions of the natural numbers filling an equilateral triangle. 
 * @author Georg Fischer
 */
public class A265129 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return Z.valueOf(n + 1).square().add(1);
  }
}
#!queue	A274602	0	->	1	Triangle	--------------------------------
package irvine.oeis.a274;
// Generated by gen_seq4.pl modpas2/trian at 2021-11-12 23:48

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A274602 Triangle read by rows: T(n,k) = k*(n-k+1)^2 + n - k, 0 &lt;= k &lt;= n.
 * @author Georg Fischer
 */
public class A274602 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return Z.valueOf(n - k + 1).square().multiply(k).add(n - k);
  }
}
#!queue	A276472	0	->	1	Triangle	--------------------------------
package irvine.oeis.a276;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A276472 Modified Pascal's triangle read by rows: T(n,k) = T(n-1,k) + T(n-1,k-1), 1&lt;k&lt;n. T(n,1) = T(n-1,1) + T(n,2), n&gt;2. T(n,n) = T(n,n-1) + T(n-1,n-1), n&gt;1. T(1,1) = 1, T(2,1) = 1. n&gt;=1.
 * T(n,k) = T(n-1,k) + T(n-1,k-1), 1&lt;k&lt;n.
 * T(n, 1) = T(n-1, 1) + T(n, 2), n&gt;2.
 * T(n,n) = T(n,n-1) + T(n-1,n-1), n&gt;1.
 * T(1, 1) = 1, T(2, 1) = 1. n&gt;=1.
 * @author Georg Fischer
 */
public class A276472 extends Triangle {

  /** Construct the sequence. */
  public A276472() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    if (k == 1) {
      if (n <= 2) {
        return Z.ONE;
      }
      return get(n - 2, k - 1).add(get(n - 1, k));
    }
    if (k == n) {
      return get(n - 1, k - 2).add(get(n - 2, k - 2));
    }
    return get(n - 2, k - 1).add(get(n - 2, k - 2));
  }
}
#!queue	A286563	0	->	1	Triangle	--------------------------------
package irvine.oeis.a286;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A286563 Triangular table T(n,k) read by rows: T(n,1) = 1, and for 1 &lt; k &lt;= n, T(n,k) = the highest exponent e such that k^e divides n.
 * @author Georg Fischer
 */
public class A286563 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    if (k == 1) {
      return Z.ONE;
    } else {
      long e = 1;
      long pow = k;
      while (n % pow == 0) {
        ++e;
        pow *= k;
      }
      return Z.valueOf(e - 1);
    }
  }
}
#!queue	A293600	0	->	1	Triangle	--------------------------------
package irvine.oeis.a293;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A293600 G.f. A(x,y) = Sum_{-oo..+oo} (x - y^n)^(n+1), as a flattened rectangular array of coefficients T(n,k) of x^n * y^(k*(n+k-1)) in A(x,y) for n&gt;=1.
 * @author Georg Fischer
 */
public class A293600 extends Triangle {

  /** Construct the sequence. */
  public A293600() {
    super("1, 1,-2");
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    if (n < 2) {
      return super.compute(n, k);
    } else {
      final Z result = get(n - 1, k - 1).abs().add(get(n - 1, k).abs());
      return (k & 1) == 1 ? result.negate() : result;
    }
  }
}
#!queue	A306547	0	->	1	Triangle	--------------------------------
package irvine.oeis.a306;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A306547 Triangle read by rows, defined by Riordan's general Eulerian recursion: T(n, k) = (k+3)*T(n-1, k) + (n-k-2) * T(n-1, k-1) with T(n,1) = 1, T(n,n) = (-2)^(n-1).
 * @author Georg Fischer
 */
public class A306547 extends Triangle {

  /** Construct the sequence. */
  public A306547() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /* T(n, k) = (k+3)*T(n-1, k) + (n-k-2)*T(n-1, k-1) with T(n, 1) = 1, T(n,n) = (-2)^(n-1) */
  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return k == 1 ? Z.ONE : (k == n ? Z.valueOf(-2).pow(n - 1) : get(n - 2, k - 2).multiply(n - k - 2).add(get(n - 2, k - 1).multiply(k + 3)));
  }
}
#!queue	A316074	0	->	1	Triangle	--------------------------------
package irvine.oeis.a316;

import irvine.math.MemoryFunctionInt3;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A316074 Sequence a_k of column k shifts left k places under Weigh transform and equals signum(n) for n&lt;k; triangle T(n,k), n&gt;=1, 1&lt;=k&lt;=n, read by rows.
 * triangle T(n,k), n&gt;=1, 1&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A316074 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple program:
    b:= proc(n, i, k) option remember; `if`(n=0, 1, `if`(i<1, 0,
      add(binomial(T(i, k), j)*b(n-i*j, i-1, k), j=0..n/i)))
    end:
    T:= (n, k)-> `if`(n<k, signum(n), b(n-k$2, k)):
    seq(seq(T(n, k), k=1..n), n=1..16);
  */
  private final MemoryFunctionInt3<Z> mB = new MemoryFunctionInt3<Z>() {
    @Override
    protected Z compute(final int n, final int i, final int k) {
      if (n == 0) {
        return Z.ONE;
      }
      if (i < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int jmax = n / i;
      for (int j = 0; j <= jmax; ++j) {
        sum = sum.add(Binomial.binomial(i < k ? Z.valueOf(Integer.signum(i)) : mB.get(i - k, i - k, k), Z.valueOf(j))
          .multiply(get(n - i * j, i - 1, k)));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n < k ? Z.valueOf(Integer.signum(n)) : mB.get(n - k, n - k, k);
  }
}
#!queue	A317617	0	->	1	Triangle	--------------------------------
package irvine.oeis.a317;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A317617 Triangle T read by rows: T(n, k) = (n^3 + n)/2 + (k - (n + 1)/2)*(n mod 2).
 * @author Georg Fischer
 */
public class A317617 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf(n * n + 1).multiply(n).add((2 * k - n - 1) * (n & 1)).divide2();
  }
}
#!queue	A318754	0	->	1	Triangle	--------------------------------
package irvine.oeis.a318;

import irvine.math.MemoryFunctionInt3;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A318754 Number T(n,k) of rooted trees with n nodes such that k equals the maximal number of subtrees extending from the same node and having the same number of nodes; triangle T(n,k), n&gt;=1, 0&lt;=k&lt;=n-1, read by rows.
 * @author Georg Fischer
 */
public class A318754 extends Triangle {

  private int mN = 0;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    g:= proc(n, i, k) option remember; `if`(n=0, 1, `if`(i<1, 0, add(
          binomial(g(i-1$2, k)+j-1, j)*g(n-i*j, i-1, k), j=0..min(k, n/i))))
        end:
    T:= (n, k)-> g(n-1$2, k) -`if`(k=0, 0, g(n-1$2, k-1)):
    seq(seq(T(n, k), k=0..n-1), n=1..14);
  */
  private final MemoryFunctionInt3<Z> mB = new MemoryFunctionInt3<Z>() {
    @Override
    protected Z compute(final int n, final int i, final int k) {
      if (n == 0) {
        return Z.ONE;
      }
      if (i < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int ni = n / i;
      final int maxj = k < ni ? k : ni;
      for (int j = 0; j <= maxj; ++j) {
        sum = sum.add(Binomial.binomial(get(i - 1, i - 1, k).add(j - 1), Z.valueOf(j)).multiply(get(n - i * j, i - 1, k)));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return mB.get(n - 1, n - 1, k).subtract(k == 0 ? Z.ZERO : mB.get(n - 1, n - 1, k - 1));
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return super.next();
  }
}
#!queue	A319541	0	->	1	Triangle	--------------------------------
package irvine.oeis.a319;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A319541 Triangle read by rows: T(n,k) is the number of binary rooted trees with n leaves of exactly k colors and all non-leaf nodes having out-degree 2.
 * and all non-leaf nodes having out-degree 2.
 * @author Georg Fischer
 */
public class A319541 extends Triangle {

  /** Construct the sequence. */
  public A319541() {
    super(1);
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    A:= proc(n, k) option remember; `if`(n<2, k*n, `if`(n::odd, 0,
          (t-> t*(1-t)/2)(A(n/2, k)))+add(A(i, k)*A(n-i, k), i=1..n/2))
        end:
    T:= (n, k)-> add((-1)^i*binomial(k, i)*A(n, k-i), i=0..k):
    seq(seq(T(n, k), k=1..n), n=1..12);  # _Alois P. Heinz_, Sep 23 2018
  */
  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    Z sum = Z.ZERO;
    for (int i = 0; i <= k; ++i) {
      final Z term = Binomial.binomial(k, i).multiply(A319539.A.get(n, k - i));
      sum = sum.add(((i & 1) == 0) ? term : term.negate());
    }
    return sum;
  }
}
#!queue	A334312	0	->	1	Triangle	--------------------------------
package irvine.oeis.a334;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.PrependSequence;
import irvine.oeis.a023.A023900;
import irvine.oeis.triangle.Triangle;

/**
 * A334312 Triangle read by rows: T(n,k) = Sum_{i=k..n} A191898(i,k).
 * T(n,k) = Sum_{i=k..n} A023900(gcd(i,k)).
 * @author Georg Fischer
 */
public class A334312 extends Triangle {

  private MemorySequence mSeq = MemorySequence.cachedSequence(new PrependSequence(new A023900(), 1));

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    Z sum = Z.ZERO;
    for (int i = k; i <= n; ++i) {
      sum = sum.add(mSeq.a(IntegerUtils.gcd(i, k)));
    }
    return sum;
  }
}
#!queue	A342186	0	->	1	Triangle	--------------------------------
package irvine.oeis.a342;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A342186 Triangle read by rows, matrix inverse of A139382.
 * @author Georg Fischer
 */
public class A342186 extends Triangle {

  /** Construct the sequence. */
  public A342186() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /* T(n,k) = T(n-1,k-1) - (2^(n-1)-1) * T(n-1,k), n, k >= 1, T(1, 1) = 1, T(n, 0) = 0. */
  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n == k ? Z.ONE : get(n - 2, k - 2).subtract(get(n - 2, k - 1).multiply(Z.ONE.shiftLeft(n - 1).subtract(Z.ONE)));
  }
}
#!queue	A343125	0	->	2	Triangle	--------------------------------
package irvine.oeis.a343;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A343125 Triangle T(k, n) = (n+3)*(k-n) - 4, k &gt;= 2, 1 &lt;= n &lt;= k-1, read by rows.
 * @author Georg Fischer
 */
public class A343125 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int k, int n) {
    ++n;
    k = k + 2;
    return Z.valueOf((n + 3L) * (k - n) - 4);
  }
}
#!queue	A999999	0	0	0	0
