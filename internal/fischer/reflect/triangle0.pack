#!queue	A053218	0	->	1	Triangle	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A053218 Triangle read by rows: T(n,k) = T(n,k-1) + T(n-1,k-1) for k &gt;= 2 with T(n,1) = 1.
 * @author Georg Fischer
 */
public class A053218 extends Triangle {

  /** Construct the sequence. */
  public A053218() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(n + 1) : get(n, k - 1).add(get(n - 1, k - 1));
  }
}
#!queue	A054098	0	->	1	Triangle	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A054098 Triangular array generated by its row sums: T(n,0)=1 for n &gt;= 0, T(1,1)=2, T(n,k)=T(n,k-1)+d*r(n-k) for k=2,3,...,n, d=(-1)^(k+1), n &gt;= 2, r(h)=sum of the numbers in row h of T.
 * T(n, 0)=1 for n &gt;= 0, T(1, 1)=2,
 * T(n,k)=T(n,k-1)+d*r(n-k) for k=2, 3,...,n, d=(-1)^(k+1),
 * n &gt;= 2, r(h)=sum of the numbers in row h of T.
 * @author Georg Fischer
 */
public class A054098 extends Triangle {

  private Z mTerm;

  /** Construct the sequence. */
  public A054098() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  /**
   * Compute a row sum
   * @param n number of the row
   * @return row sum
   */
  private Z rowSum(final int n) {
    Z sum = Z.ZERO;
    for (int j = 0; j <= n; ++j) {
      sum = sum.add(get(n, j));
    }
    return sum;
  }

  @Override
  public Z compute(final int n, final int k) {
    if (k == 0) {
      mTerm = Z.ONE;
    } else if (k == 1) {
      if (n == 1) {
        mTerm = Z.TWO;
      } else {
        mTerm = rowSum(n - 1);
      }
    } else {
      mTerm = mTerm.add(rowSum(n - k).multiply((((k + 1) & 1) == 0) ? 1 : -1));
    }
    return mTerm;
  }
}
#!queue	A055096	0	->	2	Triangle	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A055096 Triangle read by rows, sums of 2 distinct nonzero squares: T(n,k) = k^2+n^2, (n&gt;=2, 1 &lt;= k &lt;= n-1).
 * @author Georg Fischer
 */
public class A055096 extends Triangle {

  /** Construct the sequence. */
  public A055096() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n + 2).multiply(n + 2).add((k + 1) * (k + 1));
  }
}
#!queue	A055215	0	->	1	Triangle	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A055215 A path-counting array, read by rows: T(i,j)=number of paths from (0,0) to (i-j,j) using steps (1 unit right and 1 unit up) or (1 unit right and 2 units up).
 * T(i, 0)=T(i, i)=1 for i &gt;= 0; T(i, 1)=1 for i &gt;= 1; T(i, j)=T(i-2, j-1)+T(i-3, j-2) for 2&lt;=j&lt;=i-1, i &gt;= 3.
 * @author Georg Fischer
 */
public class A055215 extends Triangle {

  /** Construct the sequence. */
  public A055215() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int i, final int j) {
    if (j <= 1 || j == i) {
      return Z.ONE;
    }
    return get(i - 2, j - 1).add(get(i - 3, j - 2));
  }
}
#!queue	A055302	0	->	1	Triangle	--------------------------------
package irvine.oeis.a055;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A055302 Triangle of number of labeled rooted trees with n nodes and k leaves, n &gt;= 1, 1 &lt;= k &lt;= n.
 * T(n,k) = (n!/k!)*Stirling2(n-1, n-k).
 * @author Georg Fischer
 */
public class A055302 extends Triangle {

  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;

  /** Construct the sequence. */
  public A055302() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return FACTORIAL.factorial(n + 1).divide(FACTORIAL.factorial(k + 1)).multiply(Stirling.secondKind(n, n - k));
  }
}
#!queue	A055314	0	->	2	Triangle	--------------------------------
package irvine.oeis.a055;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A055314 Triangle T(n,k) read by rows: number of labeled trees with n nodes and k leaves, n &gt;= 2, 2 &lt;= k &lt;= n.
 * T(n, k) = (n!/k!)*Stirling2(n-2, n-k).
 * @author Georg Fischer
 */
public class A055314 extends Triangle {

  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;

  /** Construct the sequence. */
  public A055314() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return FACTORIAL.factorial(n + 2).divide(FACTORIAL.factorial(k + 2)).multiply(Stirling.secondKind(n, n - k));
  }
}
#!queue	A055356	0	->	1	Triangle	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A055356 Triangle of increasing mobiles (circular rooted trees) with n nodes and k leaves. 
 * @author Georg Fischer
 */
public class A055356 extends Triangle {

  /** Construct the sequence. */
  public A055356() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return n == 0 ? Z.ONE : get(n - 1, k).multiply(k + 1).add(get(n - 1, k - 1).multiply(n - 1));
  }
}
#!queue	A055864	0	->	1	Triangle	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A055864 Coefficient triangle for certain polynomials.
 * a(n, m)=0 if n &lt; m; a(n, m)= n^(m-1)*(n+1)^(n-m), n &gt;= m &gt;= 1;
 * @author Georg Fischer
 */
public class A055864 extends Triangle {

  /** Construct the sequence. */
  public A055864() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    if (n == 0) {
      return Z.ONE;
    }
    if (n < k) {
      return Z.ZERO;
    }
    return Z.valueOf(n + 1).pow(k).multiply(Z.valueOf(n + 2).pow(n - k));
  }
}
#!queue	A056023	0	->	1	Triangle	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A056023 The positive integers written as a triangle, where row n is written from right to left if n is odd and otherwise from left to right.
 * (1) every positive integer occurs exactly once;
 * (2) row n consists of n consecutive numbers;
 * (3) odd-numbered rows are decreasing;
 * (4) even-numbered rows are increasing; and
 * (5) column 1 is increasing.
 * T(n, k) = (n^2 - (n - 2*k)*(-1)^(n mod 2))/2 + n mod 2.
 * @author Georg Fischer
 */
public class A056023 extends Triangle {

  /** Construct the sequence. */
  public A056023() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return Z.valueOf((n * n - (n - 2 * k) * (((n & 1) == 0) ? 1 : -1)) / 2 + (n & 1));
  }
}
#!queue	A056203	0	->	1	Triangle	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A056203 Triangle of numbers related to congruum problem: T(n,k)=n^2+2nk-k^2 with n&gt;k&gt;0, starting at T(2,1)=7.
 * @author Georg Fischer
 */
public class A056203 extends Triangle {

  /** Construct the sequence. */
  public A056203() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    n += 2;
    ++k;
    return Z.valueOf(n).square().add(2 * n * k).subtract(k * k);
  }
}
#!queue	A056951	0	->	1	Triangle	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A056951 Triangle whose rows show the result of flipping the first, first two, ... and finally first n coins when starting with the stack (1,2,3,4,...,n) [starting with all heads up, where signs show whether particular coins end up heads or tails].
 * @author Georg Fischer
 */
public class A056951 extends Triangle {

  /** Construct the sequence. */
  public A056951() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    if (n == 1) {
      return Z.valueOf(-n);
    } else if (n == k) {
      return Z.valueOf(n - 1);
    } else {
      return Z.valueOf(2 * k - n - (2 * k <= n + 1 ? 2 : 1));
    }
  }
}
#!queue	A057027	0	->	1	Triangle	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A057027 Triangle T read by rows: row n consists of the numbers C(n,2)+1 to C(n+1,2); numbers in odd-numbered places form an increasing sequence and the others a decreasing sequence.
 * numbers in odd-numbered places form an increasing sequence and the others a decreasing sequence.
 * @author Georg Fischer
 */
public class A057027 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  private int mRow = 0;

  @Override
  protected void addRow() {
    super.addRow();
    long head = mRow * (mRow + 1) / 2 + 1;
    ++mRow;
    long tail = mRow * (mRow + 1) / 2;
    // System.out.println("addRow, mRow=" + mRow + ", head=" + head + ", tail=" + tail);
    int col = 0;
    while (col < mRow) {
      mLastRow[col++] = Z.valueOf(head++);
      if (col < mRow) {
        mLastRow[col++] = Z.valueOf(tail--);
      }
    }
  }

  @Override
  protected Z compute(final int n, final int k) {
    return n == 0 ? Z.ONE : get(n, k);
  }
}
#!queue	A059369	0	->	1	Triangle	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A059369 Triangle of numbers T(n,k) = T(n-1,k-1) + ((n+k-1)/k)*T(n-1,k), n &gt;= 1, 1 &lt;= k &lt;= n, with T(n,1) = n!, T(n,n) = 1; read from right to left.
 * @author Georg Fischer
 */
public class A059369 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return n == 0 ? Z.ONE : get(n - 1, k - 1).multiply(2L * n - k + 1).divide(n - k + 1).add(get(n - 1, k));
  }
}
#!queue	A060642	0	->	1	Triangle	--------------------------------
package irvine.oeis.a060;

import irvine.factor.factor.Jaguar;
import irvine.math.MemoryFunction2;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A060642 Triangle read by rows: row n lists number of ordered partitions into k parts of partitions of n.
 * @author Georg Fischer
 */
public class A060642 extends Triangle {

  /** Construct the sequence. */
  public A060642() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    A:= proc(n, k) option remember; `if`(n=0, 1, k*add(
          A(n-j, k)*numtheory[sigma](j), j=1..n)/n)
        end:
    T:= (n, k)-> add(A(n, k-i)*(-1)^i*binomial(k, i), i=0..k):
    seq(seq(T(n, k), k=1..n), n=1..12);  # _Alois P. Heinz_, Mar 12 2015
  */
  private final MemoryFunction2<Integer, Z> mA = new MemoryFunction2<Integer, Z>() {
    @Override
    protected Z compute(final Integer n, final Integer k) {
      if (n == 0) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      for (int j = 1; j <= n; ++j) {
        sum = sum.add(get(n - j, k).multiply(Jaguar.factor(j).sigma()));
      }
      return sum.multiply(k).divide(n);
    }
  };

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    Z sum = Z.ZERO;
    for (int i = 0; i <= k; ++i) {
      sum = sum.add(mA.get(n, k - i).multiply(Binomial.binomial(k, i)).multiply(((i & 1) == 0) ? 1 : -1));
    }
    return sum;
  }
}
#!queue	A062169	0	->	1	Triangle	--------------------------------
package irvine.oeis.a062;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A062169 Triangle T(n, k) = k! mod n for n &gt;= 1, 1 &lt;= k &lt;= n.
 * @author Georg Fischer
 * @author Sean A. Irvine
 */
public class A062169 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int m, final int r) {
    final long n = m + 1;
    final long k = r + 1;
    long f = 1 % n;
    for (long j = 2; j <= k && f != 0; ++j) {
      f *= j;
      f %= n;
    }
    return Z.valueOf(f);
  }
}
#!queue	A070216	0	->	1	Triangle	--------------------------------
package irvine.oeis.a070;
// Generated by gen_seq4.pl trisimple at 2021-11-08 22:02

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A070216 Triangle T(n, k) = n^2 + k^2, 1 &lt;= k &lt;= n, read by rows.
 * @author Georg Fischer
 */
public class A070216 extends Triangle {

  /** Construct the sequence. */
  public A070216() {
    super(1);
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n + 1).square().add(Z.valueOf(k + 1).square());
  }
}
#!queue	A074147	0	->	1	Triangle	--------------------------------
package irvine.oeis.a074;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A074147 (2n-1) odd numbers followed by 2n even numbers.
 *
 * @author Georg Fischer
 */
public class A074147 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n).square().add(1).divide2().add(1 + 2 * k);
  }
}
#!queue	A075497	0	->	1	Triangle	--------------------------------
package irvine.oeis.a075;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A075497 Stirling2 triangle with scaled diagonals (powers of 2).
 * a(n, m) = 2*m*a(n-1, m) + a(n-1, m-1), n &gt;= m &gt;= 1, else 0, with a(n, 0) := 0 and a(1, 1)=1.
 * @author Georg Fischer
 */
public class A075497 extends Triangle {

  protected int mPower;

  /** Construct the sequence. */
  public A075497() {
    this(2);
  }

  /**
   * Generic constructor with parameters
   * @param power exponent
   */
  public A075497(final int power) {
    setOffset($(OFFSET));
    hasRAM(false);
    mPower = power;
  }

  @Override
  public Z compute(final int n, final int k) {
    if (n == 0) {
      return Z.ONE;
    }
    return get(n - 1, k).multiply(mPower * (long) (k + 1)).add(get(n - 1, k - 1));
  }
}
#!queue	A075856	0	->	1	Triangle	--------------------------------
package irvine.oeis.a075;
// Generated by gen_seq4.pl trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A075856 Triangle formed from coefficients of the polynomials p(1)=x, p(n+1) = (n + x*(n+1))*p(n) + x*x*(d/dx)p(n).
 * @author Georg Fischer
 */
public class A075856 extends Triangle {

  /** Construct the sequence. */
  public A075856() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n == 1 ? Z.ONE : get(n - 2, k - 2).multiply(n + k - 1).add(get(n - 2, k - 1).multiply(n - 1));
  }
}
#!queue	A076014	0	->	1	Triangle	--------------------------------
package irvine.oeis.a076;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A076014 Triangle in which m-th entry of n-th row is m^(n-1). 
 * @author Georg Fischer
 */
public class A076014 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return n == 0 ? Z.ONE : Z.valueOf(k + 1).pow(n);
  }
}
#!queue	A079510	0	->	1	Triangle	--------------------------------
package irvine.oeis.a079;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A079510 Triangle T(n,k) read by rows; related to number of preorders.
 * T[n_, k_]:= ... If[n==1 &amp;&amp; k==1, 1, n*(T[n-1, k-1] + T[n-2, k-1])]];
 * @author Georg Fischer
 */
public class A079510 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    if (n == 0) {
      return Z.ONE;
    } else if (k == 0) {
      return Z.ZERO;
    }
    return get(n - 1, k - 1).add(get(n - 2, k - 1)).multiply(n + 1);
  }
}
#!queue	A080510	0	->	1	Triangle	--------------------------------
package irvine.oeis.a080;

import irvine.math.MemoryFunction2;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A080510 Triangle read by rows: T(n,k) gives the number of set partitions of {1,...,n} with maximum block length k.
 * @author Georg Fischer
 */
public class A080510 extends Triangle {

  /** Construct the sequence. */
  public A080510() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Maple:
    b:= proc(n, i) option remember; `if`(n=0, 1, `if`(i<1, 0,
           add(b(n-i*j, i-1) *n!/i!^j/(n-i*j)!/j!, j=0..n/i)))
        end:
    T:= (n, k)-> b(n, k) -b(n, k-1):
    seq(seq(T(n, k), k=1..n), n=1..12);  # _Alois P. Heinz_, Apr 20 2012
  */
  private final MemoryFunction2<Integer, Z> mB = new MemoryFunction2<Integer, Z>() {
    @Override
    protected Z compute(final Integer n, final Integer i) {
      if (n == 0) {
        return Z.ONE;
      }
      if (i < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int jmax = n / i;
      for (int j = 0; j <= jmax; ++j) {
        sum = sum.add(get(n - i * j, i - 1).multiply(MemoryFactorial.SINGLETON.factorial(n))
          .divide(MemoryFactorial.SINGLETON.factorial(i).pow(j))
          .divide(MemoryFactorial.SINGLETON.factorial(n - i * j))
          .divide(MemoryFactorial.SINGLETON.factorial(j)));
      }
      return sum;
    }
  };

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return mB.get(n, k).subtract(mB.get(n, k - 1));
  }
}
#!queue	A081720	0	->	1	Triangle	--------------------------------
package irvine.oeis.a081;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A081720 Triangle T(n,k) read by rows, giving number of bracelets (turnover necklaces) with n beads of k colors (n &gt;= 1, 1 &lt;= k &lt;= n).
 * Adapted from Maple.
 * @author Georg Fischer
 */
public class A081720 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  /* Caution, this method is used in A276550! */
  @Override
  public Z compute(int n, int k) {
    ++n; // offset 1, 1
    ++k;
    Z sum = Z.ZERO;
    final Z zk = Z.valueOf(k);
    for (final Z d : Jaguar.factor(n).divisors()) {
      sum = sum.add(Euler.phi(d).multiply(zk.pow(n / d.intValue())));
    }
    if ((n & 1) == 0) {
      sum = sum.add(zk.add(1).multiply(zk.pow(n / 2)).multiply(n / 2));
    } else {
      sum = sum.add(Z.valueOf(n).multiply(zk.pow((n + 1) / 2)));
    }
    return sum.divide(2L * n);
  }
}
#!queue	A083487	0	->	1	Triangle	--------------------------------
package irvine.oeis.a083;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A083487 Triangle read by rows: T(r,c) = 2*r*c + r + c (1 &lt;= c &lt;= r).
 * @author Georg Fischer
 */
public class A083487 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(2 * (n + 1) * (k + 1) + n + 1 + k + 1);
  }
}
#!queue	A085383	0	->	1	Triangle	--------------------------------
package irvine.oeis.a085;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A085383 Triangle read by rows, 1 &lt;= k &lt;= n: T(n,k) = floor(n/k)*ceiling(n/k).
 * @author Georg Fischer
 */
public class A085383 extends Triangle {

  /** Construct the sequence. */
  public A085383() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    ++n;
    ++k;
    return n == 1 ? Z.ONE : new Q(n, k).ceiling().multiply(n / k);
  }
}
#!queue	A085916	0	->	1	Triangle	--------------------------------
package irvine.oeis.a085;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A085916 Array T(i,1)=i, T(1,j)=j and T(i,j)=T(i-1,j-1)*T(i,j-1) read by antidiagonals.
 * @author Georg Fischer
 */
public class A085916 extends Triangle {

  /** Construct the sequence. */
  public A085916() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int i, final int j) {
    if (j == 0) {
      return Z.valueOf(i + 1);
    } else if (i == j) {
      return Z.valueOf(j + 1);
    } else {
      return get(i - 1, j).multiply(get(i - 2, j - 1));
    }
  }
}
#!queue	A086800	0	->	1	Triangle	--------------------------------
package irvine.oeis.a086;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000040;
import irvine.oeis.triangle.Triangle;

/**
 * A086800 Triangle read by rows in which row n lists differences between prime(n) and prime(k) for 1 &lt;= k &lt;= n.
 * @author Georg Fischer
 */
public class A086800 extends Triangle {

  private final MemorySequence mSeq = MemorySequence.cachedSequence(new A000040());

  /** Construct the sequence. */
  public A086800() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return n == k ? Z.ZERO : mSeq.a(n).subtract(mSeq.a(k));
  }
}
#!queue	A087322	0	->	1	Triangle	--------------------------------
package irvine.oeis.a087;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A087322 Triangle T read by rows: T(n, 1) = 2*n + 1. For 1 &lt; k &lt;= n, T(n, k) = 2*T(n,k-1) + 1.
 * @author Georg Fischer
 */
public class A087322 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf(2 * n + 3) : get(n, k - 1).multiply2().add(1);
  }
}
#!queue	A087854	0	->	1	Triangle	--------------------------------
package irvine.oeis.a087;

import irvine.factor.factor.Jaguar;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Euler;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A087854 Triangle read by rows: T(n,k) is the number of n-bead necklaces with exactly k different colored beads.
 * T(n,k) = (k!/n) * Sum_{d|n} phi(d) * S2(n/d, k)
 * @author Georg Fischer
 */
public class A087854 extends Triangle {

  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;

  /** Construct the sequence. */
  public A087854() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    if (n == 0) {
      return Z.ONE;
    }
    ++n;
    ++k;
    Z sum = Z.ZERO;
    for (final Z zd : Jaguar.factor(n).divisors()) {
      final int d = zd.intValue();
      sum = sum.add(Stirling.secondKind(n / d, k).multiply(Euler.phiAsLong(d)));
    }
    return sum.multiply(FACTORIAL.factorial(k)).divide(n);
  }
}
#!queue	A090971	0	->	1	Triangle	--------------------------------
package irvine.oeis.a090;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A090971 Sierpi\u0144ski's triangle, read by rows, starting from 1: T(n,k) = (T(n-1,k) + T(n-1,k-1)) mod 2.
 * @author Georg Fischer
 */
public class A090971 extends Triangle {

  /** Construct the sequence. */
  public A090971() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  public Z compute(final int n, final int k) {
    return k == 0 ? Z.valueOf((n + 1) & 1) : (k == n ? Z.ONE : get(n - 1, k - 1).add(get(n - 1, k)).mod(Z.TWO));
  }
}
#!queue	A091441	0	->	1	Triangle	--------------------------------
package irvine.oeis.a091;
// Generated by gen_seq4.pl trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A091441 Table (by antidiagonals) of permutations of two types of objects such that each cycle contains at least one object of each type. Each type of object is labeled from its own label set.
 * @author Georg Fischer
 */
public class A091441 extends Triangle {

  /** Construct the sequence. */
  public A091441() {
    setOffset($(OFFSET));
    hasRAM(false);
  }

  @Override
  protected Z compute(int n, int k) {
    ++n;
    ++k;
    return n == 1 ? Z.ONE : get(n - 2, k - 2).multiply(k).add(get(n - 2, k - 1).multiply(n - k + 1));
  }
}
#!queue	A092283	0	->	1	Triangle	--------------------------------
package irvine.oeis.a092;
// Generated by gen_seq4.pl trisimple at 2021-11-08 22:02

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A092283 Triangular array read by rows: T(n,k)=n+k^2, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A092283 extends Triangle {

  /** Construct the sequence. */
  public A092283() {
    super(1);
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n + 1).add((k + 1) * (k + 1));
  }
}
#!queue	A092477	0	->	1	Triangle	--------------------------------
package irvine.oeis.a092;
// Generated by gen_seq4.pl modpas2/trian at 2021-11-12 23:48

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A092477 Triangle read by rows: T(n,k) = (2^k - 1)^n, 1&lt;=k&lt;=n.
 * @author Georg Fischer
 */
public class A092477 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return Z.ONE.shiftLeft(k + 1).subtract(1).pow(n + 1);
  }
}
#!queue	A093898	0	->	1	Triangle	--------------------------------
package irvine.oeis.a093;
// Generated by gen_seq4.pl trisimple at 2021-11-08 22:02

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A093898 Triangle read by rows: T(n,r) = n^r + r^n (1 &lt;= r &lt;= n).
 * @author Georg Fischer
 */
public class A093898 extends Triangle {

  /** Construct the sequence. */
  public A093898() {
    super(1);
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n + 1).pow(k + 1).add(Z.valueOf(k + 1).pow(n + 1));
  }
}
#!queue	A093995	0	->	1	Triangle	--------------------------------
package irvine.oeis.a093;
// Generated by gen_seq4.pl triman/trian1 at 2021-10-31 22:17

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A093995 n^2 repeated n times, triangle read by rows.
 * @author Georg Fischer
 */
public class A093995 extends Triangle {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    setOffset($(OFFSET));
    hasRAM(true);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return Z.valueOf(n + 1).square();
  }
}
#!queue	A999999	0	0	0	0
