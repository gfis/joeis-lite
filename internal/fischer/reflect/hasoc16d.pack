#!queue	A000003	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000003 Number of classes of primitive positive definite binary quadratic forms of discriminant D = -4n; or equivalently the class number of the quadratic order of discriminant D = -4n.
 * @author Sean A. Irvine
 */
public class A000003 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000003() {
    super(1);
  }

  private long mD = 0;

  // Cf. Cohen 5.3.5 and implementation in LongUtils.
  // This one has primitiveness check

  @Override
  public Z next() {
    mD -= 4;
    return Z.valueOf(LongUtils.classNumber(mD));
  }
}
#!queue	A000005	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000005 d(n) (also called tau(n) or sigma_0(n)), the number of divisors of n.
 * @author Sean A. Irvine
 */
public class A000005 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000005() {
    super(1);
  }

  protected long mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(++mN).sigma0();
  }
}

#!queue	A000010	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000010 Euler totient function phi(n): count numbers &lt;= n and prime to n.
 * @author Sean A. Irvine
 */
public class A000010 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000010() {
    super(1);
  }

  protected long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(Euler.phiAsLong(++mN));
  }
}

#!queue	A000011	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;

/**
 * A000011 Number of n-bead necklaces (turning over is allowed) where complements are equivalent.
 * @author Sean A. Irvine
 */
public class A000011 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000011() {
    super(0);
  }

  private int mN = -1;
  private final Sequence mA000013 = new A000013();

  @Override
  public Z next() {
    return mA000013.next().add(Z.ONE.shiftLeft(++mN / 2)).divide2();
  }
}

#!queue	A000013	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000013 Definition (1): Number of n-bead binary necklaces with beads of 2 colors where the colors may be swapped but turning over is not allowed.
 * @author Sean A. Irvine
 */
public class A000013 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000013() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN < 1) {
      return Z.ONE;
    }
    final Z n = Z.valueOf(mN);
    Z sum = Z.ZERO;
    // divisors below does not include 1
    for (final Z d : Jaguar.factor(n).divisors()) {
      final int ld = d.intValue();
      sum = sum.add(Z.valueOf(Euler.phiAsLong(2L * ld)).shiftLeft(mN / ld));
    }
    return sum.divide(2L * mN);
  }
}

#!queue	A000016	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000016 a(n) is the number of distinct (infinite) output sequences from binary n-stage shift register which feeds back the complement of the last stage.
 * @author Sean A. Irvine
 */
public class A000016 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000016() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN < 3) {
      return Z.ONE;
    }
    final Z n = Z.valueOf(mN);
    final FactorSequence fs = Jaguar.factor(n);
    Z sum = Z.ZERO;
    for (final Z d : fs.divisors()) {
      final int i = d.intValue();
      if ((i & 1) == 1) {
        sum = sum.add(Z.valueOf(Euler.phiAsLong(i)).shiftLeft(mN / i));
      }
    }
    return sum.divide(2L * mN);
  }
}

#!queue	A000025	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.IntegerUtils;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000025 Coefficients of the 3rd order mock theta function f(q).
 * @author Sean A. Irvine
 */
public class A000025 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000025() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final int h = IntegerUtils.sqrt(mN);
    Z c = Z.ZERO;
    for (int k = 1; k <= h; ++k) {
      Polynomial<Z> den = RING.add(RING.one(), RING.monomial(Z.ONE, mN - k * k + 1));
      for (int j = 1; j <= k; ++j) {
        den = RING.multiply(den, RING.add(RING.one(), RING.monomial(Z.ONE, j)));
      }
      c = c.add(RING.coeff(RING.monomial(Z.ONE, k * k), RING.pow(den, 2), mN));
    }
    return c;
  }
}

#!queue	A000029	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000029 Number of necklaces with n beads of 2 colors, allowing turning over (these are also called bracelets).
 * @author Sean A. Irvine
 */
public class A000029 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000029() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN < 4) {
      return Z.valueOf(mN + 1);
    }
    Z sum = Z.ZERO;
    for (final Z d : Jaguar.factor(mN).divisors()) {
      sum = sum.add(Euler.phi(d).shiftLeft(mN / d.longValue()));
    }
    sum = sum.divide(2L * mN);
    if ((mN & 1) == 0) {
      sum = sum.add(Z.THREE.shiftLeft(mN / 2 - 2));
    } else {
      sum = sum.add(Z.ONE.shiftLeft((mN - 1) / 2));
    }
    return sum;
  }

}

#!queue	A000031	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000031 Number of n-bead necklaces with 2 colors when turning over is not allowed; also number of output sequences from a simple n-stage cycling shift register; also number of binary irreducible polynomials whose degree divides n.
 * @author Sean A. Irvine
 */
public class A000031 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000031() {
    super(0);
  }

  protected int mN = -1;

  @Override
  public Z next() {
    if (++mN < 4) {
      return Z.valueOf(mN + 1);
    }
    Z sum = Z.ZERO;
    for (final Z d : Jaguar.factor(mN).divisors()) {
      sum = sum.add(Euler.phi(d).shiftLeft(mN / d.longValue()));
    }
    return sum.divide(mN);
  }

}

#!queue	A000037	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000037 Numbers that are not squares (or, the nonsquares).
 * @author Sean A. Irvine
 */
public class A000037 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000037() {
    super(1);
  }

  private long mN = 1;

  @Override
  public Z next() {
    while (true) {
      final long s = LongUtils.sqrt(++mN);
      if (s * s != mN) {
        break;
      }
    }
    return Z.valueOf(mN);
  }
}

#!queue	A000041	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000041 a(n) is the number of partitions of n (the partition numbers).
 * @author Sean A. Irvine
 */
public class A000041 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000041() {
    super(0);
  }

  protected int mN = -1;

  @Override
  public Z next() {
    return IntegerPartition.partitions(++mN);
  }
}

#!queue	A000043	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000043 Mersenne exponents: primes p such that 2^p - 1 is prime. Then 2^p - 1 is called a Mersenne prime.
 * @author Sean A. Irvine
 */
public class A000043 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000043() {
    super(1);
  }

  private final Fast mPrime = new Fast(); // this knows about Mersenne primes
  private long mN = 1;
  private Z mZ = Z.ONE;

  @Override
  public Z next() {
    while (true) {
      mZ = mZ.multiply2().add(1); // mZ = 11111... in binary
      if (mPrime.isPrime(++mN) && mPrime.isPrime(mZ)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A000046	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.util.array.LongDynamicArray;

/**
 * A000046 Number of primitive n-bead necklaces (turning over is allowed) where complements are equivalent.
 * @author Sean A. Irvine
 */
public class A000046 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000046() {
    super(0);
  }

  private long mN = -1;
  private final LongDynamicArray<Z> mA11Cache = new LongDynamicArray<>();
  private final Sequence mA11 = new A000011();

  private Z a11(final long v) {
    while (mA11Cache.length() <= v) {
      mA11Cache.set(mA11Cache.length(), mA11.next());
    }
    return mA11Cache.get(v);
  }

  @Override
  public Z next() {
    if (++mN < 4) {
      return Z.ONE;
    }
    final FactorSequence fs = Jaguar.factor(mN);
    Z sum = a11(mN);
    for (final Z d : fs.divisors()) {
      final long dd = d.longValue();
      if (dd == 1) {
        continue;
      }
      sum = ZUtils.mobiusAdd(Mobius.mobius(dd), sum, a11(mN / dd));
    }
    return sum;
  }

}

#!queue	A000048	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A000048 Number of n-bead necklaces with beads of 2 colors and primitive period n, when turning over is not allowed but the two colors can be interchanged.
 * @author Sean A. Irvine
 */
public class A000048 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000048() {
    super(0);
  }

  protected int mN = -1;

  @Override
  public Z next() {
    if (++mN < 4) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (final Z d : Jaguar.factor(mN).divisors()) {
      final int dd = d.intValue();
      if ((dd & 1) == 1) {
        final Z t = Z.ONE.shiftLeft(mN / dd);
        sum = ZUtils.mobiusAdd(Mobius.mobius(dd), sum, t);
      }
    }
    return sum.divide(2L * mN);
  }

}

#!queue	A000051	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000051 a(n) = 2^n + 1.
 * @author Sean A. Irvine
 */
public class A000051 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000051() {
    super(0);
  }

  private Z mN = Z.ONE;

  @Override
  public Z next() {
    final Z r = mN.add(1);
    mN = mN.multiply2();
    return r;
  }
}

#!queue	A000055	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;

/**
 * A000055 Number of trees with n unlabeled nodes.
 * @author Sean A. Irvine
 */
public class A000055 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000055() {
    super(0);
  }

  private final MemorySequence mB = new A000081(0);

  @Override
  public Z next() {
    final int n = mB.size();
    mB.next();
    if (n < 4) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k <= n; ++k) {
      sum = sum.add(mB.a(k).multiply(mB.a(n - k)));
    }
    if ((n & 1) == 0) {
      sum = sum.subtract(mB.a(n / 2));
    }
    return mB.a(n).subtract(sum.divide2());
  }

}

#!queue	A000058	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000058 Sylvester's sequence: a(n+1) = a(n)^2 - a(n) + 1, with a(0) = 2.
 * @author Sean A. Irvine
 */
public class A000058 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000058() {
    super(0);
  }

  private Z mN = null;

  @Override
  public Z next() {
    if (mN == null) {
      mN = Z.TWO;
    } else {
      mN = mN.square().subtract(mN).add(1);
    }
    return mN;
  }
}

#!queue	A000061	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;
import java.util.HashMap;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.LongUtils;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000061 Generalized tangent numbers d(n,1).
 * @author Sean A. Irvine
 */
public class A000061 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000061() {
    super(1);
  }

  protected int mT = 0;
  private final HashMap<String, Z> mCache = new HashMap<>();

  private Z bigDbn(final long b, final long n) {
    if (b == 1) {
      return (n & 1) == 0 ? Z.NEG_ONE : Z.ONE;
    }
    Z sum = Z.ZERO;
    if ((b & 3) == 1) {
      for (long k = 1; k <= (b - 1) / 2; ++k) {
        sum = sum.add(Z.valueOf(b - 4 * k).pow(2 * n - 1).multiply(LongUtils.jacobi(k, b)));
      }
    } else {
      long k = 1;
      while (k < b) {
        sum = sum.add(Z.valueOf(b - k).pow(2 * n - 1).multiply(LongUtils.jacobi(b, k)));
        k += 2;
      }
    }
    return (n & 1) == 0 ? sum.negate() : sum;
  }

  private Z[] handleFactors(final long a, final long n) {
    Z mz = Z.ONE;
    Z bz = Z.ONE;
    final FactorSequence fs = Jaguar.factor(a);
    final ArrayList<Z> p = new ArrayList<>();
    for (final Z f : fs.toZArray()) {
      final int e = fs.getExponent(f);
      if ((e & 1) == 1) {
        bz = bz.multiply(f);
        if ((e - 1) / 2 > 0) {
          mz = mz.multiply(f.pow((e - 1) / 2));
          p.add(f);
        }
      } else {
        mz = mz.multiply(f.pow(e / 2));
        p.add(f);
      }
    }
    Z prod2 = Z.ONE;
    final long b = bz.longValue();
    long prod1 = mz.longValue();
    for (final Z piz : p) {
      final long pi = piz.longValue();
      if ((pi & 1) == 1) {
        prod1 /= pi;
        if (b == 1) {
          prod2 = prod2.multiply(piz.pow(2 * n).subtract(Z.ONE));
        } else {
          prod2 = prod2.multiply(piz.pow(2 * n).subtract(LongUtils.jacobi(b, pi)));
        }
      }
    }
    final Z r = prod2.multiply(Z.valueOf(prod1).pow(2 * n)).multiply(mz.pow(2 * n - 1));
    return new Z[] {bz, b == 1 && a != 1 ? r.divide2() : r};
  }

  private Z uncachedDbn(final long b, final int n) {
    if (b == 1 && n <= 1) {
      return Z.ONE;
    }
    Z r = bigDbn(b, n);
    for (int i = 1; i < n; ++i) {
      r = r.subtract(dbn(b, n - i).multiply(Z.valueOf(b * b).negate().pow(i))
                     .multiply(Binomial.binomial(2 * n - 1, 2 * i)));
    }
    return r;
  }

  private Z dbn(final long b, final int n) {
    final String key = b + "_" + n;
    Z r = mCache.get(key);
    if (r != null) {
      return r;
    }
    r = uncachedDbn(b, n);
    mCache.put(key, r);
    return r;
  }

  private Z dan(final long a, final int n) {
    final String key = a + "_" + n;
    Z r = mCache.get(key);
    if (r != null) {
      return r;
    }
    // Handle a=bm^2
    final Z[] sf = handleFactors(a, n);
    final long b = sf[0].longValue();
    r = a == b ? uncachedDbn(b, n) : dbn(b, n);
    r = r.multiply(sf[1]);
    mCache.put(key, r);
    return r;
  }

  protected int getN() {
    return 1;
  }

  protected int getA() {
    return ++mT;
  }

  @Override
  public Z next() {
    return dan(getA(), getN());
  }
}
#!queue	A000063	5	->	5	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000063 Symmetrical dissections of an n-gon.
 * @author Sean A. Irvine
 */
public class A000063 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000063() {
    super(5);
  }

  private long mN = 4;

  @Override
  public Z next() {
    ++mN;
    Z t = Binomial.catalan(mN / 2 - 1);
    if ((mN & 3) == 0) {
      t = t.subtract(Binomial.catalan(mN / 4 - 1));
    }
    if (mN % 6 == 0) {
      t = t.subtract(Binomial.catalan(mN / 6 - 1));
    }
    return t;
  }
}

#!queue	A000079	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000079 Powers of 2: a(n) = 2^n.
 * @author Sean A. Irvine
 */
public class A000079 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000079() {
    super(0);
  }

  private Z mN = null;

  @Override
  public Z next() {
    if (mN == null) {
      mN = Z.ONE;
    } else {
      mN = mN.multiply2();
    }
    return mN;
  }
}
#!queue	A000081	0	->	0	MemorySequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.util.array.DynamicArray;

/**
 * A000081 Number of unlabeled rooted trees with n nodes (or connected functions with a fixed point).
 * @author Sean A. Irvine
 */
public class A000081 extends MemorySequence {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final DynamicArray<Z> mS = new DynamicArray<>();

  private Z sum(final int k) {
    final Z r = mS.get(k);
    if (r != null) {
      return r;
    }
    Z sum = Z.ZERO;
    if (k == 1) {
      sum = Z.ONE;
    } else {
      for (final Z t : Jaguar.factor(k).divisors()) {
        sum = sum.add(t.multiply(a(t.intValue())));
      }
    }
    mS.set(k, sum);
    return sum;
  }

  @Override
  protected Z computeNext() {
    final int n = size();
    if (n == 0) {
      return Z.ZERO;
    } else if (n == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 1; k < n; ++k) {
      sum = sum.add(a(n - k).multiply(sum(k)));
    }
    return sum.divide(n - 1);
  }
}

#!queue	A000105	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.lattice.Canons;
import irvine.math.lattice.Hunter;
import irvine.math.lattice.Lattices;
import irvine.math.lattice.ParallelHunter;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000105 Number of free polyominoes (or square animals) with n cells.
 * @author Sean A. Irvine
 */
public class A000105 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000105() {
    super(0);
  }

  private final ParallelHunter mHunter = new ParallelHunter(6,
    () -> new Hunter(Lattices.Z2, true),
    () -> new Hunter(Lattices.Z2, true) {
      {
        setKeeper((animal, forbidden) -> {
          if (Canons.Z2_FREE.isFreeCanonical(animal)) {
            increment(1);
          }
        });
      }
    }
  );

  protected int mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(mHunter.count(++mN));
  }
}
#!queue	A000111	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000111 Euler or up/down numbers: e.g.f. sec(x) + tan(x). Also for n &gt;= 2, half the number of alternating permutations on n letters (A001250).
 * @author Sean A. Irvine
 */
public class A000111 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000111() {
    super(0);
  }

  protected final ArrayList<Z> mA = new ArrayList<>();
  protected int mN = -1;

  @Override
  public Z next() {
    if (++mN < 3) {
      mA.add(Z.ONE);
      return Z.ONE;
    }
    if (mN < 0) {
      throw new UnsupportedOperationException();
    }
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.add(mA.get(k).multiply(mA.get(mN - 1 - k)).multiply(Binomial.binomial(mN - 1, k)));
    }
    sum = sum.divide2();
    mA.add(sum);
    return sum;
  }
}

#!queue	A000114	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000114 Number of cusps of principal congruence subgroup GAMMA^{hat}(n).
 * @author Sean A. Irvine
 */
public class A000114 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000114() {
    super(2);
  }

  protected long mN = 1;
  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    if (++mN == 2) {
      return Z.THREE;
    }
    Z b = Z.valueOf(mN).square();
    long d = 2;
    while (d <= mN) {
      if (mN % d == 0) {
        final Z d2 = Z.valueOf(d).square();
        b = b.multiply(d2.subtract(Z.ONE)).divide(d2);
      }
      d = mPrime.nextPrime(d);
    }
    return b.divide2();
  }
}

#!queue	A000119	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicArray;
import irvine.util.array.LongDynamicLongArray;

/**
 * A000119 Number of representations of n as a sum of distinct Fibonacci numbers.
 * @author Sean A. Irvine
 */
public class A000119 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000119() {
    super(0);
  }

  private long mN = -1;
  private final LongDynamicLongArray mA = new LongDynamicLongArray();
  private final LongDynamicArray<Z> mB = new LongDynamicArray<>();

  private Z b(final long k) {
    final Z r = mB.get(k);
    if (r != null) {
      return r;
    }
    final A000045 fib = new A000045();
    fib.next();
    fib.next();
    long f;
    Z s = Z.ZERO;
    while ((f = fib.next().longValue()) <= k) {
      if (k % f == 0) {
        s = s.signedAdd(((k / f) & 1) != 0, Z.valueOf(f));
      }
    }
    mB.set(k, s);
    return s;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      mA.set(0, 1L);
      return Z.ONE;
    }
    Z s = Z.ZERO;
    for (long k = 1; k <= mN; ++k) {
      s = s.add(b(k).multiply(mA.get(mN - k)));
    }
    s = s.divide(mN);
    mA.set(mN, s.longValue());
    return s;
  }
}

#!queue	A000120	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000120 1's-counting sequence: number of 1's in binary expansion of n (or the binary weight of n).
 * @author Sean A. Irvine
 */
public class A000120 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000120() {
    super(0);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return Z.valueOf(mN.bitCount());
  }
}

#!queue	A000123	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicArray;

/**
 * A000123 Number of binary partitions: number of partitions of 2n into powers of 2.
 * @author Sean A. Irvine
 */
public class A000123 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000123() {
    super(0);
  }

  private long mN = -1;
  private final LongDynamicArray<Z> mA = new LongDynamicArray<>();

  @Override
  public Z next() {
    if (++mN == 0) {
      mA.set(0, Z.ONE);
      return Z.ONE;
    }
    final Z r = mA.get(mN - 1).add(mA.get(mN >>> 1));
    mA.set(mN, r);
    return r;
  }
}

#!queue	A000130	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000130 One-half the number of permutations of length n with exactly 1 rising or falling successions.
 * @author Sean A. Irvine
 */
public class A000130 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000130() {
    super(0);
  }

  private Z mAa = Z.ONE;
  private Z mAb = Z.ZERO;
  private Z mBa = Z.ONE;
  private Z mBb = Z.ZERO;
  private Z mCa = Z.ZERO;
  private Z mCb = Z.TWO;
  private Z mDa = Z.ZERO;
  private Z mDb = Z.FOUR;
  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    if (mN < 2) {
      return Z.ZERO;
    } else if (mN == 2) {
      return Z.ONE;
    } else if (mN == 3) {
      return Z.TWO;
    }
    final Z constant = mDa.multiply(mN + 1)
      .subtract(mCa.multiply(mN - 2))
      .subtract(mBa.multiply(mN - 5))
      .add(mAa.multiply(mN - 3));
    final Z linear = mDb.multiply(mN + 1)
      .subtract(mCb.multiply(mN - 2))
      .subtract(mBb.multiply(mN - 5))
      .add(mAb.multiply(mN - 3))
      .subtract(mDa)
      .add(mCa.multiply(mN - 5))
      .add(mBa.multiply(2 * mN - 11))
      .subtract(mAa.multiply(3 * mN - 9));
    mAa = mBa;
    mBa = mCa;
    mCa = mDa;
    mDa = constant;
    mAb = mBb;
    mBb = mCb;
    mCb = mDb;
    mDb = linear;
    return linear.divide2();
  }
}
#!queue	A000136	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000136 Number of ways of folding a strip of n labeled stamps.
 * @author Sean A. Irvine
 */
public class A000136 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000136() {
    super(1);
  }

  private final A000682 mA682 = new A000682();
  private long mN = 0;

  @Override
  public Z next() {
    return mA682.next().multiply(++mN);
  }
}

#!queue	A000139	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000139 a(n) = 2*(3*n)! / ((2*n+1)!*(n+1)!).
 * @author Sean A. Irvine
 */
public class A000139 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000139() {
    super(0);
  }

  private Z mBinomial = Z.TWO;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.TWO;
    } else if (mN == 1) {
      return Z.ONE;
    } else {
      mBinomial = mBinomial.multiply(3 * mN - 2).multiply(3 * mN - 1).multiply(3)
        .divide(Z.valueOf(2 * mN + 1).multiply(mN - 1)).divide2();
      return mBinomial.divide(mN).divide(mN + 1);
    }
  }
}

#!queue	A000149	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000149 a(n) = floor(e^n).
 * @author Sean A. Irvine
 */
public class A000149 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000149() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return CR.valueOf(++mN).exp().floor();
  }
}
#!queue	A000159	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000159 Coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A000159 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000159() {
    super(3);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final Polynomial<Z> BASE = Polynomial.create(-1, 1);
  private final MemoryFactorial mFactorial = MemoryFactorial.SINGLETON;

  // This will be useful for other sequences
  Polynomial<Z> menageHitPolynomial(final int n) {
    Polynomial<Z> p = RING.zero();
    for (int k = 0; k <= n; ++k) {
      final long u = 2L * n - k;
      final Z m = Binomial.binomial(u, k)
        .multiply(2L * n)
        .multiply(mFactorial.factorial(n - k))
        .divide(u);
      p = RING.add(p, RING.multiply(RING.pow(BASE, k), m));
    }
    return p;
  }

  private int mN = 2;

  @Override
  public Z next() {
    return menageHitPolynomial(++mN).coeff(3);
  }
}
#!queue	A000166	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000166 Subfactorial or rencontres numbers, or derangements: number of permutations of n elements with no fixed points.
 * @author Sean A. Irvine
 */
public class A000166 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000166() {
    super(0);
  }

  protected int mN = -1;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    if (++mN != 0) {
      mA = mA.multiply(mN).add((mN & 1) == 0 ? 1 : -1);
    }
    return mA;
  }
}

#!queue	A000170	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000170 Number of ways of placing n nonattacking queens on an n X n board.
 * @author Sean A. Irvine
 */
public class A000170 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000170() {
    super(0);
  }

  // A simple backtracking implementation.
  // Don't expect to break any records using this :-)

  private int mN = -1;

  protected boolean isConsistent(final int[] q, final int n) {
    for (int k = 0; k < n; ++k) {
      if (q[k] == q[n]) {
        return false;   // same column
      }
      if (q[k] - q[n] == n - k) {
        return false;   // same major diagonal
      }
      if (q[n] - q[k] == n - k) {
        return false;   // same minor diagonal
      }
    }
    return true;
  }

  /**
   * Can be used by subclasses to determine if this solution should be counted,
   * and if so, with what multiplicity.
   * @param q the solution
   * @return count for this solution
   */
  protected Z count(final int[] q) {
    return Z.ONE;
  }

  protected Z count(final int[] q, final int n) {
    Z c;
    if (n == q.length) {
      c = count(q);
    } else {
      c = Z.ZERO;
      for (int k = 0; k < q.length; ++k) {
        q[n] = k;
        if (isConsistent(q, n)) {
          c = c.add(count(q, n + 1));
        }
      }
    }
    return c;
  }

  @Override
  public Z next() {
    return count(new int[++mN], 0);
  }
}
#!queue	A000183	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a061.A061702;

/**
 * A000183 Number of discordant permutations of length n.
 * @author Sean A. Irvine
 */
public class A000183 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000183() {
    super(1);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;

  @Override
  public Z next() {
    Z s = Z.ZERO;
    if (++mN > 3) {
      for (int m = 0; m <= mN; ++m) {
        final Z t = mF.factorial(mN - m).multiply(A061702.t(mN, m));
        s = s.signedAdd((m & 1) == 0, t);
      }
    }
    return s;
  }
}
#!queue	A000203	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000203 a(n) = sigma(n), the sum of the divisors of n. Also called sigma_1(n).
 * @author Sean A. Irvine
 */
public class A000203 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000203() {
    super(1);
  }

  protected long mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(++mN).sigma();
  }
}
#!queue	A000204	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000204 Lucas numbers (beginning with 1): L(n) = L(n-1) + L(n-2) with L(1) = 1, L(2) = 3.
 * @author Sean A. Irvine
 */
public class A000204 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000204() {
    super(1);
  }

  private Z mA = Z.NEG_ONE;
  private Z mB = Z.TWO;

  @Override
  public Z next() {
    final Z n = mA.add(mB);
    mA = mB;
    mB = n;
    return n;
  }

}

#!queue	A000207	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000207 Number of inequivalent ways of dissecting a regular (n+2)-gon into n triangles by n-1 non-intersecting diagonals under rotations and reflections; also the number of planar 2-trees.
 * @author Sean A. Irvine
 */
public class A000207 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000207() {
    super(1);
  }

  private int mN = 0;
  private final ArrayList<Z> mC = new ArrayList<>();
  private final A000108 mA108 = new A000108();

  {
    mC.add(mA108.next());
  }

  private Z c(final int n) {
    return mC.get(n);
  }

  @Override
  public Z next() {
    mC.add(mA108.next());
    ++mN;
    final int k = (mN & 1) == 0 ? mN / 2 + 2 : (mN + 3) / 2;
    Q r = new Q(c(mN), Z.valueOf(2L * mN + 4)).add(new Q(c(k - 2), Z.TWO));
    if ((mN & 1) == 0) {
      r = r.add(new Q(c(mN / 2), Z.FOUR));
    }
    if ((mN + 2) % 3 == 0) {
      r = r.add(new Q(c((mN - 1) / 3), Z.THREE));
    }
    assert r.isInteger();
    return r.toZ();
  }
}

#!queue	A000214	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.AffineGroupCycleIndex;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000214 Number of equivalence classes of Boolean functions of n variables under action of AG(n,2).
 * @author Sean A. Irvine
 */
public class A000214 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000214() {
    super(1);
  }

  private int mN = 0;

  @Override
  public Z next() {
    return AffineGroupCycleIndex.cycleIndex(++mN).apply(1).toZ();
  }
}
#!queue	A000215	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000215 Fermat numbers: a(n) = 2^(2^n) + 1.
 * @author Sean A. Irvine
 */
public class A000215 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000215() {
    super(0);
  }

  private int mN = 0;

  @Override
  public Z next() {
    if (mN == 0) {
      mN = 1;
    } else {
      mN <<= 1;
      if (mN < 0) {
        throw new UnsupportedOperationException();
      }
    }
    return Z.ONE.shiftLeft(mN).add(1);
  }
}
#!queue	A000225	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000225 a(n) = 2^n - 1. (Sometimes called Mersenne numbers, although that name is usually reserved for A001348.).
 * @author Sean A. Irvine
 */
public class A000225 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000225() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    return Z.ONE.shiftLeft(++mN).subtract(Z.ONE);
  }
}

#!queue	A000230	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.DynamicArray;

/**
 * A000230 a(0)=2; for n&gt;=1, a(n) = smallest prime p such that there is a gap of exactly 2n between p and next prime, or -1 if no such prime exists.
 * @author Sean A. Irvine
 */
public class A000230 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000230() {
    super(0);
  }

  private Z mP = Z.TWO;
  protected int mGapSize = -2;
  private final DynamicArray<Z> mLeastPrime = new DynamicArray<>();
  protected final Fast mPrime = new Fast();

  private Z leastGap(final int gap) {
    final int g = gap / 2;
    final Z r = mLeastPrime.get(g);
    if (r != null) {
      return r;
    }
    while (true) {
      final Z old = mP;
      mP = mPrime.nextPrime(mP);
      final int delta = mP.subtract(old).intValue() / 2;
      if (mLeastPrime.get(delta) == null) {
        mLeastPrime.set(delta, old);
      }
      if (delta == g) {
        return old;
      }
    }
  }

  @Override
  public Z next() {
    mGapSize += 2;
    return leastGap(mGapSize);
  }

}

#!queue	A000233	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;
import java.util.HashMap;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.LongUtils;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000233 Generalized class numbers.
 * @author Sean A. Irvine
 */
public class A000233 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000233() {
    super(1);
  }

  protected int mT = 0;
  private final HashMap<String, Z> mCache = new HashMap<>();

  private Z bigCbn(final long b, final long n) {
    Z sum = Z.ZERO;
    if ((b & 3) == 3) {
      for (long k = 1; k <= (b - 1) / 2; ++k) {
        sum = sum.add(Z.valueOf(b - 4 * k).pow(2 * n).multiply(LongUtils.jacobi(k, b)));
      }
    } else {
      long k = 1;
      while (k < b) {
        sum = sum.add(Z.valueOf(b - k).pow(2 * n).multiply(LongUtils.jacobi(-b, k)));
        k += 2;
      }
    }
    return (n & 1) == 0 ? sum : sum.negate();
  }

  private Z[] handleFactors(final long a, final long n) {
    Z mz = Z.ONE;
    Z bz = Z.ONE;
    final FactorSequence fs = Jaguar.factor(a);
    final ArrayList<Z> p = new ArrayList<>();
    for (final Z f : fs.toZArray()) {
      final long e = fs.getExponent(f);
      if ((e & 1) == 1) {
        bz = bz.multiply(f);
        if ((e - 1) / 2 > 0) {
          mz = mz.multiply(f.pow((e - 1) / 2));
          p.add(f);
        }
      } else {
        mz = mz.multiply(f.pow(e / 2));
        p.add(f);
      }
    }
    Z prod2 = Z.ONE;
    final long b = bz.longValue();
    long prod1 = mz.longValue();
    for (final Z piz : p) {
      final long pi = piz.longValue();
      if ((pi & 1) == 1) {
        prod1 /= pi;
        prod2 = prod2.multiply(piz.pow(2L * n + 1).subtract(LongUtils.jacobi(-b, pi)));
      }
    }
    final Z r = prod2.multiply(Z.valueOf(prod1).pow(2 * n + 1)).multiply(mz.pow(2 * n));
    return new Z[] {bz, b == 1 && a != 1 ? r.divide2() : r};
  }

  private Z uncachedCbn(final long b, final int n) {
    if (b == 1 && n <= 1) {
      return Z.ONE;
    }
    Z r = bigCbn(b, n);
    for (int i = 1; i <= n; ++i) {
      r = r.subtract(cbn(b, n - i).multiply(Z.valueOf(b * b).negate().pow(i))
                     .multiply(Binomial.binomial(2L * n, 2 * i)));
    }
    return r;
  }

  private Z cbn(final long b, final int n) {
    final String key = b + "_" + n;
    Z r = mCache.get(key);
    if (r != null) {
      return r;
    }
    r = uncachedCbn(b, n);
    mCache.put(key, r);
    return r;
  }

  private Z can(final long a, final int n) {
    final String key = a + "_" + n;
    Z r = mCache.get(key);
    if (r != null) {
      return r;
    }
    // Handle a=bm^2
    final Z[] sf = handleFactors(a, n);
    final long b = sf[0].longValue();
    r = a == b ? uncachedCbn(b, n) : cbn(b, n);
    r = r.multiply(sf[1]);
    mCache.put(key, r);
    return r;
  }

  protected int getN() {
    return 1;
  }

  protected int getA() {
    return ++mT;
  }

  @Override
  public Z next() {
    return can(getA(), getN());
  }
}
#!queue	A000244	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000244 Powers of 3: a(n) = 3^n.
 * @author Sean A. Irvine
 */
public class A000244 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000244() {
    super(0);
  }

  private Z mA = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
    } else {
      mA = mA.multiply(3);
    }
    return mA;
  }
}

#!queue	A000252	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000252 Number of invertible 2 X 2 matrices mod n.
 * @author Sean A. Irvine
 */
public class A000252 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000252() {
    super(1);
  }

  protected long mN = 0;

  @Override
  public Z next() {
    Z z = Z.valueOf(++mN).pow(4);
    for (final Z p : Jaguar.factor(mN).toZArray()) {
      z = z.multiply(p.square().subtract(Z.ONE)).multiply(p.subtract(Z.ONE)).divide(p.pow(3));
    }
    return z;
  }

}

#!queue	A000254	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000254 Unsigned Stirling numbers of first kind, s(n+1,2): a(n+1) = (n+1)*a(n) + n!.
 * @author Sean A. Irvine
 */
public class A000254 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000254() {
    super(0);
  }

  protected long mN = -1;
  private Z mA = Z.ONE;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    if (mN == 1) {
      return Z.ONE;
    }
    mF = mF.multiply(mN - 1);
    mA = mA.multiply(mN).add(mF);
    return mA;
  }

}

#!queue	A000262	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000262 Number of "sets of lists": number of partitions of {1,...,n} into any number of lists, where a list means an ordered subset.
 * @author Sean A. Irvine
 */
public class A000262 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000262() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    if (++mN < 2) {
      return Z.ONE;
    }
    final Z t = mB.multiply(2 * mN - 1).subtract(mA.multiply(mN - 1).multiply(mN - 2));
    mA = mB;
    mB = t;
    return t;
  }
}
#!queue	A000265	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000265 Remove all factors of 2 from n; or largest odd divisor of n; or odd part of n.
 * @author Sean A. Irvine
 */
public class A000265 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000265() {
    super(1);
  }

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.makeOdd();
  }
}
#!queue	A000273	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.SymmetricGroup;
import irvine.math.partitions.IntegerPartition;
import irvine.math.q.Q;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000273 Number of unlabeled simple digraphs with n nodes.
 * @author Sean A. Irvine
 */
public class A000273 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000273() {
    super(0);
  }

  protected int mN = -1;

  protected int g(final int ord, final int[] a) {
    int g = 0;
    for (int d = 1; d <= ord; ++d) {
      if (ord % d == 0) {
        int g1 = 0;
        final int lim = Math.min(mN, d);
        for (int del = 1; del <= lim; ++del) {
          if (d % del == 0) {
            g1 += del * a[del];
          }
        }
        g += g1 * Euler.phiAsLong(ord / d) * (g1 - 1);
      }
    }
    return g;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    // I think this algorithm is due to Harary
    // I'm not sure how far it can be pushed before overflow
    final IntegerPartition ip = new IntegerPartition(mN);
    final int[] a = new int[mN + 1];
    Q s = Q.ZERO;
    int[] p;
    while ((p = ip.next()) != null) {
      IntegerPartition.toCountForm(p, a);
      final int ord = IntegerPartition.ord(a);
      s = s.add(new Q(Z.ONE.shiftLeft(g(ord, a) / ord), SymmetricGroup.per(a)));
    }
    return s.toZ();
  }
}
#!queue	A000275	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000275 Coefficients of a Bessel function (reciprocal of J_0(z)); also pairs of permutations with rise/rise forbidden.
 * @author Sean A. Irvine
 */
public class A000275 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000275() {
    super(0);
  }

  protected int mN = -1;
  protected final ArrayList<Z> mA = new ArrayList<>();

  @Override
  public Z next() {
    final Z res;
    if (++mN == 0) {
      res = Z.ONE;
    } else {
      Z t = Z.ZERO;
      for (int r = 0; r < mN; ++r) {
        final Z z = Binomial.binomial(mN, r).square().multiply(mA.get(r));
        t = t.signedAdd(((r + mN) & 1) != 0, z);
      }
      res = t;
    }
    mA.add(res);
    return res;
  }
}
#!queue	A000292	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000292 Tetrahedral (or triangular pyramidal) numbers: a(n) = C(n+2,3) = n*(n+1)*(n+2)/6.
 * @author Sean A. Irvine
 */
public class A000292 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000292() {
    super(0);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.multiply(mN.add(1)).multiply(mN.add(2)).divide(6);
  }
}
#!queue	A000295	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000295 Eulerian numbers (Euler's triangle: column k=2 of A008292, column k=1 of A173018).
 * @author Sean A. Irvine
 */
public class A000295 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000295() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return Z.ONE.shiftLeft(mN).subtract(mN + 1);
  }
}
#!queue	A000311	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000311 Schroeder's fourth problem; also series-reduced rooted trees with n labeled leaves; also number of total partitions of n.
 * @author Sean A. Irvine
 */
public class A000311 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000311() {
    super(0);
  }

  private final ArrayList<Z> mA = new ArrayList<>();

  @Override
  public Z next() {
    if (mA.isEmpty()) {
      mA.add(Z.ZERO);
    } else if (mA.size() <= 2) {
      mA.add(Z.ONE);
    } else {
      final int n = mA.size() - 1;
      Z s = Z.ZERO;
      for (int k = 2; k < n; ++k) {
        s = s.add(Binomial.binomial(n, k).multiply(mA.get(k)).multiply(mA.get(n - k + 1)));
      }
      mA.add(s.multiply2().add(mA.get(n).multiply(n + 2)));
    }
    return mA.get(mA.size() - 1);
  }
}
#!queue	A000313	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000313 Number of permutations of length n with 3 consecutive ascending pairs.
 * @author Sean A. Irvine
 */
public class A000313 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000313() {
    super(1);
  }

  private int mN = -2;
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  @Override
  public Z next() {
    Z s = Z.ZERO;
    if (++mN > 1) {
      final Z b = mF.factorial(mN + 1);
      for (int k = 0; k <= mN; ++k) {
        final Z c = b.divide(mF.factorial(k));
        s = s.signedAdd((k & 1) == 0, c);
      }
    }
    return s.multiply(mN).divide(6);
  }
}
#!queue	A000315	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.ReducedLatinRectangles;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000315 Number of reduced Latin squares of order n; also number of labeled loops (quasigroups with an identity element) with a fixed identity element.
 * @author Sean A. Irvine
 */
public class A000315 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000315() {
    super(1);
  }

  protected int mN = 0;

  @Override
  public Z next() {
    return new ReducedLatinRectangles(++mN, mN).count();
  }
}
#!queue	A000326	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000326 Pentagonal numbers: a(n) = n*(3*n-1)/2.
 * @author Sean A. Irvine
 */
public class A000326 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000326() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(++mN).multiply(3L * mN - 1).divide2();
  }
}

#!queue	A000332	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000332 Binomial coefficient binomial(n,4) = n*(n-1)*(n-2)*(n-3)/24.
 * @author Sean A. Irvine
 */
public class A000332 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000332() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN < 4 ? Z.ZERO : Binomial.binomial(mN, 4);
  }
}

#!queue	A000340	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000340 a(0)=1, a(n) = 3*a(n-1) + n + 1.
 * @author Sean A. Irvine
 */
public class A000340 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000340() {
    super(0);
  }

  protected long mN = 0;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    mA = mA.multiply(3).add(++mN);
    return mA;
  }
}
#!queue	A000364	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000364 Euler (or secant or "Zig") numbers: e.g.f. (even powers only) sec(x) = 1/cos(x).
 * @author Sean A. Irvine
 */
public class A000364 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000364() {
    super(0);
  }

  // Euler or secant numbers

  protected final ArrayList<Z> mA364 = new ArrayList<>();
  protected int mN = -1;

  @Override
  public Z next() {
    // Use recurrence due to Ralf Stephan
    if (++mN == 0) {
      mA364.add(Z.ONE);
      return Z.ONE;
    }
    Z t = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      final Z z = Binomial.binomial(2 * mN, 2 * k).multiply(mA364.get(k));
      t = t.signedAdd((k & 1) == 0, z);
    }
    if ((mN & 1) == 0) {
      t = t.negate();
    }
    mA364.add(t);
    return t;
  }
}
#!queue	A000367	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.q.BernoulliSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000367 Numerators of Bernoulli numbers B_2n.
 * @author Sean A. Irvine
 */
public class A000367 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000367() {
    super(0);
  }

  final BernoulliSequence mB = new BernoulliSequence(0);

  @Override
  public Z next() {
    final Z q = mB.nextQ().num();
    mB.nextQ();
    return q;
  }
}
#!queue	A000378	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000378 Sums of three squares: numbers of the form x^2 + y^2 + z^2.
 * @author Sean A. Irvine
 */
public class A000378 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000378() {
    super(1);
  }

  long mN = -1;

  @Override
  public Z next() {
    while (true) {
      long n = ++mN;
      while (n != 0 && (n & 3) == 0) {
        n >>= 2;
      }
      if ((n & 7) != 7) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A000380	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a061.A061702;

/**
 * A000380 Number of permutations of an n-sequence discordant with three given permutations (see reference) in n-3 places.
 * @author Sean A. Irvine
 */
public class A000380 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000380() {
    super(3);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final Polynomial<Z> BASE = Polynomial.create(-1, 1);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = coeff() - 1;

  protected int coeff() {
    return 3;
  }

  @Override
  public Z next() {
    Polynomial<Z> s = RING.zero();
    ++mN;
    for (int k = 0; k <= mN; ++k) {
      final Z t = mF.factorial(mN - k).multiply(A061702.t(mN, k));
      s = RING.add(s, RING.multiply(RING.pow(BASE, k, coeff()), t));
    }
    return s.coeff(coeff());
  }
}
#!queue	A000384	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000384 Hexagonal numbers: a(n) = n*(2*n-1).
 * @author Sean A. Irvine
 */
public class A000384 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000384() {
    super(0);
  }

  protected Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.multiply2().subtract(Z.ONE).multiply(mN);
  }
}
#!queue	A000392	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000392 Stirling numbers of second kind S(n,3).
 * @author Sean A. Irvine
 */
public class A000392 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000392() {
    super(0);
  }

  private int mN = -1;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    if (++mN > 2) {
      mA = mA.multiply(3).add(Z.ONE.shiftLeft(mN - 2)).subtract(1);
    }
    return mA;
  }
}

#!queue	A000394	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A000394 Numbers of form x^2 + y^2 + 7z^2.
 * @author Sean A. Irvine
 */
public class A000394 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000394() {
    super(0);
  }

  private final LongDynamicBooleanArray mSeq = new LongDynamicBooleanArray();
  private long mLast = -1;
  private long mDone = -1;

  protected int multiplier() {
    return 7;
  }

  private void update(final long n) {
    // Updates x^2 + y^2 + 7z^2
    // Note symmetric in x and y, so only need to do 1 loop for them
    final long x = LongUtils.sqrt(n);
    if (x > mDone) {
      final long xx = x * x;
      for (long y = 0; y <= x; ++y) {
        final long yy = xx + y * y;
        for (long z = 0; z <= x; ++z) {
          final long k = yy + multiplier() * z * z;
          mSeq.set(k);
        }
      }
      final long zp = multiplier() * xx;
      for (long xp = 0; xp <= x; ++xp) {
        final long yy = xp * xp + zp;
        for (long y = 0; y <= x; ++y) {
          final long k = yy + y * y;
          mSeq.set(k);
        }
      }
      mDone = x;
    }
  }

  @Override
  public Z next() {
    while (true) {
      update(++mLast);
      if (mSeq.isSet(mLast)) {
        return Z.valueOf(mLast);
      }
    }
  }
}

#!queue	A000400	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000400 Powers of 6: a(n) = 6^n.
 * @author Sean A. Irvine
 */
public class A000400 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000400() {
    super(0);
  }

  private Z mA = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
    } else {
      mA = mA.multiply(6);
    }
    return mA;
  }
}

#!queue	A000410	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.MatrixRing;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000410 Number of singular n X n rational (0,1)-matrices.
 * @author Sean A. Irvine
 */
public class A000410 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000410() {
    super(1);
  }

  protected int mN = 0;

  private boolean bump(final long[] rows, final long limit) {
    long l = limit;
    for (int k = rows.length - 1; k >= 0; --k, --l) {
      if (++rows[k] < l) {
        for (int j = k + 1; j < rows.length; ++j) {
          rows[j] = rows[j - 1] + 1;
        }
        return true;
      }
    }
    return false;
  }

  private DefaultMatrix<Z> getZMatrix(final long[] rows) {
    final DefaultMatrix<Z> m = new DefaultMatrix<>(rows.length, rows.length, Z.ZERO);
    for (int k = 0; k < rows.length; ++k) {
      long r = rows[k];
      for (int j = 0; j < rows.length; ++j, r >>>= 1) {
        if ((r & 1) == 1) {
          m.set(k, j, Z.ONE);
        }
      }
    }
    return m;
  }

  @Override
  public Z next() {
    if (++mN > 63) {
      throw new UnsupportedOperationException();
    }
    final MatrixRing<Z> matrixRing = new MatrixRing<>(mN, Integers.SINGLETON);
    final long limit = 1L << mN;
    final long[] rows = new long[mN];
    for (int k = 0; k < rows.length; ++k) {
      rows[k] = k + 1;
    }
    long count = 0;
    do {
      if (matrixRing.isSingular(getZMatrix(rows))) {
        ++count;
      }
    } while (bump(rows, limit));
    return Z.valueOf(count);
  }
}
#!queue	A000422	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000422 Concatenation of numbers from n down to 1.
 * @author Sean A. Irvine
 */
public class A000422 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000422() {
    super(1);
  }

  protected long mN = 0;
  private long mMult = 10;
  private Z mA = Z.ZERO;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    if (++mN >= mMult) {
      mMult *= 10;
    }
    mA = mB.multiply(mN).add(mA);
    mB = mB.multiply(mMult);
    return mA;
  }
}

#!queue	A000453	4	->	4	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000453 Stirling numbers of the second kind, S(n,4).
 * @author Sean A. Irvine
 */
public class A000453 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000453() {
    super(4);
  }

  private int mN = 3;

  @Override
  public Z next() {
    return Stirling.secondKind(++mN, 4);
  }
}
#!queue	A000455	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000455 Digits of powers of 2.
 * @author Sean A. Irvine
 */
public class A000455 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000455() {
    super(0);
  }

  private String mCurrent = "";
  private int mPos = 0;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mPos >= mCurrent.length()) {
      mCurrent = Z.ONE.shiftLeft(++mN).toString();
      mPos = 0;
    }
    return Z.valueOf(mCurrent.charAt(mPos) - '0');
  }
}
#!queue	A000521	-1	->	-1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000521 Coefficients of modular function j as power series in q = e^(2 Pi i t). Another name is the elliptic modular invariant J(tau).
 * @author Sean A. Irvine
 */
public class A000521 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000521() {
    super(-1);
  }

  private final ArrayList<Z> mA = new ArrayList<>();
  protected int mN = -2;

  {
    mA.add(Z.ONE);                     // -1
    mA.add(Z.valueOf(744));            // 0
    mA.add(Z.valueOf(196884));         // 1
    mA.add(Z.valueOf(21493760));       // 2
    mA.add(Z.valueOf(864299970));      // 3
    mA.add(Z.valueOf(20245856256L));   // 4
    mA.add(Z.valueOf(333202640600L));  // 5
  }

  private Z c(final int n) {
    return mA.get(n + 1);
  }

  @Override
  public Z next() {
    // Using approach due to Mahler, more efficient approaches are known
    if (++mN + 1 >= mA.size()) {
      final int n = mN / 4;
      Z sum;
      switch (mN & 3) {
      case 0:
        final Z cn = c(n);
        sum = c(2 * n + 1).add(cn.square().subtract(cn).divide2());
        for (int k = 1; k < n; ++k) {
          sum = sum.add(c(k).multiply(c(2 * n - k)));
        }
        break;
      case 1:
        sum = c(2 * n + 3).subtract(c(2).multiply(c(2 * n)))
          .add(c(n + 1).square().subtract(c(n + 1)).divide2())
          .add(c(2 * n).square().add(c(2 * n)).divide2());
        for (int k = 1; k <= n; ++k) {
          sum = sum.add(c(k).multiply(c(2 * n - k + 2)));
        }
        for (int k = 1; k < 2 * n; ++k) {
          final Z t = c(k).multiply(c(4 * n - k));
          sum = sum.signedAdd((k & 1) == 0, t);
        }
        for (int k = 1; k < n; ++k) {
          sum = sum.add(c(k).multiply(c(4 * n - 4 * k)));
        }
        break;
      case 2:
        sum = c(2 * n + 2);
        for (int k = 1; k <= n; ++k) {
          sum = sum.add(c(k).multiply(c(2 * n - k + 1)));
        }
        break;
      default:
        sum = c(2 * n + 4).subtract(c(2).multiply(c(2 * n + 1)))
          .subtract(c(2 * n + 1).square().subtract(c(2 * n + 1)).divide2());
        for (int k = 1; k <= n + 1; ++k) {
          sum = sum.add(c(k).multiply(c(2 * n - k + 3)));
        }
        for (int k = 1; k <= 2 * n; ++k) {
          final Z t = c(k).multiply(c(4 * n - k + 2));
          sum = sum.signedAdd((k & 1) == 0, t);
        }
        for (int k = 1; k <= n; ++k) {
          sum = sum.add(c(k).multiply(c(4 * n - 4 * k + 2)));
        }
        break;
      }
      mA.add(sum);
    }
    return c(mN);
  }
}
#!queue	A000522	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000522 Total number of ordered k-tuples (k=0..n) of distinct elements from an n-element set: a(n) = Sum_{k=0..n} n!/k!.
 * @author Sean A. Irvine
 */
public class A000522 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000522() {
    super(0);
  }

  private Z mA = Z.ZERO;
  private int mN = -1;

  @Override
  public Z next() {
    mA = mA.multiply(++mN).add(1);
    return mA;
  }
}
#!queue	A000537	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000537 Sum of first n cubes; or n-th triangular number squared.
 * @author Sean A. Irvine
 */
public class A000537 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000537() {
    super(0);
  }

  private long mN = -1;
  private Z mS = Z.ZERO;

  @Override
  public Z next() {
    mS = mS.add(Z.valueOf(++mN).pow(3));
    return mS;
  }
}
#!queue	A000566	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000566 Heptagonal numbers (or 7-gonal numbers): n*(5*n-3)/2.
 * @author Sean A. Irvine
 */
public class A000566 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000566() {
    super(0);
  }

  protected Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.multiply(5).subtract(3).multiply(mN).divide2();
  }
}

#!queue	A000567	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000567 Octagonal numbers: n*(3*n-2). Also called star numbers.
 * @author Sean A. Irvine
 */
public class A000567 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000567() {
    super(0);
  }

  protected Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.multiply(3).subtract(2).multiply(mN);
  }
}

#!queue	A000568	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.IntegerUtils;
import irvine.math.group.SymmetricGroup;
import irvine.math.partitions.IntegerPartition;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000568 Number of outcomes of unlabeled n-team round-robin tournaments.
 * @author Sean A. Irvine
 */
public class A000568 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000568() {
    super(0);
  }

  protected int mN = -1;

  private boolean isOddParts(final int[] p) {
    for (final int v : p) {
      if ((v & 1) == 0) {
        return false;
      }
    }
    return true;
  }

  private int t(final int[] j) {
    int sum = 0;
    for (int r = 0; r < j.length; ++r) {
      for (int s = 0; s < j.length; ++s) {
        sum += j[r] * j[s] * IntegerUtils.gcd(r, s);
      }
      sum -= j[r];
    }
    return sum / 2;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final IntegerPartition ip = new IntegerPartition(mN);
    final int[] a = new int[mN + 1];
    Q s = Q.ZERO;
    int[] p;
    while ((p = ip.next()) != null) {
      if (isOddParts(p)) {
        IntegerPartition.toCountForm(p, a);
        s = s.add(new Q(Z.ONE.shiftLeft(t(a)), SymmetricGroup.per(a)));
      }
    }
    return s.toZ();
  }
}
#!queue	A000578	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000578 The cubes: a(n) = n^3.
 * @author Sean A. Irvine
 */
public class A000578 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000578() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(++mN).pow(3);
  }
}
#!queue	A000580	7	->	7	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000580 a(n) = binomial coefficient C(n,7).
 * @author Sean A. Irvine
 */
public class A000580 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000580() {
    super(7);
  }

  private int mN = 6;

  @Override
  public Z next() {
    return Binomial.binomial(++mN, 7);
  }
}

#!queue	A000583	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000583 Fourth powers: a(n) = n^4.
 * @author Sean A. Irvine
 */
public class A000583 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000583() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(++mN).pow(4);
  }
}

#!queue	A000584	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000584 Fifth powers: a(n) = n^5.
 * @author Sean A. Irvine
 */
public class A000584 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000584() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(++mN).pow(5);
  }
}

#!queue	A000595	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.IntegerUtils;
import irvine.math.group.SymmetricGroup;
import irvine.math.partitions.IntegerPartition;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000595 Number of binary relations on n unlabeled points.
 * @author Sean A. Irvine
 */
public class A000595 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000595() {
    super(0);
  }

  protected int mN = -1;

  protected int t(final int[] j) {
    int sum = 0;
    for (int r = 0; r < j.length; ++r) {
      for (int s = 0; s < j.length; ++s) {
        sum += j[r] * j[s] * IntegerUtils.gcd(r, s);
      }
    }
    return sum;
  }

  protected Z zeroCase() {
    return Z.ONE;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return zeroCase();
    }
    final IntegerPartition ip = new IntegerPartition(mN);
    final int[] a = new int[mN + 1];
    Q s = Q.ZERO;
    int[] p;
    while ((p = ip.next()) != null) {
      IntegerPartition.toCountForm(p, a);
      s = s.add(new Q(Z.ONE.shiftLeft(t(a)), SymmetricGroup.per(a)));
    }
    return s.toZ();
  }
}
#!queue	A000598	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.PolynomialRingField;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000598 Number of rooted ternary trees with n nodes; number of n-carbon alkyl radicals C(n)H(2n+1) ignoring stereoisomers.
 * @author Sean A. Irvine
 */
public class A000598 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000598() {
    super(0);
  }

  private static final CycleIndex CYCLE_INDEX = SymmetricGroup.create(3).cycleIndex();
  protected static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  protected int mN = -1;
  protected Polynomial<Q> mG = RING.zero();

  protected CycleIndex cycleIndex() {
    return CYCLE_INDEX;
  }

  protected int limit() {
    return mN;
  }

  /**
   * Polynomial associated with this sequence.
   * @return polynomial
   */
  public Polynomial<Q> g() {
    return mG;
  }

  @Override
  public Z next() {
    ++mN;
    mG = RING.add(RING.one(), RING.shift(cycleIndex().apply(mG, limit()), 1));
    return mG.coeff(mN).toZ();
  }
}

#!queue	A000602	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000602 Number of n-node unrooted quartic trees; number of n-carbon alkanes C(n)H(2n+2) ignoring stereoisomers.
 * @author Sean A. Irvine
 */
public class A000602 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000602() {
    super(0);
  }

  private final A000022 mA22 = new A000022();
  private final A000200 mA200 = new A000200();
  private boolean mFirst = true;

  @Override
  public Z next() {
    final Z r = mA22.next().add(mA200.next());
    if (mFirst) {
      mFirst = false;
      return Z.ONE;
    }
    return r;
  }
}

#!queue	A000616	-1	->	-1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.WreathExponentiation;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000616 a(-1)=1 by convention; for n &gt;= 0, a(n) = number of irreducible Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A000616 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000616() {
    super(-1);
  }

  private static final CycleIndex Z2 = SymmetricGroup.create(2).cycleIndex();
  private int mN = -2;

  @Override
  public Z next() {
    if (++mN < 1) {
      if (mN == -1) {
        return Z.ONE;
      }
      return Z.TWO;
    }
    return WreathExponentiation.exponentiation(Z2, SymmetricGroup.create(mN).cycleIndex()).apply(1).toZ();
  }
}
#!queue	A000666	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.group.PolynomialRingField;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.MultivariateMonomial;
import irvine.math.polynomial.PairMultiply;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000666 Number of symmetric relations on n nodes.
 * @author Sean A. Irvine
 */
public class A000666 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000666() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final CycleIndex zn = SymmetricGroup.create(mN).cycleIndex();
    final MultivariateMonomial m = new MultivariateMonomial();
    m.add(1, 1);
    final CycleIndex c = zn.multiply(m);
    final CycleIndex pair = c.op(PairMultiply.OP, c);
    final Polynomial<Q> g = pair.applyOnePlusXToTheN();
    return RING.eval(g, Q.ONE).toZ();
  }
}
#!queue	A000669	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicArray;

/**
 * A000669 Number of series-reduced planted trees with n leaves. Also the number of essentially series series-parallel networks with n edges; also the number of essentially parallel series-parallel networks with n edges.
 * @author Sean A. Irvine
 */
public class A000669 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000669() {
    super(1);
  }

  protected long mN = 0;
  protected final LongDynamicArray<Z> mA = new LongDynamicArray<>();
  protected final LongDynamicArray<Z> mP = new LongDynamicArray<>();

  @Override
  public Z next() {
    if (++mN == 1) {
      mA.set(1, Z.ONE);
      mP.set(1, Z.ONE);
    } else if (mN == 2) {
      mA.set(2, Z.ONE);
      mP.set(2, Z.THREE);
    } else if (mN == 3) {
      mA.set(3, Z.TWO);
      mP.set(3, Z.SEVEN);
    } else {
      final Z n = Z.valueOf(mN);
      final FactorSequence fs = Jaguar.factor(n);
      Z t3 = Z.ZERO;
      for (final Z d : fs.divisors()) {
        if (!d.equals(n)) {
          t3 = t3.add(d.multiply(mA.get(d.longValue())));
        }
      }
      Z ts = Z.ZERO;
      for (long k = 1; k < mN - 1; ++k) {
        ts = ts.add(mP.get(k).multiply(mA.get(mN - k)));
      }
      final Z t4 = t3.add(ts.multiply2()).add(mP.get(mN - 1));
      mA.set(mN, t4.divide(mN));
      mP.set(mN, t3.add(t4));
    }
    return mA.get(mN);
  }
}
#!queue	A000670	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000670 Fubini numbers: number of preferential arrangements of n labeled elements; or number of weak orders on n labeled elements; or number of ordered partitions of [n].
 * @author Sean A. Irvine
 */
public class A000670 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000670() {
    super(0);
  }

  protected int mN = -1;
  protected final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      s = s.add(mF.factorial(k).multiply(Stirling.secondKind(mN, k)));
    }
    return s;
  }
}
#!queue	A000700	0	->	0	A000593	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.math.z.Z;

/**
 * A000700 Expansion of Product_{k&gt;=0} (1 + x^(2k+1)); number of partitions of n into distinct odd parts; number of self-conjugate partitions; number of symmetric Ferrers graphs with n nodes.
 * @author Sean A. Irvine
 */
public class A000700 extends A000593 {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  protected final ArrayList<Z> mA = new ArrayList<>();
  private final ArrayList<Z> mB = new ArrayList<>();
  private boolean mFirst = true;

  /** Construct the sequence. */
  public A000700() {
    super(0);
  }

  @Override
  public Z next() {
    if (mFirst) {
      mFirst = false;
      mA.add(Z.ONE);
      return Z.ONE;
    }
    mB.add(super.next());
    if (mFirst || mN == 1) {
      mA.add(Z.ONE);
      return Z.ONE;
    }
    final int n = (int) mN;
    Z s = Z.ZERO;
    for (int k = 0; k < n; ++k) {
      final Z t = mB.get(k).multiply(mA.get(n - 1 - k));
      s = s.signedAdd((k & 1) == 0, t);
    }
    s = s.divide(n);
    mA.add(s);
    return s;
  }
}

#!queue	A000720	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000720 pi(n), the number of primes &lt;= n. Sometimes called PrimePi(n) to distinguish it from the number 3.14159...
 * @author Sean A. Irvine
 */
public class A000720 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000720() {
    super(1);
  }

  protected Z mN = Z.ZERO;
  private Z mP = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    if (mN.isPrime()) {
      mP = mP.add(1);
    }
    return mP;
  }
}
#!queue	A000721	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.HararyMultiply;
import irvine.math.polynomial.MultivariateMonomial;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A000721 Number of balanced Boolean functions of n variables.
 * @author Sean A. Irvine
 */
public class A000721 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000721() {
    super(1);
  }

  /*
    Computation follows the method described in "Enumerating Types of
    Boolean Functions" by Alasdair Urquhart.  As such it is quite a
    lot more general than this sequence, and actually computes successive
    generating functions (by n) for the number of boolean functions with
    n outputs and k true outputs.  This sequence has k == 2^(n-1).
  */

  private static Z e(final int v) {
    Z s = Z.ZERO;
    for (final Z dd : Jaguar.factor(v).divisors()) {
      final int d = dd.intValue();
      final int m = Mobius.mobius(v / d);
      if (m != 0) {
        s = s.signedAdd(m == 1, Z.ONE.shiftLeft(d));
      }
    }
    return s.divide(v);
  }

  private static Z g(final int v) {
    if ((v & 1) == 1) {
      return Z.ZERO;
    }
    Z s = Z.ZERO;
    final int m = v / 2;
    for (final Z dd : Jaguar.factor(v).divisors()) {
      final int d = dd.intValue();
      if (m % d != 0) {
        final int t = Mobius.mobius(v / d);
        if (t != 0) {
          s = s.signedAdd(t == 1, Z.ONE.shiftLeft(d / 2));
        }
      }
    }
    return s.divide(v);
  }

  private CycleIndex z(final int n) {
    return SymmetricGroup.create(n).cycleIndex();
  }

  MultivariateMonomial ia1(final int r) {
    final MultivariateMonomial res = new MultivariateMonomial();
    for (final Z vv : Jaguar.factor(r).divisors()) {
      final int v = vv.intValue();
      res.add(v, e(v));
    }
    return res;
  }

  private MultivariateMonomial ia2(final int r) {
    final MultivariateMonomial res = new MultivariateMonomial();
    final int rr = 2 * r;
    for (final Z vv : Jaguar.factor(rr).divisors()) {
      final int v = vv.intValue();
      if (r % v != 0) {
        res.add(v, g(v));
      }
    }
    return res;
  }

  protected CycleIndex iZ2(final int r) {
    final CycleIndex iz = new CycleIndex("I(Z(2))");
    final MultivariateMonomial m1 = ia1(r);
    m1.setCoefficient(Q.HALF);
    iz.add(m1);
    final MultivariateMonomial m2 = ia2(r);
    m2.setCoefficient(Q.HALF);
    iz.add(m2);
    return iz;
  }

  private CycleIndex power(final CycleIndex ci, final Z power) {
    CycleIndex c = ci;
    for (Z k = Z.TWO; k.compareTo(power) <= 0; k = k.add(1)) {
      c = c.op(HararyMultiply.OP, ci);
    }
    return c;
  }

  private CycleIndex multiply(final CycleIndex a, final CycleIndex b) {
    if (a.isEmpty()) {
      return b;
    }
    if (b.isEmpty()) {
      return a;
    }
    return a.op(HararyMultiply.OP, b);
  }

  protected CycleIndex f(final int n) {
    // This recomputes a lot of quantities that could be cached or
    // incrementally built.  However, this was complicated enough to
    // get working, that I've opted not to do that for now.
    final CycleIndex zn = z(n);
    final CycleIndex[] iz = new CycleIndex[n + 1];
    for (int k = 1; k < iz.length; ++k) {
      iz[k] = iZ2(k);
    }
    final ArrayList<CycleIndex> r = new ArrayList<>();
    for (final MultivariateMonomial t : zn.values()) {
      final int md = t.maxIndex();
      CycleIndex w = new CycleIndex(t.toString());
      for (int j = 1; j <= md; ++j) {
        final Z d = t.get(new Pair<>(MultivariateMonomial.DEFAULT_VARIABLE, j));
        if (d.signum() > 0) {
          w = multiply(w, power(iz[j], d));
        }
      }
      w.multiply(t.getCoefficient());
      r.add(w);
    }

    final CycleIndex ans = new CycleIndex("G");
    for (final CycleIndex w : r) {
      ans.add(w);
    }
    return ans;
  }

  int mN = 0;

  @Override
  public Z next() {
    final CycleIndex ans = f(++mN);
    //System.out.println(ans);
    final Polynomial<Q> gf = ans.applyOnePlusXToTheN();
    //System.out.println(gf);
    return gf.coeff(1 << (mN - 1)).toZ();
  }
}
#!queue	A000722	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000722 Number of invertible Boolean functions of n variables: a(n) = (2^n)!.
 * @author Sean A. Irvine
 */
public class A000722 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000722() {
    super(0);
  }

  int mN = -1;

  @Override
  public Z next() {
    int f = 1 << ++mN;
    Z p = Z.ONE;
    while (f > 1) {
      p = p.multiply(f--);
    }
    return p;
  }
}
#!queue	A000741	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000741 Number of compositions of n into 3 ordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A000741 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000741() {
    super(1);
  }

  private long mN = 0;

  protected Z p(final Z n) {
    return n.subtract(2).multiply(n.subtract(1)).divide2();
  }

  @Override
  public Z next() {
    Z sum = Z.ZERO;
    for (final Z d : Jaguar.factor(++mN).divisors()) {
      sum = sum.add(p(d).multiply(Mobius.mobius(mN / d.longValue())));
    }
    return sum;
  }
}
#!queue	A000759	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.lattice.Lattices;
import irvine.math.lattice.ParallelWalker;
import irvine.math.lattice.SelfAvoidingWalker;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000759 Number of n-step self-avoiding walks on cubic lattice ending at point with x=0.
 * @author Sean A. Irvine
 */
public class A000759 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000759() {
    super(0);
  }

  private final ParallelWalker mWalker = new ParallelWalker(8,
    () -> new SelfAvoidingWalker(Lattices.Z3),
    () -> new SelfAvoidingWalker(Lattices.Z3) {
      {
        setAccumulator((walk, weight, axesMask) -> {
          if (mLattice.ordinate(walk[walk.length - 1], 0) == targetX()) {
            increment(weight);
          }
        });
      }

      @Override
      protected boolean isAcceptable(final long point, final int remainingSteps) {
        return super.isAcceptable(point, remainingSteps) && Math.abs(mLattice.ordinate(point, 0) - targetX()) <= remainingSteps;
      }
    });
  private final long mX = Lattices.Z3.toPoint(1, 0, 0);
  private final long mXN = Lattices.Z3.toPoint(-1, 0, 0);
  private final long mY = Lattices.Z3.toPoint(0, 1, 0);
  private int mN = -1;

  protected long targetX() {
    return 0;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    // There is an asymmetry in this problem depending on whether the first step
    // is in the X direction.  A first step in Y or Z is "equivalent" and can
    // be counted with multiplicity 2.  In both cases there is an additional
    // multiplicity of 2 for symmetry +1 versus -1.
    final Z a;
    if (targetX() == 0) {
      a = Z.valueOf(mWalker.count(mN, 2, 1, Lattices.Z3.origin(), mX));
      mWalker.clear();
    } else {
      final Z a1 = Z.valueOf(mWalker.count(mN, 1, 1, Lattices.Z3.origin(), mX));
      mWalker.clear();
      final Z a2 = Z.valueOf(mWalker.count(mN, 1, 1, Lattices.Z3.origin(), mXN));
      mWalker.clear();
      a = a1.add(a2);
    }
    final Z b = Z.valueOf(mWalker.count(mN, 4, targetX() == 0 ? 2 : 3, Lattices.Z3.origin(), mY));
    mWalker.clear();
    return a.add(b);
  }
}
#!queue	A000765	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.lattice.Lattices;
import irvine.math.lattice.ParallelWalker;
import irvine.math.lattice.SelfAvoidingWalker;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000765 Number of n-step self-avoiding walks on f.c.c. lattice ending at point with x = 0.
 * @author Sean A. Irvine
 */
public class A000765 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000765() {
    super(0);
  }

  private final ParallelWalker mWalker = new ParallelWalker(8,
    () -> new SelfAvoidingWalker(Lattices.FCC),
    () -> new SelfAvoidingWalker(Lattices.FCC) {
      {
        setAccumulator((walk, weight, axesMask) -> {
          if (mLattice.ordinate(walk[walk.length - 1], 0) == targetX()) {
            increment(weight);
          }
        });
      }

      @Override
      protected boolean isAcceptable(final long point, final int remainingSteps) {
        return super.isAcceptable(point, remainingSteps) && Math.abs(mLattice.ordinate(point, 0) - targetX()) <= remainingSteps;
      }
    });
  private final long mA = Lattices.FCC.toPoint(1, 1, 0);
  private final long mAN = Lattices.FCC.toPoint(-1, 1, 0);
  private final long mB = Lattices.FCC.toPoint(0, 1, 1);
  private int mN = -1;

  protected long targetX() {
    return 0;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    // There is an asymmetry in this problem depending on whether the first step
    // is in the X direction.  A first step in Y or Z is "equivalent" and can
    // be counted with multiplicity 2.  In both cases there is an additional
    // multiplicity of 2 for symmetry +1 versus -1.
    final Z a;
    if (targetX() == 0) {
      a = Z.valueOf(mWalker.count(mN, 8, 7, Lattices.FCC.origin(), mA));
      mWalker.clear();
    } else {
      final Z a1 = Z.valueOf(mWalker.count(mN, 4, 7, Lattices.FCC.origin(), mA));
      mWalker.clear();
      final Z a2 = Z.valueOf(mWalker.count(mN, 4, 7, Lattices.FCC.origin(), mAN));
      mWalker.clear();
      a = a1.add(a2);
    }
    final Z b = Z.valueOf(mWalker.count(mN, 4, 7, Lattices.FCC.origin(), mB));
    mWalker.clear();
    return a.add(b);
  }
}

//public class A000765 extends A001336 {
//
//  // There is an asymmetry in this problem depending on whether the first step
//  // is in the X direction.  A first step in Y or Z is "equivalent" and can
//  // be counted with multiplicity 2.  In both cases there is an additional
//  // multiplicity of 2 for +1 versus -1.
//
//  @Override
//  protected long count(final int point) {
//    return x(point) == BIAS ? 1 : 0;
//  }
//
//  @Override
//  public Z next() {
//    if (++mN == 0) {
//      return Z.ONE;
//    }
//    setPathLength(mN);
//    setPathElement(0, ORIGIN);
//    return Z.valueOf(8 * count(ORIGIN + X1 + Y1, 1) + 4 * count(ORIGIN + Y1 + 1, 1));
//  }
//}
#!queue	A000793	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.IntegerUtils;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000793 Landau's function g(n): largest order of permutation of n elements. Equivalently, largest LCM of partitions of n.
 * @author Sean A. Irvine
 */
public class A000793 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000793() {
    super(0);
  }

  protected int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final IntegerPartition p = new IntegerPartition(mN);
    int[] v;
    Z best = Z.ZERO;
    while ((v = p.next()) != null) {
      final Z lcm = IntegerUtils.lcm(v);
      if (lcm.compareTo(best) > 0) {
        best = lcm;
      }
    }
    return best;
  }
}
#!queue	A000806	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000806 Bessel polynomial y_n(-1).
 * @author Sean A. Irvine
 */
public class A000806 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000806() {
    super(0);
  }

  private Z mA = Z.ZERO;
  private Z mB = Z.ONE;
  private long mN = -1;

  @Override
  public Z next() {
    final Z t = mB.multiply(1 - 2 * ++mN).add(mA);
    mA = mB;
    mB = t;
    return t;
  }
}

#!queue	A000866	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000866 2^n written in base 5.
 * @author Sean A. Irvine
 */
public class A000866 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000866() {
    super(0);
  }

  private Z mN = null;

  @Override
  public Z next() {
    mN = mN == null ? Z.ONE : mN.multiply2();
    return new Z(mN.toString(5));
  }
}
#!queue	A000915	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000915 Stirling numbers of first kind s(n+4, n).
 * @author Sean A. Irvine
 */
public class A000915 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000915() {
    super(1);
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return Stirling.firstKind(mN + 4, mN);
  }
}

#!queue	A000931	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000931 Padovan sequence (or Padovan numbers): a(n) = a(n-2) + a(n-3) with a(0) = 1, a(1) = a(2) = 0.
 * @author Sean A. Irvine
 */
public class A000931 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000931() {
    super(0);
  }

  private Z mA = Z.ZERO;
  private Z mB = Z.ONE;
  private Z mC = Z.NEG_ONE;

  @Override
  public Z next() {
    final Z t = mA.add(mB);
    mA = mB;
    mB = mC;
    mC = t;
    return t;
  }
}
#!queue	A000939	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000939 Number of inequivalent n-gons.
 * @author Sean A. Irvine
 */
public class A000939 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000939() {
    super(1);
  }

  private int mN = 0;
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  private Z sum(final Z initial) {
    Z t = initial;
    for (int d = 1; d <= mN; ++d) {
      if (mN % d == 0) {
        final Z r = Z.valueOf(mN / d);
        t = t.add(Euler.phi(r).square().multiply(mF.factorial(d)).multiply(r.pow(d)));
      }
    }
    return t.divide(2L * mN * mN);
  }

  private Z even() {
    final int m = mN / 2;
    return sum(mF.factorial(m).multiply(m).shiftLeft(m));
  }

  private Z odd() {
    return sum(Z.ZERO);
  }

  @Override
  public Z next() {
    if (++mN < 3) {
      return Z.ONE;
    }
    return (mN & 1) == 0 ? even() : odd();
  }
}

#!queue	A000940	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000940 Number of n-gons with n vertices.
 * @author Sean A. Irvine
 */
public class A000940 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000940() {
    super(3);
  }

  private int mN = 2;
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  private Z sum(final Z initial) {
    Z t = initial;
    for (int d = 1; d <= mN; ++d) {
      if (mN % d == 0) {
        final Z r = Z.valueOf(mN / d);
        t = t.add(Euler.phi(r).square().multiply(mF.factorial(d)).multiply(r.pow(d)));
      }
    }
    return t.divide(4L * mN * mN);
  }

  private Z even() {
    final int m = mN / 2;
    return sum(mF.factorial(m).multiply((long) mN * (mN + 6)).shiftLeft(m - 2));
  }

  private Z odd() {
    final int m = (mN - 1) / 2;
    return sum(mF.factorial(m).multiply((long) mN * mN).shiftLeft(m));
  }

  @Override
  public Z next() {
    return (++mN & 1) == 0 ? even() : odd();
  }
}
#!queue	A000949	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000949 Number of forests with n nodes and height at most 2.
 * @author Sean A. Irvine
 */
public class A000949 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000949() {
    super(0);
  }

  protected int mN = -1;
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ONE;
    final Z fn = mF.factorial(mN);
    for (int m = 1; m < mN; ++m) {
      final Z r = fn.divide(mF.factorial(m));
      Z mp = Z.ONE;
      for (int k = 1; k <= mN - m; ++k) {
        mp = mp.multiply(m);
        final Z kp = Z.valueOf(k).pow(mN - m - k);
        s = s.add(mp.multiply(kp).multiply(r).divide(mF.factorial(k)).divide(mF.factorial(mN - m - k)));
      }
    }
    return s;
  }
}
#!queue	A000959	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicLongArray;

/**
 * A000959 Lucky numbers.
 * @author David W. Wilson
 * @author Sean A. Irvine
 */
public class A000959 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000959() {
    super(1);
  }

  protected final LongDynamicLongArray mLucky = new LongDynamicLongArray();
  private long mN = -1;
  private long mG = 0;

  @Override
  public Z next() {
    if (++mN == 0) {
      mLucky.set(0, 1L);
    } else if (mN == 1) {
      mLucky.set(1, 3L);
    } else {
      // Compute the mNth lucky number
      // Update mG to largest index with mLucky[mG] <= mN+1
      if (mLucky.get(mG + 1) <= mN + 1) {
        ++mG;
      }

      // Now we are going to trace the position k of the mNth
      // lucky number backwards through the sieving process.
      // k is the nth lucky number, so it is at position mN
      // after all the sieves.
      long k = mN;

      // If mLucky[i] > mN+1, the sieve on mLucky[i] does not alter
      // the position of the mNth lucky number, that is, does not
      // alter k. So we need to run backwards through the sieves
      // for which mLucky[i] <= mN+1. The last such sieve is the
      // sieve for mLucky[mG], by definition of mG.

      // So, we run backwards through the sieves for mLucky[mG]
      // down to the sieve for mLucky[1] = 3.
      for (long i = mG; i > 0; --i) {
        // Here k is the position of the mNth lucky number
        // after the sieve on mLucky[i]. Adjust the position
        // prior to the sieve on mLucky[i].
        k = k * mLucky.get(i) / (mLucky.get(i) - 1);
      }

      // Here k is the position of the mNth lucky number prior to
      // sieve on 3; that is, after the sieve on 2. Adjust the
      // position prior to the sieve on 2.
      k = 2 * k;

      // Here k is the position of the mNth lucky number prior to
      // the sieve on 2, that is, within the natural numbers
      // (1, 2, 3, ...) indexed on 0. So the nth lucky number is
      mLucky.set(mN, k + 1);
    }
    return Z.valueOf(mLucky.get(mN));
  }
}
#!queue	A000960	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000960 Flavius Josephus's sieve: Start with the natural numbers; at the k-th sieving step, remove every (k+1)-st term of the sequence remaining after the (k-1)-st sieving step; iterate.
 * @author Sean A. Irvine
 */
public class A000960 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000960() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    Z a = Z.valueOf(++mN);
    for (long d = mN - 1; d > 0; --d) {
      a = a.add(d - 1).divide(d).add(1).multiply(d);
    }
    return a;
  }
}
#!queue	A000984	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a000;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A000984 Central binomial coefficients: binomial(2*n,n) = (2*n)!/(n!)^2.
 * @author Sean A. Irvine
 */
public class A000984 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A000984() {
    super(0);
  }

  private Z mV = Z.ONE;
  protected long mN = -1;

  @Override
  public Z next() {
    if (++mN > 0) {
      mV = mV.multiply(4 * mN - 2).divide(mN);
    }
    return mV;
  }
}

#!queue	A001003	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001003 Schroeder's second problem (generalized parentheses); also called super-Catalan numbers or little Schroeder numbers.
 * @author Sean A. Irvine
 */
public class A001003 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001003() {
    super(0);
  }

  protected int mN = -1;
  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    if (++mN < 2) {
      return Z.ONE;
    }
    final Z t = mB.multiply(6L * mN - 3)
      .subtract(mA.multiply(mN - 2L))
      .divide(mN + 1L);
    mA = mB;
    mB = t;
    return t;
  }
}
#!queue	A001037	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A001037 Number of degree-n irreducible polynomials over GF(2); number of n-bead necklaces with beads of 2 colors when turning over is not allowed and with primitive period n; number of binary Lyndon words of length n.
 * @author Sean A. Irvine
 */
public class A001037 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001037() {
    super(0);
  }

  protected int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(mN).divisors()) {
      final int d = dd.intValue();
      final Z z = Z.ONE.shiftLeft(d);
      sum = ZUtils.mobiusAdd(Mobius.mobius(mN / d), sum, z);
    }
    return sum.divide(mN);
  }
}
#!queue	A001044	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001044 a(n) = (n!)^2.
 * @author Sean A. Irvine
 */
public class A001044 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001044() {
    super(0);
  }

  private Z mF = null;
  private long mN = 0;

  @Override
  public Z next() {
    if (mF == null) {
      mF = Z.ONE;
    } else {
      mF = mF.multiply(Z.valueOf(++mN).square());
    }
    return mF;
  }
}
#!queue	A001045	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001045 Jacobsthal sequence (or Jacobsthal numbers): a(n) = a(n-1) + 2*a(n-2), with a(0) = 0, a(1) = 1; also a(n) = nearest integer to 2^n/3.
 * @author Sean A. Irvine
 */
public class A001045 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001045() {
    super(0);
  }

  private Z mA = null;
  private Z mB = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ZERO;
      return Z.ZERO;
    }
    if (mB == null) {
      mB = Z.ONE;
      return Z.ONE;
    }
    final Z t = mB.add(mA.multiply2());
    mA = mB;
    mB = t;
    return t;
  }
}
#!queue	A001055	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001055 The multiplicative partition function: number of ways of factoring n with all factors greater than 1 (a(1) = 1 by convention).
 * @author Sean A. Irvine
 */
public class A001055 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001055() {
    super(1);
  }

  private final PrimeDivision mFactor = new PrimeDivision();
  protected final Fast mPrime = new Fast();
  protected long mN = 0;

  protected long t(final long n, final long m) {
    if (mPrime.isPrime(n)) {
      return n <= m ? 1 : 0;
    }

    long sum = 0;
    final long excl = Math.min(m + 1, n);
    for (final Z dd : mFactor.factorize(Z.valueOf(n)).divisors()) {
      final long d = dd.longValue();
      if (d != 1 && d < excl) {
        sum += t(n / d, d);
      }
    }
    if (n <= m) {
      ++sum;
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    } else {
      return Z.valueOf(t(mN, mN));
    }
  }
}
#!queue	A001065	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001065 Sum of proper divisors (or aliquot parts) of n: sum of divisors of n that are less than n.
 * @author Sean A. Irvine
 */
public class A001065 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001065() {
    super(1);
  }

  protected long mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(++mN).sigma().subtract(mN);
  }
}
#!queue	A001067	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.q.BernoulliSequence;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001067 Numerator of Bernoulli(2*n)/(2*n).
 * @author Sean A. Irvine
 */
public class A001067 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001067() {
    super(1);
  }

  private final BernoulliSequence mB = new BernoulliSequence(1);
  private long mN = 0;

  @Override
  public Z next() {
    mN += 2;
    mB.nextQ(); // skip odd terms
    final Q s = mB.nextQ().divide(mN);
    return s.num();
  }
}

#!queue	A001093	-1	->	-1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001093 a(n) = n^3 + 1.
 * @author Sean A. Irvine
 */
public class A001093 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001093() {
    super(-1);
  }

  private Z mN = Z.valueOf(-2);

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.pow(3).add(1);
  }
}

#!queue	A001097	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001097 Twin primes.
 * @author Sean A. Irvine
 */
public class A001097 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001097() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  private Z mN = Z.TWO;

  @Override
  public Z next() {
    while (true) {
      mN = mPrime.nextPrime(mN);
      if (mPrime.isPrime(mN.add(2)) || mPrime.isPrime(mN.subtract(2))) {
        return mN;
      }
    }
  }
}

#!queue	A001106	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001106 9-gonal (or enneagonal or nonagonal) numbers: a(n) = n*(7*n-5)/2.
 * @author Sean A. Irvine
 */
public class A001106 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001106() {
    super(0);
  }

  protected Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.multiply(mN.multiply(7).subtract(5)).divide2();
  }
}

#!queue	A001142	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001142 a(n) = Product_{k=1..n} k^(2k - 1 - n).
 * @author Sean A. Irvine
 */
public class A001142 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001142() {
    super(0);
  }

  protected int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z p = Z.ONE;
    for (int k = 1; k < mN; ++k) {
      p = p.multiply(Binomial.binomial(mN, k));
    }
    return p;
  }
}
#!queue	A001168	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.lattice.Hunter;
import irvine.math.lattice.Lattices;
import irvine.math.lattice.ParallelHunter;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001168 Number of fixed polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A001168 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001168() {
    super(0);
  }

  private final ParallelHunter mHunter = new ParallelHunter(7, () -> new Hunter(Lattices.Z2, true));
  private int mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(mHunter.count(++mN));
  }
}
#!queue	A001189	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001189 Number of degree-n permutations of order exactly 2.
 * @author Sean A. Irvine
 */
public class A001189 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001189() {
    super(1);
  }

  private int mN = 1;
  private Z mA = null;
  private Z mB = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ZERO;
      return Z.ZERO;
    }
    if (mB == null) {
      mB = Z.ONE;
      return Z.ONE;
    }
    final Z t = mB.add(mA.add(1).multiply(++mN));
    mA = mB;
    mB = t;
    return t;
  }
}
#!queue	A001203	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001203 Simple continued fraction expansion of Pi.
 * @author Sean A. Irvine
 */
public class A001203 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001203() {
    super(0);
  }

  private CR mU = CR.PI;

  @Override
  public Z next() {
    final Z a = mU.floor();
    final CR d = mU.subtract(CR.valueOf(a));
    mU = d.inverse();
    return a;
  }
}
#!queue	A001223	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001223 Prime gaps: differences between consecutive primes.
 * @author Sean A. Irvine
 */
public class A001223 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001223() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  private Z mP = Z.TWO;

  @Override
  public Z next() {
    final Z p = mP;
    mP = mPrime.nextPrime(mP);
    return mP.subtract(p);
  }
}
#!queue	A001233	6	->	6	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001233 Unsigned Stirling numbers of first kind s(n,6).
 * @author Sean A. Irvine
 */
public class A001233 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001233() {
    super(6);
  }

  private long mN = 5;

  @Override
  public Z next() {
    return Stirling.firstKind(++mN, 6).abs();
  }
}
#!queue	A001265	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001265 Table T(n,k) in which n-th row lists prime factors of 2^n - 1 (n &gt;= 2), with repetition.
 * @author Sean A. Irvine
 */
public class A001265 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001265() {
    super(0);
  }

  private int mN = -1;
  private final ArrayList<Z> mPending = new ArrayList<>();
  private int mPos = 0;

  protected Z base() {
    return Z.TWO;
  }

  @Override
  public Z next() {
    if (mPos >= mPending.size()) {
      mPending.clear();
      mPos = 0;
      final FactorSequence fs = Jaguar.factor(base().pow(++mN).subtract(1));
      if (fs.omega() == 0) {
        mPending.add(mN == 0 ? Z.ZERO : Z.ONE);
      } else {
        for (final Z a : fs.toZArray()) {
          for (int k = 0; k < fs.getExponent(a); ++k) {
            mPending.add(a);
          }
        }
      }
    }
    return mPending.get(mPos++);
  }
}
#!queue	A001278	4	->	4	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import java.util.Arrays;
import java.util.Collections;

import irvine.math.group.IntegerField;
import irvine.math.group.MultivariatePolynomialField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.MultivariatePolynomial;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001278 Number of permutations of length n by rises.
 * @author Sean A. Irvine
 */
public class A001278 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001278() {
    super(4);
  }

  private static final MultivariatePolynomialField<Z> RING1 = new MultivariatePolynomialField<>(IntegerField.SINGLETON, 2);
  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final MultivariatePolynomial<Z> NUM = new MultivariatePolynomial<>(IntegerField.SINGLETON, 2, new int[][]{{2, 0}, {2, 1}, {1, 0}}, Arrays.asList(Z.ONE, Z.NEG_ONE, Z.NEG_ONE));
  private static final MultivariatePolynomial<Z> DEN = new MultivariatePolynomial<>(IntegerField.SINGLETON, 2, new int[][]{{2, 0}, {2, 1}, {0, 0}}, Arrays.asList(Z.ONE, Z.NEG_ONE, Z.NEG_ONE));
  private int mN = 2 * order() - 1;

  protected int order() {
    return 2;
  }

  @Override
  public Z next() {
    MultivariatePolynomial<Z> num = new MultivariatePolynomial<>(IntegerField.SINGLETON, 2, new int[][] {{0, 0}}, Collections.singletonList(Z.ONE));
    MultivariatePolynomial<Z> den = num;
    ++mN;
    // This is a bit of a guess on these constraints
    final int[] lim = {mN + 1, order()};
    Polynomial<Z> p = RING.one();
    Z f = Z.ONE;
    for (int k = 1; k <= mN; ++k) {
      f = f.multiply(k);
      num = num.multiply(NUM, lim);
      den = den.multiply(DEN, lim);
      final Polynomial<Z> s = RING1.series(num, den, order(), mN);
      p = RING.add(p, RING.multiply(s, f));
    }
    return p.coeff(mN);
  }

}
#!queue	A001285	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001285 Thue-Morse sequence: let A_k denote the first 2^k terms; then A_0 = 1 and for k &gt;= 0, A_{k+1} = A_k B_k, where B_k is obtained from A_k by interchanging 1's and 2's.
 * @author Sean A. Irvine
 */
public class A001285 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001285() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(1 + (Long.bitCount(++mN) & 1));
  }
}
#!queue	A001303	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001303 Stirling numbers of first kind, s(n+3, n), negated.
 * @author Sean A. Irvine
 */
public class A001303 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001303() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return Stirling.firstKind(mN + 3, mN).negate();
  }
}
#!queue	A001329	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.IntegerUtils;
import irvine.math.group.SymmetricGroup;
import irvine.math.partitions.IntegerPartition;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001329 Number of nonisomorphic groupoids with n elements.
 * @author Sean A. Irvine
 */
public class A001329 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001329() {
    super(0);
  }

  private int mN = start();

  protected int start() {
    return -1;
  }

  protected Z innerSum(final int[] j, final int m) {
    Z sum = Z.ZERO;
    for (int d = 1; d < j.length; ++d) {
      if (m % d == 0) {
        sum = sum.add((long) d * j[d]);
      }
    }
    return sum;
  }

  protected int scale() {
    return 1;
  }

  protected Z fix(final int[] j) {
    Z prod = Z.ONE;
    for (int r = 1; r < j.length; ++r) {
      for (int s = 1; s < j.length; ++s) {
        prod = prod.multiply(innerSum(j, IntegerUtils.lcm(r, s)).pow((long) scale() * j[r] * j[s] * IntegerUtils.gcd(r, s)));
      }
    }
    return prod;
  }

  @Override
  public Z next() {
    if (++mN <= 1) {
      return Z.ONE;
    }
    final IntegerPartition ip = new IntegerPartition(mN);
    final int[] a = new int[mN + 1];
    Q s = Q.ZERO;
    int[] p;
    while ((p = ip.next()) != null) {
      IntegerPartition.toCountForm(p, a);
      s = s.add(new Q(fix(a), SymmetricGroup.per(a)));
    }
    return s.toZ();
  }
}
#!queue	A001350	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001350 Associated Mersenne numbers.
 * @author Sean A. Irvine
 */
public class A001350 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001350() {
    super(0);
  }

  private Z mA = Z.ONE;
  private Z mB = Z.NEG_ONE;
  private int mSign = -1;

  @Override
  public Z next() {
    mSign = -mSign;
    final Z t = mA.add(mB).add(1 - mSign);
    mA = mB;
    mB = t;
    return t;
  }
}
#!queue	A001358	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000040;

/**
 * A001358 Semiprimes (or biprimes): products of two primes.
 * @author Sean A. Irvine
 */
public class A001358 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001358() {
    super(1);
  }

  private final MemorySequence mPrimes = MemorySequence.cachedSequence(new A000040());
  private final TreeSet<Z> mA = new TreeSet<>();
  private Z mP = mPrimes.next();

  @Override
  public Z next() {
    while (mA.isEmpty() || mA.first().compareTo(mP.multiply2()) >= 0) {
      for (int k = 0; k < mPrimes.size(); ++k) {
        mA.add(mP.multiply(mPrimes.a(k)));
      }
      mP = mPrimes.next();
    }
    return mA.pollFirst();
  }
}
#!queue	A001405	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001405 a(n) = binomial(n, floor(n/2)).
 * @author Sean A. Irvine
 */
public class A001405 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001405() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    if (++mN >= 2) {
      final Z t = mB.multiply2().add(mA.multiply(mN - 1).shiftLeft(2)).divide(mN + 1);
      mA = mB;
      mB = t;
    }
    return mB;
  }
}
#!queue	A001411	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.lattice.Lattices;
import irvine.math.lattice.ParallelWalker;
import irvine.math.lattice.SelfAvoidingWalker;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001411 Number of n-step self-avoiding walks on square lattice.
 * @author Sean A. Irvine
 */
public class A001411 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001411() {
    super(0);
  }

  protected final ParallelWalker mWalker = new ParallelWalker(8, () -> new SelfAvoidingWalker(Lattices.Z2));
  private final long mX1 = Lattices.Z2.toPoint(1, 0);
  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : Z.valueOf(mWalker.count(mN, 4, 1, Lattices.Z2.origin(), mX1));
  }
}
#!queue	A001412	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.lattice.Lattices;
import irvine.math.lattice.ParallelWalker;
import irvine.math.lattice.SelfAvoidingWalker;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001412 Number of n-step self-avoiding walks on cubic lattice.
 * @author Sean A. Irvine
 */
public class A001412 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001412() {
    super(0);
  }

  private final ParallelWalker mWalker = new ParallelWalker(8, () -> new SelfAvoidingWalker(Lattices.Z3));
  private final long mC = Lattices.Z3.neighbour(Lattices.Z3.origin(), 0);
  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : Z.valueOf(mWalker.count(mN, 6, 1, Lattices.Z3.origin(), mC));
  }
}
#!queue	A001415	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001415 Number of ways of folding a 2 X n strip of stamps.
 * @author Fred Lunnon (ALGOL68, C versions)
 * @author Sean A. Irvine (Java port)
 */
public class A001415 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001415() {
    super(0);
  }

  // Implements algorithm as described in "Multi-dimensional map-folding",
  // by W. F. Lunnon, The Computer J, 14, 1, pp. 75--80.  Note the original
  // paper contains a few omissions, so this actual code is based on a C
  // implementation by Fred Lunnon.

  // Significant changes: Java initializes all arrays to 0, so a lot of
  // initialization code was removed.
  // The original required the p[] array to be bordered with -1 sentinels,
  // this has been removed, since the length is implicit in a Java array.

  private int mN = -1;
  private long mCount = 0;

  protected void process(final int[] a, final int[] b, final int n) {
    mCount += n;
  }

  /* Perform  job(a, b, ...)  on each folding of  p[0] x ... x p[p.length - 1]  map,
    with sentinel  p[d+1] = -1 ;
    where  a[l], b[l]  denote leaf folded above, below leaf  l ;
    leaves numbered  1 <= l <= n ,  l = 0  marking outside world;
    enumerate general, normal foldings when  flag = 0, 1  resp;
    job()  must avoid modifying array parameters;  A,B  vary given  p ;
    res/mod specify which set of folding to compute in this run.  To get the
    total you need to set res = 0 .. mod-1 in turn.  You can use mod == 0, to
    run the full set at once.
     */
  protected void foldings(final int[] p, final boolean flag, final int res, final int mod) {
    int n = 1; // leaves
    for (final int pp : p) {
      n *= pp;
    }

    final int[] a = new int[n + 1];
    final int[] b = new int[n + 1];
    final int[] count = new int[n + 1];
    final int[] gapter = new int[n + 1];
    final int[] gap = new int[n * n + 1];
    /* b[m] holds leaf below leaf m in the current folding, a[m] leaf above.
       count[m] counts sections with some gap for new leaf l below leaf m,
       gap[gapter[l-1] + j] holds  j-th (possible or actual) gap for leaf l,
       later gap[gapter[l]] holds gap where leaf l is currently inserted. */

    final int dim = p.length; // dimensions
    final int[] bigP = new int[dim + 1];
    final int[][] c = new int[dim + 1][n + 1];
    final int[][][] d = new int[dim + 1][n + 1][n + 1];
    bigP[0] = 1;
    for (int i = 1; i <= dim; i++) {
      bigP[i] = bigP[i - 1] * p[i - 1];
    }
    for (int i = 1; i <= dim; i++) {
      for (int m = 1; m <= n; m++) {
        c[i][m] = (m - 1) / bigP[i - 1] - ((m - 1) / bigP[i]) * p[i - 1] + 1;
      }
    }
    for (int i = 1; i <= dim; i++) {
      for (int l = 1; l <= n; l++) {
        for (int m = 1; m <= l; m++) {
          final int delta = c[i][l] - c[i][m];
          d[i][l][m] = ((delta & 1) == 0)
            ? c[i][m] == 1 ? m : m - bigP[i - 1]
            : c[i][m] == p[i - 1] || m + bigP[i - 1] > l ? m : m + bigP[i - 1];
        }
      }
    }

    /* bigP[i] = p[1] * ... * p[i], c[i,m] = i-th coordinate of leaf m,
       d[i,l,m] =  leaf connected to  m  in section  i  when inserting  l */
    int g = 0;
    int l = 1;
    // Kick off with null folding
    while (l > 0) { // Main backtrack loop
      if (!flag || l <= 1 || b[0] == 1) { // Filter normal case
        if (l > n) {
          process(a, b, n); // Process new folding
        } else {
          int dd = 0;
          int gg = gapter[l - 1];
          g = gg;
          /* dd counts sections in which leaf l is unconstrained;
             gg, g count possible, actual gaps for l, offset by gapter[l-1] */

          // Append to stack potential gaps for leaf l in each section
          for (int i = 1; i <= dim; i++) {
            if (d[i][l][l] == l) {
              ++dd;
            } else {
              for (int m = d[i][l][l]; m != l; m = d[i][l][b[m]]) {
                if (mod == 0 || l != mod || m % mod == res) {
                  gap[gg] = m;
                  if (count[m]++ == 0) {
                    ++gg;
                  }
                }
              }
            }
          }

          // Discard from stack potential gaps not common to all sections
          if (dd == dim) {
            for (int m = 0; m < l; m++) {
              gap[gg++] = m;
            }
          }
          for (int j = g; j < gg; j++) {
            gap[g] = gap[j];
            if (count[gap[j]] == dim - dd) {
              ++g;
            }
            count[gap[j]] = 0;
          }
        }
      }

      // If no more gaps, detach leaf l and retreat to previous level
      while (l > 0 && g == gapter[l - 1]) {
        --l;
        b[a[l]] = b[l];
        a[b[l]] = a[l];
      }
      // For each gap insert leaf l and advance to next level
      if (l > 0) {
        a[l] = gap[--g];
        b[l] = b[a[l]];
        b[a[l]] = l;
        a[b[l]] = l;
        gapter[l++] = g;
      }
    }
  }

  protected int[] getDimensions(final int n) {
    return new int[] {n, 2};
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mCount = 0;
    foldings(getDimensions(mN), true, 0, 0);
    return Z.valueOf(mCount);
  }

  /**
   * Run the counting for a particular folding.
   * @param args extent of each dimension
   */
  public static void main(final String... args) {
    if (args.length == 0) {
      System.out.println("Usage: [res/mod] dimension...");
      return;
    }
    final int res;
    final int mod;
    final int slash = args[0].indexOf('/');
    int argsUsed = 0;
    if (slash >= 0) {
      res = Integer.parseInt(args[0].substring(0, slash));
      mod = Integer.parseInt(args[0].substring(slash + 1));
      ++argsUsed;
    } else {
      res = 0;
      mod = 0;
    }
    final int[] d = new int[args.length - argsUsed];
    for (int k = 0; k + argsUsed < args.length; ++k) {
      d[k] = Integer.parseInt(args[k + argsUsed]);
    }
    final A001415 folder = new A001415();
    folder.foldings(d, true, res, mod);
    System.out.println(folder.mCount);
  }
}
#!queue	A001430	1	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a001;

import java.util.Map;

import irvine.math.IntegerUtils;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.MultivariateMonomial;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.util.Pair;

/**
 * A001430 Number of graphs with n nodes and n-2 edges.
 * @author Sean A. Irvine
 */
public class A001430 extends MemoryFunction1Sequence<Polynomial<Q>> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001430() {
    super(1);
  }

  // See p. 145 in Riordan "Introduction to Combinatorial Analysis"
  private MultivariateMonomial slepian(final MultivariateMonomial t) {
    final int mm = t.maxIndex();
    final MultivariateMonomial m = new MultivariateMonomial();
    for (final Map.Entry<Pair<String, Integer>, Z> e : t.entrySet()) {
      final int j = e.getKey().right();
      // Handle terms of form a_j^k
      final Z k = e.getValue();
      if ((j & 1) == 0) {
        final int y = j / 2;
        m.add(y, k);
        m.add(j, k.multiply(k).multiply(y).subtract(k));
      } else {
        m.add(j, k.multiply(k).multiply(j).subtract(k).divide2());
      }
      // Handle all other composition terms; i.e. a_j^k o a_i^d
      for (int i = j + 1; i <= mm; ++i) {
        final Z d = t.get(new Pair<>(MultivariateMonomial.DEFAULT_VARIABLE, i));
        final int gcd = IntegerUtils.gcd(i, j);
        m.add(i * j / gcd, d.multiply(k).multiply(gcd));
      }
    }
    m.setCoefficient(t.getCoefficient());
    return m;
  }

  private CycleIndex slepian(final int n) {
    final CycleIndex zn = SymmetricGroup.create(n).cycleIndex();
    final CycleIndex ans = new CycleIndex("G");
    for (final MultivariateMonomial t : zn.values()) {
      ans.add(slepian(t));
    }
    return ans;
  }

  @Override
  protected Polynomial<Q> compute(final int n) {
    return n == 0 ? null : slepian(n).applyOnePlusXToTheN();
  }

  protected Z numberLinearGraphs(final int nodes, final int edges) {
    if (nodes == 1) {
      return edges == 0 ? Z.ONE : Z.ZERO;
    }
    if (edges < 0) {
      return Z.ZERO;
    }
    return get(nodes).coeff(edges).toZ();
  }

  protected int mN = 0;

  @Override
  public Z next() {
    return numberLinearGraphs(++mN, mN - 2);
  }

}
#!queue	A001464	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001464 Expansion of e.g.f. exp( -x -(1/2)*x^2 ).
 * @author Sean A. Irvine
 */
public class A001464 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001464() {
    super(0);
  }

  private long mN = -2;
  private Z mA = Z.ONE;
  private Z mB = Z.ZERO;

  @Override
  public Z next() {
    final Z t = mB.negate().subtract(mA.multiply(++mN));
    mA = mB;
    mB = t;
    return t;
  }
}
#!queue	A001497	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001497 Triangle of coefficients of Bessel polynomials (exponents in decreasing order).
 * @author Sean A. Irvine
 */
public class A001497 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001497() {
    super(0);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = -1;
  private int mK = 0;

  protected Z t(final int n, final int m) {
    return mF.factorial(2 * n - m)
      .shiftRight(n - m)
      .divide(mF.factorial(m))
      .divide(mF.factorial(n - m));
  }

  @Override
  public Z next() {
    if (++mK > mN) {
      ++mN;
      mK = 0;
    }
    return t(mN, mK);
  }
}
#!queue	A001550	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001550 a(n) = 1^n + 2^n + 3^n.
 * @author Sean A. Irvine
 */
public class A001550 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001550() {
    super(0);
  }

  private Z mTwo = null;
  private Z mThree = Z.ONE;

  @Override
  public Z next() {
    if (mTwo == null) {
      mTwo = Z.ONE;
    } else {
      mTwo = mTwo.multiply2();
      mThree = mThree.multiply(3);
    }
    return mThree.add(mTwo).add(1);
  }
}
#!queue	A001551	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001551 a(n) = 1^n + 2^n + 3^n + 4^n.
 * @author Sean A. Irvine
 */
public class A001551 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001551() {
    super(0);
  }

  private Z mTwo = null;
  private Z mThree = Z.ONE;
  private Z mFour = Z.ONE;

  @Override
  public Z next() {
    if (mTwo == null) {
      mTwo = Z.ONE;
    } else {
      mTwo = mTwo.multiply2();
      mThree = mThree.multiply(3);
      mFour = mFour.shiftLeft(2);
    }
    return mFour.add(mThree).add(mTwo).add(1);
  }
}
#!queue	A001552	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001552 a(n) = 1^n + 2^n + ... + 5^n.
 * @author Sean A. Irvine
 */
public class A001552 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001552() {
    super(0);
  }

  private Z mTwo = null;
  private Z mThree = Z.ONE;
  private Z mFour = Z.ONE;
  private Z mFive = Z.ONE;

  @Override
  public Z next() {
    if (mTwo == null) {
      mTwo = Z.ONE;
    } else {
      mTwo = mTwo.multiply2();
      mThree = mThree.multiply(3);
      mFour = mFour.shiftLeft(2);
      mFive = mFive.multiply(5);
    }
    return mFive.add(mFour).add(mThree).add(mTwo).add(1);
  }
}
#!queue	A001553	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001553 a(n) = 1^n + 2^n + ... + 6^n.
 * @author Sean A. Irvine
 */
public class A001553 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001553() {
    super(0);
  }

  private Z mTwo = null;
  private Z mThree = Z.ONE;
  private Z mFour = Z.ONE;
  private Z mFive = Z.ONE;
  private Z mSix = Z.ONE;

  @Override
  public Z next() {
    if (mTwo == null) {
      mTwo = Z.ONE;
    } else {
      mTwo = mTwo.multiply2();
      mThree = mThree.multiply(3);
      mFour = mFour.shiftLeft(2);
      mFive = mFive.multiply(5);
      mSix = mSix.multiply(6);
    }
    return mSix.add(mFive).add(mFour).add(mThree).add(mTwo).add(1);
  }
}
#!queue	A001554	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001554 a(n) = 1^n + 2^n + ... + 7^n.
 * @author Sean A. Irvine
 */
public class A001554 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001554() {
    super(0);
  }

  private Z mTwo = null;
  private Z mThree = Z.ONE;
  private Z mFour = Z.ONE;
  private Z mFive = Z.ONE;
  private Z mSix = Z.ONE;
  private Z mSeven = Z.ONE;

  @Override
  public Z next() {
    if (mTwo == null) {
      mTwo = Z.ONE;
    } else {
      mTwo = mTwo.multiply2();
      mThree = mThree.multiply(3);
      mFour = mFour.shiftLeft(2);
      mFive = mFive.multiply(5);
      mSix = mSix.multiply(6);
      mSeven = mSeven.multiply(7);
    }
    return mSeven.add(mSix).add(mFive).add(mFour).add(mThree).add(mTwo).add(1);
  }
}
#!queue	A001601	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001601 a(n) = 2*a(n-1)^2 - 1, if n&gt;1. a(0)=1, a(1)=3.
 * @author Sean A. Irvine
 */
public class A001601 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001601() {
    super(0);
  }

  private Z mA = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
    } else if (Z.ONE.equals(mA)) {
      mA = Z.THREE;
    } else {
      mA = mA.square().multiply2().subtract(1);
    }
    return mA;
  }
}
#!queue	A001608	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001608 Perrin sequence (or Ondrej Such sequence): a(n) = a(n-2) + a(n-3) with a(0) = 3, a(1) = 0, a(2) = 2.
 * @author Sean A. Irvine
 */
public class A001608 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001608() {
    super(0);
  }

  private Z mA = Z.TWO;
  private Z mB = Z.ONE;
  private Z mC = Z.NEG_ONE;

  @Override
  public Z next() {
    final Z t = mA.add(mB);
    mA = mB;
    mB = mC;
    mC = t;
    return t;
  }
}
#!queue	A001614	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001614 Connell sequence: 1 odd, 2 even, 3 odd, ...
 * @author Sean A. Irvine
 */
public class A001614 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001614() {
    super(1);
  }

  private long mBlockLength = 0;
  private long mBlockRemaining = 0;
  private long mN = 0;

  @Override
  public Z next() {
    if (mBlockRemaining == 0) {
      mBlockRemaining = ++mBlockLength;
      if ((mBlockLength & 1) == 1) {
        mN -= 2;
      }
    }
    --mBlockRemaining;
    mN += 2;
    return Z.valueOf(mN + (mBlockLength & 1));
  }
}
#!queue	A001692	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001692 Number of irreducible polynomials of degree n over GF(5); dimensions of free Lie algebras.
 * @author Sean A. Irvine
 */
public class A001692 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001692() {
    super(0);
  }

  private final ArrayList<Z> mPowers = new ArrayList<>();
  private int mN = -1;

  protected int colors() {
    return 5;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      mPowers.add(Z.ONE);
      return Z.ONE;
    }
    mPowers.add(mPowers.get(mN - 1).multiply(colors()));
    Z s = Z.ZERO;
    for (final Z d : Jaguar.factor(mN).divisors()) {
      final int dd = d.intValue();
      s = s.add(mPowers.get(mN / dd).multiply(Mobius.mobius(dd)));
    }
    return s.divide(mN);
  }
}
#!queue	A001764	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001764 a(n) = binomial(3*n,n)/(2*n+1) (enumerates ternary trees and also noncrossing trees).
 * @author Sean A. Irvine
 */
public class A001764 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001764() {
    super(0);
  }

  private long mN = -1;

  protected Z a1764(final long n) {
    return Binomial.binomial(3 * n, n).divide(2 * n + 1);
  }

  @Override
  public Z next() {
    return a1764(++mN);
  }
}
#!queue	A001790	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.q.Q;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001790 Numerators in expansion of 1/sqrt(1-x).
 * @author Sean A. Irvine
 */
public class A001790 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001790() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    return new Q(Binomial.binomial(2L * ++mN, mN), Z.ONE.shiftLeft(2 * mN)).num();
  }
}
#!queue	A001792	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001792 a(n) = (n+2)*2^(n-1).
 * @author Sean A. Irvine
 */
public class A001792 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001792() {
    super(0);
  }

  private int mN = -2;

  @Override
  public Z next() {
    return Z.valueOf(++mN + 3).shiftLeft(mN);
  }
}
#!queue	A001824	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001824 Central factorial numbers.
 * @author Sean A. Irvine
 */
public class A001824 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001824() {
    super(0);
  }

  private long mN = -1;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    ++mN;
    mF = mF.multiply(Z.valueOf(2 * mN + 1).square());
    Z s = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      s = s.add(mF.divide(Z.valueOf(2 * k + 1).square()));
    }
    return s;
  }
}
#!queue	A001831	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001831 Number of labeled graded partially ordered sets with n elements of height at most 1.
 * @author Sean A. Irvine
 */
public class A001831 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001831() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      s = s.add(Binomial.binomial(mN, k).multiply(Z.ONE.shiftLeft(k).subtract(1).pow(mN - k)));
    }
    return s;
  }
}
#!queue	A001840	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001840 Expansion of g.f. x/((1 - x)^2*(1 - x^3)).
 * @author Sean A. Irvine
 */
public class A001840 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001840() {
    super(0);
  }

  protected long mN = -1;

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(mN + mN % 3).multiply(mN / 3 + 1).divide2();
  }
}
#!queue	A001864	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001864 Total height of rooted trees with n labeled nodes.
 * @author Sean A. Irvine
 */
public class A001864 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001864() {
    super(1);
  }

  protected int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k < mN; ++k) {
      s = s.add(Binomial.binomial(mN, k).multiply(Z.valueOf(mN - k).pow(mN - k)).multiply(Z.valueOf(k).pow(k)));
    }
    return s;
  }
}
#!queue	A001865	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001865 Number of connected functions on n labeled nodes.
 * @author Sean A. Irvine
 */
public class A001865 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001865() {
    super(1);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  protected int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    Z m = Z.ONE;
    for (int k = 0; k < mN; ++k) {
      if (k > 1) {
        m = m.multiply(mN);
      }
      final Z t = mF.factorial(k == 0 ? mN - 1 : mN).multiply(m).divide(mF.factorial(k));
      s = s.add(t);
    }
    return s;
  }
}
#!queue	A001884	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.api.Matrix;
import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.group.IntegerField;
import irvine.math.group.MatrixRing;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001884 Hit polynomials.
 * @author Sean A. Irvine
 */
public class A001884 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001884() {
    super(1);
  }

  protected int coeff() {
    return 1;
  }

  protected final DegreeLimitedPolynomialRingField<Z> mRing = new DegreeLimitedPolynomialRingField<>(IntegerField.SINGLETON, coeff());

  private int mN = coeff() - 1;

  protected Matrix<Polynomial<Z>> a(final int n) {
    final Matrix<Polynomial<Z>> m = new DefaultMatrix<>(n, n, mRing.zero());
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        m.set(i, j, Math.abs(i - j) <= 1 ? mRing.x() : mRing.one());
      }
    }
    return m;
  }

  @Override
  public Z next() {
    final MatrixRing<Polynomial<Z>> ring = new MatrixRing<>(++mN, mRing);
    final Polynomial<Z> p = ring.permanent(a(mN));
    return p.coeff(coeff());
  }
}
#!queue	A001892	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001892 Number of permutations of (1,...,n) having n-2 inversions (n&gt;=2).
 * @author Sean A. Irvine
 */
public class A001892 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001892() {
    super(2);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final Polynomial<Z> POLY = Polynomial.create(1, -1);

  protected int delta() {
    return 1;
  }

  private int mN = delta();
  private Polynomial<Z> mP = RING.pow(POLY, mN);

  @Override
  public Z next() {
    ++mN;
    mP = RING.multiply(mP, POLY);
    Polynomial<Z> p = RING.one();
    for (int j = 1; j <= mN; ++j) {
      p = RING.multiply(p, RING.oneMinusXToTheN(j));
    }
    return RING.coeff(p, mP, mN - 1 - delta());
  }
}
#!queue	A001898	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import java.util.ArrayList;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.BernoulliSequence;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001898 Denominators of Bernoulli polynomials B(n)(x).
 * @author Sean A. Irvine
 */
public class A001898 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001898() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final BernoulliSequence mB = new BernoulliSequence(0);
  private final ArrayList<Polynomial<Q>> mBPoly = new ArrayList<>();
  protected int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      mBPoly.add(RING.one());
    } else {
      Polynomial<Q> sum = RING.zero();
      for (int t = 1; t <= mN; ++t) {
        final Polynomial<Q> b = RING.multiply(mBPoly.get(mN - t), mB.get(t).multiply(Binomial.binomial(mN, t)));
        sum = RING.signedAdd((t & 1) == 0, sum, b);
      }
      mBPoly.add(RING.shift(RING.multiply(sum, new Q(-1, mN)), 1));
    }
    final Polynomial<Q> p = mBPoly.get(mBPoly.size() - 1);
    Z den = Z.ONE;
    for (int k = 0; k <= p.degree(); ++k) {
      den = den.lcm(p.coeff(k).den());
    }
    return den;
  }
}
#!queue	A001902	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001902 Successive denominators of Wallis's approximation to Pi/2 (reduced).
 * @author Sean A. Irvine
 */
public class A001902 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001902() {
    super(0);
  }

  private long mN = 0;
  private Q mP = Q.ONE;
  private long mAdd = 1;

  @Override
  public Z next() {
    if (++mN > 1) {
      mAdd = -mAdd;
      final long n = mN & ~1;
      mP = mP.multiply(new Q(n, n + mAdd));
    }
    return mP.den();
  }
}
#!queue	A001918	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A001918 Least positive primitive root of n-th prime.
 * @author Sean A. Irvine
 */
public class A001918 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001918() {
    super(1);
  }

  protected final Fast mPrime = new Fast();
  protected Z mP = Z.ONE;

  /**
   * The prime for the most recent result
   * @return the prime
   */
  public Z getP() {
    return mP;
  }

  @Override
  public Z next() {
    mP = mPrime.nextPrime(mP);
    return ZUtils.leastPrimitiveRoot(mP);
  }
}
#!queue	A001934	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001934 Expansion of 1/theta_4(q)^2 in powers of q.
 * @author Sean A. Irvine
 */
public class A001934 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001934() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private Polynomial<Z> mNum = RING.one();
  private Polynomial<Z> mDen = RING.one();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN >= 1) {
      mNum = RING.multiply(mNum, RING.pow(RING.onePlusXToTheN(mN), 2));
      mDen = RING.multiply(mDen, RING.pow(RING.oneMinusXToTheN(mN), 2));
    }
    return RING.coeff(mNum, mDen, mN);
  }
}

#!queue	A001966	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a001;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A001966 v-pile counts for the 4-Wythoff game with i=2.
 * @author Sean A. Irvine
 */
public class A001966 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A001966() {
    super(0);
  }

  private static final CR N = CR.FIVE.sqrt().add(CR.THREE);
  private long mN = -1;

  @Override
  public Z next() {
    return N.multiply(CR.valueOf(++mN).add(CR.HALF)).floor();
  }
}
#!queue	A002034	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002034 Kempner numbers: smallest positive integer m such that n divides m!.
 * @author Sean A. Irvine
 */
public class A002034 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002034() {
    super(1);
  }

  protected int mN = 0;

  protected Z kempner(final Z n) {
    if (n.isProbablePrime()) {
      return n;
    }
    long c = 1;
    Z f = Z.ONE;
    while (true) {
      f = f.mod(n);
      if (f.isZero()) {
        return Z.valueOf(c);
      }
      f = f.multiply(++c);
    }
  }

  @Override
  public Z next() {
    return kempner(Z.valueOf(++mN));
  }
}

#!queue	A002055	5	->	5	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002055 Number of diagonal dissections of a convex n-gon into n-4 regions.
 * @author Sean A. Irvine
 */
public class A002055 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002055() {
    super(5);
  }

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    return Binomial.binomial(2 * mN + 4, mN).multiply(mN + 2).divide2();
  }
}
#!queue	A002075	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002075 Number of equivalence classes with primitive period n of base 3 necklaces, where necklaces are equivalent under rotation and permutation of symbols.
 * @author Sean A. Irvine
 */
public class A002075 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002075() {
    super(1);
  }

  private int mN = 0;

  private int hprime(final int d) {
    switch (d % 6) {
      case 0:
        return -6;
      case 3:
        return -3;
      case 1:
    case 5:
      return 1;
    default:
      return -2;
    }
  }

  private int h(final int n) {
    if (n == 1) {
      return 1;
    } else if ((n & (n - 1)) == 0) {
      return -1;
    } else {
      return 0;
    }
  }

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (final Z dd : Jaguar.factor(mN).divisors()) {
      final int d = dd.intValue();
      final int mu = Mobius.mobius(d);
      if (mu != 0) {
        final Z t = Z.THREE.pow(mN / d).multiply(hprime(d) * mu);
        s = s.add(t);
      }
    }
    s = s.divide(3);
    s = s.add(h(mN));
    return s.divide(2 * mN);
  }
}
#!queue	A002126	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002126 Number of solutions to n=p+q where p and q are primes or zero.
 * @author Sean A. Irvine
 */
public class A002126 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002126() {
    super(0);
  }

  private long mN = -1;
  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    long s = mPrime.isPrime(mN) ? 2 : 0;
    for (long k = 2; k < mN; k = mPrime.nextPrime(k)) {
      if (mPrime.isPrime(mN - k)) {
        ++s;
      }
    }
    return Z.valueOf(s);
  }
}
#!queue	A002135	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002135 Number of terms in a symmetrical determinant: a(n) = n*a(n-1) - (n-1)*(n-2)*a(n-3)/2.
 * @author Sean A. Irvine
 */
public class A002135 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002135() {
    super(0);
  }

  private Z mA = Z.NEG_ONE;
  protected Z mB = Z.ZERO;
  protected Z mC = Z.ZERO;
  protected long mN = -1;

  @Override
  public Z next() {
    ++mN;
    final Z t = mC.multiply(mN).subtract(mA.multiply(mN - 1).multiply(mN - 2).divide2());
    mA = mB;
    mB = mC;
    mC = t;
    return t;
  }
}
#!queue	A002176	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a100.A100640;

/**
 * A002176 a(n) = LCM of denominators of Cotesian numbers {C(n,k), 0 &lt;= k &lt;= n}.
 * @author Sean A. Irvine
 */
public class A002176 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002176() {
    super(1);
  }

  protected int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ONE;
    for (int k = 0; k <= mN; ++k) {
      s = s.lcm(A100640.cotesian(mN, k).den());
    }
    return s;
  }
}
#!queue	A002193	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002193 Decimal expansion of square root of 2.
 * @author Sean A. Irvine
 */
public class A002193 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002193() {
    super(1);
  }

  private Z mX = n();
  private Z mR = Z.ZERO;

  protected Z n() {
    return Z.TWO;
  }

  @Override
  public Z next() {
    long d = 0;
    while (mR.multiply(20).add(d).multiply(d).compareTo(mX) <= 0) {
      ++d;
    }
    --d;
    mX = mX.subtract(mR.multiply(20).add(d).multiply(d)).multiply(100);
    mR = mR.multiply(10).add(d);
    return Z.valueOf(d);
  }
}
#!queue	A002202	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002202 Values taken by totient function phi(m) (A000010).
 * @author Sean A. Irvine
 */
public class A002202 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002202() {
    super(1);
  }

  private Z mN = null;

  @Override
  public Z next() {
    if (mN == null) {
      mN = Z.ZERO;
      return Z.ONE;
    }
    while (true) {
      mN = mN.add(2);
      if (!Euler.inversePhi(mN).isEmpty()) {
        return mN;
      }
    }
  }
}
#!queue	A002212	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002212 Number of restricted hexagonal polyominoes with n cells.
 * @author Sean A. Irvine
 */
public class A002212 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002212() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 1) {
      final Z t = mB.multiply(3).multiply(2 * mN - 1).subtract(mA.multiply(5).multiply(mN - 2)).divide(mN + 1);
      mA = mB;
      mB = t;
    }
    return mB;
  }
}
#!queue	A002215	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import java.util.Arrays;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002215 Number of polyhexes with n hexagons, having reflectional symmetry (see Harary and Read for precise definition).
 * @author Sean A. Irvine
 */
public class A002215 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002215() {
    super(1);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> TWO_X = RING.create(Arrays.asList(Q.ZERO, Q.TWO));
  private static final Polynomial<Q> A = RING.create(Arrays.asList(Q.ONE, new Q(-3)));
  private static final Polynomial<Q> B = RING.create(Arrays.asList(Q.ZERO, new Q(-6), Q.FIVE));
  private static final Polynomial<Q> C = RING.create(Arrays.asList(Q.ONE, Q.TWO));
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    final Polynomial<Q> s = RING.subtract(A, RING.sqrt1p(B, mN));
    final Polynomial<Q> u = RING.series(s, TWO_X, mN);
    final Polynomial<Q> u2 = RING.multiply(u.substitutePower(2, mN), C, mN);
    final Polynomial<Q> gf = RING.add(RING.x(), u2);
    return gf.coeff(mN).toZ();
  }
}
#!queue	A002223	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002223 Smallest prime p of form p = 8k-1 such that first n primes (p_1=2, ..., p_n) are quadratic residues mod p.
 * @author Sean A. Irvine
 */
public class A002223 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002223() {
    super(1);
  }

  // I suspect there must be a sieve approach to this...

  private final Fast mPrime = new Fast();
  private Z mP = Z.SEVEN;
  private int mN = 0;

  protected Z residueClass() {
    return Z.SEVEN;
  }

  @Override
  public Z next() {
    ++mN;
    while (true) {
      if (mP.and(Z.SEVEN).equals(residueClass())) {
        Z p = Z.ONE;
        boolean ok = true;
        for (int k = 0; k < mN; ++k) {
          p = mPrime.nextPrime(p);
          if (p.jacobi(mP) != 1) {
            ok = false;
            break;
          }
        }
        if (ok) {
          return mP;
        }
      }
      mP = mPrime.nextPrime(mP);
    }
  }
}
#!queue	A002251	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a000.A000201;
import irvine.oeis.a001.A001950;
import irvine.util.array.LongDynamicLongArray;

/**
 * A002251 Start with the nonnegative integers; then swap L(k) and U(k) for all k &gt;= 1, where L = A000201, U = A001950 (lower and upper Wythoff sequences).
 * @author Sean A. Irvine
 */
public class A002251 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002251() {
    super(0);
  }

  private final A000201 mL = new A000201();
  private final A001950 mU = new A001950();
  private final LongDynamicLongArray mA = new LongDynamicLongArray();
  private long mN = -1;

  private void ensure(final long x) {
    while (mA.length() <= x) {
      mA.set(mA.length(), mA.length());
    }
  }

  @Override
  public Z next() {
    ensure(++mN);
    final long l = mL.next().longValueExact();
    ensure(l);
    final long u = mU.next().longValueExact();
    ensure(u);
    final long v = mA.get(u);
    mA.set(u, mA.get(l));
    mA.set(l, v);
    return Z.valueOf(mA.get(mN));
  }
}
#!queue	A002275	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002275 Repunits: (10^n - 1)/9. Often denoted by R_n.
 * @author Sean A. Irvine
 */
public class A002275 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002275() {
    super(0);
  }

  private Z mN = null;

  protected long unit() {
    return 1;
  }

  @Override
  public Z next() {
    if (mN == null) {
      mN = Z.ZERO;
    } else {
      mN = mN.multiply(10).add(unit());
    }
    return mN;
  }
}
#!queue	A002288	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002288 G.f.: q * Product_{m&gt;=1} (1-q^m)^8*(1-q^2m)^8.
 * @author Sean A. Irvine
 */
public class A002288 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002288() {
    super(0);
  }

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    Polynomial<Z> p = RING.one();
    for (int k = 1; k <= mN; ++k) {
      final Polynomial<Z> a = RING.pow(RING.oneMinusXToTheN(k), 8, mN);
      final Polynomial<Z> b = RING.pow(RING.oneMinusXToTheN(2 * k), 8, mN);
      p = RING.multiply(p, RING.multiply(a, b), mN);
    }
    return p.coeff(mN - 1);
  }
}
#!queue	A002293	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002293 Number of dissections of a polygon: binomial(4*n, n)/(3*n + 1).
 * @author Sean A. Irvine
 */
public class A002293 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002293() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return Binomial.binomial(4 * mN, mN).divide(3 * mN + 1);
  }
}
#!queue	A002302	3	->	3	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A002302 Generalized tangent numbers.
 * @author Sean A. Irvine
 */
public class A002302 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002302() {
    super(3);
  }

  private long mN = -1;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k < 0 || k > n) {
      return Z.ZERO;
    }
    if (n == 1 && k == 1) {
      return Z.ONE;
    }
    return get(n - 1, k - 1).multiply(k - 1).add(get(n - 1, k + 1).multiply(k + 1));
  }

  @Override
  public Z next() {
    ++mN;
    return get(mN + 4, mN);
  }
}
#!queue	A002306	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import java.util.HashMap;

import irvine.math.q.Q;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002306 Numerators of Hurwitz numbers H_n (coefficients in expansion of Weierstrass P-function).
 * @author Sean A. Irvine
 */
public class A002306 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002306() {
    super(1);
  }

  private static final Q H0 = new Q(1, 10);

  private final HashMap<Long, Q> mCache = new HashMap<>();
  private int mN = 0;

  protected Q hurwitz(final long n) {
    if (n == 1) {
      return H0;
    }
    final Q r = mCache.get(n);
    if (r != null) {
      return r;
    }
    Q s = Q.ZERO;
    for (long k = 1; k < n; ++k) {
      final Q c = hurwitz(n - k).multiply(hurwitz(k));
      final Q t = c.multiply(Binomial.binomial(4 * n, 4 * k)).multiply(4 * n - 4 * k - 1).multiply(4 * k - 1);
      s = s.add(t);
    }
    final Z d = Z.valueOf(n).square().shiftLeft(4).subtract(1).multiply(2 * n - 3);
    s = s.multiply(new Q(Z.THREE, d));
    mCache.put(n, s);
    return s;
  }

  @Override
  public Z next() {
    return hurwitz(++mN).num();
  }
}
#!queue	A002322	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Carmichael;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002322 Reduced totient function psi(n): least k such that x^k == 1 (mod n) for all x prime to n; also known as the Carmichael lambda function (exponent of unit group mod n); also called the universal exponent of n.
 * @author Sean A. Irvine
 */
public class A002322 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002322() {
    super(1);
  }

  protected long mN = 0;

  @Override
  public Z next() {
    return Carmichael.lambda(++mN);
  }
}
#!queue	A002326	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.group.IntegersMod;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002326 Multiplicative order of 2 mod 2n+1.
 * @author Sean A. Irvine
 */
public class A002326 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002326() {
    super(0);
  }

  protected Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(2);
    return new IntegersMod(mN).ord(Z.TWO.mod(mN));
  }
}
#!queue	A002370	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002370 a(n) = (2*n-1)^2 * a(n-1) - 3*C(2*n-1,3) * a(n-2) for n&gt;1; a(0) = a(1) = 1.
 * @author Sean A. Irvine
 */
public class A002370 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002370() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 1) {
      final long k = 2 * mN - 1;
      final Z t = mB.multiply(Z.valueOf(k).square()).subtract(mA.multiply(Binomial.binomial(k, 3)).multiply(3));
      mA = mB;
      mB = t;
    }
    return mB;
  }
}
#!queue	A002378	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002378 Oblong (or promic, pronic, or heteromecic) numbers: a(n) = n*(n+1).
 * @author Sean A. Irvine
 */
public class A002378 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002378() {
    super(0);
  }

  protected Z mN = Z.ZERO;

  @Override
  public Z next() {
    final Z p = mN;
    mN = mN.add(1);
    return p.multiply(mN);
  }
}
#!queue	A002379	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002379 a(n) = floor(3^n / 2^n).
 * @author Sean A. Irvine
 */
public class A002379 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002379() {
    super(0);
  }

  private Z mT = Z.ONE;
  protected int mN = -1;

  @Override
  public Z next() {
    if (++mN > 0) {
      mT = mT.multiply(3);
    }
    return mT.shiftRight(mN);
  }
}
#!queue	A002385	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.string.StringUtils;

/**
 * A002385 Palindromic primes: prime numbers whose decimal expansion is a palindrome.
 * @author Sean A. Irvine
 */
public class A002385 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002385() {
    super(1);
  }

  protected final Fast mPrime = new Fast();
  private Z mP = Z.ONE;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      final String p = mP.toString();
      final int len = p.length();
      if ((len & 1) == 0 && len > 2) {
        // There are no even length prime palindromes with length > 2, so skip ahead
        mP = Z.TEN.pow(len);
        continue;
      }
      if (StringUtils.isPalindrome(p)) {
        return mP;
      }
    }
  }
}
#!queue	A002386	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002386 Primes (lower end) with record gaps to the next consecutive prime: primes p(k) where p(k+1) - p(k) exceeds p(j+1) - p(j) for all j &lt; k.
 * @author Sean A. Irvine
 */
public class A002386 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002386() {
    super(1);
  }

  protected final Fast mPrime = new Fast();
  private Z mP = Z.TWO;
  private Z mGap = Z.ZERO;
  protected long mN = 0;

  @Override
  public Z next() {
    while (true) {
      final Z a = mP;
      mP = mPrime.nextPrime(a);
      ++mN;
      final Z diff = mP.subtract(a);
      if (diff.compareTo(mGap) > 0) {
        mGap = diff;
        return a;
      }
    }
  }
}

#!queue	A002387	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002387 Least k such that H(k) &gt; n, where H(k) is the harmonic number Sum_{i=1..k} 1/i.
 * @author Sean A. Irvine
 */
public class A002387 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002387() {
    super(0);
  }

  // There is a conjectured formula that is much faster than this exact calculation

  private Q mHarmonicSum = Q.ZERO;
  private Q mN = Q.NEG_ONE;
  private Z mK = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    while (mHarmonicSum.compareTo(mN) <= 0) {
      mK = mK.add(1);
      mHarmonicSum = mHarmonicSum.add(new Q(Z.ONE, mK));
    }
    return mK;
  }
}

#!queue	A002398	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Binomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002398 Coefficients for step-by-step integration.
 * @author Sean A. Irvine
 */
public class A002398 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002398() {
    super(0);
  }

  // After Jack Grahl

  static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = -1;

  Z l(final int n) {
    if (n == 0) {
      return Z.ONE;
    }
    final Z p = l(n - 1);
    return p.lcm(Z.valueOf(n + 1));
  }

  private Z lfac(final int n) {
    return mF.factorial(n).multiply(l(n));
  }

  Z bigA(final int n, final int m) {
    return lfac(m).divide(lfac(n));
  }

  Z gamma(final int p, final int j) {
    return (p & 1) == 0 ? Binomial.binomial(j, p) : Binomial.binomial(j, p).negate();
  }

  Z alef(final int n) {
    Polynomial<Z> a = RING.one();
    for (int i = 0; i < n; ++i) {
      a = RING.multiply(a, Polynomial.create(i, 1));
    }
    Z x = Z.ZERO;
    for (int d = 0; d <= a.degree(); ++d) {
      final Z b = a.coeff(d);
      if (!Z.ZERO.equals(b)) {
        x = x.add(b.multiply(l(n).divide(d + 1)));
      }
    }
    return x;
  }

  Z delta(final int p, final int j) {
    Z sum = Z.ZERO;
    for (int k = p; k <= j; ++k) {
      sum = sum.add(gamma(p, k).multiply(bigA(k, j)).multiply(alef(k)));
    }
    return sum;
  }

  @Override
  public Z next() {
    return delta(0, ++mN);
  }
}
#!queue	A002415	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002415 4-dimensional pyramidal numbers: a(n) = n^2*(n^2-1)/12.
 * @author Sean A. Irvine
 */
public class A002415 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002415() {
    super(0);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    final Z n2 = mN.square();
    return n2.multiply(n2.subtract(1)).divide(12);
  }
}
#!queue	A002417	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002417 4-dimensional figurate numbers: a(n) = n*binomial(n+2, 3).
 * @author Sean A. Irvine
 */
public class A002417 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002417() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return Binomial.binomial(mN + 2, 3).multiply(mN);
  }
}
#!queue	A002420	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002420 Expansion of sqrt(1 - 4*x) in powers of x.
 * @author Sean A. Irvine
 */
public class A002420 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002420() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    return Binomial.binomial(2 * mN, mN).divide(1 - 2 * mN);
  }
}

#!queue	A002426	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002426 Central trinomial coefficients: largest coefficient of (1 + x + x^2)^n.
 * @author Sean A. Irvine
 */
public class A002426 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002426() {
    super(0);
  }

  protected long mN = -1;
  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 1) {
      final Z t = mB.multiply(2 * mN - 1).add(mA.multiply(3).multiply(mN - 1)).divide(mN);
      mA = mB;
      mB = t;
    }
    return mB;
  }
}
#!queue	A002445	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.BernoulliSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002445 Denominators of Bernoulli numbers B_{2n}.
 * @author Sean A. Irvine
 */
public class A002445 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002445() {
    super(0);
  }

  final BernoulliSequence mB = new BernoulliSequence(0);

  @Override
  public Z next() {
    final Z q = mB.nextQ().den();
    mB.nextQ();
    return q;
  }
}
#!queue	A002455	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002455 Central factorial numbers.
 * @author Sean A. Irvine
 */
public class A002455 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002455() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private int mN = 0;
  private Z mF = Z.TWO;

  @Override
  public Z next() {
    mN += 2;
    if (mN > 2) {
      mF = mF.multiply(mN).multiply(mN - 1);
    }
    final Q c = RING.pow(RING.asin(RING.x(), mN), 4, mN).coeff(mN);
    return c.multiply(mF).toZ().divide(24);
  }
}
#!queue	A002457	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002457 a(n) = (2n+1)!/n!^2.
 * @author Sean A. Irvine
 */
public class A002457 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002457() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 0) {
      mA = mA.multiply(2 * mN + 1).multiply2().divide(mN);
    }
    return mA;
  }
}
#!queue	A002464	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002464 Hertzsprung's problem: ways to arrange n non-attacking kings on an n X n board, with 1 in each row and column. Also number of permutations of length n without rising or falling successions.
 * @author Sean A. Irvine
 */
public class A002464 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002464() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ONE;
  private Z mB = Z.ONE;
  private Z mC = Z.ZERO;
  private Z mD = Z.ZERO;

  @Override
  public Z next() {
    if (++mN <= 3) {
      return mN <= 1 ? Z.ONE : Z.ZERO;
    }
    final Z t = mD.multiply(mN + 1)
      .subtract(mC.multiply(mN - 2))
      .subtract(mB.multiply(mN - 5))
      .add(mA.multiply(mN - 3));
    mA = mB;
    mB = mC;
    mC = mD;
    mD = t;
    return t;
  }
}

#!queue	A002467	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002467 The game of Mousetrap with n cards (given n letters and n envelopes, how many ways are there to fill the envelopes so that at least one letter goes into its right envelope?).
 * @author Sean A. Irvine
 */
public class A002467 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002467() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ZERO;

  @Override
  public Z next() {
    if (++mN > 0) {
      mA = mA.multiply(mN).signedAdd((mN & 1) == 1, Z.ONE);
    }
    return mA;
  }
}
#!queue	A002488	-1	->	-1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002488 a(n) = n^(n^n).
 * @author Sean A. Irvine
 */
public class A002488 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002488() {
    super(-1);
  }

  private Z mN = Z.valueOf(-2);

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.pow(mN.pow(mN.intValueExact()).intValueExact());
  }
}
#!queue	A002491	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002491 Smallest number of stones in Tchoukaillon (or Mancala, or Kalahari) solitaire that make use of n-th hole.
 * @author Sean A. Irvine
 */
public class A002491 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002491() {
    super(1);
  }

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    Z m = mN;
    mN = mN.add(1);
    Z a = mN;
    while (m.signum() > 0) {
      final Z t = m.subtract(1);
      a = a.add(t).divide(m).multiply(m);
      m = t;
    }
    return a;
  }
}
#!queue	A002499	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.IntegerUtils;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.SymmetricGroup;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002499 Number of self-converse digraphs with n nodes.
 * @author Sean A. Irvine
 */
public class A002499 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002499() {
    super(1);
  }

  // Compare with A126067.  This is effectively the cycle index polynomials
  // evaluated at 1.

  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;
  private int mN = 0;

  private boolean eta(final int k) {
    return (k & 3) == 2;
  }

  // Based on formula on p. 155 in "Graphical Enumeration", not error in sum2 bounds in book
  private int sum2(final int p, final int[] j) {
    int s = 0;
    for (int r = 1; r <= p; ++r) {
      for (int t = r + 1; t <= p; ++t) {
        final int gcd = IntegerUtils.gcd(r, t);
        final int lcm = IntegerUtils.lcm(r, t);
        s += IntegerUtils.gcd(2, lcm) * gcd * j[r] * j[t];
      }
    }
    return s;
  }

  // This is the simpler form in the paper -- it seems to get same numbers as above
  private int sum1(final int p, final int[] j) {
    int s = 0;
    for (int k = 1; k <= p; ++k) {
      final int gcd = IntegerUtils.gcd(2, k);
      final int a = (k - 1) * j[k];
      final int b = k * (j[k] * j[k] - j[k]);
      s += gcd * (a + b) / 2;
      if (eta(k)) {
        s += j[k];
      }
    }
    return s;
  }

  protected int epsilon(final int p, final int[] j) {
    return sum1(p, j) + sum2(p, j);
  }

  /*
  // Explicit iteration over permutations, much slower than lpf based approach
  // see circa p. 35 in "Graphical Enumeration"
  public Z nextx() {
    final SymmetricGroup<Integer> sp = SymmetricGroup.create(++mN);
    final int[] j = new int[mN + 1];
    Z s = Z.ZERO;
    for (final Permutation<Integer> alpha : sp) {
      Arrays.fill(j, 0);
      int h = mN;
      for (final List<Integer> cs : alpha.cycleStructure()) {
        j[cs.size()]++;
        h -= cs.size();
      }
      j[1] += h; // Remaining elements must be 1 cycles
      j[0] = 0; // Not necessary --- since it wil be *0 anyway in calculation
      s = s.add(Z.ONE.shiftLeft(epsilon(mN, j)));
    }
    return s.divide(mFactorial.factorial(mN));
  }
  */

  /**
   * h function.
   * @param j partition in count form
   * @return <code>h(j)</code>
   */
  public static Z h(final int[] j) {
    return FACTORIAL.factorial(j.length - 1).divide(SymmetricGroup.per(j));
  }

  @Override
  public Z next() {
    final IntegerPartition partition = new IntegerPartition(++mN);
    final int[] j = new int[mN + 1];
    int[] p;
    Z s = Z.ZERO;
    while ((p = partition.next()) != null) {
      IntegerPartition.toCountForm(p, j);
      s = s.add(h(j).shiftLeft(epsilon(mN, j)));
    }
    return s.divide(FACTORIAL.factorial(mN));
  }
}
#!queue	A002538	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002538 Second-order Eulerian numbers &lt;&lt;n+1,n-1&gt;&gt;.
 * @author Sean A. Irvine
 */
public class A002538 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002538() {
    super(1);
  }

  private Z mA = Z.ZERO;
  private Z mF = Z.ONE;
  private long mN = 0;

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    mA = mA.multiply(mN + 2).add(mF.multiply(mN));
    return mA;
  }
}
#!queue	A002545	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002545 Numerator of Sum_{i+j+k=n; i,j,k &gt; 0} 1/(i*j*k).
 * @author Sean A. Irvine
 */
public class A002545 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002545() {
    super(3);
  }

  private long mN = -1;
  private Z mF = Z.TWO;

  protected Q step() {
    ++mN;
    mF = mF.multiply(mN + 3);
    return new Q(Stirling.firstKind(mN + 3, 3).multiply(6), mF).abs();
  }

  @Override
  public Z next() {
    return step().num();
  }
}
#!queue	A002547	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.q.Q;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002547 Numerator of the n-th harmonic number H(n) divided by (n+1); a(n) = A001008(n) / ((n+1)*A002805(n)).
 * @author Sean A. Irvine
 */
public class A002547 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002547() {
    super(1);
  }

  private long mN = -1;
  private Z mF = Z.ONE;

  protected Q step() {
    ++mN;
    mF = mF.multiply(mN + 2);
    return new Q(Stirling.firstKind(mN + 2, 2).multiply2(), mF).abs();
  }

  @Override
  public Z next() {
    return step().num();
  }
}
#!queue	A002596	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.group.PolynomialRingField;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002596 Numerators in expansion of sqrt(1+x). Absolute values give numerators in expansion of sqrt(1-x).
 * @author Sean A. Irvine
 */
public class A002596 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002596() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return RING.sqrt1p(RING.x(), mN).coeff(mN).num();
  }
}
#!queue	A002599	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002599 A generalized partition function.
 * @author Sean A. Irvine
 */
public class A002599 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002599() {
    super(1);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private Polynomial<Z> mDen = RING.one();
  private int mN = 0;

  protected int limit() {
    return 5;
  }

  @Override
  public Z next() {
    if (++mN <= limit()) {
      mDen = RING.multiply(mDen, RING.pow(RING.oneMinusXToTheN(mN), mN));
    }
    final int t = Math.max(limit(), mN);
    return RING.coeff(RING.one(), mDen, t);
  }
}
#!queue	A002658	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002658 a(0) = a(1) = 1; for n &gt; 0, a(n+1) = a(n)*(a(0) + ... + a(n-1)) + a(n)*(a(n) + 1)/2.
 * @author Sean A. Irvine
 */
public class A002658 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002658() {
    super(0);
  }

  private Z mSum = null;
  private Z mPrev = null;

  @Override
  public Z next() {
    if (mSum == null) {
      mSum = Z.ONE;
      return Z.ONE;
    }
    if (mPrev == null) {
      mPrev = Z.ONE;
    } else {
      final Z t = mSum.multiply(mPrev).add(mPrev.multiply(mPrev.add(1)).divide2());
      mSum = mSum.add(mPrev);
      mPrev = t;
    }
    return mPrev;
  }
}
#!queue	A002672	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A002672 Denominators of central difference coefficients M_{3}^(2n+1).
 * @author Sean A. Irvine
 */
public class A002672 extends MemoryFunction2Sequence<Integer, Q> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002672() {
    super(1);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  @Override
  protected Q compute(final Integer k, final Integer q) {
    if (k.equals(q)) {
      return Q.ONE;
    }
    if (k == 0 || k > q || ((k + q) & 1) == 1) {
      return Q.ZERO;
    }
    if (k == 1 && (q & 1) == 1) {
      return new Q(Z.ONE, Z.ONE.shiftLeft(q - 1));
    }
    if (k == 2 && (q & 1) == 0) {
      return Q.ONE;
    }
    return get(k - 2, q - 2).add(get(k, q - 2).multiply(k * (long) k).divide(4));
  }

  protected Q bigM(final int k, final int q) {
    return get(k, q).multiply(mF.factorial(k)).divide(mF.factorial(q));
  }

  private int mN = 1;

  @Override
  public Z next() {
    mN += 2;
    return bigM(3, mN).den();
  }
}
#!queue	A002724	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.HararyMultiply;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002724 Number of inequivalent n X n binary matrices, where equivalence means permutations of rows or columns.
 * @author Sean A. Irvine
 */
public class A002724 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002724() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN <= 0) {
      return Z.ONE;
    }
    final CycleIndex zn = SymmetricGroup.create(mN).cycleIndex();
    return zn.op(HararyMultiply.OP, zn).apply(1).toZ();
  }
}
#!queue	A002729	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.LongUtils;
import irvine.math.q.Q;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002729 Number of equivalence classes of binary sequences of period n.
 * @author Sean A. Irvine
 */
public class A002729 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002729() {
    super(0);
  }

  // After maple program by Pab Ter

  private int mN = -1;

  private long m(final long k, final long l) {
    Z s = Z.ONE;
    long e = 1;
    Z kp = Z.ONE;
    while (true) {
      if (s.mod(l) == 0) {
        return e;
      }
      kp = kp.multiply(k);
      s = s.add(kp);
      ++e;
    }
  }

  private int c(final long k, final long t, final long p) {
    Q s = Q.ZERO;
    for (long u = 0; u < p; ++u) {
      s = s.add(new Q(1, m(k, p / LongUtils.gcd(p, u * (k - 1) + t))));
    }
    return s.toZ().intValueExact();
  }

  private Z n(final long p) {
    if (p <= 3) {
      return Z.valueOf(p + 1);
    }
    Z s = Z.ZERO;
    for (long t = 0; t < p; ++t) {
      for (long k = 1; k < p; ++k) {
        if (LongUtils.gcd(p, k) == 1) {
          s = s.add(Z.ONE.shiftLeft(c(k, t, p)));
        }
      }
    }
    return s.divide(p).divide(Euler.phiAsLong(p));
  }

  @Override
  public Z next() {
    return n(++mN);
  }
}
#!queue	A002762	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRing;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002762 Number of bipartite partitions.
 * @author Sean A. Irvine
 */
public class A002762 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002762() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>("y", IntegerField.SINGLETON);
  private static final PolynomialRing<Polynomial<Z>> RING_OUT = new PolynomialRing<>(RING);
  private final int mM = m();
  private final int mK = k();
  private int mN = -1;

  protected int m() {
    return 6;
  }

  protected int k() {
    return 2;
  }

  private Polynomial<Polynomial<Z>> series(final Polynomial<Polynomial<Z>> num, final Polynomial<Polynomial<Z>> den, final int order, final int m) {
    final Polynomial<Z> d = den.coeff(0);
    final ArrayList<Polynomial<Z>> a = new ArrayList<>();
    for (int k = 0; k <= order; ++k) {
      Polynomial<Z> s = num.coeff(k);
      for (int j = 0; j < k; ++j) {
        s = RING.subtract(s, RING.multiply(a.get(j), den.coeff(k - j)));
      }
      a.add(RING.series(s, d, m));
    }
    return RING_OUT.create(a);
  }

  // product(product(1-x^r * y^t),t=k..m), r=0..n) * product(1-x^s, s=1..n)
  // remember where we are up to (in terms of n) to avoid excessive recomputation
  private Polynomial<Polynomial<Z>> mCurrent = RING_OUT.one();
  private int mCurrentIndex = -1;

  private Polynomial<Polynomial<Z>> den(final int n) {
    while (mCurrentIndex < n) {
      ++mCurrentIndex;
      // left product
      for (int t = mK; t <= mM; ++t) {
        final Polynomial<Z> yt = RING.monomial(Z.ONE, t);
        mCurrent = RING_OUT.multiply(mCurrent, RING_OUT.oneMinusXToTheN(yt, mCurrentIndex));
      }
      // right product
      if (mCurrentIndex > 0) {
        mCurrent = RING_OUT.multiply(mCurrent, RING_OUT.oneMinusXToTheN(mCurrentIndex));
      }
    }
    return mCurrent;
  }

  private Polynomial<Polynomial<Z>> b(final int n) {
    final Polynomial<Polynomial<Z>> den = den(n);
    return series(RING_OUT.one(), den, n, mM);
  }

  private Z coeff(final int n) {
    return b(n).coeff(n).coeff(mM);
  }

  @Override
  public Z next() {
    return coeff(++mN);
  }
}
#!queue	A002771	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002771 Number of terms in a skew determinant: a(n) = (A000085(n) + A081919(n))/2.
 * @author Sean A. Irvine
 */
public class A002771 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002771() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    Z df = Z.ONE;
    for (long k = 0; k <= mN; k += 2) {
      s = s.add(Binomial.binomial(mN, k).multiply(df).multiply(df.add(1)).divide2());
      df = df.multiply(k + 1);
    }
    return s;
  }
}
#!queue	A002807	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002807 a(n) = Sum_{k=3..n} (k-1)!*C(n,k)/2.
 * @author Sean A. Irvine
 */
public class A002807 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002807() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ZERO;
  private Z mB = Z.ZERO;

  @Override
  public Z next() {
    if (++mN > 2) {
      final Z t = mB.multiply(mN).subtract(mA.multiply(mN - 1)).add(Z.valueOf(mN - 1).multiply(mN - 2).divide2());
      mA = mB;
      mB = t;
    }
    return mB;
  }
}

#!queue	A002829	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002829 Number of trivalent (or cubic) labeled graphs with 2n nodes.
 * @author Sean A. Irvine
 */
public class A002829 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002829() {
    super(0);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private final ArrayList<Q> mSub = new ArrayList<>();
  private int mN = -1;

  private Q sub(final int n) {
    while (n >= mSub.size()) {
      final int i = mSub.size();
      Q a = Q.ZERO;
      for (int j = 0; j <= i; ++j) {
        final Z jf = mF.factorial(j);
        Z threes = Z.ONE;
        for (int k = 0; k <= 2 * (i - j); ++k, threes = threes.multiply(3)) {
          final Z den = jf.multiply(threes).multiply(mF.factorial(k)).multiply(mF.factorial(2 * i - 2 * j - k));
          a = a.signedAdd(((j + k) & 1) == 0, new Q(mF.doubleFactorial(2 * i + 2 * k - 1), den));
        }
      }
      a = a.multiply(new Q(Z.THREE.pow(i), Z.ONE.shiftLeft(i)));
      mSub.add(a);
    }
    return mSub.get(n);
  }

  @Override
  public Z next() {
    ++mN;
    Q s = Q.ZERO;
    for (int i = 0; i <= mN; ++i) {
      s = s.add(sub(i).divide(mF.factorial(mN - i)));
    }
    return s.multiply(mF.factorial(2 * mN)).divide(Z.SIX.pow(mN)).toZ();
  }
}
#!queue	A002849	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A002849 Number of maximal collections of pairwise disjoint subsets {X,Y,Z} of {1, 2, ..., n}, each satisfying X + Y = Z.
 * @author Sean A. Irvine
 */
public class A002849 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002849() {
    super(1);
  }

  // After Franklin T. Adams-Watters

  private int mN = 0;

  private HashMap<Pair<List<Long>, Integer>, Z> mCache = new HashMap<>();

  private Z nxyz(final List<Long> v, final int t) {
    if (t == 0) {
      return Z.ONE;
    }
    final Pair<List<Long>, Integer> key = new Pair<>(v, t);
    final Z res = mCache.get(key);
    if (res != null) {
      return res;
    }
    Z r = Z.ZERO;
    for (int i3 = 3 * t; i3 < v.size(); ++i3) {
      final long n = v.get(i3);
      for (int i1 = 1; i1 <= i3 - 2; ++i1) {
        final long x2 = n - v.get(i1);
        if (x2 <= v.get(i1)) {
          break;
        }
        for (int i2 = i1 + 1; i2 < i3; ++i2) {
          if (v.get(i2) >= x2) {
            if (v.get(i2) == x2) {
              final ArrayList<Long> newV = new ArrayList<>();
              for (int k = 0; k <= i3 - 3; ++k) {
                newV.add(v.get(k < i1 ? k : (k < i2 - 1 ? k + 1 : k + 2)));
              }
              r = r.add(nxyz(newV, t - 1));
            }
            break;
          }
        }
      }
    }
    mCache.put(key, r);
    return r;
  }

  @Override
  public Z next() {
    ++mN;
    final int r = mN % 12;
    final int t = mN / 3 - (r == 6 || r == 9 ? 1 : 0);
    final ArrayList<Long> v = new ArrayList<>();
    for (long k = 0; k <= mN; ++k) {
      v.add(k);
    }
    return nxyz(v, t);
  }
}
#!queue	A002858	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002858 Ulam numbers: a(1) = 1; a(2) = 2; for n&gt;2, a(n) = least number &gt; a(n-1) which is a unique sum of two distinct earlier terms.
 * @author Sean A. Irvine
 */
public class A002858 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002858() {
    super(1);
  }

  // Ulam numbers
  protected final ArrayList<Z> mSeq = new ArrayList<>();
  private final TreeSet<Z> mSums = new TreeSet<>();
  private final HashSet<Z> mNotUnique = new HashSet<>();

  protected Z a1() {
    return Z.ONE;
  }

  protected Z a2() {
    return Z.TWO;
  }

  @Override
  public Z next() {
    if (mSeq.isEmpty()) {
      final Z a1 = a1();
      mSeq.add(a1);
      return a1;
    }
    if (mSeq.size() == 1) {
      final Z a2 = a2();
      mSeq.add(a2);
      mSums.add(a2.add(a1()));
      return a2;
    }
    final Z prev = mSeq.get(mSeq.size() - 1);
    while (true) {
      final Z next = mSums.pollFirst();
      if (next.compareTo(prev) <= 0 || mNotUnique.contains(next)) {
        mNotUnique.remove(next);
        continue;
      }
      for (final Z v : mSeq) {
        final Z s = v.add(next);
        if (!mSums.add(s)) {
          mNotUnique.add(s);
        }
      }
      mSeq.add(next);
      return next;
    }
  }
}
#!queue	A002905	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;

import irvine.math.nauty.GenerateGraphs;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002905 Number of connected graphs with n edges.
 * @author Sean A. Irvine
 */
public class A002905 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002905() {
    super(0);
  }

  private final ArrayList<Z> mEdgeCounts = new ArrayList<>();
  protected int mN = 0;

  @Override
  public Z next() {
    final GenerateGraphs gg = new GenerateGraphs(1);
    gg.setConnectionLevel(1);
    gg.setVertices(++mN);
    gg.setMaxEdges((mN * mN - mN) / 2);
    gg.sanitizeParams();
    gg.run(false, false, false, 0, 0);
    final long[] cnt = gg.edgeCounts();
    //System.out.println(mN + " " + Arrays.toString(cnt));
    for (int k = 0; k < cnt.length; ++k) {
      if (k >= mEdgeCounts.size()) {
        mEdgeCounts.add(Z.valueOf(cnt[k]));
      } else {
        mEdgeCounts.set(k, mEdgeCounts.get(k).add(cnt[k]));
      }
    }
    return mEdgeCounts.get(mN - 1);
  }
}
#!queue	A002931	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Point;

/**
 * A002931 Number of self-avoiding polygons of length 2n on square lattice (not allowing rotations).
 * @author Sean A. Irvine
 */
public class A002931 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002931() {
    super(1);
  }

  // Backtracking search -- only good for a few terms of this sequence!

  // Polygons unique up to translation.  Handled by a canonicalization method:
  // (a) translated polygon so that all points are non-negative
  // (b) select "start point" to be a point (min{x}, 0)
  // (c) select winding direction to that the first step from the "start point" increases x

  /**
   * Representation of a polygon on the square lattice.
   */
  public static final class Polygon extends LinkedHashSet<Point> {
    private final Point mHead;

    /**
     * Construct a new polygon.
     * @param parent parent polygon
     * @param head point to add
     */
    public Polygon(final Polygon parent, final Point head) {
      if (parent != null) {
        addAll(parent);
      }
      if (head != null) {
        add(head);
      }
      mHead = head;
    }

    private Point head() {
      return mHead;
    }

    /**
     * Translate to canonical position.
     * @return canonical form of the polygon
     */
    public Polygon canonicalize() {
      int minX = Integer.MAX_VALUE;
      int minY = Integer.MAX_VALUE;
      for (final Point cell : this) {
        minX = Math.min(minX, cell.left());
        minY = Math.min(minY, cell.right());
      }
      final ArrayList<Point> translatedPoints = new ArrayList<>();
      for (final Point cell : this) {
        translatedPoints.add(new Point(cell.left() - minX, cell.right() - minY));
      }
      // Find least y = 0 point to be canonical
      int best = -1;
      final int size = translatedPoints.size();
      for (int k = 0; k < size; ++k) {
        final Point pt = translatedPoints.get(k);
        if (pt.right() == 0 && (best == -1 || pt.left() < translatedPoints.get(best).left())) {
          best = k;
        }
      }
      assert best >= 0;
      // Now determine winding direction so that x increases on the first step
      final int bestx = translatedPoints.get(best).left();
      final int dir = translatedPoints.get((best + 1) % size).left() > bestx ? 1 : -1;
      final Polygon translate = new Polygon(null, null); // critical that head is null for comparisons to work
      for (int k = 0; k < size; ++k) {
        final Point e = translatedPoints.get((size + dir * k + best) % size);
        translate.add(e);
      }
      return translate;
    }

    @Override
    public boolean equals(final Object o) {
      if (!super.equals(o)) {
        return false; // has different points
      }
      if (!(o instanceof Polygon)) {
        return false;
      }
      // Check ordering of points is the same
      final Iterator<Point> a = this.iterator();
      final Iterator<Point> b = ((Polygon) o).iterator();
      while (a.hasNext()) {
        assert b.hasNext();
        final Point ap = a.next();
        final Point bp = b.next();
        if (!ap.equals(bp)) {
          return false;
        }
      }
      return true;
    }

    @Override
    public int hashCode() {
      return super.hashCode();
    }
  }

  private static final Polygon FIRST_EDGE = new Polygon(null, new Point(1, 0));

  private static final int[] DELTA_X = {1, -1, 0, 0};
  private static final int[] DELTA_Y = {0, 0, 1, -1};

  protected int mN = 0;
  protected final HashSet<Polygon> mPolygons = new HashSet<>();

  private void search(final int distanceRemaining, final Polygon pathSoFar) {
    assert distanceRemaining >= 0;
    final Point head = pathSoFar.head();
    if (distanceRemaining == 0) {
      final int x = head.left();
      final int y = head.right();
      if (x == 0 && y == 0) {
        mPolygons.add(pathSoFar.canonicalize());
      }
      return;
    }
    // Four candidate steps at each point.  One is guaranteed to be already present in the polygon,
    // but depending on the structure more than one might already be present.  Also, the step
    // might take us so far away from the origin that we can never get back
    final int x = head.left();
    final int y = head.right();
    final int remaining = distanceRemaining - 1;
    for (int k = 0; k < DELTA_X.length; ++k) {
      final int nx = x + DELTA_X[k];
      final int ny = y + DELTA_Y[k];
      if (ny < 0) {
        continue; // this one can always be generated by a different path
      }
      if (ny == 0 && nx < 0) {
        continue; // this one can always be generated by a different path
      }
      if (nx == 0 && ny == 0 && remaining != 0) {
        continue; // can't return to origin yet
      }
      if (Math.abs(nx) + Math.abs(ny) > remaining) {
        continue; // current head is too far from the origin to ever return
      }
      final Point newHead = new Point(nx, ny);
      if (pathSoFar.contains(newHead)) {
        continue; // intersects an existing point
      }
      search(remaining, new Polygon(pathSoFar, newHead));
    }
  }

  protected Z postFilter() {
    return Z.valueOf(mPolygons.size());
  }

  @Override
  public Z next() {
    mN += 2;
    if (mN == 2) {
      return Z.ZERO; // Otherwise the search will find (0, 0)->(1, 0)->(0, 0)
    }
    mPolygons.clear();
    // Start with the edge (0, 0) -> (1, 0)
    search(mN - 1, FIRST_EDGE);
    return postFilter();
  }
}

#!queue	A002944	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a002;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A002944 a(n) = LCM(1,2,...,n) / n.
 * @author Sean A. Irvine
 */
public class A002944 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A002944() {
    super(1);
  }

  protected Z mN = Z.ZERO;
  private Z mLcm = Z.ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    mLcm = mLcm.lcm(mN);
    return mLcm.divide(mN);
  }
}
#!queue	A003022	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003022 Length of shortest (or optimal) Golomb ruler with n marks.
 * @author Sean A. Irvine
 */
public class A003022 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003022() {
    super(2);
  }

  // This implementation is simple search and will not compute many terms in a reasonable time

  private int mN = 1;
  private int mMin = 0;
  protected int[] mPositions = new int[0];

  private void search(final Set<Integer> knownDeltas, final int[] positions, final int markNumber, final int lastUsed) {
    if (markNumber == mN) {
      if (lastUsed < mMin) {
        mPositions = Arrays.copyOf(positions, positions.length);
        mMin = lastUsed;
      }
      return;
    }
    int k = lastUsed;
    while (++k < mMin) {
      boolean ok = true;
      for (int j = 0; j < markNumber; ++j) {
        if (knownDeltas.contains(k - positions[j])) {
          ok = false;
          break;
        }
      }
      if (ok) {
        for (int j = 0; j < markNumber; ++j) {
          knownDeltas.add(k - positions[j]);
        }
        positions[markNumber] = k;
        search(knownDeltas, positions, markNumber + 1, k);
        for (int j = 0; j < markNumber; ++j) {
          knownDeltas.remove(k - positions[j]);
        }
      }
    }
  }

  @Override
  public Z next() {
    ++mN;
    mMin = Integer.MAX_VALUE;
    search(new HashSet<>(), new int[mN], 1, 0);
    return Z.valueOf(mMin);
  }
}
#!queue	A003030	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;
import java.util.HashMap;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Point;

/**
 * A003030 Number of strongly connected digraphs with n labeled nodes.
 * @author Sean A. Irvine
 */
public class A003030 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003030() {
    super(1);
  }

  private int mN = 0;
  private final HashMap<Point, Z> mLambda = new HashMap<>();

  protected Z lambda(final int m, final int n) {
    if (n == 0) {
      return Z.ONE;
    }
    final Point key = new Point(m, n);
    final Z res = mLambda.get(key);
    if (res != null) {
      return res;
    }
    Z s = Z.ONE.shiftLeft(n * (n + m - 1));
    for (int k = 0; k < n; ++k) {
      s = s.subtract(Binomial.binomial(n, k).multiply(lambda(m, k)).shiftLeft((n - k) * (n - 1)));
    }
    mLambda.put(key, s);
    return s;
  }

  private Z iota(final int n) {
    return lambda(1, n - 1).shiftLeft(n - 1);
  }

  private final ArrayList<Z> mS = new ArrayList<>();
  {
    mS.add(null);
    mS.add(Z.ONE);
  }

  protected Z s(final int n) {
    while (n >= mS.size()) {
      final int m = mS.size();
      Z s = iota(m);
      for (int j = 1; j < m; ++j) {
        s = s.subtract(Binomial.binomial(m - 1, j - 1).multiply(lambda(j, m - j)).multiply(mS.get(j)));
      }
      mS.add(s);
    }
    return mS.get(n);
  }

  @Override
  public Z next() {
    return s(++mN);
  }
}
#!queue	A003032	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003032 Smallest integer m such that the product of every 3 consecutive integers &gt; m has a prime factor &gt; prime(n).
 * @author Sean A. Irvine
 */
public class A003032 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003032() {
    super(2);
  }

  private final Fast mPrime = new Fast();
  private Z mP = firstPrime();
  private Z mLimit = Z.valueOf(1000);

  protected int getNumberOfConsecutivePrimes() {
    return 3;
  }

  protected Z firstPrime() {
    return Z.TWO;
  }

  private void buildSmoothToLimit(final List<Z> unsorted, final Z n, final Z maxPrime, final Z start, final Z limit) {
    for (Z k = start; k.compareTo(maxPrime) <= 0; k = mPrime.nextPrime(k)) {
      final Z t = n.multiply(k);
      if (t.compareTo(limit) <= 0) {
        unsorted.add(t);
        buildSmoothToLimit(unsorted, t, maxPrime, k, limit);
      }
    }
  }

  @Override
  public Z next() {
    mP = mPrime.nextPrime(mP);
    final ArrayList<Z> smooth = new ArrayList<>();
    buildSmoothToLimit(smooth, Z.ONE, mP, Z.TWO, mLimit);
    Collections.sort(smooth);
    for (int k = smooth.size() - getNumberOfConsecutivePrimes(); k >= 0; --k) {
      final Z u = smooth.get(k);
      boolean ok = true;
      for (int j = 1; j < getNumberOfConsecutivePrimes(); ++j) {
        if (!u.add(j).equals(smooth.get(k + j))) {
          ok = false;
          break;
        }
      }
      if (ok) {
        mLimit = u.multiply(1000); // Hack for how far to search for next term
        return u;
      }
    }
    throw new RuntimeException();
  }
}
#!queue	A003057	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003057 n appears n - 1 times.
 * @author Sean A. Irvine
 */
public class A003057 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003057() {
    super(2);
  }

  private long mN = 1;
  private long mC = 0;

  @Override
  public Z next() {
    if (++mC >= mN) {
      ++mN;
      mC = 1;
    }
    return Z.valueOf(mN);
  }
}
#!queue	A003095	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003095 a(n) = a(n-1)^2 + 1 for n &gt;= 1, with a(0) = 0.
 * @author Sean A. Irvine
 */
public class A003095 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003095() {
    super(0);
  }

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ZERO : mA.square().add(1);
    return mA;
  }
}
#!queue	A003114	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003114 Number of partitions of n into parts 5k+1 or 5k+4.
 * @author Sean A. Irvine
 */
public class A003114 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003114() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private int mN = -1;
  private int mLast = -4;
  private Polynomial<Q> mDen = RING.one();

  @Override
  public Z next() {
    if (++mN >= mLast) {
      mLast += 5;
      mDen = RING.multiply(mDen, RING.multiply(RING.oneMinusXToTheN(mLast + 3), RING.oneMinusXToTheN(mLast)));
    }
    return RING.coeff(RING.one(), mDen, mN).toZ();
  }
}
#!queue	A003136	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003136 Loeschian numbers: numbers of the form x^2 + xy + y^2; norms of vectors in A2 lattice.
 * @author Sean A. Irvine
 */
public class A003136 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003136() {
    super(1);
  }

  private final TreeSet<Z> mA = new TreeSet<>();
  private Z mXLast = Z.NEG_ONE;
  private Z mLimit = Z.ZERO;

  @Override
  public Z next() {
    while (mA.isEmpty() || mA.first().compareTo(mLimit) > 0) {
      mXLast = mXLast.add(1);
      mLimit = mXLast.square();
      final Z lim3 = mLimit.multiply(3);
      for (Z k = Z.ZERO; k.compareTo(mXLast) <= 0; k = k.add(1)) {
        final Z kk = k.square();
        mA.add(mLimit.add(kk.multiply(3)));
        mA.add(lim3.add(kk));
      }
    }
    return mA.pollFirst();
  }
}

#!queue	A003141	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.graph.Graph;
import irvine.math.graph.GraphFactory;
import irvine.math.nauty.DirectedGraph;
import irvine.math.nauty.Multigraph;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003141 Minimal number of arcs whose reversal yields a transitive tournament.
 * @author Sean A. Irvine
 */
public class A003141 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003141() {
    super(0);
  }

  private static final class DigraphCheck extends DirectedGraph {
    private int mMax = 0; // maximum of the minimums for a graph
    private int mMin = 0;

    private void removeCycles(final Graph g, final int removedSoFar) {
      if (removedSoFar >= mMin) {
        // Already exceeded current minimum for this graph
        return;
      }
      if (!g.isCyclic()) {
        if (removedSoFar < mMin) {
          mMin = removedSoFar;
        }
        return;
      }
      // Sequentially try removing each edge in the graph
      for (int u = 0; u < g.order(); ++u) {
        int v = -1;
        while ((v = g.nextVertex(u, v)) >= 0) {
          g.removeEdge(u, v);
          removeCycles(g, removedSoFar + 1);
          if (mMin <= mMax) {
            // Early exit if this graph can be "solved" with less removals than current maximum
            return;
          }
          g.addEdge(u, v);
        }
      }
    }

    @Override
    protected void process(final Graph g) {
      //System.out.println(g);
      mMin = Integer.MAX_VALUE;
      removeCycles(g, 0);
      mMax = Math.max(mMax, mMin);
    }
  }

  protected int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    final Graph graph = GraphFactory.complete(mN);
    final DigraphCheck digraphChecker = new DigraphCheck();
    digraphChecker.direct(graph, 0, graph.order() - 1, Multigraph.NOLIMIT, true);
    return Z.valueOf(digraphChecker.mMax);
  }

}

#!queue	A003159	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003159 Numbers n whose binary representation ends in an even number of zeros.
 * @author Sean A. Irvine
 */
public class A003159 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003159() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if ((Long.numberOfTrailingZeros(mN) & 1) == 0) {
        return Z.valueOf(mN);
      }
    }
  }

}
#!queue	A003168	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003168 Number of blobs with 2n+1 edges.
 * @author Sean A. Irvine
 */
public class A003168 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003168() {
    super(0);
  }

  long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    for (long k = 1; k <= mN; ++k) {
      s = s.add(Binomial.binomial(mN, k).multiply(Binomial.binomial(2 * mN + k, k - 1)));
    }
    return s.divide(mN);
  }
}
#!queue	A003190	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a003;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.polynomial.PalmerSymPowerCycleIndex;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A003190 Number of connected 2-plexes.
 * @author Sean A. Irvine
 */
public class A003190 extends MemoryFunction2Sequence<Integer, Q> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003190() {
    super(1);
  }

  // This is close, but currently differs from existing sequence in later terms
  // It is unclear if this implementation or the original results are wrong.
  // In particular, for the monomial a_3a_4 I get a_1a_4a_6a_{12}^2, but it
  // looks like the papers has a_1a_2^3a_4^7.  Tracing this further, the
  // difference occurs in the calculation of M2 where I get a_6a_{12}^2 and
  // it apparently should be a_2^3a_4^6.
  //
  // Extra evidence that my implementation is correct comes from A000665 which
  // is the Euler transform of this sequence.

  private int mN = 0;

  private final PalmerSymPowerCycleIndex mSym = new PalmerSymPowerCycleIndex();

  @Override
  protected Q compute(final Integer n, final Integer p) {
    Q s = Q.ZERO;
    for (int k = 1; k < p; ++k) {
      s = s.add(mSym.get(n, p - k).multiply(get(n, k)).multiply(k));
    }
    return mSym.get(n, p).subtract(s.divide(p));
  }

  protected Z c(final int n, final int p) {
    Q s = Q.ZERO;
    for (final Z dd : Jaguar.factor(p).divisors()) {
      final int d = dd.intValueExact();
      s = s.add(get(n, p / d).multiply(Mobius.mobius(d)).divide(d));
    }
    assert s.isInteger();
    return s.toZ();
  }

  @Override
  public Z next() {
    return c(2, ++mN);
  }
}
#!queue	A003239	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Binomial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003239 Number of rooted planar trees with n non-root nodes: circularly cycling the subtrees at the root gives equivalent trees.
 * @author Sean A. Irvine
 */
public class A003239 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003239() {
    super(0);
  }

  protected long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    for (final Z d : Jaguar.factor(mN).divisors()) {
      s = s.add(Binomial.binomial(d.multiply2(), d).multiply(Euler.phiAsLong(mN / d.longValueExact())));
    }
    return s.divide(2 * mN);
  }
}
#!queue	A003288	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003288 Number of n-step self-avoiding walks on f.c.c. lattice from (0,0,0) to (0,0,2).
 * @author Sean A. Irvine
 */
public class A003288 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003288() {
    super(2);
  }

  // Walks in hexagonal fcc lattice between origin and a selected target

  // The following implementation uses minimal memory.  Just a grid to keep tracks of points
  // included in the current path.  It researches for each new distance "n" rather than
  // expanding for previous existing paths.  8-bits are used for each coordinate, this
  // allows +/- 127 in each dimension, more than adequate for what can be exhaustively
  // enumerated.
  private final boolean[] mUsed = new boolean[1 << 24];
  private long mCount = 0;
  protected int mN = first() - 1;

  protected int first() {
    return 2;
  }

  protected int coord(final int x, final int y, final int z) {
    return ((z & 0xFF) << 16) + ((y & 0xFF) << 8) + (x & 0xFF);
  }

  protected void use(final int x, final int y, final int z) {
    mUsed[coord(x, y, z)] = true;
  }

  protected void clear(final int x, final int y, final int z) {
    mUsed[coord(x, y, z)] = false;
  }

  private void search(final int x, final int y, final int z, final int tx, final int ty, final int tz, final int stepsRemaining) {
    if (stepsRemaining <= 0) {
      if (stepsRemaining == 0 && x == tx && y == ty && z == tz) {
        ++mCount;
      }
    } else if (tx != x || ty != y || tz != z) {
      // Check that it is possible to reach the target within the remaining numbers of moves
      final int dx = Math.abs(tx - x);
      final int dy = Math.abs(ty - y);
      final int dz = Math.abs(tz - z);
      final int d = Math.max(Math.max(dx, dy), dz);
      if (d <= stepsRemaining) {
        final int coord = coord(x, y, z);
        if (!mUsed[coord]) {
          mUsed[coord] = true;
          search(x + 1, y + 1, z, tx, ty, tz, stepsRemaining - 1);
          search(x + 1, y - 1, z, tx, ty, tz, stepsRemaining - 1);
          search(x - 1, y + 1, z, tx, ty, tz, stepsRemaining - 1);
          search(x - 1, y - 1, z, tx, ty, tz, stepsRemaining - 1);
          search(x + 1, y, z + 1, tx, ty, tz, stepsRemaining - 1);
          search(x + 1, y, z - 1, tx, ty, tz, stepsRemaining - 1);
          search(x - 1, y, z + 1, tx, ty, tz, stepsRemaining - 1);
          search(x - 1, y, z - 1, tx, ty, tz, stepsRemaining - 1);
          search(x, y + 1, z + 1, tx, ty, tz, stepsRemaining - 1);
          search(x, y + 1, z - 1, tx, ty, tz, stepsRemaining - 1);
          search(x, y - 1, z + 1, tx, ty, tz, stepsRemaining - 1);
          search(x, y - 1, z - 1, tx, ty, tz, stepsRemaining - 1);
          mUsed[coord] = false;
        }
      }
    }
  }

  protected long search(final int x, final int y, final int z, final int tx, final int ty, final int tz, final int stepsRemaining, final int m) {
    mCount = 0;
    if (stepsRemaining >= 0) {
      search(x, y, z, tx, ty, tz, stepsRemaining);
    }
    return mCount * m;
  }

  protected long search() {
    final int tx = 0;
    final int ty = 0;
    final int tz = 2;
    //return search(0, 0, 0, tx, ty, tz, mN, 1); // Basic search
    // Expanding first few links to exploit symmetries
    use(0, 0, 0);
    return search(1, 1, 0, tx, ty, tz, mN - 1, 4)
      + search(1, 0, 1, tx, ty, tz, mN - 1, 4)
      + search(1, 0, -1, tx, ty, tz, mN - 1, 4);
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(search());
  }

}
#!queue	A003290	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003290 Number of n-step self-avoiding walks on hexagonal lattice from (0,0) to (0,2).
 * @author Sean A. Irvine
 */
public class A003290 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003290() {
    super(2);
  }

  // Walks in hexagonal lattice between origin and a selected target

  /*
  // To avoid churn, this implementation replaces an early object-oriented search with
  // more direct arrays for keeping track of nodes in the paths so far.
  // It stores all paths, so that later levels can avoid recomputing them, however,
  // this turns out to be much slower than a more targeted search from the start.
  // The following arrays are co-indexed and store nodes in the path.
  // Further symmetry considerations mean we can sometimes reduced the paths to be
  // explored at the expense of keeping a multiplicity.
  protected static final long NULL = -1;
  private final LongDynamicByteArray mX = new LongDynamicByteArray();
  private final LongDynamicByteArray mY = new LongDynamicByteArray();
  private final LongDynamicByteArray mMultiplicity = new LongDynamicByteArray();
  private final LongDynamicLongArray mParent = new LongDynamicLongArray();
  protected long mStartOfCurrentWalks = 0;
  protected long mNextFreeNode = 0;

  private boolean contains(final long w, final int x, final int y) {
    // Recursive form
    //return (mX.get(w) == x && mY.get(w) == y) || (mParent.get(w) != NULL && contains(mParent.get(w), x, y));
    // Iterative form
    long n = w;
    do {
      if (mX.get(n) == x && mY.get(n) == y) {
        return true;
      }
      n = mParent.get(n);
    } while (n != NULL);
    return false;
  }

  protected void add(final long parent, final int x, final int y, final int m) {
    mX.set(mNextFreeNode, (byte) x);
    mY.set(mNextFreeNode, (byte) y);
    mMultiplicity.set(mNextFreeNode, (byte) m);
    mParent.set(mNextFreeNode, parent);
    ++mNextFreeNode;
  }

  protected void init() {
    // Set up initial search space for this target, dealing with symmetry multiplicities
    add(NULL, 0, 0, 1); // Root node
    mStartOfCurrentWalks = mNextFreeNode;
    add(0, 2, 0, 1);
    add(0, -2, 0, 1);
    add(0, 1, 1, 2);
    add(0, -1, 1, 2);
  }

  {
    init();
  }

  protected int targetX() {
    return 4;
  }

  protected int targetY() {
    return 0;
  }

  //@Override
  public Z nextAlt() {
    final int tx = targetX();
    final int ty = targetY();
    final long prevStart = mStartOfCurrentWalks;
    mStartOfCurrentWalks = mNextFreeNode;
    for (long w = prevStart; w < mStartOfCurrentWalks; ++w) {
      final int x = mX.get(w);
      final int y = mY.get(w);
      final int m = mMultiplicity.get(w);
      if (x == tx && y == ty) {
        continue; // Don't explore further once we hit the target
      }
      if (!contains(w, x + 2, y)) {
        add(w, x + 2, y, m);
      }
      if (!contains(w, x - 2, y)) {
        add(w, x - 2, y, m);
      }
      if (!contains(w, x + 1, y + 1)) {
        add(w, x + 1, y + 1, m);
      }
      if (!contains(w, x + 1, y - 1)) {
        add(w, x + 1, y - 1, m);
      }
      if (!contains(w, x - 1, y + 1)) {
        add(w, x - 1, y + 1, m);
      }
      if (!contains(w, x - 1, y - 1)) {
        add(w, x - 1, y - 1, m);
      }
    }
    long r = 0;
    for (long w = mStartOfCurrentWalks; w < mNextFreeNode; ++w) {
      final int x = mX.get(w);
      final int y = mY.get(w);
      final int m = mMultiplicity.get(w);
      if (x == tx && y == ty) {
        r += m;
      }
    }
    return Z.valueOf(r);
  }
  */

  // The following implementation uses minimal memory.  Just a grid to keep tracks of points
  // included in the current path.  It re-searches for each new distance "n" rather than
  // expanding for previous existing paths.  8-bits are used for each coordinate, this
  // allows +/- 127 in each dimension, more than adequate for what can be exhaustively
  // enumerated.
  private final boolean[] mUsed = new boolean[65536];
  private long mCount = 0;
  protected int mN = first() - 1;

  protected int first() {
    return 2;
  }

  protected int coord(final int x, final int y) {
    return ((y & 0xFF) << 8) + (x & 0xFF);
  }

  protected void use(final int x, final int y) {
    mUsed[coord(x, y)] = true;
  }

  protected void clear(final int x, final int y) {
    mUsed[coord(x, y)] = false;
  }

  private void search(final int x, final int y, final int tx, final int ty, final int stepsRemaining) {
    if (stepsRemaining <= 0) {
      if (stepsRemaining == 0 && x == tx && y == ty) {
        ++mCount;
      }
    } else if (tx != x || ty != y) {
      // Check that it is possible to reach the target within the remaining numbers of moves
      final int dx = Math.abs(tx - x) >>> 1;
      final int dy = Math.abs(ty - y);
      final int d = Math.max(dx, dy);
      if (d <= stepsRemaining) {
        final int coord = coord(x, y);
        if (!mUsed[coord]) {
          mUsed[coord] = true;
          search(x + 2, y, tx, ty, stepsRemaining - 1);
          search(x - 2, y, tx, ty, stepsRemaining - 1);
          search(x + 1, y + 1, tx, ty, stepsRemaining - 1);
          search(x + 1, y - 1, tx, ty, stepsRemaining - 1);
          search(x - 1, y + 1, tx, ty, stepsRemaining - 1);
          search(x - 1, y - 1, tx, ty, stepsRemaining - 1);
          mUsed[coord] = false;
        }
      }
    }
  }

  protected long search(final int x, final int y, final int tx, final int ty, final int stepsRemaining, final int m) {
    mCount = 0;
    if (stepsRemaining >= 0) {
      search(x, y, tx, ty, stepsRemaining);
    }
    return mCount * m;
  }

  protected long search() {
    final int tx = 4;
    final int ty = 0;
    // return search(0, 0, tx, ty, mN, 1); // Basic search
    // Expanding first few links to exploit symmetries
    use(0, 0);
    long total = search(1, 1, tx, ty, mN - 1, 2);
    total += search(-1, 1, tx, ty, mN - 1, 2);
    use(-2, 0);
    total += search(-4, 0, tx, ty, mN - 2, 1);
    total += search(-1, 1, tx, ty, mN - 2, 2);
    total += search(-3, 1, tx, ty, mN - 2, 2);
    clear(-2, 0);
    use(2, 0);
    total += search(4, 0, tx, ty, mN - 2, 1);
    total += search(1, 1, tx, ty, mN - 2, 2);
    total += search(3, 1, tx, ty, mN - 2, 2);
    clear(2, 0);
    clear(0, 0);
    return total;
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(search());
  }

}
#!queue	A003313	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.DynamicIntArray;

/**
 * A003313 Length of shortest addition chain for n.
 * @author Sean A. Irvine
 */
public class A003313 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003313() {
    super(1);
  }

  private static final class ChainNode {
    private final int mHead;
    private final ChainNode mTail;

    private ChainNode(final int head, final ChainNode tail) {
      mHead = head;
      mTail = tail;
    }
  }

  private final DynamicIntArray mShortest = new DynamicIntArray();
  private List<ChainNode> mActiveChains = null;
  private int mChainLength = -1;
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    while (mShortest.get(mN) == 0) {
      if (++mChainLength == 0) {
        mActiveChains = Collections.singletonList(new ChainNode(1, null));
        return Z.ZERO;
      } else {
        final List<ChainNode> newChains = new ArrayList<>();
        for (final ChainNode c : mActiveChains) {
          final int head = c.mHead;
          ChainNode s = c;
          while (s != null && 2 * s.mHead > head) {
            final int h = s.mHead;
            for (ChainNode k = s; k != null && h + k.mHead > head; k = k.mTail) {
              final int n = h + k.mHead;
              newChains.add(new ChainNode(n, c));
              if (mShortest.get(n) == 0) {
                mShortest.set(n, mChainLength);
              }
            }
            s = s.mTail;
          }
        }
        mActiveChains = newChains;
      }
    }
    return Z.valueOf(mShortest.get(mN));
  }
}
#!queue	A003415	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003415 a(n) = n' = arithmetic derivative of n: a(0) = a(1) = 0, a(prime) = 1, a(mn) = m*a(n) + n*a(m).
 * @author Sean A. Irvine
 */
public class A003415 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003415() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN < 2) {
      return Z.ZERO;
    }
    final FactorSequence fs = Jaguar.factor(mN);
    Z s = Z.ZERO;
    for (final Z p : fs.toZArray()) {
      s = s.add((mN / p.longValueExact()) * fs.getExponent(p));
    }
    return s;
  }
}
#!queue	A003430	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.Collections;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003430 Number of unlabeled series-parallel posets (i.e., generated by unions and sums) with n nodes.
 * @author Sean A. Irvine
 */
public class A003430 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003430() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> TWO = RING.create(Collections.singletonList(Q.TWO));

  private Polynomial<Q> mA = RING.one();
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Polynomial<Q> a = RING.zero();
    for (int k = 1; k <= mN; ++k) {
      final Polynomial<Q> ak = mA.substitutePower(k, mN);
      final Polynomial<Q> t = RING.add(RING.add(ak, RING.series(RING.one(), ak, mN)), RING.subtract(RING.monomial(Q.ONE, k), TWO));
      a = RING.add(a, RING.divide(t, new Q(k)));
    }
    mA = RING.exp(a, mN);
    //System.out.println("gf=" + mA);
    return mA.coeff(mN).toZ();
  }
}
#!queue	A003434	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003434 Number of iterations of phi(x) at n needed to reach 1.
 * @author Sean A. Irvine
 */
public class A003434 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003434() {
    super(1);
  }

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    long c = 0;
    Z m = mN;
    while (!Z.ONE.equals(m)) {
      ++c;
      m = Euler.phi(m);
    }
    return Z.valueOf(c);
  }
}
#!queue	A003442	4	->	4	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.ArrayList;
import java.util.HashMap;

import irvine.factor.factor.Jaguar;
import irvine.math.IntegerUtils;
import irvine.math.MemoryFunction2;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Binomial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A003442 Number of nonequivalent dissections of an n-gon into (n-3) polygons by nonintersecting diagonals rooted at a cell up to rotation.
 * @author Sean A. Irvine
 */
public class A003442 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003442() {
    super(4);
  }

  protected static final PolynomialRingField<Q> RING = new PolynomialRingField<>("y", Rationals.SINGLETON);

  static class VFunction extends MemoryFunction2<Integer, Polynomial<Q>> {
    private Z v(final long r, final long s) {
      assert r >= 0;
      if (r == 0) {
        return s == 1 ? Z.ONE : Z.ZERO;
      }
      if (s < r) {
        return Z.ZERO;
      }
      if (r == 1 && s == 1) {
        return Z.ZERO;
      }
      return Binomial.binomial(s - 2, r - 1).multiply(Binomial.binomial(r + s - 1, s)).divide(r);
    }

    @Override
    public Polynomial<Q> compute(final Integer r, final Integer n) {
      final ArrayList<Q> coeff = new ArrayList<>();
      for (int k = 0; k < n; ++k) {
        coeff.add(new Q(v(r, k)));
      }
      return RING.create(coeff);
    }
  }

  protected final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  protected final VFunction mV = new VFunction();
  private final HashMap<Pair<Polynomial<Q>, Integer>, Polynomial<Q>> mPowerCache = new HashMap<>();

  private Polynomial<Q> power(final Polynomial<Q> v, final int p, final int n) {
    if (p == 1) {
      return v;
    }
    final Pair<Polynomial<Q>, Integer> key = new Pair<>(v, p);
    final Polynomial<Q> res = mPowerCache.get(key);
    if (res != null) {
      return res;
    }
    final Polynomial<Q> r = RING.pow(v, p, n);
    mPowerCache.put(key, r);
    return r;
  }

  protected Polynomial<Q> f(final int r, final int n) {
    if (r <= 1) {
      return r == 0 ? RING.zero() : RING.series(RING.monomial(Q.ONE, 3), RING.oneMinusXToTheN(1), n);
    }
    mPowerCache.clear();
    Polynomial<Q> sum = RING.zero();
    for (final Z d : Jaguar.factor(r - 1).divisors()) {
      final int dp = d.intValueExact();
      final int q = (r - 1) / dp;
      final IntegerPartition part = new IntegerPartition(q);
      final int[] a = new int[q + 1];
      int[] p;
      while ((p = part.next()) != null) {
        IntegerPartition.toCountForm(p, a);
        final int sumA = (int) IntegerUtils.sum(a);
        final int start = (Math.max(3, sumA) + dp - 1) / dp;
        for (int m = start; m <= n; ++m) {
          if (sumA <= m) {
            Q c = new Q(mF.factorial(m - 1).multiply(Euler.phiAsLong(dp)), mF.factorial(m - sumA).multiply(dp));
            Polynomial<Q> v = RING.one();
            for (int i = 1; i < a.length; ++i) {
              if (a[i] > 0) {
                c = c.divide(mF.factorial(a[i]));
                v = RING.multiply(v, power(mV.get(i, n), a[i], n).substitutePower(dp, n));
              }
            }
            sum = RING.add(sum, RING.multiply(v, c).shift(dp * (m - sumA)).truncate(n));
          }
        }
      }
    }
    return sum;
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    return f(mN, mN + 3).coeff(mN + 3).toZ();
  }
}

#!queue	A003586	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003586 3-smooth numbers: numbers of the form 2^i*3^j with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A003586 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003586() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply2());
    mPriority.add(r.multiply(3));
    return r;
  }
}
#!queue	A003591	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003591 Numbers of form 2^i*7^j, with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A003591 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003591() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply2());
    mPriority.add(r.multiply(7));
    return r;
  }
}
#!queue	A003595	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003595 Numbers of the form 5^i*7^j with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A003595 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003595() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply(5));
    mPriority.add(r.multiply(7));
    return r;
  }
}
#!queue	A003658	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003658 Fundamental discriminants of real quadratic fields; indices of primitive positive Dirichlet L-series.
 * @author Sean A. Irvine
 */
public class A003658 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003658() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final long r = mN & 3;
      if (r == 1) {
        if (LongUtils.isSquareFree(mN)) {
          return Z.valueOf(mN);
        }
      } else if (r == 0 && ((mN / 4) & 3) > 1 && LongUtils.isSquareFree(mN / 4)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A003920	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003920 Order of universal Chevalley group B_n (3).
 * @author Sean A. Irvine
 */
public class A003920 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003920() {
    super(1);
  }

  private long mN = start();

  static Z orderUniversalChevalleyB(final Z q, final long n) {
    Z p = q.pow(n * n);
    for (long k = 1; k <= n; ++k) {
      p = p.multiply(q.pow(2 * k).subtract(1));
    }
    return p;
  }

  protected int start() {
    return 0;
  }

  protected Z q() {
    return Z.THREE;
  }

  @Override
  public Z next() {
    return orderUniversalChevalleyB(q(), ++mN);
  }
}
#!queue	A003927	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003927 Order of simple Chevalley group B_n (3).
 * @author Sean A. Irvine
 */
public class A003927 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003927() {
    super(2);
  }

  private int mN = start();

  static Z orderSimpleChevalleyB(final Z q, final int n) {
    return A003920.orderUniversalChevalleyB(q, n).divide(Z.TWO.gcd(q.subtract(1)));
  }

  protected int start() {
    return 1;
  }

  protected Z q() {
    return Z.THREE;
  }

  @Override
  public Z next() {
    return orderSimpleChevalleyB(q(), ++mN);
  }
}
#!queue	A003961	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a003;

import irvine.factor.factor.Jaguar;
import irvine.factor.prime.Fast;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A003961 Completely multiplicative with a(prime(k)) = prime(k+1).
 * @author Sean A. Irvine
 */
public class A003961 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A003961() {
    super(1);
  }

  private long mN = 0;
  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    final FactorSequence fs = Jaguar.factor(++mN);
    Z prod = Z.ONE;
    for (final Z p : fs.toZArray()) {
      prod = prod.multiply(mPrime.nextPrime(p).pow(fs.getExponent(p)));
    }
    return prod;
  }
}
#!queue	A004009	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004009 Expansion of Eisenstein series E_4(q) (alternate convention E_2(q)); theta series of E_8 lattice.
 * @author Sean A. Irvine
 */
public class A004009 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004009() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : Jaguar.factor(mN).sigma(3).multiply(240);
  }
}
#!queue	A004012	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004012 Theta series of hexagonal close-packing.
 * @author Sean A. Irvine
 */
public class A004012 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004012() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final Polynomial<Z> NEGX = RING.negate(RING.x());

  private int mN = -1;

  private Polynomial<Z> a0(final int n, final int m) {
    final long[] coeff = new long[n + 1];
    coeff[0] = 1;
    for (int k = 1; m * k * k <= n; ++k) {
      coeff[m * k * k] = 2;
    }
    return Polynomial.create(coeff);
  }

  private Polynomial<Z> a0(final int n) {
    return RING.multiply(a0(n, 3), RING.multiply(a0(n, 8), a0(n, 9), n), n);
  }

  private Polynomial<Z> a1(final int n) {
    final Polynomial<Z> t0 = RING.pow(RING.eta(RING.monomial(Z.ONE, 9), n), 3, n);
    final Polynomial<Z> t1 = RING.pow(RING.eta(RING.monomial(Z.ONE, 32), n), 2, n);
    final Polynomial<Z> num = RING.multiply(t0, t1, n).shift(3);
    final Polynomial<Z> den = RING.multiply(RING.eta(RING.monomial(Z.ONE, 3), n), RING.eta(RING.monomial(Z.ONE, 16), n), n);
    return RING.series(num, den, n);
  }

  @Override
  public Z next() {
    ++mN;
    final Polynomial<Z> a0 = a0(mN);
    final Polynomial<Z> gf = RING.subtract(RING.add(RING.multiply(a0, Z.TWO), RING.multiply(a1(mN), Z.SIX)), RING.substitute(a0, NEGX, mN));
    return gf.coeff(mN);
  }
}
#!queue	A004086	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A004086 Read n backwards (referred to as R(n) in many sequences).
 * @author Sean A. Irvine
 */
public class A004086 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004086() {
    super(0);
  }

  protected long mN = -1;

  @Override
  public Z next() {
    return ZUtils.reverse(Z.valueOf(++mN));
  }
}

#!queue	A004105	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.IntegerUtils;
import irvine.math.group.SymmetricGroup;
import irvine.math.partitions.IntegerPartition;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004105 Number of point-self-dual nets with 2n nodes. Also number of directed 2-multigraphs with loops on n nodes.
 * @author Sean A. Irvine
 */
public class A004105 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004105() {
    super(0);
  }

  private int mN = -1;

  protected Z base() {
    return Z.THREE;
  }

  private Z fix(final int[] s) {
    int exp = 0;
    for (int i = 1; i < s.length; ++i) {
      for (int j = 1; j < s.length; ++j) {
        exp += IntegerUtils.gcd(i, j) * s[i] * s[j];
      }
    }
    return base().pow(exp);
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final IntegerPartition part = new IntegerPartition(mN);
    final int[] s = new int[mN + 1];
    int[] p;
    Q sum = Q.ZERO;
    while ((p = part.next()) != null) {
      IntegerPartition.toCountForm(p, s);
      sum = sum.add(new Q(fix(s), SymmetricGroup.per(s)));
    }
    return sum.toZ();
  }
}

#!queue	A004113	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.Sequence0;
import irvine.oeis.transform.EulerTransform;

/**
 * A004113 Number of rooted trees with n nodes and 2-colored non-leaf nodes.
 * @author Sean A. Irvine
 */
public class A004113 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004113() {
    super(1);
  }

  private Z mA = Z.ONE;

  private class A004133Inner extends Sequence0 {
    @Override
    public Z next() {
      return mA;
    }
  }

  private int mN = 0;
  private final A004133Inner mSeq = new A004133Inner();
  private final Sequence mEulerTransform = new EulerTransform(mSeq);

  @Override
  public Z next() {
    if (++mN <= 1) {
      return Z.valueOf(mN);
    }
    mA = mEulerTransform.next().multiply2();
    return mA;
  }
}
#!queue	A004152	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A004152 Sum of digits of n!.
 * @author Sean A. Irvine
 */
public class A004152 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004152() {
    super(0);
  }

  private Z mF = Z.ONE;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    return Z.valueOf(ZUtils.digitSum(mF));
  }
}
#!queue	A004186	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004186 Arrange digits of n in decreasing order.
 * @author Sean A. Irvine
 */
public class A004186 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004186() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    final char[] s = String.valueOf(++mN).toCharArray();
    Arrays.sort(s);
    return new Z(new StringBuilder(new String(s)).reverse());
  }
}
#!queue	A004201	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004201 Accept one, reject one, accept two, reject two, ...
 * @author Sean A. Irvine
 */
public class A004201 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004201() {
    super(1);
  }

  private Z mA = Z.ZERO;
  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (--mM <= 0) {
      mA = mA.add(mN++);
      mM = mN;
    }
    mA = mA.add(1);
    return mA;
  }
}
#!queue	A004283	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004283 Least positive multiple of n written in base 3 using only 0 and 1.
 * @author Sean A. Irvine
 */
public class A004283 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004283() {
    super(1);
  }

  private Z mN = init();

  protected Z init() {
    return Z.ZERO;
  }

  private boolean is01(final String s) {
    for (int k = 0; k < s.length(); ++k) {
      final char c = s.charAt(k);
      if (c != '0' && c != '1') {
        return false;
      }
    }
    return true;
  }

  protected int base() {
    return 3;
  }

  @Override
  public Z next() {
    mN = mN.add(1);
    long k = 0;
    while (true) {
      final String s = mN.multiply(++k).toString(base());
      if (is01(s)) {
        return new Z(s);
      }
    }
  }
}
#!queue	A004431	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004431 Numbers that are the sum of 2 distinct nonzero squares.
 * @author Sean A. Irvine
 */
public class A004431 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004431() {
    super(1);
  }

  private long mN = 4;

  @Override
  public Z next() {
    while (true) {
      final FactorSequence fs = Jaguar.factor(++mN);
      boolean seen1 = false;
      boolean seen3 = true;
      for (final Z p : fs.toZArray()) {
        final long r = p.mod(4);
        if (r == 1) {
          seen1 = true;
        } else if (r == 3) {
          final int e = fs.getExponent(p);
          if ((e & 1) == 1) {
            seen3 = false;
            break;
          }
        }
      }
      if (seen1 && seen3) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A004432	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004432 Numbers that are the sum of 3 distinct nonzero squares.
 * @author Sean A. Irvine
 */
public class A004432 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004432() {
    super(1);
  }

  // After M. F. Hasler

  private long mN = 13;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      for (long x = 1; 3 * x * x < mN; ++x) {
        final long u = mN - x * x;
        for (long y = x + 1; 2 * y * y < u; ++y) {
          final long z2 = u - y * y;
          final long z = LongUtils.sqrt(z2);
          if (z * z == z2) {
            return Z.valueOf(mN);
          }
        }
      }
    }
  }
}
#!queue	A004489	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004489 Table of tersums m + n (answers written in base 10).
 * @author Sean A. Irvine
 */
public class A004489 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004489() {
    super(0);
  }

  private int r(final String s, final int n) {
    return n < 0 ? 0 : s.charAt(n) - '0';
  }

  protected Z tersum(final Z a, final Z b) {
    final String as = a.toString(3);
    final String bs = b.toString(3);
    final StringBuilder sb = new StringBuilder();
    for (int k = Math.max(as.length(), bs.length()); k >= 1; --k) {
      final int r = (r(as, as.length() - k) + r(bs, bs.length() - k)) % 3;
      sb.append(r);
    }
    return new Z(sb, 3);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return tersum(Z.valueOf(mM), Z.valueOf(mN - mM));
  }
}

#!queue	A004738	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a004;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A004738 Concatenation of sequences (1,2,...,n-1,n,n-1,...,2) for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A004738 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A004738() {
    super(1);
  }

  private long mN = 1;
  private long mM = 0;

  @Override
  public Z next() {
    if (--mM < 2) {
      ++mN;
      mM = 2 * mN - 1;
    }
    return Z.valueOf(mM > mN ? 2 * mN - mM : mM);
  }
}

#!queue	A005048	4	->	4	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.Collection;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005048 Minimal span of set of n elements with no 4-term arithmetic progression.
 * @author Sean A. Irvine
 */
public class A005048 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005048() {
    super(4);
  }

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private int mN = getProgressionLength() - 1;
  private int mMin = 4;
  private long mBestIncluded = 0;
  private Collection<Long> mProgressions = null;

  private static Collection<Long> progressions(final int m, final int limit) {
    if (limit > 64) {
      throw new UnsupportedOperationException();
    }
    // Construct syndromes of all n element arithmetic progressions of m elements
    final ArrayList<Long> res = new ArrayList<>();
    final long q = m - 1;
    for (int firstElement = 1; firstElement <= limit - q; ++firstElement) {
      final long a = 1L << (firstElement - 1);
      for (int d = 1; d <= (limit - firstElement + q) / q; ++d) {
        long v = a;
        boolean ok = true;
        for (int j = 1; j < m; ++j) {
          final int bit = firstElement - 1 + d * j;
          if (bit > 63) {
            ok = false;
            break;
          }
          v |= 1L << bit;
        }
        if (ok) {
          assert (long) Long.bitCount(v) == m;
          res.add(v);
        }
      }
    }
    return res;
  }

  private void search(final long included, final int count, final int lastIndex) {
    if (count == mN) {
      if (lastIndex < mMin) {
        mMin = lastIndex;
        mBestIncluded = included;
      }
    }
    if (lastIndex + mN - count >= mMin) {
      return; // Will never beat current best
    }
    for (int p = lastIndex + 1; p <= mMin; ++p) {
      final long v = included + (1L << (p - 1));
      boolean ok = true;
      for (final long t : mProgressions) {
        if ((v & t) == t) {
          ok = false;
          break;
        }
      }
      if (ok) {
        // Recursively search
        search(v, count + 1, p);
      }
    }
  }

  private String printSet(final long included) {
    final StringBuilder sb = new StringBuilder("{");
    long v = included;
    int k = 1;
    while (v != 0) {
      if ((v & 1) == 1) {
        if (sb.length() > 1) {
          sb.append(", ");
        }
        sb.append(k);
      }
      v >>>= 1;
      ++k;
    }
    sb.append('}');
    return sb.toString();
  }

  protected int getProgressionLength() {
    return 4;
  }

  @Override
  public Z next() {
    ++mN;
    if (mMin > 50) {
      throw new UnsupportedOperationException();
    }
    mMin = Math.min(64, 2 * mMin);
    mProgressions = progressions(getProgressionLength(), mMin);
    search(0, 0, 0);
    if (mVerbose) {
      System.out.println("Solution: " + printSet(mBestIncluded));
    }
    return Z.valueOf(mMin - 1);
  }
}

#!queue	A005190	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005190 Central quadrinomial coefficients: largest coefficient of (1 + x + x^2 + x^3)^n.
 * @author Sean A. Irvine
 */
public class A005190 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005190() {
    super(0);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private static final Polynomial<Z> POLY = Polynomial.create(1, 1, 1, 1);
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return RING.pow(POLY, mN, 3 * mN / 2).coeff(3 * mN / 2);
  }
}

#!queue	A005228	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A005228 Sequence and first differences (A030124) together list all positive numbers exactly once.
 * @author Sean A. Irvine
 */
public class A005228 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005228() {
    super(1);
  }

  private Z mA = null;
  protected final LongDynamicBooleanArray mSeen = new LongDynamicBooleanArray();
  private long mC = 1;

  private long nextComplement() {
    while (mSeen.isSet(++mC)) {
      // do nothing
    }
    return mC;
  }

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.add(nextComplement());
    mSeen.set(mA.longValueExact());
    return mA;
  }
}
#!queue	A005249	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005249 Determinant of inverse Hilbert matrix.
 * @author Sean A. Irvine
 */
public class A005249 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005249() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    final Z n = Z.valueOf(++mN);
    final Z n2 = n.square();
    Z prod = n.pow(mN);
    for (int k = 1; k < mN; ++k) {
      prod = prod.multiply(n2.subtract((long) k * k).pow(mN - k));
    }
    Z f = Z.ONE;
    for (int k = 2; k < mN; ++k) {
      f = f.multiply((long) k * k);
      prod = prod.divide(f);
    }
    return prod;
  }
}

#!queue	A005264	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A005264 Number of labeled rooted Greg trees with n nodes.
 * @author Sean A. Irvine
 */
public class A005264 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005264() {
    super(1);
  }

  // After Peter Luschny

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (k < 0 || k > n) {
      return Z.ZERO;
    }
    if (k == 0 && (n == 0 || n == 1)) {
      return Z.ONE;
    }
    return get(n - 1, k - 1).multiply(n - 1).add(get(n - 1, k).multiply(3 * n - k - 4)).subtract(get(n - 1, k + 1).multiply(k + 1));
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k < mN; ++k) {
      sum = sum.signedAdd((k & 1) == 0, get(mN, k).shiftLeft(mN - k - 1));
    }
    return sum;
  }
}
#!queue	A005290	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005290 Representation degeneracies for boson strings.
 * @author Sean A. Irvine
 */
public class A005290 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005290() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  private int mN = degree() - 1;

  private Polynomial<Z> g(final int j, final Polynomial<Z> p) {
    Polynomial<Z> s = RING.zero();
    for (int k = 1; k <= mN + 1; ++k) {
      final Polynomial<Z> t = RING.monomial(Z.ONE, k * j + k * (k - 1) / 2);
      final Polynomial<Z> u = RING.pow(RING.oneMinusXToTheN(k), 2, mN + 1);
      s = RING.signedAdd((k & 1) == 1, s, RING.multiply(t, u, mN + 1));
    }
    return RING.multiply(RING.pow(p, 2, mN + 1), s, mN + 1);
  }

  protected int degree() {
    return 0;
  }

  @Override
  public Z next() {
    ++mN;
    Polynomial<Z> pInv = RING.one();
    for (int k = 1; k < mN + 1; ++k) {
      pInv = RING.multiply(pInv, RING.oneMinusXToTheN(k), mN + 1);
    }
    final Polynomial<Z> p = RING.series(RING.one(), pInv, mN + 1);
    final Polynomial<Z> g = g(degree(), p);
    return g.coeff(mN);
  }
}
#!queue	A005303	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005303 Representation degeneracies for Ramond strings.
 * @author Sean A. Irvine
 */
public class A005303 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005303() {
    super(0);
  }

  // I'm not sure that the continuation of this power function is correct.

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final int[] IRREGULAR_POWERS = {0, 0, 2, 4, 3, 4};

  private int mN = -1;

  protected int power(final int n) {
    return n < IRREGULAR_POWERS.length ? IRREGULAR_POWERS[n] : ((n & 1) == 0 ? 2 : 4);
  }

  @Override
  public Z next() {
    ++mN;
    Polynomial<Z> prod = RING.one();
    for (int k = 1; k <= mN; ++k) {
      prod = RING.multiply(prod, RING.pow(RING.oneMinusXToTheN(k), power(k), mN), mN);
    }
    return RING.coeff(RING.one(), prod, mN);
  }
}
#!queue	A005316	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A005316 Meandric numbers: number of ways a river can cross a road n times.
 * @author Andrew Howroyd
 * @author Sean A. Irvine (Java port)
 */
public class A005316 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005316() {
    super(0);
  }

  // Java implementation based on a C# implementation by Andrew Howroyd.
  // https://oeis.org/A005316/a005316.cs.txt
  // Original documentation for C# version follows.
  // Note some functionality discussed is not present in this Java version.

  /* Author: Andrew Howroyd. (c) 2015
     Terms of use: You may freely use this software for personal, open source, educational or commercial use.
     However, you may not redistribute or use this software in conjunction with any modification or improvement for which use is
     not fully granted to all under the terms of this or GPL/LGPL license. (to use freely you must be willing to give freely)
     You may release this code under the GNU Lesser Public License (LGPL v2.1: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html)
     If you modify, adapt or reformat this code, please state clearly that the code has been modified from the original.
     No warranty.
   */

    /*
        This software is not a complete program. It is left to the end user to provide application code, api and top level enumeration functions.
        It is more intended as a starter tool-kit for those wanting to explore meanders or reproduce some of the known results.
        The code was compiled using Visual Studio Community 2015 and was run on the Windows platform using .Net 4.5.
        For BigInteger, the System.Numerics package must be added as a reference to the project. This is part of the standard .Net library.

        The basic meander transfer enumeration method is implemented in the MeanderProblem class. Sub classes of this provide
        customizations for different sequences. Included here are BasicMeanderProblem, MeandersByComponents and ParallelRoadsMeanderProblem.
        The first two enumerate the most important core sequences, whilst the ParallelRoadsMeanderProblem is a demonstration
        of how the same algorithm can be extended to a more complex problem - by pretending the multiple roads are a single
        snake like road and adding book keeping to track the meander from one bend to the next.
        The algorithm has also been successfully used to enumerate a variety of other meander sequences. (A060148, A077056, A060972, A259974).
        Code for these is not included here as it would add unnecessary clutter with little additional insight.

        In addition to a sub-class of BasicMeanderProblem a state machine processor is required. Two are included here.
        SimpleProcessor is the most natural and simple implementation, but will eventually fail at about 40 bridges due to
        insufficient memory to contain the entire state space. This is suitable for many needs.
        DivideAndConquerProcessor is a processor that reduces memory use at the cost of additional CPU by sub-dividing
        the problem into multiple partitions which are processed independently.

        The method is generally applicable to any meander problem that can be reduced to a simple left to right scan of the meander.
        More generally the 'transfer-matrix' method is applicable to a very wide class of enumeration problem.

        Sample usage:

        public Z OpenMeanderCount( int length)
        {
            int nn = length - 1;
            var processor = new SimpleProcessor<Z>() { CreateStateMachine = k => new BasicMeanderProblem( k) };
            return processor.Process(nn, new BasicMeanderProblem(nn).OpenMeanderInitialStates);
        }

        ArchConfiguration which is un-related and independent of the other classes is a set of utilities for working
        with arch configuration and menander permutations.

     */

  /**
   * Base class for meander enumeration problems.
   *
   * Algorithm:
   * Based on: I. Jensen,
   * <a href="http://arXiv.org/abs/cond-mat/0008178">A transfer matrix approach to the enumeration of plane meanders</a>,
   * J. Phys. A 33 (2000), no. 34, 5953-5963.
   *
   * There are a few minor implementation differences.
   *   - Two separate bit sequences are used for the lower and upper segments, with the least significant bits closest to the road.
   *     These are inter-woven into a single integer valued state.
   *   - Bit value 1 is used to indicate that an arch originates on this side of the road and 0 indicates on the other side. This gives better symmetry when processing.
   *   - This algorithm does not have any notion of a free end - there is always a loop. Open meanders can be enumerated with an alternative initial state.
   *
   * Performance:
   * The primary limiting factor of the algorithm as presented here is memory rather than CPU. Approximately 2 GB is required to get to about 40 bridges.
   * However, by adopting a multi-stage process it is possible to some extent to trade memory usage for additional CPU.
   * The algorithm as presented here uses Z for both states and counts. For better CPU performance,  64-bit long integers can be used
   * at least for the open meander problem up to about 60 bridges before overflow will be an issue.
   */
  protected static final int WORD_SHIFT = 2;
  //protected static final int WORD_MASK = (1 << WORD_SHIFT) - 1;
  private static final Z ODD_BITS = Z.valueOf(0x5555555555555555L);

  /**
   * Combines the states for the lower and upper halves into a single integer.
   * Each half only uses even numbered bits, so they can be interleaved with a simple bit shift.
   * @param lower lower half
   * @param upper upper half
   * @return packed value
   */
  protected static Z pack(final Z lower, final Z upper) {
    if (lower.isZero() || upper.isZero()) {
      throw new IllegalStateException("invalid state");
    }
    return lower.or(upper.multiply2());
  }

  /*
   * The initial state of the traversal.
   */
  protected static final Z DEFAULT_INITIAL_STATE = pack(Z.ONE, Z.ONE);

  protected interface Func<S, R> {
    R f(S x);
  }

  protected interface Func2<A, B, R> {
    R f(A x, B y);
  }

  protected interface Func3<A, B, C, R> {
    R f(A x, B y, C z);
  }

  protected enum Action {
    NONE, NEW_ARCH, JOIN_ARCH, MOVE_UP, MOVE_DOWN, CLOSE_LOOP
  }

  protected abstract static class MeanderProblem {
    protected final int mLayerIndex;

    /**
     * Constructor.
     * @param layerIndex layer index
     */
    protected MeanderProblem(final int layerIndex) {
      mLayerIndex = layerIndex;
    }

    /**
     * Index of the transition layer. Useful for diagnostics/progress reporting.
     * @return the layer index
     */
    public int getLayerIndex() {
      return mLayerIndex;
    }

    /*
     * Enumerate next states from previous state.
     */
    protected <T> ArrayList<T> enumeratePossibilities(final Z state, final Func3<Action, Z, Z, T> capture) {
      // split the incoming state into lower and upper halves for ease of processing.
      final Z lower = extractLower(state);
      final Z upper = state.subtract(lower).divide2();

      final ArrayList<T> list = new ArrayList<>();

      // There are four possible state transitions.
      // 1. Leg of arch crosses from below road to above road. Allowed if not at edge guard.
      if (!lower.equals(Z.ONE)) {
        list.add(capture.f(Action.MOVE_UP, lower.shiftRight(WORD_SHIFT), (upper.shiftLeft(WORD_SHIFT)).xor(crossRoad(lower))));
      }
      // 2. Leg of arch crosses from above road to below road. Allowed if not at edge guard.
      if (!upper.equals(Z.ONE)) {
        list.add(capture.f(Action.MOVE_DOWN, (lower.shiftLeft(WORD_SHIFT)).xor(crossRoad(upper)), upper.shiftRight(WORD_SHIFT)));
      }
      // 3. Introduction of new arch. Allowed always.
      list.add(capture.f(Action.NEW_ARCH, (lower.shiftLeft(WORD_SHIFT)).or(Z.ONE), (upper.shiftLeft(WORD_SHIFT)).or(Z.ONE)));

      // 4. Arch connection. Possible if not at edge guard on either side.
      if (!lower.equals(Z.ONE) && !upper.equals(Z.ONE)) {
        final Action test = closingAction(lower, upper);
        if (test != Action.NONE) {
          list.add(capture.f(test, joinArch(lower, upper).shiftRight(WORD_SHIFT), joinArch(upper, lower).shiftRight(WORD_SHIFT)));
        }
      }
      return list;
    }

    protected Action closingAction(final Z lower, final Z upper) {
      return lower.isEven() || upper.isEven() ? Action.JOIN_ARCH : Action.CLOSE_LOOP;
    }

    /*
     * When crossing the road, we need to invert the bit that indicates if the arch originated on this side of the road.
     */
    protected Z crossRoad(final Z v) {
      return v.isEven() ? Z.ONE : Z.ZERO;
    }

    /*
     * Handles the mechanics of re-joining arches.
     */
    private Z joinArch(Z v, final Z alt) {
      // see Iwan Jenson paper to understand what is going on here. (with illustrations)
      if (v.isEven() && alt.isOdd()) {
        int n = 0;
        Z bit = Z.ONE;
        while (n >= 0) {
          bit = bit.shiftLeft(WORD_SHIFT);
          n += v.and(bit).isZero() ? 1 : -1;
        }
        v = v.xor(bit);
      }
      return v;
    }

    /**
     * Test for enclosure. Used to identify forest meander systems. (A060148)
     * @param v upper or lower half (doesn't matter which)
     * @return true if enclosed
     */
    protected boolean isEnclosed(final Z v) {
      boolean enclosed = true;
      for (Z bit = Z.TWO; bit.compareTo(v) <= 0; bit = bit.shiftLeft(WORD_SHIFT)) {
        enclosed = !enclosed;
      }
      return enclosed;
    }

    /**
     * Variation on pack that may swap lower and upper words. This reduces the total
     * number of states by about half, but is not safe in those cases where the distinction
     * between upper and lower is important. (This is purely a questionable optimization
     * that in a few cases allows an extra term to be computed)
     * @param lower lower half
     * @param upper upper half
     * @return packed value
     */
    protected Z packSymmetrical(final Z lower, final Z upper) {
      return lower.compareTo(upper) < 0 ? (upper.or(lower.multiply2())) : (lower.or(upper.multiply2()));
    }

    /**
     * Extracts the lower arch configuration from an encoding.
     * The upper arch configuration can the be obtained by subtraction.
     * This undoes the encoding of pack.
     * @param v encoding
     * @return lower arch
     */
    protected Z extractLower(final Z v) {
      Z mask = ODD_BITS;
      int bits = 64;
      while (mask.compareTo(v) < 0) {
        mask = mask.or(mask.shiftLeft(bits));
        bits += bits;
      }
      return v.and(mask);
    }
  }

  /**
   * Interface to abstract state enumeration process.
   * @param <T> type of state
   */
  protected interface StateMachine<T> {

    int getLayerIndex();

    Iterable<T> enumerate(final T state);
  }

  /**
   * Processing component to determine number of open meanders. (A005316).
   */
  protected static class BasicMeanderProblem extends MeanderProblem implements StateMachine<Z> {
    private final Z mLimit;
    private final boolean mIsOdd;

    public BasicMeanderProblem(final int remainingBridges) {
      super(remainingBridges);
      mLimit = Z.ONE.shiftLeft(2 + (WORD_SHIFT * (remainingBridges + 1)));
      mIsOdd = (remainingBridges & 1) == 1;
    }

    /**
     * Initial states to enumerate open meanders.
     * @return initial states
     */
    public Iterable<Z> openMeanderInitialStates() {
      return Collections.singleton(mIsOdd ? pack(Z.ONE.shiftLeft(WORD_SHIFT).or(Z.ONE).shiftLeft(WORD_SHIFT), Z.ONE) : pack(Z.ONE.shiftLeft(WORD_SHIFT).or(Z.ONE), Z.ONE.shiftLeft(WORD_SHIFT).or(Z.ONE)));
    }

    /**
     * Initial states used to enumerate semi-meanders. (A000682)
     * @return meanders
     *
     */
    public Iterable<Z> semiMeanderInitialStates() {
      final ArrayList<Z> res = new ArrayList<>();
      Z bits = mIsOdd ? Z.ONE : Z.ONE.shiftLeft(WORD_SHIFT).or(Z.ONE);
      Z state = pack(bits, bits);
      while (state.compareTo(mLimit) < 0) {
        res.add(state);
        bits = bits.shiftLeft(WORD_SHIFT).or(Z.ONE).shiftLeft(WORD_SHIFT).or(Z.ONE);
        state = pack(bits, bits);
      }
      return res;
    }

//    /**
//     * Initial states for rotationally symmetric loops on two parallel roads. (part of A086031)
//     * gives 1, 3, 16, 105, 786, 6398, 55280, 499293, 4667290, 44840730
//     */
//    public Iterator<Z> ParallelRoadSymmetricMeanderInitialStates
//    {
//      get
//      {
//        Z bits = (1 << WORD_SHIFT) | 1;
//        var state = Pack(bits << WORD_SHIFT, Z.ONE);
//        int r = 1;
//        while (state < m_Limit) {
//          yield return state;
//          r += 2;
//          bits = (((bits << WORD_SHIFT) | Z.ONE) << WORD_SHIFT) | Z.ONE;
//          state = Pack(bits << (WORD_SHIFT * r), Z.ONE);
//        }
//      }
//    }

    /**
     * Enumerate next states from previous state.
     */
    @Override
    public Iterable<Z> enumerate(final Z state) {
      final ArrayList<Z> list = new ArrayList<>();
      for (final Z next : enumeratePossibilities(state, (action, lower, upper) -> pack(lower, upper))) {
        if (mLimit.signum() < 0 || next.compareTo(mLimit) < 0) {
          list.add(next);
        }
      }
      return list;
    }

    @Override
    protected Action closingAction(final Z lower, final Z upper) {
      return super.closingAction(lower, upper) == Action.JOIN_ARCH ? Action.JOIN_ARCH : Action.NONE;
    }
  }

//    /**
//     * Processing component for meanders with multiple parallel roads. (A076876, A206432, A204352 etc). Can also handle loops on multiple parallel roads (A086031).
//     */
//    class ParallelRoadsMeanderProblem : MeanderProblem, IStateMachine<Pair<int, Z>>
//    {
//        private final Z m_Limit;
//        private final int m_MaxRoads;
//        private final boolean m_IsPath;
//        private final int m_Remaining;
//        private final int m_Sign;
//
//        public ParallelRoadsMeanderProblem( int remaining, int maxRoads, boolean isPath, boolean isOdd) : base( remaining)
//        {
//            m_Limit = Z.ONE << (2 + (WORD_SHIFT * (remaining + 1)));
//            m_Remaining = remaining;
//            m_MaxRoads = maxRoads;
//            m_IsPath = isPath;
//            m_Sign = isOdd ? 0 : 1;
//        }
//
//        public Pair<int, Z> InitialState
//        {
//            get
//            {
//                return Pair.Create( m_IsPath ? -1 : 1,
//              m_Remaining % 2 == 0 ? Pack( (Z.ONE << WORD_SHIFT) | Z.ONE, (Z.ONE << WORD_SHIFT) | Z.ONE)
//              : Pack( Z.ONE, ((Z.ONE << WORD_SHIFT) | Z.ONE) << WORD_SHIFT));
//            }
//        }
//
//        public Iterator<Pair<int, Z>> Enumerate( Pair<int, Z> state)
//        {
//            return EnumeratePossibilities( state.Item2,
//                    ( action, lower, upper) => Pair.Create( state.Item1 < 0 && upper.equals(Z.ONE) ? -state.Item1 : state.Item1, Pack( lower, upper)))
//                .Where( next => m_Limit.Sign < 0 || next.Item2 < m_Limit)
//                .SelectMany( Fork);
//        }
//
//        private Iterator<Pair<int, Z>> Fork( Pair<int, Z> state)
//        {
//            // There is always the option to stay on the current road.
//            yield return state;
//
//            // If we are not yet at the limit, also look into the possibility of moving to the next.
//            if (state.Item1 < m_MaxRoads && -state.Item1 < m_MaxRoads)
//            {
//                var lower = ExtractLower( state.Item2);
//                var upper = (state.Item2 - lower) >> 1;
//                boolean canAdvance = (state.Item1 & 1) == m_Sign ? lower.equals(Z.ONE)
//                                : state.Item1 < 0 ? upper == ((1 << WORD_SHIFT) | 1) : upper.equals(Z.ONE);
//                if (canAdvance)
//                {
//                    yield return Pair.Create( state.Item1 + (state.Item1 < 0 ? -1 : 1), state.Item2);
//                }
//            }
//        }
//
//        protected override Action ClosingAction( Z lower, Z upper)
//        {
//            return base.ClosingAction( lower, upper) == Action.JoinArch ? Action.JoinArch : Action.None;
//        }
//    }

  /**
   * Simple processing engine that will work with any kind of state type.
   * @param <S> state type
   */
  public static class SimpleProcessor<S> {
    private long mTotalTransitions;

    long getTotalTransitions() {
      return mTotalTransitions;
    }

    void setTotalTransitions(final long totalTransitions) {
      mTotalTransitions = totalTransitions;
    }

    Func<Integer, StateMachine<S>> mCreateStateMachine;

    /**
     * Set state creation machine.
     * @param createStateMachine state creator
     */
    public void setCreateStateMachine(final Func<Integer, StateMachine<S>> createStateMachine) {
      mCreateStateMachine = createStateMachine;
    }

    Func<Integer, StateMachine<S>> getCreateStateMachine() {
      return mCreateStateMachine;
    }

    /**
     * Main function. Processes initial states down to final count.
     * @param bridges number of bridges
     * @param initialStates initial states
     * @return count
     */
    public Z process(final int bridges, final Iterable<S> initialStates) {
      List<Pair<S, Z>> counts = new ArrayList<>();
      for (final S state : initialStates) {
        counts.add(new Pair<>(state, Z.ONE));
      }
      int nn = bridges;
      while (nn > 0) {
        counts = accumulate(getCreateStateMachine().f(--nn), counts);
      }
      return total(counts);
    }

    /*
     * Determines the final total value.
     */
    protected Z total(final Iterable<Pair<S, Z>> counts) {
      Z total = Z.ZERO;
      for (final Pair<S, Z> kv : counts) {
        total = total.add(kv.right());
      }
      return total;
    }

    /*
     * Processes one layer.
     */
    protected List<Pair<S, Z>> accumulate(final StateMachine<S> layer, final List<Pair<S, Z>> previous) {
      final HashMap<S, Z> counts = new HashMap<>();
      long transitions = 0;
      for (final Pair<S, Z> kv : previous) {
        for (final S state : layer.enumerate(kv.left())) {
          final Z n = counts.get(state);
          counts.put(state, n != null ? n.add(kv.right()) : kv.right());
          ++transitions;
        }
      }
      mTotalTransitions += transitions;
      final ArrayList<Pair<S, Z>> res = new ArrayList<>();
      for (final Map.Entry<S, Z> e : counts.entrySet()) {
        res.add(new Pair<>(e.getKey(), e.getValue()));
      }
      return res;
    }
  }

  private int mN = -2;

  @Override
  public Z next() {
    ++mN;
    final SimpleProcessor<Z> processor = new SimpleProcessor<>();
    processor.setCreateStateMachine(BasicMeanderProblem::new);
    return processor.process(mN, new BasicMeanderProblem(mN).openMeanderInitialStates());
  }
}
#!queue	A005327	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005327 Certain subgraphs of a directed graph (inverse binomial transform of A005321).
 * @author Sean A. Irvine
 */
public class A005327 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005327() {
    super(1);
  }

  private Z mA = null;
  private long mAdd = 1;
  private Z mTwos = Z.ONE;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
    } else {
      mAdd = -mAdd;
      mTwos = mTwos.multiply2();
      mA = mA.multiply(mTwos.subtract(1)).add(mAdd);
    }
    return mA;
  }
}
#!queue	A005345	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005345 Number of elements of a free idempotent monoid on n letters.
 * @author Sean A. Irvine
 */
public class A005345 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005345() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN > 31) {
      throw new UnsupportedOperationException();
    }
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      Z t = Binomial.binomial(mN, k);
      for (int i = 1; i <= k; ++i) {
        t = t.multiply(Z.valueOf(k - i + 1).pow(1 << i));
      }
      sum = sum.add(t);
    }
    return sum;
  }
}
#!queue	A005371	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Fibonacci;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005371 a(n) = L(L(n)), where L(n) are Lucas numbers A000032.
 * @author Sean A. Irvine
 */
public class A005371 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005371() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    return Fibonacci.lucas(Fibonacci.lucas(++mN).intValueExact());
  }
}
#!queue	A005384	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005384 Sophie Germain primes p: 2p+1 is also prime.
 * @author Sean A. Irvine
 */
public class A005384 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005384() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  private Z mP = Z.ONE;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      if (mPrime.isPrime(mP.multiply2().add(1))) {
        return mP;
      }
    }
  }
}
#!queue	A005408	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005408 The odd numbers: a(n) = 2*n + 1.
 * @author Sean A. Irvine
 */
public class A005408 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005408() {
    super(0);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(2);
    return mN;
  }
}
#!queue	A005437	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005437 Column of Kempner tableau.
 * @author Sean A. Irvine
 */
public class A005437 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005437() {
    super(0);
  }

  protected Z[] mPrev = new Z[0];

  @Override
  public Z next() {
    final Z[] t = new Z[mPrev.length + 1];
    if ((t.length & 1) == 1) {
      // m recurrence
      if (t.length == 1) {
        t[0] = Z.ONE;
      } else {
        t[0] = Z.ZERO;
        for (int k = 1; k < t.length; ++k) {
          t[k] = t[k - 1].add(mPrev[k - 1]);
        }
      }
    } else {
      t[t.length - 1] = Z.ZERO;
      for (int k = t.length - 2; k >= 0; --k) {
        t[k] = t[k + 1].add(mPrev[k]);
      }
    }
    mPrev = t;
    //System.out.println(Arrays.toString(mPrev));
    return mPrev[(mPrev.length - 1) / 2];
  }
}

#!queue	A005473	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005473 Primes of form k^2 + 4.
 * @author Sean A. Irvine
 */
public class A005473 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005473() {
    super(1);
  }

  protected Z mN = Z.ZERO;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      final Z plus = mN.square().add(4);
      if (plus.isProbablePrime()) {
        return plus;
      }
    }
  }
}
#!queue	A005516	12	->	12	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.factor.factor.Jaguar;
import irvine.math.LongUtils;
import irvine.math.z.Binomial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005516 Number of n-bead bracelets (turnover necklaces) with 12 red beads.
 * @author Sean A. Irvine
 */
public class A005516 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005516() {
    super(12);
  }

  private final int mK = beads();
  private int mN = mK - 1;

  protected int beads() {
    return 12;
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(LongUtils.gcd(mN, mK)).divisors()) {
      final int d = dd.intValueExact();
      sum = sum.add(Binomial.binomial(mN / d, mK / d).multiply(Euler.phiAsLong(d)));
    }
    sum = sum.divide(mN);
    sum = sum.add(Binomial.binomial(((mN & 1) == 1 ? mN - 1 : mN - ((mK & 1) == 1 ? 2 : 0)) / 2, mK / 2));
    return sum.divide2();
  }
}
#!queue	A005574	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005574 Numbers k such that k^2 + 1 is prime.
 * @author Sean A. Irvine
 */
public class A005574 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005574() {
    super(1);
  }

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (mN.square().add(1).isProbablePrime()) {
        return mN;
      }
    }
  }
}

#!queue	A005579	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.factor.prime.Fast;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005579 Least number of distinct prime factors in even numbers having an abundancy index &gt; n.
 * @author Sean A. Irvine
 */
public class A005579 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005579() {
    super(2);
  }

  private long mN = 1;
  private long mK;
  private Q mProd = Q.ONE;
  private Z mP = Z.ONE;
  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    final Q n = new Q(++mN);
    while (mProd.compareTo(n) <= 0) {
      ++mK;
      mP = mPrime.nextPrime(mP);
      mProd = mProd.multiply(new Q(mP, mP.subtract(1)));
    }
    return Z.valueOf(mK);
  }
}

#!queue	A005608	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import java.util.HashMap;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005608 Number of Boolean functions realized by cascades of n gates.
 * @author Sean A. Irvine
 */
public class A005608 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005608() {
    super(1);
  }

  private final HashMap<String, Z> mButlerSCache = new HashMap<>();

  protected Z computeButlerS1(final int i, final long s, final long r) {
    Z sum = Z.ZERO;
    for (int k = 0; k <= i; ++k) {
      sum = sum.signedAdd((k & 1) == 0, Binomial.binomial(i, k).multiply(Z.valueOf(i - k).pow(s * r)));
    }
    return sum.multiply(Binomial.binomial(s, i));
  }

  private Z computeButlerS(final int i, final int s, final int r, final int n) {
    if (n == 0) {
      return Z.TWO;
    }
    if (n == 1) {
      return computeButlerS1(i, s, r);
    } else {
      Z sum = Z.ZERO;
      for (int j = 1; j <= s; ++j) {
        Z t = Z.ZERO;
        for (int k = 0; k < i; ++k) {
          t = t.signedAdd((k & 1) == 0, Binomial.binomial(i, k).multiply(Binomial.binomial(Z.valueOf(i - k).pow(r).longValueExact(), j)));
        }
        t = t.multiply(Binomial.binomial(s, i));
        sum = sum.add(t.multiply(butlerS(j, s, r, n - 1)).divide(Binomial.binomial(s, j)));
      }
      return sum;
    }
  }

  protected Z butlerS(final int i, final int s, final int r, final int n) {
    final String key = i + "," + s + "," + r + "," + n;
    final Z res = mButlerSCache.get(key);
    if (res != null) {
      return res;
    }
    final Z t = computeButlerS(i, s, r, n);
    mButlerSCache.put(key, t);
    return t;
  }

  protected Z butlerN(final int n, final int s, final int r) {
    Z sum = Z.ZERO;
    for (int i = 1; i <= s; ++i) {
      sum = sum.add(butlerS(i, s, r, n));
    }
    return sum;
  }

  private int mN = 0;

  @Override
  public Z next() {
    return butlerN(++mN, 3, 2);
  }
}

#!queue	A005614	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005614 The binary complement of the infinite Fibonacci word A003849. Start with 1, apply 0-&gt;1, 1-&gt;10, iterate, take limit.
 * @author Sean A. Irvine
 */
public class A005614 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005614() {
    super(0);
  }

  private StringBuilder mSeq = new StringBuilder("10");
  private int mPos = -1;
  private int mRepPos = 0;

  @Override
  public Z next() {
    if (++mPos >= mSeq.length()) {
      mSeq.append(mSeq.charAt(++mRepPos) == '0' ? "1" : "10");
    }
    return mSeq.charAt(mPos) == '0' ? Z.ZERO : Z.ONE;
  }
}

#!queue	A005654	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005654 Number of bracelets (turn over necklaces) with n red, 1 pink and n-1 blue beads; also reversible strings with n red and n-1 blue beads; also next-to-central column in Losanitsch's triangle A034851.
 * @author Sean A. Irvine
 */
public class A005654 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005654() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return Binomial.binomial(2 * mN - 1, mN).add(Binomial.binomial(mN - 1, mN / 2)).divide2();
  }
}
#!queue	A005728	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005728 Number of fractions in Farey series of order n.
 * @author Sean A. Irvine
 */
public class A005728 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005728() {
    super(0);
  }

  private Z mA = Z.ONE;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN > 0) {
      mA = mA.add(Euler.phiAsLong(mN));
    }
    return mA;
  }
}

#!queue	A005754	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.MemoryFunction2;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A005754 Number of planted identity matched trees with n nodes.
 * @author Sean A. Irvine
 */
public class A005754 extends MemoryFunction2Sequence<Long, Z> {

  protected int mLeaves;

  /** Construct the sequence. */
  public A005754() {
    this(2);
  }

  /**
   * Generic constructor with parameter
   * @param leaves number of leaves
   */
  public A005754(final int leaves) {
    super(leaves - 1);
    mLeaves = leaves;
  }

  // After Alois P. Heinz

  private class BFunction extends MemoryFunction2<Long, Z> {
    @Override
    protected Z compute(final Long n, final Long k) {
      if (n == 0) {
        return Z.ONE;
      }
      if (k < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final Z m = get(k - 1, k - 1).multiply(mLeaves);
      for (long j = 0; j <= n / k; ++j) {
        sum = sum.add(Binomial.binomial(m, Z.valueOf(j)).multiply(get(n - k * j, k - 1)));
      }
      return sum;
    }
  }

  private final BFunction mB = new BFunction();
  private long mN = -1;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 0) {
      return Z.ONE;
    }
    if (k < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long j = 0; j <= n / k; ++j) {
      sum = sum.add(Binomial.binomial(mB.get(k - 1, k - 1), Z.valueOf(j)).multiply(get(n - k * j, k - 1)));
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    return get(mN, mN);
  }
}
#!queue	A005811	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005811 Number of runs in binary expansion of n (n&gt;0); number of 1's in Gray code for n.
 * @author Sean A. Irvine
 */
public class A005811 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005811() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    long r = 1;
    long m = mN >>> 1;
    long c = mN & 1;
    while (m != 0) {
      if ((m & 1) != c) {
        ++r;
        c = 1 - c;
      }
      m >>>= 1;
    }
    return Z.valueOf(r);
  }
}
#!queue	A005843	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005843 The nonnegative even numbers: a(n) = 2n.
 * @author Sean A. Irvine
 */
public class A005843 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005843() {
    super(0);
  }

  private Z mN = Z.valueOf(-2);

  @Override
  public Z next() {
    mN = mN.add(2);
    return mN;
  }
}
#!queue	A005900	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005900 Octahedral numbers: a(n) = n*(2*n^2 + 1)/3.
 * @author Sean A. Irvine
 */
public class A005900 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005900() {
    super(0);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.pow(3).multiply2().add(mN).divide(3);
  }
}
#!queue	A005940	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a005;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A005940 The Doudna sequence: write n-1 in binary; power of prime(k) in a(n) is # of 1's that are followed by k-1 0's.
 * @author Sean A. Irvine
 */
public class A005940 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005940() {
    super(1);
  }

  private long mN = 0;
  private final Fast mPrime = new Fast();

  @Override
  public Z next() {
    long m = mN++;
    Z prod = Z.ONE;
    Z p = Z.TWO;
    do {
      if ((m & 1) == 1) {
        prod = prod.multiply(p);
      } else {
        p = mPrime.nextPrime(p);
      }
    } while ((m >>>= 1) > 0);
    return prod;
  }
}
#!queue	A005946	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a005;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A005946 Number of n-step mappings with 5 inputs.
 * @author Sean A. Irvine
 */
public class A005946 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A005946() {
    super(1);
  }

  protected static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;
  protected int mN = 0;

  protected static Z per(final int[] a) {
    Z c = Z.ONE;
    for (int i = 1; i < a.length; ++i) {
      c = c.multiply(FACTORIAL.factorial(a[i])).multiply(FACTORIAL.factorial(i).pow(a[i]));
    }
    return c;
  }

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 1 || n == 1) {
      return Z.ONE;
    }
    if (n == 2) {
      return Z.valueOf(m);
    }
    // Eqn (16) Hogg & Huberman
    Z sum = Z.ZERO;
    final IntegerPartition part = new IntegerPartition(n);
    final int[] lambda = new int[n + 1];
    int[] p;
    while ((p = part.next()) != null) {
      IntegerPartition.toCountForm(p, lambda);
      Z t = Z.ONE;
      for (int k = 1; k < lambda.length; ++k) {
        t = t.multiply(get(k, m - 1).pow(lambda[k]));
      }
      t = t.multiply(FACTORIAL.factorial(n));
      t = t.divide(per(lambda));
      sum = sum.add(t);
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(5, ++mN);
  }
}
#!queue	A006128	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.factor.factor.Jaguar;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006128 Total number of parts in all partitions of n. Also, sum of largest parts of all partitions of n.
 * @author Sean A. Irvine
 */
public class A006128 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006128() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      sum = sum.add(IntegerPartition.partitions(mN - k).multiply(Jaguar.factor(k).sigma0()));
    }
    return sum;
  }
}
#!queue	A006155	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.Arrays;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006155 Expansion of e.g.f. 1/(2-x-e^x).
 * @author Sean A. Irvine
 */
public class A006155 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006155() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> C = RING.create(Arrays.asList(Q.TWO, Q.NEG_ONE));
  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    return RING.coeff(RING.one(), RING.subtract(C, RING.exp(RING.x(), mN)), mN).multiply(mF).toZ();
  }
}

#!queue	A006156	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.string.StringUtils;

/**
 * A006156 Number of ternary squarefree words of length n.
 * @author Sean A. Irvine
 */
public class A006156 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006156() {
    super(0);
  }

  protected ArrayList<String> mWords = new ArrayList<>();

  protected char maxLetter() {
    return 'c';
  }

  @Override
  public Z next() {
    if (mWords.isEmpty()) {
      mWords.add("");
    } else {
      final ArrayList<String> next = new ArrayList<>();
      for (final String w : mWords) {
        for (char letter = 'a'; letter <= maxLetter(); ++letter) {
          final String a = letter + w;
          if (StringUtils.isSquareFreeWord(a)) {
            next.add(a);
          }
        }
      }
      mWords = next;
    }
    return Z.valueOf(mWords.size());
  }
}

#!queue	A006219	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;
import irvine.util.Permutation;

/**
 * A006219 From descending subsequences of permutations.
 * @author Sean A. Irvine
 */
public class A006219 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006219() {
    super(3);
  }

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private int mN = 2;

  private Pair<Integer, Integer> max(final Pair<Integer, Integer> a, final Pair<Integer, Integer> b) {
    if (a.left().equals(b.left())) {
      return a.right() < b.right() ? a : b;
    }
    return a.left() < b.left() ? b : a;
  }

  private Pair<Integer, Integer> scan(final int[] p, final int k, final Pair<Integer, Integer> current) {
    Pair<Integer, Integer> res = current;
    for (int j = k + 1; j < p.length; ++j) {
      if (p[j] < p[k]) {
        res = max(res, scan(p, j, new Pair<>(current.left() + 1, current.right())));
      }
    }
    return res;
  }

  private long[] f(final int n) {
    final long[] f = new long[n + 1];
    final Permutation perm = new Permutation(n);
    int[] p;
    while ((p = perm.next()) != null) {
      Pair<Integer, Integer> best = new Pair<>(0, 0);
      int biggestSeen = -1;
      for (int k = 0; k < p.length; ++k) {
        if (p[k] > biggestSeen) { // Make sure it cannot extend left
          biggestSeen = p[k];
          best = max(best, scan(p, k, new Pair<>(1, p[k])));
        }
      }
      f[best.right() + 1]++; // +1 because I'm using 0..(n-1) rather than 1..n in permutations
    }
    if (mVerbose) {
      System.out.println(Arrays.toString(f));
    }
    return f;
  }

  protected Z f(final int n, final int m) {
    return Z.valueOf(f(n)[m]);
  }

  @Override
  public Z next() {
    return f(++mN, 3);
  }
}
#!queue	A006277	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006277 a(n) = (a(n-1) + 1)*a(n-2).
 * @author Sean A. Irvine
 */
public class A006277 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006277() {
    super(0);
  }

  private Z mA = null;
  private Z mB = null;

  @Override
  public Z next() {
    if (mB == null) {
      if (mA == null) {
        mA = Z.ONE;
        return Z.ONE;
      }
      mB = Z.ONE;
    } else {
      final Z t = mB.add(1).multiply(mA);
      mA = mB;
      mB = t;
    }
    return mB;
  }
}
#!queue	A006308	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.Arrays;

import irvine.factor.prime.Fast;
import irvine.math.cc.CC;
import irvine.math.cc.ComputableComplexField;
import irvine.math.cr.CR;
import irvine.math.cr.ComputableReals;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A006308 Coefficients of period polynomials.
 * @author Sean A. Irvine
 */
public class A006308 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006308() {
    super(2);
  }

  private static final PolynomialRing<CR> RING = new PolynomialRing<>(ComputableReals.SINGLETON);

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  protected final Fast mPrime = new Fast();
  protected int mP = 2;

  protected static CR etaStar(final int p, final int q, final int i) {
    CC sum = CC.ZERO;
    final CC zeta = ComputableComplexField.SINGLETON.exp(new CC(CR.ZERO, CR.TAU.divide(CR.valueOf(p * p))));
    final int p2 = p * p;
    long qq = 1;
    for (int v = 0; v < p - 1; ++v) {
      final int e = (int) (((q + i * (long) p) * qq) % p2);
      sum = ComputableComplexField.SINGLETON.add(sum, ComputableComplexField.SINGLETON.pow(zeta, e));
      qq *= q;
      qq %= p2;
    }
    return sum.re();
  }

  private Polynomial<CR> f(final int p, final int q) {
    Polynomial<CR> f = RING.one();
    for (int k = 0; k < p; ++k) {
      f = RING.multiply(f, RING.create(Arrays.asList(etaStar(p, q, k).negate(), CR.ONE)));
    }
    return f;
  }

  // The following version uses an actual rational ring extension and
  // delays the actual computation of zeta values until near the end.
  // It appears to be slower than the alternative
//  private static Polynomial<Q> etaStar(final RationalUnityExtension ext, final int p, final int q, final int i) {
//    Polynomial<Q> mSum = ext.zero();
//    final int p2 = ext.power();
//    assert p2 == p * p;
//    long qq = 1;
//    for (int v = 0; v < p - 1; ++v) {
//      final int e = (int) (((q + i * (long) p) * qq) % p2);
//      mSum = ext.add(mSum, ext.monomial(Q.ONE, e));
//      qq *= q;
//      qq %= p2;
//    }
//    return mSum;
//  }
//
//  private Polynomial<Polynomial<Q>> f2(final int p, final int q) {
//    final RationalUnityExtension ext = new RationalUnityExtension(p * p);
//    final PolynomialRing<Polynomial<Q>> ring = new PolynomialRing<>(ext);
//    Polynomial<Polynomial<Q>> f = ring.one();
//    for (int k = 0; k < p; ++k) {
//      f = ring.multiply(f, ring.create(Arrays.asList(etaStar(ext, p, q, k).negate(), ext.one())));
//    }
//    return f;
//  }
//
//  private Z coeff(final Polynomial<Polynomial<Q>> f, final int n, final int p) {
//    final Polynomial<Q> c = f.coeff(n);
//    CC mSum = CC.ZERO;
//    final CC zeta = ComputableComplexField.SINGLETON.exp(new CC(CR.ZERO, CR.TAU.divide(CR.valueOf(p * p))));
//    CC z = CC.ONE;
//    for (int k = 0; k <= c.degree(); ++k) {
//      if (!c.coeff(k).equals(Q.ZERO)) {
//        mSum = ComputableComplexField.SINGLETON.add(mSum, ComputableComplexField.SINGLETON.multiply(z, CR.valueOf(c.coeff(k))));
//      }
//      z = ComputableComplexField.SINGLETON.multiply(z, zeta);
//    }
//    return mSum.re().toZ();
//  }

  protected int coeffNumber() {
    return mP - 2;
  }

  protected Z sign(final Z n) {
    return n.negate();
  }

  @Override
  public Z next() {
    mP = (int) mPrime.nextPrime(mP);
    final long p2 = mP * mP;
    final Z g = ZUtils.leastPrimitiveRoot(Z.valueOf(p2));
    final int q = g.modPow(Z.valueOf(mP), Z.valueOf(p2)).intValueExact();
    final Polynomial<CR> f = f(mP, q);
    if (mVerbose) {
      System.out.println("f(" + mP + ")=" + f);
    }
    return sign(f.coeff(coeffNumber()).toZ());
//    final Polynomial<Polynomial<Q>> f2 = f2(mP, q);
//    if (mVerbose) {
//      System.out.println("f(" + mP + ")=" + f2);
//    }
//    return coeff(f2, mP - 2, mP).negate();
  }
}

#!queue	A006318	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006318 Large Schr\u00f6der numbers (or large Schroeder numbers, or big Schroeder numbers).
 * @author Sean A. Irvine
 */
public class A006318 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006318() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      sum = sum.add(Binomial.binomial(mN, k).multiply(Binomial.binomial(mN, k - 1)).shiftLeft(k));
    }
    return sum.divide(mN);
  }
}

#!queue	A006339	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;
import java.util.LinkedList;

import irvine.factor.factor.Jaguar;
import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006339 Least hypotenuse of n distinct Pythagorean triangles.
 * @author Sean A. Irvine
 */
public class A006339 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006339() {
    super(0);
  }

  // After Albert H. Mao

  private int mN = -1;
  private final ArrayList<Z> mOneModFourPrimes = new ArrayList<>();
  private final Fast mPrime = new Fast();

  {
    mOneModFourPrimes.add(Z.FIVE);
  }

  private void ensurePrimes(final int limit) {
    Z p = mOneModFourPrimes.get(mOneModFourPrimes.size() - 1);
    while (mOneModFourPrimes.size() <= limit) {
      p = mPrime.nextPrime(p);
      if (p.mod(4) == 1) {
        mOneModFourPrimes.add(p);
      }
    }
  }

  private ArrayList<LinkedList<Integer>> factorizations(final int n, final int limit) {
    final ArrayList<LinkedList<Integer>> res = new ArrayList<>();
    if (n == 1) {
      res.add(new LinkedList<>());
    } else {
      for (final Z dd : Jaguar.factor(n).divisors()) {
        final int d = dd.intValueExact();
        if (d > 1 && d <= limit) {
          for (final LinkedList<Integer> z : factorizations(n / d, d)) {
            z.addFirst(d);
            res.add(z);
          }
        }
      }
    }
    return res;
  }

  @Override
  public Z next() {
    ++mN;
    Z min = null;
    for (final LinkedList<Integer> f : factorizations(2 * mN + 1, 2 * mN + 1)) {
      ensurePrimes(f.size());
      Z prod = Z.ONE;
      int k = 0;
      for (final int d : f) {
        prod = prod.multiply(mOneModFourPrimes.get(k++).pow((d - 1) / 2));
      }
      if (min == null || min.compareTo(prod) > 0) {
        min = prod;
      }
    }
    return min;
  }

}
#!queue	A006384	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Binomial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006384 Number of planar maps with n edges.
 * @author Sean A. Irvine
 */
public class A006384 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006384() {
    super(0);
  }

  private int mN = -1;

  private Z q(final int n) {
    if ((mN & 1) == 0) {
      final int m = (n - 2) / 2;
      return Z.THREE.pow(m).multiply(Binomial.binomial(n - 2, m)).multiply((n - 1L) * n).shiftLeft(2).divide((n + 2L) * n);
    } else {
      final int m = (n - 1) / 2;
      return Z.THREE.pow(m).multiply(Binomial.binomial(n - 1, m)).multiply(n).shiftLeft(2).divide(n + 1);
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    Z three = Z.ONE;
    for (int k = 1; k < mN; ++k) {
      three = three.multiply(Z.THREE);
      if (mN % k == 0) {
        s = s.add(three.multiply(Euler.phiAsLong(mN / k)).multiply(Binomial.binomial(2 * k, k)));
      }
    }
    s = s.add(three.multiply(Z.THREE).multiply(Binomial.binomial(2 * mN, mN)).multiply2().divide((mN + 1L) * (mN + 2L)));
    s = s.add(q(mN));
    return s.divide(2L * mN);
  }
}
#!queue	A006385	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006385 Number of connected planar maps with n edges.
 * @author T. R. S. Walsh
 * @author Sean A. Irvine
 */
public class A006385 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006385() {
    super(0);
  }

  protected static final int MAX_EDGES = 30;
  protected static final int DIM = 2 * MAX_EDGES + 1;

  protected static final int OPEN_PAREN = 0;
  protected static final int CLOSE_PAREN = -1;
  protected static final int OPEN_BRACKET = 2;
  protected static final int CLOSE_BRACKET = 1;
  protected static final int DELETED = -2;

  protected final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  protected final int[] mP = new int[DIM];
  protected final int[] mQ = new int[DIM];
  protected final int[] mQMate = new int[DIM];
  protected final int[] mPMate = new int[DIM];
  protected final int[] mSMate = new int[DIM];
  protected final int[] mS = new int[DIM];
  protected final int[] mPr = new int[DIM];
  private final int[] mPrPos = new int[DIM];

  protected long mTotal = 0;
  protected long mTotalSensed = 0;

  /* Reusable stacks, should only be used with a single simple method. */
  private final int[] mStack1 = new int[MAX_EDGES];
  private final int[] mStack2 = new int[MAX_EDGES];

  protected String lehman(final int e) {
    final StringBuilder sb = new StringBuilder();
    for (int i = 1; i <= 2 * e; ++i) {
      switch (mS[i]) {
        case OPEN_PAREN:
          sb.append(" (");
          break;
        case CLOSE_PAREN:
          sb.append(" )");
          break;
        case OPEN_BRACKET:
          sb.append(" [");
          break;
        case CLOSE_BRACKET:
          sb.append(" ]");
          break;
        default:
          throw new RuntimeException();
      }
    }
    return sb.toString();
  }

  /**
   * Count planar maps.
   * @param rt type of maps
   * @param e number of edges
   * @param vmn minimum number of vertices
   * @param vmx maximum number of vertices
   * @param lehman true to print the Lehman code
   * @return total number of planar maps
   */
  long planarCount(final int rt, final int e, final int vmn, final int vmx, final boolean lehman) {
    assert e >= 0 && e <= MAX_EDGES;
    final int[] vert = new int[DIM];
    final int[] next = new int[DIM];
    final int[] code = new int[DIM];
    final int[] prev = new int[DIM];
    final long[] sensed = new long[DIM];
    final long[] unsensed = new long[DIM];
    long sumu = 0;
    mTotal = 0;
    mTotalSensed = 0;

    for (int v = vmn; v <= vmx; ++v) {
      final int np = v - 1;
      final int nq = e - np;
      long root = 0;
      long ct = 0;
      firstBracket(nq);
      do {
        if (bracketPairs(nq)) {
          throw new RuntimeException("Invalid bracket system.");
        }
        firstParenthesis(np);
        do {
          if (parenthesisPairs(np)) {
            throw new RuntimeException("Invalid parenthesis system.");
          }
          firstSys(np, nq);
          do {
            if (reject(e)) {
              continue;
            }
            ++ct;
            ++root;
            ++mTotal;
            if (lehman) {
              System.out.printf("%5d:", ct);
              System.out.print(lehman(e));
            }
            if (rt > 0) {
              decode(e, vert, next);
              if (rejectDecode(e, vert)) {
                continue;
              }
              boolean max = true;
              for (int r = 2; r <= 2 * e; ++r) {
                if (alfred(e, v, vert, next, r, code, 1)) {
                  max = false;
                  break;
                }
              }
              if (max) {
                ++sensed[v];
                ++mTotalSensed;
                if (lehman) {
                  System.out.printf("  Sensed map #%d.", sensed[v]);
                }
                if (rt > 1) {
                  for (int i = 1; i <= 2 * e; ++i) {
                    prev[next[i]] = i;
                  }
                  for (int r = 1; r <= 2 * e; ++r) {
                    if (alfred(e, v, vert, prev, r, code, 1)) {
                      max = false;
                      break;
                    }
                  }
                  if (max) {
                    ++unsensed[v];
                    ++sumu;
                    if (lehman) {
                      System.out.printf(" Unsensed map #%d.", unsensed[v]);
                    }
                  }
                }
              }
            }
            if (lehman) {
              System.out.println();
            }
          } while (nextSys(np, nq));
        } while (nextParenthesis(np));
      } while (nextBracket(nq));
      if (mVerbose) {
        System.out.printf("%3d%4d", e, v);
        System.out.printf("%12d%n", root);
      }
    }
    if (mVerbose) {
      System.out.printf("%3d sum", e);
      System.out.printf("%12d%n", mTotal);
      if (rt > 0) {
        dumpTable("Number of sensed planar maps with e edges and v vertices", sensed, mTotalSensed, vmn, vmx, e);
        if (rt > 1) {
          dumpTable("Number of unsensed planar maps with e edges and v vertices.", unsensed, sumu, vmn, vmx, e);
        }
      }
    }
    return sumu;
  }

  protected boolean rejectDecode(final int e, final int[] vert) {
    return false; // Accept everything by default
  }

  protected static void dumpTable(final String header, final long[] counts, final long sum, final int vmn, final int vmx, final int e) {
    System.out.println();
    System.out.println(header);
    System.out.println("  e   v");
    for (int v = vmn; v <= vmx; ++v) {
      System.out.printf("%3d%4d", e, v);
      System.out.printf("%12d%n", counts[v]);
    }
    System.out.printf("%3d sum", e);
    System.out.printf("%12d%n", sum);
  }

  protected boolean reject(final int e) {
    return false; // Accept everything by default
  }

  /* Constructs the Lehman code for the planar map defined by vert and next rooted at r. */
  protected boolean alfred(final int e, final int v, final int[] vert, final int[] next, final int r, final int[] code, final int c) {
    int d, i;
    final int[] el = new int[2 * e + 1];
    final int[] vl = new int[v + 1];
    d = r;
    vl[vert[d]] = 1;
    for (i = 1; i <= 2 * e; ++i) {
      if (el[d] == 0) {
        // The edge containing d is seen for the first time.
        if (vl[vert[2 * e + 1 - d]] == 0)  {
          // The vertex at the other end of this edge not yet seen.
          el[d] = -1;
          el[2 * e + 1 - d] = -1; // Put this edge in the tree.
          code[i] = 0; // left parenthesis
          vl[vert[2 * e + 1 - d]] = 1; // Now we've seen this vertex.
        } else  {
          // The vertex at the other end of this edge has already been seen.
          el[d] = 1;
          el[2 * e + 1 - d] = 1; // Put this edge in the cotree.
          code[i] = 2;
        }
      } else {
        code[i] = el[d]; // The edge containing d is seen for the second time.
      }
      if (c > 0) {
        // We're testing the code mS, decoded by vert and next, for maximality.
        if (code[i] > mS[i]) {
          return true; // The map rooted at d has a bigger code than mS.
        } else if (code[i] < mS[i]) {
          return false; // The map rooted at d has a smaller code than mS.
        }
      }
      if (code[i] <= 0) {
        d = next[2 * e + 1 - d]; // Go to the other end of the edge containing d and rotate.
      } else {
        d = next[d]; // Just rotate.
      }
    }
    return false;
  }

  /* Creates the map defined by vert and next rooted at dart 1 whose Lehman code is mS. */
  protected void decode(final int e, final int[] vert, final int[] next) {
    final int[] ds = new int[2 * e + 1];
    int vc = 1;
    int ec = 0;
    int dOld = 0;
    vert[0] = 1;
    for (int i = 1; i <= 2 * e; ++i) {
      final int d;
      if (ds[i] == 0) {
        // First occurrence of an integer or a left parenthesis.
        d = ++ec;
        ds[i] = d;
        ds[mSMate[i]] = 2 * e + 1 - d;
      } else {
        d = ds[i];
      }
      vert[d] = vert[dOld];
      next[dOld] = d;
      if (mS[i] <= OPEN_PAREN) {
        dOld = 2 * e + 1 - d;
      } else {
        dOld = d;
      }
      if (mS[i] == OPEN_PAREN) {
        vert[dOld] = ++vc;
      }
    }
    vert[1] = 1;
    next[dOld] = 1;
  }

  /* Reusable space for nextSys. */
  private final int[] mRight = new int[DIM];
  private final int[] mLeft = new int[DIM];

  protected boolean nextSys(final int np, final int nq) {
    final int sz = 2 * (np + nq);
    for (int i = 0; i <= sz; ++i) {
      mRight[i] = i + 1;
      mLeft[i] = i - 1;
    }
    mRight[sz] = 0;
    mLeft[0] = sz;
    int ipr = 2 * np;
    while (ipr > 0) {
      int ipos = mPrPos[ipr]; // the position of the parentheses having priority ipr
      int jpos = mRight[ipos];
      final int t = mS[jpos];
      if (jpos != 0 && t > 0 && (mS[ipos] == OPEN_PAREN || mSMate[ipos] <= mSMate[jpos])) {
        // the parenthesis can be moved to the right
        mS[ipos + 1] = mS[ipos];
        mS[ipos] = t;
        if (jpos > ipos + 1) {
          mSMate[ipos + 1] = mSMate[ipos];
          mSMate[mSMate[ipos]]++;
          mSMate[ipos] = mSMate[jpos];
          mSMate[mSMate[jpos]] = ipos;
          mS[jpos] = DELETED;
          mRight[ipos] = ipos + 1;
          mLeft[ipos + 1] = ipos;
          mRight[ipos + 1] = mRight[ipos];
          mLeft[mRight[jpos]] = ipos + 1;
        } else {
          final int ex = mSMate[ipos];
          mSMate[ipos] = mSMate[jpos];
          mSMate[jpos] = ex;
          mSMate[mSMate[ipos]] = ipos;
          mSMate[mSMate[jpos]] = jpos;
        }
        ++mPrPos[ipr];
        // now move the integers to replace the deleted parentheses
        jpos = sz;
        int kpos = jpos - 1;
        while (kpos >= 1) {
          if (kpos == jpos) {
            --kpos;
          } else if (mS[kpos] == OPEN_PAREN || mS[kpos] == CLOSE_PAREN) {
            jpos = kpos--;
          } else if (mS[kpos] == DELETED) {
            if (mS[jpos] > CLOSE_BRACKET) {
              --jpos;
            }
            --kpos;
          } else {
            // kpos < jpos and mS[kpos] is an integer
            if (mS[jpos] == DELETED) {
              // it's a blank - insert the integer
              mS[jpos] = mS[kpos];
              mS[kpos] = DELETED;
              mSMate[jpos] = mSMate[kpos--];
              mSMate[mSMate[jpos]] = jpos;
            }
            --jpos;
          }
        }
        // all blanks are now contiguous with nearest parenthesis to their left
        // now insert the deleted parenthesis in the blanks
        int i = 0;
        for (ipos = 1; ipos <= sz; ++ipos) {
          if (mS[ipos] <= OPEN_PAREN) {
            ++i;
            if (mS[ipos] == DELETED) {
              mS[ipos] = mP[i];
              mPrPos[mPr[i]] = ipos;
            }
          }
        }
        // now the deleted parentheses have been inserted
        // now find the mates to all the parentheses
        int ex = -1;
        for (i = 1; i <= sz; ++i) {
          if (mS[i] == OPEN_PAREN) {
            // it's a left parenthesis - save its position
            mStack1[++ex] = i;
          } else if (mS[i] == CLOSE_PAREN) {
            // it's a right parenthesis
            // the position of its mate is on the top of the stack
            mSMate[i] = mStack1[ex];
            mSMate[mStack1[ex--]] = i;
          }
        }
        return true;
      } else {
        mS[ipos] = DELETED; // it can't be moved - delete it
        mRight[mLeft[ipos]] = mRight[ipos];
        mLeft[mRight[ipos]] = mLeft[ipos];
        --ipr;
      }
    }
    return false;
  }

  protected void firstSys(final int np, final int nq) {
    int i = 0;
    while (i < 2 * np) {
      mS[++i] = mP[i];
      mSMate[i] = mPMate[i];
    }
    int j = 0;
    while (j < 2 * nq) {
      mS[++i] = mQ[j];
      mSMate[i] = mQMate[j++] + 2 * np + 1;
    }
  }

  protected boolean parenthesisPairs(final int n) {
    int ex = -1;
    int prc = -1;
    for (int i = 1; i <= 2 * n; ++i) {
      if (mP[i] == 0) {
        mStack1[++ex] = i;
        prc += 2;
        mPrPos[prc] = i;
        mPr[i] = prc;
        mStack2[ex] = prc;
      } else {
        mPMate[i] = mStack1[ex];
        mPMate[mStack1[ex]] = i;
        mPrPos[mStack2[ex] + 1] = i;
        mPr[i] = mStack2[ex] + 1;
        if (--ex < -1) {
          return true;
        }
      }
    }
    return ex != -1;
  }

  protected void firstParenthesis(final int n) {
    mP[0] = CLOSE_PAREN;
    int i = 0;
    while (i < 2 * n) {
      mP[++i] = OPEN_PAREN;
      mP[++i] = CLOSE_PAREN;
    }
  }

  protected boolean nextParenthesis(final int n) {
    if (n <= 0) {
      return false;
    }
    int i = 2 * n;
    int exc = 0;
    while (mP[i] == CLOSE_PAREN) {
      --i;
      ++exc;
    }
    while (mP[i] == OPEN_PAREN) {
      --i;
      --exc;
    }
    if (i == 0) {
      return false;
    }
    mP[i] = 0;
    exc += 2;
    while (exc > 0) {
      mP[++i] = CLOSE_PAREN;
      --exc;
    }
    while (i < 2 * n) {
      mP[++i] = OPEN_PAREN;
      mP[++i] = CLOSE_PAREN;
    }
    return true;
  }

  protected void firstBracket(final int n) {
    int i = -1;
    while (i < 2 * n - 1) {
      mQ[++i] = OPEN_BRACKET;
      mQ[++i] = CLOSE_BRACKET;
    }
  }

  protected boolean nextBracket(final int n) {
    if (n <= 0) {
      return false;
    }
    int i = 2 * n - 1;
    int exc = 0;
    while (mQ[i] == CLOSE_BRACKET) {
      --i;
      ++exc;
    }
    while (i >= 0 && mQ[i] == OPEN_BRACKET) {
      --i;
      --exc;
    }
    if (i < 0) {
      return false;
    }
    mQ[i] = OPEN_BRACKET;
    exc += 2;
    while (exc > 0) {
      mQ[++i] = CLOSE_BRACKET;
      --exc;
    }
    while (i < 2 * n - 1) {
      mQ[++i] = OPEN_BRACKET;
      mQ[++i] = CLOSE_BRACKET;
    }
    return true;
  }

  protected boolean bracketPairs(final int n) {
    int ex = -1;
    int prc = -1;
    for (int i = 0; i < 2 * n; ++i) {
      if (mQ[i] == OPEN_BRACKET) {
        mStack1[++ex] = i;
        prc += 2;
        mStack2[ex] = prc;
      } else {
        mQMate[i] = mStack1[ex];
        mQMate[mStack1[ex]] = i;
        mPr[i] = mStack2[ex] + 1;
        if (--ex < -1) {
          return true;
        }
      }
    }
    return ex != -1;
  }

  protected boolean isPair(final int start, final int end, final int openType, final int closeType) {
    if (mS[start] != openType) {
      return false;
    }
    if (mS[end] != closeType) {
      return false;
    }
    int open = 0;
    for (int k = start + 1; k < end; ++k) {
      if (mS[k] == openType) {
        ++open;
      } else if (mS[k] == closeType && --open < 0) {
        return false;
      }
    }
    return open == 0;
  }

  protected int mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(planarCount(2, ++mN, 1, mN + 1, mVerbose));
  }
}
#!queue	A006519	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006519 Highest power of 2 dividing n.
 * @author Sean A. Irvine
 */
public class A006519 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006519() {
    super(1);
  }

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    mN.makeOdd();
    return Z.ONE.shiftLeft(mN.auxiliary());
  }
}
#!queue	A006521	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006521 Numbers n such that n divides 2^n + 1.
 * @author Sean A. Irvine
 */
public class A006521 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006521() {
    super(1);
  }

  private int mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Z.ONE.shiftLeft(mN).add(1).mod(mN) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A006538	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicLongArray;

/**
 * A006538 Worst cases for Pierce expansions (denominators).
 * @author Sean A. Irvine
 */
public class A006538 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006538() {
    super(1);
  }

  private final LongDynamicLongArray mP = new LongDynamicLongArray();
  private final LongDynamicLongArray mMinA = new LongDynamicLongArray();
  protected final LongDynamicLongArray mMinB = new LongDynamicLongArray();
  private long mA = 0;
  protected long mN = 0;

  protected long v(final long a, final long k) {
    return a % k;
  }

  private void tryNextA() {
    ++mA;
    long n = 0;
    long b = 0;
    for (long k = 1; k <= mA; ++k) {
      final long pk = mP.get(v(mA, k)) + 1;
      mP.set(k, pk);
      if (pk > n) {
        n = pk;
        b = k;
      }
      final long bestB = mMinA.get(n);
      if (bestB == 0 || bestB > mA) {
        mMinA.set(n, mA);
        mMinB.set(n, b);
      }
    }
  }

  @Override
  public Z next() {
    ++mN;
    while (mMinB.get(mN) == 0) {
      tryNextA();
    }
    //System.out.println("n=" + mN + " b=" + mMinB.get(mN));
    return Z.valueOf(mMinA.get(mN));
  }

}
#!queue	A006562	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006562 Balanced primes (of order one): primes which are the average of the previous prime and the following prime.
 * @author Sean A. Irvine
 */
public class A006562 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006562() {
    super(1);
  }

  protected final Fast mPrime = new Fast();
  private Z mP = Z.THREE;

  @Override
  public Z next() {
    while (true) {
      final Z prev = mP;
      mP = mPrime.nextPrime(mP);
      if (prev.add(mPrime.nextPrime(mP)).equals(mP.multiply2())) {
        return mP;
      }
    }
  }
}
#!queue	A006577	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006577 Number of halving and tripling steps to reach 1 in '3x+1' problem, or -1 if 1 is never reached.
 * @author Sean A. Irvine
 */
public class A006577 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006577() {
    super(1);
  }

  protected Z mN = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    Z m = mN;
    long c = 0;
    while (!Z.ONE.equals(m)) {
      ++c;
      m = m.isEven() ? m.divide2() : m.multiply(3).add(1);
    }
    return Z.valueOf(c);
  }
}
#!queue	A006613	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.IntegerUtils;
import irvine.math.LongUtils;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006613 Zarankiewicz's problem.
 * @author Sean A. Irvine
 */
public class A006613 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006613() {
    super(3);
  }

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  protected int mN = init();
  private int mK = 5;

  protected int init() {
    return j() - 1;
  }

  protected int j() {
    return 3;
  }

  protected int cols() {
    return mN;
  }

  private boolean checkMin(final int[] p, final int n) {
    int count = 0;
    for (final int q : p) {
      if (q >= n) {
        ++count;
      }
    }
    return count >= 2;
  }

  protected boolean isZarankiewicz(final long[] matrix) {
    // Check exists a 2xj submatrix all ones
    for (int row1 = 0; row1 < matrix.length; ++row1) {
      final long r1 = matrix[row1];
      if ((long) Long.bitCount(r1) >= j()) {
        for (int row2 = row1 + 1; row2 < matrix.length; ++row2) {
          final long r2 = matrix[row2] & r1;
          if ((long) Long.bitCount(r2) >= j()) {
            // Found pair of rows with at least j ones in same place, hence exist column selection
            return true;
          }
        }
      }
    }
    return false;
  }

  private boolean bump(final long[] start, final long[] matrix) {
    // Step to the next possible matrix with the same number of 1s as the given
    // matrix in each row.  Once all such matrices are exhausted return false.
    final long maskLimit = 1L << cols();
    for (int k = matrix.length - 1; k >= 0; --k) {
      final long t = LongUtils.swizzle(matrix[k]);
      if (t < maskLimit) {
        matrix[k] = t;
        return true;
      } else {
        matrix[k] = start[k];
      }
    }
    return false;
  }

  private boolean isZarankiewicz(final long[] start, final long[] matrix) {
    //dump(matrix);
    // Check that every matrix generated by swizzling the start matrix is Zarankiewicz
    do {
      if (!isZarankiewicz(matrix)) {
        return false; // Found a matrix without all 1s 2xj submatrix
      }
    } while (bump(start, matrix));
    return true;
  }

//  private void dump(final long[] matrix) {
//    for (final long m : matrix) {
//      final String s = Long.toBinaryString(m | (1L << 62));
//      System.out.println(s.substring(s.length() - cols()));
//    }
//  }

  private boolean zarankiewicz(final int n, final int k) {
    // For every n x cols() binary matrix (n >= j) we are to insert k ones
    // If there exists a n x cols() matrix with a 2xj submatrix not all 1s, then
    // false is returned, otherwise true.
    assert cols() >= j();
    if (mVerbose) {
      System.out.println("Trying k=" + k);
    }

    // A simple condition is that every row of the matrix must contain at least 3 ones.
    // So we want partitions of k into n parts with every part at least 3.
    final IntegerPartition part = new IntegerPartition(k);
    final long[] matrix = new long[n];
    final long[] start = new long[n];
    int[] p;
    boolean ok = false;
    while ((p = part.next()) != null) {
      // Only consider partitions with n parts and each part <= n
      // (i.e. fitting within n x n matrix)
      if (p.length == n && IntegerUtils.max(p) <= cols()) {
        //System.out.println("Partition: " + Arrays.toString(p));
        if (checkMin(p, j())) {
          //System.out.println("Accepted for matrix generation");
          // Build the packed binary matrix with 1s according to the partition
          for (int row = 0; row < p.length; ++row) {
            matrix[row] = (1L << p[row]) - 1;
          }
          System.arraycopy(matrix, 0, start, 0, matrix.length);
          if (!isZarankiewicz(start, matrix)) {
            return false; // Found a matrix that does not work, this k is too small
          }
          ok = true; // Partition passed
        } else {
          return false; // Eliminated this k because exists rows with insufficient 1s
        }
      }
    }
    return ok; // Every valid partition passed matrix testing
  }

  private int zarankiewicz(final int n) {
    // Find minimum k satisfying Zarankiewicz condition
    while (!zarankiewicz(n, mK)) {
      ++mK;
    }
    return mK;
  }

  @Override
  public Z next() {
    return Z.valueOf(zarankiewicz(++mN));
  }
}

#!queue	A006718	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006718 Number of golygons of length 8n.
 * @author Sean A. Irvine
 */
public class A006718 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006718() {
    super(0);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = -8;

  @Override
  public Z next() {
    mN += 8;
    final int c = mN * (mN / 8);
    Polynomial<Z> p1 = RING.one();
    for (int k = 1; k < mN; k += 2) {
      p1 = RING.multiply(p1, RING.onePlusXToTheN(k), c);
    }
    final int d = (mN / 8) * (mN / 2 + 1);
    Polynomial<Z> p2 = RING.one();
    for (int k = 1; k <= mN / 2; ++k) {
      p2 = RING.multiply(p2, RING.onePlusXToTheN(k), d);
    }
    return p1.coeff(c).multiply(p2.coeff(d));
  }
}
#!queue	A006774	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Point;

/**
 * A006774 Number of 2n-step polygons on honeycomb.
 * @author Sean A. Irvine
 */
public class A006774 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006774() {
    super(0);
  }

  protected int mN = -2;

  private final HashSet<Point> mVisited = new HashSet<>();

  {
    mVisited.add(new Point(0, 0));
    mVisited.add(new Point(1, 0));
  }

  private Z b(final int n, final int x, final int y) {
    final Point v = new Point(x, y);
    if (n == 0) {
      return x == 0 && y == 0 ? Z.ONE : Z.ZERO;
    } else if (y < 0 || (y == 0 && x > 0)) { // Make sure our start point is least possible
      return Z.ZERO;
    } else if (Math.abs(x) + Math.abs(y) > n) {
      return Z.ZERO; // Can never make it back in remaining steps
    } else if (mVisited.contains(v)) {
      return Z.ZERO;
    } else {
      mVisited.add(v);
      final Z c = b(n - 1, x + 1, y).add(b(n - 1, x - 1, y)).add(b(n - 1, x, y - 1 + 2 * ((x + y) & 1)));
      mVisited.remove(v);
      return c;
    }
  }

  @Override
  public Z next() {
    mN += 2;
    if (mN == 0) {
      return Z.ONE;
    }
    return b(mN - 2, 1, 1);
  }
}
#!queue	A006779	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006779 Number of n-step spirals on cubic lattice.
 * @author Sean A. Irvine
 */
public class A006779 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006779() {
    super(0);
  }

  // Cf. A001412.
  // Cubic lattice
  // Coordinate of a point is (x,y,z).
  // Pack (x,y,z) into a single int with 10-bits per entry.  To avoid
  // having to worry about propagation of negatives, bias each coordinate by
  // 2^9.  Hence we can deal with lattice extent of roughly 2^9 in any
  // direction (an amount that will not be exhausted in a brute force
  // counting of paths, etc.)
  // Neighbours change one coordinate by +/- 1.
  private static final int BITS_PER_COORDINATE = 10;
  private static final int Y_SHIFT = 2 * BITS_PER_COORDINATE;
  private static final int MASK = (1 << BITS_PER_COORDINATE) - 1;
  private static final int BIAS = 1 << (BITS_PER_COORDINATE - 1);
  private static final int ORIGIN = (BIAS << (2 * BITS_PER_COORDINATE))
    | (BIAS << BITS_PER_COORDINATE)
    | BIAS;
  private static final int X1 = 1 << Y_SHIFT;
  private static final int Y1 = 1 << BITS_PER_COORDINATE;
  private static final int[] DELTAS = {1, X1, Y1, -1, -X1, -Y1};

  private int mN = -1;
  private int[] mPath = null;

  protected static int z(final int point) {
    return (point & MASK) - BIAS;
  }

  protected static int y(final int point) {
    return ((point >> BITS_PER_COORDINATE) & MASK) - BIAS;
  }

  protected static int x(final int point) {
    return ((point >> Y_SHIFT) & MASK) - BIAS;
  }

  private void setPathElement(final int pos, final int value) {
    mPath[pos] = value;
  }

  private boolean contains(final int point, final int n) {
    for (int k = 0; k <= n; ++k) {
      if (mPath[k] == point) {
        return true;
      }
    }
    return false;
  }

  private boolean check(final int point, final int n) {
    return !contains(point, n);
  }

  protected int model(final int theta) {
    return 3;
  }

  protected long count(final int point) {
    return 6;
  }

  private long count(final int point, final int n, final int theta) {
    if (n == mN) {
      return count(point);
    }
    mPath[n] = point;
    long count = 0;
    int limit = theta + model(theta);
    if (limit >= DELTAS.length) {
      limit -= DELTAS.length;
    }
    int t = theta;
    do {
      final int newPoint = point + DELTAS[t];
      if (check(newPoint, n)) {
        count += count(newPoint, n + 1, t);
      }
      if (++t == DELTAS.length) {
        t = 0; // mod
      }
    } while (t != limit);
    return count;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mPath = new int[mN];
    setPathElement(0, ORIGIN);
    return Z.valueOf(count(ORIGIN + 1, 1, 0));
  }
}
#!queue	A006780	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006780 Number of n-step spirals on cubic lattice.
 * @author Sean A. Irvine
 */
public class A006780 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006780() {
    super(0);
  }

  // Cf. A001412.
  // Cubic lattice
  // Coordinate of a point is (x,y,z).
  // Pack (x,y,z) into a single int with 10-bits per entry.  To avoid
  // having to worry about propagation of negatives, bias each coordinate by
  // 2^9.  Hence we can deal with lattice extent of roughly 2^9 in any
  // direction (an amount that will not be exhausted in a brute force
  // counting of paths, etc.)
  // Neighbours change one coordinate by +/- 1.
  private static final int BITS_PER_COORDINATE = 10;
  private static final int Y_SHIFT = 2 * BITS_PER_COORDINATE;
  private static final int BIAS = 1 << (BITS_PER_COORDINATE - 1);
  private static final int MASK = (1 << BITS_PER_COORDINATE) - 1;
  private static final int ORIGIN = (BIAS << (2 * BITS_PER_COORDINATE))
    | (BIAS << BITS_PER_COORDINATE)
    | BIAS;
  private static final int X1 = 1 << Y_SHIFT;
  private static final int Y1 = 1 << BITS_PER_COORDINATE;
  private static final int[] DELTAS = {1, X1, Y1, -1, -X1, -Y1};
  private static final int[][] NEXT_STATES = {
    {0, 1},
    {0, 1, 2, 3, 5},
    {0, 1, 2, 3, 4},
    {3, 4},
    {0, 2, 3, 4, 5},
    {0, 1, 3, 4, 5},
  };

  private int mN = -1;
  private int[] mPath = null;

  protected static int z(final int point) {
    return (point & MASK) - BIAS;
  }

  protected static int y(final int point) {
    return ((point >> BITS_PER_COORDINATE) & MASK) - BIAS;
  }

  protected static int x(final int point) {
    return ((point >> Y_SHIFT) & MASK) - BIAS;
  }

  private void setPathElement(final int pos, final int value) {
    mPath[pos] = value;
  }

  private boolean contains(final int point, final int n) {
    for (int k = 0; k <= n; ++k) {
      if (mPath[k] == point) {
        return true;
      }
    }
    return false;
  }

  protected long count(final int point) {
    return 2;
  }

  private long count(final int point, final int n, final int state) {
    if (n == mN) {
      return count(point);
    }
    mPath[n] = point;
    long count = 0;
    for (final int s : NEXT_STATES[state]) {
      final int newPoint = point + DELTAS[s];
      if (!contains(newPoint, n)) {
        count += count(newPoint, n + 1, s);
      }
    }
    return count;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mPath = new int[mN];
    setPathElement(0, ORIGIN);
    return Z.valueOf(count(ORIGIN + 1, 1, 0)).add(Z.valueOf(count(ORIGIN + X1, 1, 1))).add(Z.valueOf(count(ORIGIN + Y1, 1, 2)));
  }
}
#!queue	A006853	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import irvine.math.group.PolynomialRing;
import irvine.math.group.SymmetricGroup;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A006853 Balanced colorings of n-cube.
 * @author Sean A. Irvine
 */
public class A006853 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006853() {
    super(0);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final HashMap<Pair<Integer, List<Integer>>, Z> mCache = new HashMap<>();
  private int mN = -1;

  private Z computeBigN(final int k, final int[] j) {
    Polynomial<Z> p = RING.one();
    for (int i = 1; i < j.length; ++i) {
      if (j[i] > 0) {
        p = RING.multiply(p, RING.pow(RING.onePlusXToTheN(i), j[i], k), k);
      }
    }
    return p.coeff(k);
  }

  private Z bigN(final int k, final int[] j) {
    final ArrayList<Integer> l = new ArrayList<>(j.length);
    for (final int t : j) {
      l.add(t);
    }
    final Pair<Integer, List<Integer>> key = new Pair<>(k, l);
    final Z res = mCache.get(key);
    if (res != null) {
      return res;
    }
    final Z bn = computeBigN(k, j);
    mCache.put(key, bn);
    return bn;
  }

  private boolean isEvenA(final int[] j) {
    long s = 0;
    for (int i = 2; i < j.length; i += 2) {
      s += j[i];
    }
    return (s & 1) == 0;
  }

  protected Z bigN(final int n, final int k2) {
    assert (k2 & 1) == 0;
    final int k = k2 / 2;
    Q sum = Q.ZERO;
    final IntegerPartition part = new IntegerPartition(k2);
    final int[] j = new int[k2 + 1];
    int[] p;
    while ((p = part.next()) != null) {
      IntegerPartition.toCountForm(p, j);
      final Z nj = bigN(k, j).pow(n);
      sum = sum.signedAdd(isEvenA(j), new Q(nj, SymmetricGroup.per(j)));
    }
    //System.out.println("N_" + n + "," + k2 + "=" + sum);
    return sum.toZ();
  }

  @Override
  public Z next() {
    if (++mN < 2) {
      return Z.TWO;
    }
    Z sum = Z.ONE; // k == 0 gives 1
    for (int k = 1; k < (1L << mN) / 4; ++k) {
      sum = sum.add(bigN(mN, 2 * k));
    }
    return sum.multiply2().add(bigN(mN, (1 << mN) / 2));
  }
}
#!queue	A006880	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006880 Number of primes &lt; 10^n.
 * @author Sean A. Irvine
 */
public class A006880 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006880() {
    super(0);
  }

  private final Fast mPrime = new Fast();
  private long mLimit = 1;
  private long mP = 0;
  private long mCount = 0;

  @Override
  public Z next() {
    while (mP < mLimit) {
      mP = mPrime.nextPrime(mP);
      ++mCount;
    }
    mLimit *= 10;
    return Z.valueOf(mCount - 1);
  }
}
#!queue	A006881	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006881 Squarefree semiprimes: Numbers that are the product of two distinct primes.
 * @author Sean A. Irvine
 */
public class A006881 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006881() {
    super(1);
  }

  private long mN = 5;

  @Override
  public Z next() {
    while (true) {
      final FactorSequence fs = Jaguar.factor(++mN);
      final Z[] f = fs.toZArray();
      if (f.length == 2 && fs.getExponent(f[0]) == 1 && fs.getExponent(f[1]) == 1) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A006882	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006882 Double factorials n!!: a(n) = n*a(n-2) for n &gt; 1, a(0) = a(1) = 1.
 * @author Sean A. Irvine
 */
public class A006882 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006882() {
    super(0);
  }

  private long mN = -1;
  private Z mA = Z.ONE;
  private Z mB = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 1) {
      final Z t = mA.multiply(mN);
      mA = mB;
      mB = t;
    }
    return mB;
  }
}
#!queue	A006918	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006918 a(n) = binomial(n+3, 3)/4 for odd n, n*(n+2)*(n+4)/24 for even n.
 * @author Sean A. Irvine
 */
public class A006918 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006918() {
    super(0);
  }

  protected long mN = -1;

  @Override
  public Z next() {
    return (++mN & 1) == 0
      ? Z.valueOf(mN).multiply(mN + 2).multiply(mN + 4).divide(24)
      : Binomial.binomial(mN + 3, 3).divide(4);
  }
}
#!queue	A006932	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006932 Number of permutations of [n] with at least one strong fixed point (a permutation p of {1,2,...,n} is said to have j as a strong fixed point if p(k) &lt; j for k &lt; j and p(k) &gt; j for k &gt; j).
 * @author Sean A. Irvine
 */
public class A006932 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006932() {
    super(1);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private final ArrayList<Z> mCoeff = new ArrayList<>();

  {
    mCoeff.add(Z.ONE);
  }

  protected Z mF = Z.ONE;
  private int mN = 0;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    mCoeff.add(mF);
    final Polynomial<Z> t = RING.create(mCoeff);
    return mF.subtract(RING.coeff(t, RING.add(RING.one(), t.shift(1)), mN));
  }
}
#!queue	A006966	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.ArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import gebhardt.Benes;
import gebhardt.Globals;
import gebhardt.LattEnum;
import gebhardt.Lattice;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a055.A055512;
import irvine.util.CliFlags;

/**
 * A006966 Number of lattices on n unlabeled nodes.
 * @author Volker Gebhardt
 * @author Sean A. Irvine (Java port)
 */
public class A006966 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006966() {
    super(0);
  }

  // This sequence is based on a C implementation by Volker Gebhardt.
  // If you are serious about calculating new terms for this sequence, then please
  // refer to the original implementation as it supports parallel computation and
  // other features not present here.
  // Cf. https://arxiv.org/abs/1609.08255

  // Original notice:

  /*
   * main.c
   *
   * Created on: 22 Mar 2014
   * Last modified: 23 Feb 2019
   * Author: Volker Gebhardt, v.gebhardt@westernsydney.edu.au
   *
   *   Copyright (C) 2015-2019 by Volker Gebhardt
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
   *   the Free Software Foundation; either version 3 of the License, or
   *   (at your option) any later version.
   *
   *   This program is distributed in the hope that it will be useful,
   *   but WITHOUT ANY WARRANTY; without even the implied warranty of
   *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   *   GNU General Public License for more details.
   *
   *   You should have received a copy of the GNU General Public License
   *   along with this program; if not, write to the
   *   Free Software Foundation, Inc.,
   *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
   */

  private static final int THREADS = Integer.parseInt(System.getProperty("oeis.threads",
    String.valueOf(Runtime.getRuntime().availableProcessors())));
  private static final int SMALL = 7;

  protected int mN = -1;
  {
    Benes.initSmall();
  }

  private int mLatticeIndex = -1;

  protected LattEnum getEnum(final Lattice lattice, final int minSize) {
    return new LattEnum.LattEnumCount(lattice, mN, minSize, new Globals());
  }

  private void setLatticeIndex(final int index) {
    mLatticeIndex = index;
  }

  @Override
  public Z next() {
    if (++mN <= 1) {
      return Z.ONE;
    }

    if (mLatticeIndex >= 0) {
      // This block is used in the special case where only a partial computation is being
      // performed.  In particular, we are going to count the subset of lattices generated
      // from a given lattice index.  This allows for coarse-grained parallelism in
      // computing larger terms.

      // Compute all small lattices (this will include the specified index)
      final LattEnum.LattAccumulate accumulate = new LattEnum.LattAccumulate(Lattice.init2(), SMALL, 3, new Globals());
      accumulate.doEnumeration();
      //System.out.println("Total seed lattices: " + accumulate.mLattices.size());
      final LattEnum et = getEnum(accumulate.getLattices().get(mLatticeIndex), SMALL + 1);
      et.doEnumeration();
      return et.getCount();
    }

    if (mN >= SMALL) {
      // Parallel execution.
      final LattEnum.LattAccumulate accumulate = new LattEnum.LattAccumulate(Lattice.init2(), SMALL, 3, new Globals());
      accumulate.doEnumeration();

      final ExecutorService exec = Executors.newFixedThreadPool(THREADS);
      final ArrayList<Future<Z>> futures = new ArrayList<>();
      try {
        for (final Lattice lattice : accumulate.getLattices()) {
          futures.add(exec.submit(() -> {
            final LattEnum et = getEnum(lattice, SMALL + 1);
            et.doEnumeration();
            return et.getCount();
          }));
        }
      } finally {
        exec.shutdown();
      }
      try {
        exec.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);
        Z sum = Z.ZERO;
        for (final Future<Z> f : futures) {
          sum = sum.add(f.get());
        }
        return sum;
      } catch (final InterruptedException | ExecutionException e) {
        throw new UnsupportedOperationException(e);
      }
    }

    // Single threaded for small sizes
    final LattEnum e = getEnum(Lattice.init2(), 3);
    e.doEnumeration();
    return e.getCount();
  }

  /**
   * Run this sequence for the specified value of <code>n</code>.
   * @param args value to run
   */
  public static void main(final String[] args) {
    final CliFlags flags = new CliFlags("A006966");
    flags.setDescription("Counting labelled and unlabelled lattices");
    flags.registerRequired(Integer.class, "n", "number of points in the lattice");
    flags.registerOptional('l', "labelled", "count labelled lattices");
    flags.registerOptional('i', "index", Integer.class, "l", "lattice index number to generate from [0, 76]");
    flags.setFlags(args);
    final int n = (Integer) flags.getAnonymousValue(0);
    final A006966 seq = flags.isSet("labelled") ? new A055512() : new A006966();
    if (flags.isSet("index")) {
      seq.setLatticeIndex((Integer) flags.getValue("index"));
    }
    seq.mN = n - 1;
    System.out.println(seq.next());
  }
}
#!queue	A006977	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006977 Cellular automaton with Rule 230: 000, 001, 010, 011, ..., 111 -&gt; 0,1,1,0,0,1,1,1.
 * @author Sean A. Irvine
 */
public class A006977 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006977() {
    super(0);
  }

  private static final boolean[] AUTOMATA = {false, true, true, false, false, true, true, true};
  private Z mA = null;

  protected boolean isSet(final int v) {
    return AUTOMATA[v];
  }

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
    } else {
      Z t = mA.shiftLeft(2);
      Z bit = Z.ONE;
      mA = Z.ZERO;
      while (!t.isZero()) {
        if (isSet(Z.SEVEN.and(t).intValueExact())) {
          mA = mA.or(bit);
        }
        bit = bit.shiftLeft(1);
        t = t.shiftRight(1);
      }
    }
    mA = mA.makeOdd();
    return mA;
  }
}
#!queue	A006987	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a006;

import java.util.TreeSet;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A006987 Binomial coefficients: C(n,k), 2 &lt;= k &lt;= n-2, sorted, duplicates removed.
 * @author Sean A. Irvine
 */
public class A006987 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A006987() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();
  private long mN = 2 * start();

  protected long start() {
    return 2;
  }

  @Override
  public Z next() {
    while (mPriority.isEmpty() || Binomial.binomial(mN, start()).compareTo(mPriority.first()) <= 0) {
      for (long k = start(); k <= mN / 2; ++k) {
        mPriority.add(Binomial.binomial(mN, k));
      }
      ++mN;
    }
    return mPriority.pollFirst();
  }
}
#!queue	A007046	3	->	3	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A007046 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007046 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007046() {
    super(3);
  }

  private long mN = 2;

  @Override
  protected Z compute(final Long n, final Long k) {
    final long kh = k * (k + 1) / 2;
    if (n == kh) {
      return Z.ONE;
    } else if (n < kh) {
      return Z.ZERO;
    }
    Z sum = get(n, k + 1);
    for (long r = 1; r <= k; ++r) {
      sum = sum.add(get(n - kh + r * (r - 1) / 2, r).multiply(Binomial.binomial(k + 1, r)));
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, 2L);
  }
}
#!queue	A007048	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A007048 Number of irreducible positions of size n in Montreal solitaire.
 * @author Sean A. Irvine
 */
public class A007048 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007048() {
    super(1);
  }

  private long mN = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    final long kh = k * (k + 1) / 2;
    if (n == kh) {
      return Z.ONE;
    } else if (n < kh) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (long r = k - 1; r * (r + 1) <= 2 * n; ++r) {
      if (r > 0) {
        sum = sum.add(get(n - k, r).multiply(Binomial.binomial(r + 1, k)));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, 1L);
  }
}
#!queue	A007088	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007088 The binary numbers (or binary words, or binary vectors, or binary expansion of n): numbers written in base 2.
 * @author Sean A. Irvine
 */
public class A007088 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007088() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return new Z(Long.toBinaryString(++mN));
  }
}
#!queue	A007165	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007165 Number of P-graphs with 2n edges.
 * @author Sean A. Irvine
 */
public class A007165 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007165() {
    super(1);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final Polynomial<Z> TWO = Polynomial.create(2);
  private static final Polynomial<Z> THREE = Polynomial.create(3);
  private Polynomial<Z> mA = Polynomial.create(1, 1);
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN > 1) {
      mA = RING.add(RING.add(RING.one(),
        RING.multiply(mA, RING.subtract(THREE, RING.multiply(mA, Z.TWO)), mN).shift(1)),
        RING.multiply(RING.pow(mA, 2, mN - 2), RING.add(mA, TWO), mN - 2).shift(2));
    }
    return mA.coeff(mN);
  }
}
#!queue	A007166	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import java.util.Arrays;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007166 Number of blobs with 2n+1 edges.
 * @author Sean A. Irvine
 */
public class A007166 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007166() {
    super(0);
  }

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private Polynomial<Z> mS = RING.zero();
  private int mN = 0;

  protected Z select(final Polynomial<Z> s, final Polynomial<Z> b, final int n) {
    return b.coeff(2 * n - 1);
  }

  @Override
  public Z next() {
    ++mN;
    final int n = 2 * mN;
    Polynomial<Z> p = RING.one();
    for (int i = 1; i < n; i += 2) {
      p = RING.multiply(p, RING.pow(RING.oneMinusXToTheN(i), mS.coeff(i), n));
    }
    p = RING.series(RING.one(), p, n);
    final Z[] coeff = new Z[n];
    Arrays.fill(coeff, Z.ZERO);
    coeff[0] = Z.ZERO;
    coeff[1] = Z.ONE;
    for (int k = 0; k < n; ++k) {
      coeff[k] = coeff[k].subtract(mS.coeff(k));
      if ((k & 1) == 1) {
        coeff[k] = coeff[k].add(p.coeff(k));
      }
    }
    final Polynomial<Z> b = RING.create(Arrays.asList(coeff));
    mS = RING.add(RING.x(), RING.series(RING.pow(b, 3, n), RING.subtract(RING.one(), RING.pow(b, 2, n)), n));
    return select(mS, b, mN);
  }
}
#!queue	A007180	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007180 Expansion of critical exponent for walks on tetrahedral lattice.
 * @author Sean A. Irvine
 */
public class A007180 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007180() {
    super(1);
  }

  // Diamond or tetrahedral lattice
  // Using a four-dimensional coordinate system.
  // See http://en.wikipedia.org/wiki/Diamond_cubic

  // Coordinate of a point is (x,y,z,t) such that x+y+z+t = 0 or 1.
  // The neighbours of each point are found by changing any one coordinate by
  // +/- 1.  Hence there are eight neighbours for each point.
  // Pack (x,y,z,t) into a single long with 16-bits per entry.  To avoid
  // having to worry about propagation of negatives, bias each coordinate by
  // 0x8000.  Hence we can deal with lattice extent of roughly 2^15 in any
  // direction (an amount that will not be exhausted in a brute force
  // counting of paths, etc.)
  protected static final int BITS_PER_COORDINATE = 16;
  private static final int Y_SHIFT = 2 * BITS_PER_COORDINATE;
  private static final int X_SHIFT = 3 * BITS_PER_COORDINATE;
  protected static final long MASK = (1L << BITS_PER_COORDINATE) - 1;
  private static final long BIAS = 1L << (BITS_PER_COORDINATE - 1);
  protected static final long ORIGIN = (BIAS << (3 * BITS_PER_COORDINATE))
    | (BIAS << (2 * BITS_PER_COORDINATE))
    | (BIAS << BITS_PER_COORDINATE)
    | BIAS;

  protected static long t(final long point) {
    return point & MASK;
  }

  protected static long z(final long point) {
    return (point >> BITS_PER_COORDINATE) & MASK;
  }

  protected static long y(final long point) {
    return (point >> Y_SHIFT) & MASK;
  }

  protected static long x(final long point) {
    return (point >> X_SHIFT) & MASK;
  }

  protected int mN = 0;
  private long[] mPath = null;

  protected void setPathLength(final int n) {
    mPath = new long[n];
  }

  protected void setPathElement(final int pos, final long value) {
    mPath[pos] = value;
  }

  protected boolean contains(final long point, final int n) {
    for (int k = 0; k <= n; ++k) {
      if (mPath[k] == point) {
        return true;
      }
    }
    return false;
  }

  protected boolean check(final long point, final int n) {
    return t(point) <= z(point) && !contains(point, n);
  }

  protected long count(final long point) {
    return 1;
  }

  // sgn alternates between 1 and -1 in accordance to whether the sum of the point is 0 or 1
  protected long count(final long point, final long sgn, final int n) {
    if (n == mN) {
      return count(point);
    }
    mPath[n] = point;
    long count = 0;
    for (long delta = 1; delta != 0; delta <<= BITS_PER_COORDINATE) {
      final long newPoint = point + sgn * delta;
      if (check(newPoint, n)) {
        count += count(newPoint, -sgn, n + 1);
      }
    }
    return count;
  }

  @Override
  public Z next() {
    setPathLength(++mN);
    return Z.valueOf(count(ORIGIN, 1, 0));
  }
}
#!queue	A007188	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.prime.Fast;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007188 Multiplicative encoding of Pascal triangle: Product p(i+1)^C(n,i).
 * @author Sean A. Irvine
 */
public class A007188 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007188() {
    super(0);
  }

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z prod = Z.ONE;
    Z p = Z.ONE;
    for (long k = 0; k <= mN; ++k) {
      p = mPrime.nextPrime(p);
      prod = prod.multiply(p.pow(Binomial.binomial(mN, k)));
    }
    return prod;
  }
}
#!queue	A007200	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.lattice.Accumulator;
import irvine.math.lattice.Lattices;
import irvine.math.lattice.SelfAvoidingWalker;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007200 Number of self-avoiding walks on hexagonal lattice, with additional constraints.
 * @author Sean A. Irvine
 */
public class A007200 extends AbstractSequence {

  private int mN;
  private final int mM;
  private final long mC = Lattices.HEXAGONAL.neighbour(Lattices.HEXAGONAL.origin(), 0);
  private final SelfAvoidingWalker mWalker = new SelfAvoidingWalker(Lattices.HEXAGONAL) {
    {
      setAccumulator(new Accumulator() {
        @Override
        public void accumulate(final long[] walk, final int weight, final int axesMask) {
          if (mN < mM) {
            return;
          }
          final long hi = walk[(mN - mM) / 2];
          final long lo = walk[(mN + mM) >>> 1];
          if (Lattices.HEXAGONAL.isAdjacent(lo, hi)) {
            increment(weight);
          }
          if (((mN ^ mM) & 1) == 1) {
            if (Lattices.HEXAGONAL.isAdjacent(lo, walk[(mN + mM - 1) / 2])) {
              increment(weight);
            }
          }
        }
      });
    }
  };

  protected A007200(final int m) {
    super(2);
    mM = m;
    mN = mM - 1;
  }

  /** Construct the sequence. */
  public A007200() {
    this(2);
  }

  @Override
  public Z next() {
    return Z.valueOf(mWalker.count(++mN, 6, 1, Lattices.HEXAGONAL.origin(), mC));
  }
}
#!queue	A007223	2	->	2	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A007223 Number of distinct perforation patterns for deriving (v,b) = (n+2,n) punctured convolutional codes from (2,1).
 * @author Sean A. Irvine
 */
public class A007223 extends MemoryFunction2Sequence<Integer, Polynomial<Z>> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007223() {
    super(2);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = 1;

  @Override
  protected Polynomial<Z> compute(final Integer b, final Integer v) {
    Polynomial<Z> p = RING.zero();
    for (final Z dd : Jaguar.factor(b).divisors()) {
      final int d = dd.intValue();
      p = RING.add(p, RING.multiply(RING.pow(RING.onePlusXToTheN(d), v * b / d), Euler.phi(dd)));
    }
    return RING.divide(p, Z.valueOf(b));
  }

  @Override
  public Z next() {
    return get(++mN, 2).coeff(mN + 2);
  }
}
#!queue	A007226	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007226 a(n) = 2*det(M(n; -1))/det(M(n; 0)), where M(n; m) is the n X n matrix with (i,j)-th element equal to 1/binomial(n + i + j + m, n).
 * @author Sean A. Irvine
 */
public class A007226 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007226() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    return Binomial.binomial(3 * mN, mN).multiply2().subtract(Binomial.binomial(3 * mN, mN + 1));
  }
}
#!queue	A007253	-1	->	-1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007253 McKay-Thompson series of class 5a for Monster.
 * @author Sean A. Irvine
 */
public class A007253 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007253() {
    super(-1);
  }

  protected static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final Polynomial<Z> X5 = RING.monomial(Z.ONE, 5);
  private static final Polynomial<Z> X25 = RING.monomial(Z.ONE, 25);
  protected int mN = -2;

  @Override
  public Z next() {
    if (++mN == -1) {
      return Z.ONE;
    }
    final int deg = mN + 1; // One higher so we can shift up by 1 to hand q^-1
    final Polynomial<Z> eta = RING.eta(RING.x(), deg);
    final Polynomial<Z> eta5 = RING.eta(X5, deg);
    final Polynomial<Z> eta25 = RING.eta(X25, deg);
    final Polynomial<Z> a = RING.add(RING.one(), RING.series(RING.multiply(eta25.shift(1), Z.FIVE), eta, deg));
    final Polynomial<Z> b = RING.add(RING.x(), RING.pow(RING.series(eta, eta5, deg), 6, deg));
    final Polynomial<Z> ab = RING.multiply(a, b, deg).shift(-1);

    final Polynomial<Z> c = RING.series(eta.shift(1), eta25.shift(1), deg);
    final Polynomial<Z> d = RING.series(RING.multiply(eta25.shift(1), Z.FIVE), eta, deg).shift(1);
    final Polynomial<Z> cd5 = RING.multiply(RING.subtract(c, d), Z.FIVE); // is shifted up by 1
    final Polynomial<Z> e = RING.series(RING.multiply(RING.pow(eta25, 3, deg).shift(2), RING.pow(eta, 3, deg), deg), RING.pow(eta5, 6, deg), deg);
    final Polynomial<Z> cd5e = RING.multiply(cd5, e, deg).shift(-1);

    final Polynomial<Z> f = RING.add(ab, cd5e);
    return f.coeff(mN);
  }
}
#!queue	A007318	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007318 Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0 &lt;= k &lt;= n. Studied by scholars in many countries long before Pascal (see Comments).
 * @author Sean A. Irvine
 */
public class A007318 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007318() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return Binomial.binomial(mN, mM);
  }
}
#!queue	A007331	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007331 Fourier coefficients of E_{infinity,4}.
 * @author Sean A. Irvine
 */
public class A007331 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007331() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN <= 1) {
      return Z.valueOf(mN);
    }
    Z s = Z.ZERO;
    for (final Z d : Jaguar.factor(mN).divisors()) {
      if (((mN / d.longValueExact()) & 1) == 1) {
        s = s.add(d.pow(3));
      }
    }
    return s;
  }
}
#!queue	A007343	3	->	3	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.util.Pair;

/**
 * A007343 Number of homogeneous primitive partition identities with largest part n.
 * @author Sean A. Irvine
 */
public class A007343 extends MemoryFunction2Sequence<Integer, Integer> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007343() {
    super(3);
  }

  private int mN = 2;
  private Z mA = Z.ZERO;

  private void getPartitions(final List<int[]> result, final int[] current, final int maxPart, final int remaining) {
    if (remaining == 0) {
      result.add(current);
    } else {
      for (int k = maxPart; k > 0; --k) {
        final int[] next = Arrays.copyOf(current, current.length + 1);
        next[current.length] = k;
        getPartitions(result, next, k, remaining - 1);
      }
    }
  }

  private void subsums(final Set<Pair<Integer, Integer>> sums, final int[] a) {
    for (long syndrome = 1; syndrome < (1L << a.length) - 1; ++syndrome) {
      long t = syndrome;
      int sum = 0;
      int cnt = 0;
      int k = 0;
      while (t != 0) {
        if ((t & 1) == 1) {
          sum += a[k];
          ++cnt;
        }
        ++k;
        t >>= 1;
      }
      sums.add(new Pair<>(sum, cnt));
    }
  }

  private boolean isPrimitive(final int[] a, final int[] b) {
    // a.length == b.length is always true by our construction
//    if (a.length != b.length) {
//      return false;
//    }
    // This quick test gets a lot of bad cases
    for (final int u : a) {
      for (final int v : b) {
        if (u == v) {
          return false;
        }
      }
    }

    final HashSet<Pair<Integer, Integer>> sumsA = new HashSet<>();
    final HashSet<Pair<Integer, Integer>> sumsB = new HashSet<>();
    subsums(sumsA, a);
    subsums(sumsB, b);
    for (final Pair<Integer, Integer> as : sumsA) {
      if (sumsB.contains(as)) {
        return false;
      }
    }
    return true;
  }

  @Override
  protected Integer compute(final Integer maxPart, final Integer degree) {
    final ArrayList<int[]> parts = new ArrayList<>();
    getPartitions(parts, new int[0], maxPart, degree);
    final long[] sums = new long[parts.size()];
    for (int k = 0; k < sums.length; ++k) {
      sums[k] = IntegerUtils.sum(parts.get(k));
    }
    int count = 0;
    for (int k = 0; k < sums.length; ++k) {
      final int[] a = parts.get(k);
      final long as = sums[k];
      if (a[0] == maxPart) {
        for (int j = k + 1; j < sums.length; ++j) {
          if (sums[j] == as && isPrimitive(a, parts.get(j))) {
            ++count;
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    ++mN;
    for (int d = 1; d < mN; ++d) {
      mA = mA.add(get(mN, d));
    }
    return mA;
  }
}
#!queue	A007346	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007346 Order of group generated by perfect shuffles of 2n cards.
 * @author Sean A. Irvine
 */
public class A007346 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007346() {
    super(1);
  }

  private int mN = 0;
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  @Override
  public Z next() {
    switch (++mN) {
      case 1:
        return Z.TWO;
      case 2:
        return Z.EIGHT;
      case 6:
        return Z.valueOf(7680);
      case 12:
        return Z.valueOf(194641920);
      default:
        break;
    }
    if ((mN & 1) == 1) {
      return mF.factorial(mN).shiftLeft(mN - 1);
    } else if ((mN & 3) == 2) {
      return mF.factorial(mN).shiftLeft(mN);
    } else {
      int np = mN;
      int k = 1;
      while ((np & 1) == 0) {
        np >>>= 1;
        ++k;
      }
      if (mN == 1 << (k - 1)) {
        return Z.valueOf(k).shiftLeft(k);
      } else {
        return mF.factorial(mN).shiftLeft(mN - 2);
      }
    }
  }
}
#!queue	A007376	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;
// Generated by gen_seq4.pl juxn 10 at 2019-07-05 09:34

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007376 The almost-natural numbers: write n in base 10 and juxtapose digits.
 * @author Georg Fischer
 */
public class A007376 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007376() {
    super(0);
  }

  private String mS = "";
  private int mPos = 0;
  private Z mN = null;

  @Override
  public Z next() {
    if (mN == null) {
      mN = Z.ZERO;
      return Z.ZERO;
    }
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = mN.toString(10);
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A007434	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007434 Jordan function J_2(n) (a generalization of phi(n)).
 * @author Sean A. Irvine
 */
public class A007434 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007434() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    Z sum = Z.ZERO;
    for (final Z d : Jaguar.factor(++mN).divisors()) {
      sum = sum.add(d.square().multiply(Mobius.mobius(mN / d.longValue())));
    }
    return sum;
  }
}
#!queue	A007474	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Euler;
import irvine.math.z.Z;

/**
 * A007474 Number of circular chord diagrams with n chords, up to rotational symmetry.
 * @author Sean A. Irvine
 */
public class A007474 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After Gheorghe Coserea

  protected long mN = -1;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n < 0) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    if (n == 1) {
      return Z.valueOf(1 - (k & 1));
    }
    if (n == 2) {
      return Z.valueOf(k - (k & 1));
    }
    if ((k & 1) == 1) {
      return get(n - 2, k).multiply(k).multiply(n - 1).add(get(n - 4, k));
    } else {
      return get(n - 1, k).add(get(n - 2, k).multiply(k).multiply(n - 1)).subtract(get(n - 3, k)).add(get(n - 4, k));
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(2 * mN).divisors()) {
      final long d = dd.longValue();
      sum = sum.add(get(2 * mN / d, d).subtract(get(2 * mN / d  - 2, d)).multiply(Euler.phiAsLong(d)));
    }
    return sum.divide(2 * mN);
  }
}

#!queue	A007538	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicByteArray;

/**
 * A007538 A self-generating sequence: there are a(n) 3's between successive 2's.
 * @author Sean A. Irvine
 */
public class A007538 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007538() {
    super(1);
  }

  private LongDynamicByteArray mSeq = new LongDynamicByteArray();
  private int mN = -1;

  {
    mSeq.set(0, (byte) 2);
  }

  @Override
  public Z next() {
    final int res = mSeq.get(++mN);
    for (int k = 0; k < res; ++k) {
      mSeq.set(mSeq.length(), (byte) 3);
    }
    mSeq.set(mSeq.length(), (byte) 2);
    return Z.valueOf(res);
  }
}
#!queue	A007559	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007559 Triple factorial numbers (3*n-2)!!! with leading 1 added.
 * @author Sean A. Irvine
 */
public class A007559 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007559() {
    super(0);
  }

  private long mN = -2;
  private Z mProd = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 0) {
      mProd = mProd.multiply(3 * mN + 1);
    }
    return mProd;
  }
}
#!queue	A007570	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Fibonacci;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007570 a(n) = F(F(n)), where F is a Fibonacci number.
 * @author Sean A. Irvine
 */
public class A007570 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007570() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    return Fibonacci.fibonacci(Fibonacci.fibonacci(++mN).intValueExact());
  }
}
#!queue	A007645	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007645 Generalized cuban primes: primes of the form x^2 + xy + y^2; or primes of the form x^2 + 3*y^2; or primes == 0 or 1 (mod 3).
 * @author Sean A. Irvine
 */
public class A007645 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007645() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  private Z mP = Z.TWO;

  @Override
  public Z next() {
    while (true) {
      mP = mPrime.nextPrime(mP);
      if (mP.mod(3) < 2) {
        return mP;
      }
    }
  }
}

#!queue	A007661	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007661 Triple factorial numbers a(n) = n!!!, defined by a(n) = n*a(n-3), a(0) = a(1) = 1, a(2) = 2. Sometimes written n!3.
 * @author Sean A. Irvine
 */
public class A007661 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007661() {
    super(0);
  }

  private Z mA = Z.ONE;
  private Z mB = Z.ONE;
  private Z mC = Z.TWO;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN < 2) {
      return Z.ONE;
    } else if (mN > 2) {
      final Z t = mA.multiply(mN);
      mA = mB;
      mB = mC;
      mC = t;
    }
    return mC;
  }
}
#!queue	A007662	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007662 Quadruple factorial numbers n!!!!: a(n) = n*a(n-4).
 * @author Sean A. Irvine
 */
public class A007662 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007662() {
    super(0);
  }

  private Z mA = Z.ONE;
  private Z mB = Z.ONE;
  private Z mC = Z.TWO;
  private Z mD = Z.THREE;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN <= 2) {
      return mN < 2 ? Z.ONE : Z.TWO;
    } else if (mN > 3) {
      final Z t = mA.multiply(mN);
      mA = mB;
      mB = mC;
      mC = mD;
      mD = t;
    }
    return mD;
  }
}
#!queue	A007678	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007678 Number of regions in regular n-gon with all diagonals drawn.
 * @author Sean A. Irvine
 */
public class A007678 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007678() {
    super(1);
  }

  // After T. D. Noe

  protected long mN = 0;

  private boolean del(final long m, final long n) {
    return n % m == 0;
  }

  @Override
  public Z next() {
    if (++mN < 3) {
      return Z.ZERO;
    }
    Z a = Z.valueOf(mN).subtract(6).multiply(mN).add(23).multiply(mN).subtract(42).multiply(mN).add(24).divide(24);
    if (del(2, mN)) {
      a = a.add(Z.FIVE.negate().multiply(mN).add(42).multiply(mN).subtract(40).multiply(mN).subtract(48).divide(48));
    }
    if (del(4, mN)) {
      a = a.subtract(3 * mN / 4);
    }
    if (del(6, mN)) {
      a = a.add(Z.valueOf(-53).multiply(mN).add(310).multiply(mN).divide(12));
    }
    if (del(12, mN)) {
      a = a.add(49 * (mN / 2));
    }
    if (del(18, mN)) {
      a = a.add(32 * mN);
    }
    if (del(24, mN)) {
      a = a.add(19 * mN);
    }
    if (del(30, mN)) {
      a = a.subtract(36 * mN);
    }
    if (del(42, mN)) {
      a = a.subtract(50 * mN);
    }
    if (del(60, mN)) {
      a = a.subtract(190 * mN);
    }
    if (del(84, mN)) {
      a = a.subtract(78 * mN);
    }
    if (del(90, mN)) {
      a = a.subtract(48 * mN);
    }
    if (del(120, mN)) {
      a = a.subtract(78 * mN);
    }
    if (del(210, mN)) {
      a = a.subtract(48 * mN);
    }
    return a;
  }
}
#!queue	A007705	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007705 Number of ways of arranging 2n+1 nonattacking queens on a 2n+1 X 2n+1 toroidal board.
 * @author Sean A. Irvine
 */
public class A007705 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007705() {
    super(0);
  }

  // This code uses a fairly simple backtracking approach to search
  // all possible placements forming a dominating set, up to the minimum
  // number of queens so far needed.

  protected int mBoardSize = -1;
  protected int mSquares;
  private long mCount = 0;
  private Z mFilled;
  protected Z[] mCovers;

  protected void initConstants() {
    mSquares = mBoardSize * mBoardSize;
    mCovers = new Z[mSquares];
    // The low mSquares bits of a long are used to indicate which squares
    // are dominated by the current state.  Once this becomes all one we
    // have reached a domination of the board.
    mFilled = Z.ONE.shiftLeft(mSquares).subtract(1);

    // We precompute the set of positions dominated by each square on the
    // board.  Empirically it is better to consider the cells in a random
    // order during the search, thus the final result is shuffled.  But,
    // for A002563 we need to know the actual assignment of queens so we
    // can test for isomorphisms.  This means we need to also keep track
    // of the actual positions where queens are placed.
    // Note this initialization only happens once for each new board size
    // so it does not need to be efficient.
    int j = 0;
    for (int y = 0, ypos = 0; y < mBoardSize; ++y, ypos += mBoardSize) {
      for (int x = 0; x < mBoardSize; ++x) {
        Z c = Z.ZERO;
        // Fill in the row
        for (int k = 0; k < mBoardSize; ++k) {
          c = c.or(Z.ONE.shiftLeft(ypos + k)); // row
          c = c.or(Z.ONE.shiftLeft(k * mBoardSize + x)); // column
        }
        // Fill in the diagonals (with wrap)
        if (mBoardSize > 1) {
          c = fillDiagonal(y, x, c, 1, 1);
          c = fillDiagonal(y, x, c, -1, 1);
          c = fillDiagonal(y, x, c, 1, -1);
          c = fillDiagonal(y, x, c, -1, -1);
        }
        mCovers[j++] = c;
      }
    }
  }

  private int step(final int z, final int dz, final int mod) {
    final int u = z + dz;
    if (u >= mod) {
      return u - mod;
    } else if (u < 0) {
      return u + mod;
    } else {
      return u;
    }
  }

  private Z fillDiagonal(final int y, final int x, Z c, final int dx, final int dy) {
    int xp = x;
    int yp = y;
    do {
      c = c.or(Z.ONE.shiftLeft(yp * mBoardSize + xp));
      xp = step(xp, dx, mBoardSize);
      yp = step(yp, dy, mBoardSize);
    } while (xp != x || yp != y);
    return c;
  }

  private void search(final Z state, final int queens, final int nextFreePosition) {
    if (queens == mBoardSize) {
      ++mCount;
    } else if (!state.equals(mFilled)) {
      for (int p = nextFreePosition; p < mSquares; ++p) {
        if (!state.testBit(p)) {
          search(state.or(mCovers[p]), queens + 1, p + 1);
        }
      }
    }
  }

  @Override
  public Z next() {
    mBoardSize += 2;
    if (IntegerUtils.gcd(mBoardSize, 6) != 1) {
      return Z.ZERO; // Ahrens theorem
    }
    mCount = 0;
    initConstants();
    search(Z.ZERO, 0, 0);
    return Z.valueOf(mCount);
  }
}
#!queue	A007710	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Permutation;

/**
 * A007710 From the game of Mousetrap.
 * @author Sean A. Irvine
 */
public class A007710 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007710() {
    super(1);
  }

  // Brute force Mousetrap

  private int mN = 0;

  protected boolean isDiscardCount(final int[] p, final int dc) {
    // 0-based rather than 1-based used in papers
    int nextFree = 0;
    int pos = 0;
    int count = -1;
    int discarded = 0;
    while (true) {
      if (++count >= p.length) {
        return discarded == dc; // loss
      }
      if (p[pos] == count) {
        count = -1; // Restart the count
        if (++discarded > dc) {
          return false;
        }
        if (discarded == p.length) {
          return discarded == dc;
        }
      } else {
        // Mismatch
        p[nextFree++] = p[pos];
        if (nextFree == p.length) {
          nextFree = 0;
        }
      }
      if (++pos == p.length) {
        pos = 0;
      }
    }
  }

  @Override
  public Z next() {
    long count = 0;
    final Permutation perm = new Permutation(++mN);
    int[] p;
    while ((p = perm.next()) != null) {
      if (isDiscardCount(Arrays.copyOf(p, p.length), 1)) {
        ++count;
      }
    }
    return Z.valueOf(count);
  }

}
#!queue	A007712	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Permutation;

/**
 * A007712 Number of once reformable permutations of {1,2,...,n}.
 * @author Sean A. Irvine
 */
public class A007712 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007712() {
    super(2);
  }

  private int mN = 1;
  private Z mF = Z.ONE;

  // This is like A007709, but we return the reformed permutation
  protected int[] reform(final int[] p) {
    // 0-based rather than 1-based used in papers
    final int[] reform = new int[p.length];
    int nextFree = 0;
    int pos = 0;
    int count = -1;
    int discarded = 0;
    while (true) {
      if (++count >= p.length) {
        return null; // loss
      }
      if (p[pos] == count) {
        reform[discarded] = count;
        count = -1; // Restart the count
        if (++discarded == p.length) {
          return reform; // win
        }
      } else {
        // Mismatch
        p[nextFree++] = p[pos];
        if (nextFree == p.length) {
          nextFree = 0;
        }
      }
      if (++pos == p.length) {
        pos = 0;
      }
    }
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    Z count = mF;
    final Permutation perm = new Permutation(mN);
    int[] p;
    while ((p = perm.next()) != null) {
      final int[] reform = reform(Arrays.copyOf(p, p.length));
      if (reform == null || reform(reform) != null) {
        count = count.subtract(1);
      }
    }
    return Z.ONE.max(count); // I don't know why a(2) != 0
  }

}
#!queue	A007750	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007750 Nonnegative integers n such that n^2*(n+1)*(2*n+1)^2*(7*n+1)/36 is a square.
 * @author Sean A. Irvine
 */
public class A007750 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007750() {
    super(0);
  }

  private Z mA = Z.ZERO;
  private Z mB = null;
  private Z mC = null;
  private Z mD = null;

  @Override
  public Z next() {
    if (mD == null) {
      if (mB == null) {
        mB = Z.ZERO;
        return Z.ZERO;
      }
      if (mC == null) {
        mC = Z.ONE;
        return Z.ONE;
      }
      mD = Z.SEVEN;
    } else {
      final Z t = mC.multiply(16).subtract(mA).add(8);
      mA = mB;
      mB = mC;
      mC = mD;
      mD = t;
    }
    return mD;
  }
}

#!queue	A007764	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicArray;

/**
 * A007764 Number of nonintersecting (or self-avoiding) rook paths joining opposite corners of an n X n grid.
 * @author Ruben Spaans (C)
 * @author Sean A. Irvine (Java port)
 */
public class A007764 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007764() {
    super(1);
  }

  /*
   * The algorithm here is essentially the same as the C version, but
   * with a few notable differences.  The original does computations
   * modulo a prime, and the results from multiple runs can then later
   * be combined with the CRT to get the final here.  Here instead we
   * simply use Z arithmetic.  This might be somewhat slower, but avoids
   * the CRT complication.
   *
   * A Java threading mechanism is used in place of pthread.
   *
   * Some of the diagnostics of the original have been disabled to give
   * clean output.  Variables and methods have been renamed to match the
   * conventions of this project.
   *
   * The original C algorithm description follows.
   */

  /* Efficient and parallel version of a program that calculates
   * terms of the sequence A007764 (and related sequences such as
   * A064297). This program is stand-alone. Warning, the code is written entirely
   * with optimization in mind, don't expect it to be easy to read and
   * understand. Programmed by Ruben Spaans in september-october 2012.
   *
   * This program was used to calculate n=22, 23, 24 (as well as verifying
   * all lower n correctly), it took around a CPU-month on a machine with
   * 4 eight-core CPUs and 1 TB RAM (huge thanks to Rune Jensen and Q2S at
   * the Norwegian University of Science and Technology for letting me run
   * the program on their computer) (n=24 required around 700 GB).
   * this program only calculates the answer modulo a large prime (just
   * below 2^63). Enough runs were done so that the product of all
   * primes used exceeded a guaranteed upper bound for the answer, then
   * CRT was used to obtain the final answer. (The CRT bit was done with
   * an external program). See the bottom of this file to see how to use the
   * program.
   *
   * A paper was under preparation, but has been on hold for several years
   * (as of september 2014). With luck, it might see the face of the earth.
   * don't hold your breath.
   */

  /*
   * Find the number of simple paths along the edges of an n*n grid between the
   * opposite corners.
   * equivalently: find the number of simple paths along the cells of an
   * (n+1)*(n+1) grid, from cell (0, 0) to cell (n,n). cells are 4-connected.
   *
   * Algorithm: dynamic programming. state representation is the same as in
   * M. Bousquet-Melou, A. J. Guttmann and I. Jensen:
   * "Self-avoiding walks crossing a square". when scanning cells row by row
   * from left to right, we have a frontier between processed and unprocessed
   * cells:
   *
   * ******
   * ****** <- * denotes scanned cells
   * **....    . denotes unscanned cells
   * ......
   *
   * Given a grid of n*n internal cells, the frontier consists of (n+1)
   * cell boundaries. each cell boundary can contain a crossing edge or none.
   * The crossing edge can belong to the path from (0, 0), or it can be an
   * "incoming" or "outgoing" edge belonging to a segment having two ends
   * going through the frontier. Assuming we scan the frontier from left to
   * right, the first loose end belonging to a segment with loose ends is
   * the incoming edge, and the second loose end of the same segment is the
   * outgoing edge. Let's use this encoding: 0=no edge, 1=loose end from
   * upper left, 2=incoming edge, 3=outgoing edge. A base-4 number with (n+1)
   * bits can represent all such boundaries. We can then store all partial
   * states in a hashmap with this base-4 number as a key, and the number of
   * ways to reach this partial state as the value. Notice that we don't need to
   * store the current (x,y)-position in the state, as this is implicitly known
   * via the i,j iteration variables. Whenever we process a given cell we only
   * have two hashmaps simultaneously in memory: the one we read from and the one
   * we write new values to (for the next iteration).
   *
   * We can improve the representation by making a mapping from the base-4 number
   * to integers 0..(m-1) where m is the number of base-4 numbers that represent
   * legal states. Then we can store the values in a regular array and ditch the
   * hashmap. This is implemented in the current version.
   *
   * Further speedup: pthreads with 30 threads (running on a machine with 32
   * physical cores), 22x speedup achieved.
   */

  /* parallel variables */
  /* please let MUTEX be a power of two */
  /* please tune this value to the target machine */
  private static final int MUTEX = 1 << 21;

  private static final int THREADS = Integer.parseInt(System.getProperty("oeis.threads",
    String.valueOf(Runtime.getRuntime().availableProcessors())));

  private static final int MAX = 32;

  private final long[][][] mDP = new long[2][MAX][MAX];
  private final Object[] mMutex = new Object[MUTEX];

  {
    // Calculate the number of states (and partial states) for rank/unrank
    // the sequence mDP[1][0][n] is actually A002026
    mDP[0][0][0] = 1;
    for (int i = 0; i < MAX - 1; ++i) {
      for (int k = 0; k < 2; ++k) {
        for (int j = 0; j < MAX - 1; ++j) {
          if (mDP[k][j][i] != 0) {
            mDP[k][j][i + 1] += mDP[k][j][i];
            if (k == 0 && j == 0) {
              mDP[1][j][i + 1] += mDP[k][j][i];
            }
            if (j != 0) {
              mDP[k][j - 1][i + 1] += mDP[k][j][i];
            }
            mDP[k][j + 1][i + 1] += mDP[k][j][i];
          }
        }
      }
    }

    // Initialize locks for synchronizing on
    for (int k = 0; k < mMutex.length; ++k) {
      mMutex[k] = new Object();
    }
  }

  /* convert from integer rank to representation in linear time */
  private long unrank(int i, long r) {
    int j = 0;
    long mask = 0;
    while (i-- != 0) {
      long c0 = mDP[1][j][i];
      if (r < c0) {
        mask <<= 2;
      } else {
        r -= c0;
        c0 = (j == 0) ? mDP[0][0][i] : 0;
        if (r < c0) {
          mask = (mask << 2) + 1;
          while (i-- != 0) {
            c0 = mDP[0][j][i];
            if (r < c0) {
              mask <<= 2;
            } else {
              r -= c0;
              c0 = (j != 0) ? mDP[0][j - 1][i] : 0;
              if (r < c0) {
                mask = (mask << 2) + 2;
                --j;
              } else {
                r -= c0;
                mask = (mask << 2) + 3;
                ++j;
              }
            }
          }
          return mask;
        } else {
          r -= c0;
          c0 = (j != 0) ? mDP[1][j - 1][i] : 0;
          if (r < c0) {
            mask = (mask << 2) + 2;
            --j;
          } else {
            r -= c0;
            mask = (mask << 2) + 3;
            ++j;
          }
        }
      }
    }
    return mask;
  }

  /* convert from representation to integer rank in linear time */
  private long rank(int i, final long mask) {
    int j = 0;
    long r = 0;
    while (i-- != 0) {
      long cur = (mask >>> (i << 1)) & 3;
      if (cur == 2) {
        r += mDP[1][j--][i];
      } else if (cur == 3) {
        r += mDP[1][j][i] + (j != 0 ? mDP[1][j - 1][i] : mDP[0][0][i]);
        ++j;
      } else if (cur != 0) {
        r += mDP[1][j][i];
        while (i-- != 0) {
          cur = (mask >>> (i << 1)) & 3;
          if (cur == 2) {
            r += mDP[0][j--][i];
          } else if (cur == 3) {
            r += mDP[0][j][i];
            if (j != 0) {
              r += mDP[0][j - 1][i];
            }
            ++j;
          }
        }
        return r;
      }
    }
    return r;
  }

  private final Z[] mPartialAnswers = new Z[64];
  private LongDynamicArray<Z> mPrev;
  private LongDynamicArray<Z> mCur;

  private void add(final long ix, final Z c) {
    synchronized (mMutex[(int) (ix & (MUTEX - 1))]) {
      mCur.set(ix, mCur.get(ix).add(c));
    }
  }

  private static final int[] SWAP = {0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15};
  private final long[] mPstart = new long[64];
  private final long[] mPend = new long[64];

  private int mGlobalI;
  private int mGlobalJ;
  private int mGlobalN;
  private int mGlobalM;
  private int mGlobalW;

  private final class CountingThread extends Thread {

    private final int mId;

    private CountingThread(final int id) {
      mId = id;
    }

    @Override
    public void run() {
      final int i = mGlobalI;
      final int j = mGlobalJ;
      final int n = mGlobalN;
      final int m = mGlobalM;
      final int w = mGlobalW;
      if (i < m - 1 && j < n - 1) {
        // regular cell
        regularCell(j, w);
      } else if (i < m - 1 && j == n - 1) {
        // right column: edges cannot go to the right, mask<<2
        rightColumn(j, w);
      } else if (i == m - 1 && j < n - 1) {
        // lower row edges cannot go down
        lowerRow(j, w);
      } else if (i == m - 1 && j == n - 1) {
        // lower right corner, just take the sum
        Z r = Z.ZERO;
        for (long z = mPstart[mId]; z < mPend[mId]; ++z) {
          r = r.add(mPrev.get(z));
        }
        mPartialAnswers[mId] = r;
      }
    }

    private void rightColumn(final int j, final int w) {
      for (long z = mPstart[mId]; z < mPend[mId]; ++z) {
        final Z c;
        if ((c = mPrev.get(z)).signum() != 0) {
          final long mask = unrank(w, z);
          final int left = (int) (mask >>> (j << 1)) & 3;
          final int up = (int) (mask >>> ((j << 1) + 2)) & 3;
          if (left == 3 && up == 3) {
            // join 33: find mate of left 3, change it from 2 to 3
            add(rank(w, (getMask(j, mask) ^ (1L << (getK(j, mask) << 1))) << 2), c);
          } else if (left == 1 && up != 0) {
            // we have 12, find up's mate, change it from 3 to 1
            add(rank(w, (getMask(j, mask) & (~(2L << (getK2(j, mask) << 1)))) << 2), c);
          } else if (left != 0 && up == 1) {
            // we have 31, find left's mate, change it from 2 to 1
            add(rank(w, (getMask(j, mask) ^ (3L << (getK(j, mask) << 1))) << 2), c);
          } else if (left != 0) { // extend single edge, case 1
            // extend down
            add(rank(w, mask << 2), c);
          } else if (up != 0) { // extend single edge, case 2
            // extend down: 0x becomes x0
            add(rank(w, (getMask(j, mask) | ((long) SWAP[up << 2] << (j << 1))) << 2), c);
          } else { // no edge
            // place nothing
            add(rank(w, mask << 2), c);
          }
        }
      }
    }

    private int getK(final int j, final long mask) {
      int k;
      int l;
      for (k = j - 1, l = 1; ; --k) {
        final long o = (mask >>> (k << 1)) & 3;
        if (o == 3) {
          ++l;
        } else if (o == 2 && --l == 0) {
          return k;
        }
      }
    }

    private int getK2(final int j, final long mask) {
      int k;
      int l;
      for (k = j + 2, l = 1; ; ++k) {
        final long o = (mask >>> (k << 1)) & 3;
        if (o == 2) {
          ++l;
        } else if (o == 3 && --l == 0) {
          break;
        }
      }
      return k;
    }

    private void case22(final int j, final int w, final Z c, final long mask) {
      // join 22: find mate of right 2, change it from 3 to 2
      add(rank(w, getMask(j, mask) ^ (1L << (getK2(j, mask) << 1))), c);
    }

    private void case12(final int j, final int w, final Z c, final long mask) {
      // we have 12, find up's mate, change it from 3 to 1
      add(rank(w, getMask(j, mask) & (~(2L << (getK2(j, mask) << 1)))), c);
    }

    private void case31(final int j, final int w, final Z c, final long mask) {
      // we have 31, find left's mate, change it from 2 to 1
      add(rank(w, getMask(j, mask) ^ (3L << (getK(j, mask) << 1))), c);
    }

    private void case33(final int j, final int w, final Z c, final long mask) {
      // join 33: find mate of left 3, change it from 2 to 3
      add(rank(w, getMask(j, mask) ^ (1L << (getK(j, mask) << 1))), c);
    }

    private void lowerRow(final int j, final int w) {
      for (long z = mPstart[mId]; z < mPend[mId]; ++z) {
        final Z c;
        if ((c = mPrev.get(z)).signum() != 0) {
          final long mask = unrank(w, z);
          final int left = (int) (mask >>> (j << 1)) & 3;
          final int up = (int) (mask >>> ((j << 1) + 2)) & 3;
          if (left == 3 && up == 2) {
            // join, easy case: 32 => 00
            add(rank(w, getMask(j, mask)), c);
          } else if (left == 2 && up == 2) {
            case22(j, w, c, mask);
          } else if (left == 3 && up == 3) {
            case33(j, w, c, mask);
          } else if (left == 1 && up != 0) {
            case12(j, w, c, mask);
          } else if (left != 0 && up == 1) {
            case31(j, w, c, mask);
          } else if (left != 0) { // extend single edge, case 1
            // extend to the right: x0 becomes 0x, but only if next cell isn't 2
            final int look = (int) (mask >>> ((j << 1) + 4)) & 3;
            if (left != 2 || look != 3) {
              add(rank(w, getMask(j, mask) | ((long) SWAP[left] << (j << 1))), c);
            }
          } else if (up != 0) { // extend single edge, case 2
            // extend to the right: no change in mask
            final int look = (int) (mask >>> ((j << 1) + 4)) & 3;
            if (up != 2 || look != 3) {
              add(z, c);
            }
          } else { // no edge
            // place nothing
            add(z, c);
          }
        }
      }
    }

    private void regularCell(final int j, final int w) {
      for (long z = mPstart[mId]; z < mPend[mId]; ++z) {
        final Z c;
        if ((c = mPrev.get(z)).signum() != 0) {
          final long mask = unrank(w, z);
          final int left = (int) (mask >>> (j << 1)) & 3;
          final int up = (int) (mask >>> ((j << 1) + 2)) & 3;
          if (left == 3 && up == 2) {
            // join, easy case: 32 => 00
            add(rank(w, getMask(j, mask)), c);
          } else if (left == 2 && up == 2) {
            case22(j, w, c, mask);
          } else if (left == 3 && up == 3) {
            case33(j, w, c, mask);
          } else if (left == 1 && up != 0) {
            case12(j, w, c, mask);
          } else if (left != 0 && up == 1) {
            // we have 31, find left's mate, change it from 2 to 1
            add(rank(w, getMask(j, mask) ^ (3L << (getK(j, mask) << 1))), c);
          } else if (left != 0) { // extend single edge, case 1
            // extend down: no change in mask
            add(z, c);
            // extend to the right: x0 becomes 0x, but only if next cell isn't 2
            final int look = (int) (mask >>> ((j << 1) + 4)) & 3;
            if (left != 2 || look != 3) {
              add(rank(w, getMask(j, mask) | ((long) SWAP[left] << (j << 1))), c);
            }
          } else if (up != 0) { // extend single edge, case 2
            // extend down: 0x becomes x0
            add(rank(w, getMask(j, mask) | ((long) SWAP[up << 2] << (j << 1))), c);
            // extend to the right: no change in mask
            final int look = (int) (mask >>> ((j << 1) + 4)) & 3;
            if (up != 2 || look != 3) {
              add(z, c);
            }
          } else { // no edge
            // place nothing
            add(z, c);
            // place 23
            add(rank(w, mask | (14L << (j << 1))), c);
          }
        }
      }
    }
  }

  private long getMask(final int j, final long mask) {
    return mask & (~(15L << (j << 1)));
  }

  private final class DeletionThread extends Thread {

    private final int mId;

    private DeletionThread(final int id) {
      mId = id;
    }

    @Override
    public void run() {
      for (long u = mPstart[mId]; u < mPend[mId]; ++u) {
        mCur.set(u, Z.ZERO);
      }
    }
  }

  private Z calc(final int n, final int m) {
    final long num = mDP[1][0][n + 1];
    final int w = n + 1;
    mPrev = new LongDynamicArray<>();
    mCur = new LongDynamicArray<>();
    for (long k = 0; k < num; ++k) {
      mPrev.set(k, Z.ZERO);
      mCur.set(k, Z.ZERO);
    }
    // Force starting edge to go down. the exact number of paths is twice the answer we get.
    mPrev.set(rank(w, 1), Z.ONE);
    if (m != n) {
      mPrev.set(rank(w, 4), Z.ONE);  // cannot use symmetry if non-square
    }
    mGlobalN = n;
    mGlobalM = m;
    mGlobalW = w;
    final long inc = num / THREADS;
    for (int k = 0; k < THREADS; ++k) {
      mPstart[k] = k * inc;
      mPend[k] = (k + 1) * inc;
    }
    mPend[THREADS - 1] = num;
    // We are not worried about creating 2 million mutexes and creating/tearing
    // down threads n^2 times, as the time for doing this is insignificant
    // compared to the calculation for large n
    for (int i = 0; i < m; ++i) {
      for (int j = 0; j < n; ++j) {
        //    System.out.println("[" + i + " " + j + "]");
        if (i == 0 && j == 0) {
          continue;
        }
        mGlobalI = i;
        mGlobalJ = j;
        final Thread[] threads = new Thread[THREADS];
        for (int k = 0; k < THREADS; ++k) {
          threads[k] = new CountingThread(k);
          threads[k].start();
        }
        for (final Thread thread : threads) {
          try {
            thread.join();
          } catch (final InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
        final LongDynamicArray<Z> t = mPrev;
        mPrev = mCur;
        mCur = t;
        if (i != m - 1 || j != n - 1) {
          // delete array with threads
          for (int k = 0; k < THREADS; ++k) {
            threads[k] = new DeletionThread(k);
            threads[k].start();
          }
          for (final Thread thread : threads) {
            try {
              thread.join();
            } catch (final InterruptedException e) {
              throw new RuntimeException(e);
            }
          }
        }
      }
    }
    Z r = Z.ZERO;
    for (int i = 0; i < THREADS; ++i) {
      r = r.add(mPartialAnswers[i]);
    }
    if (n == m) {
      r = r.multiply2();
    }
    return r;
  }

  /* m,n: dimensions of rectangle with n*m internal cells */
  /* when solving A007764, invoke with n+1,n+1 */
  private Z solve(int n, int m) {
    if (n > m) {
      final int t = n;
      n = m;
      m = t;
    }
    // require n<=m, frontier width is n+1
    return calc(n, m);
  }

  private int mN = 0; // one larger than actual board size

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    return solve(mN, mN);
  }
}
#!queue	A007862	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007862 Number of triangular numbers that divide n.
 * @author Sean A. Irvine
 */
public class A007862 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007862() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    mN += 2;
    long count = 0;
    for (final Z dd : Jaguar.factor(mN).divisors()) {
      if (mN % (dd.intValueExact() + 1) == 0) {
        ++count;
      }
    }
    return Z.valueOf(count);
  }
}
#!queue	A007949	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007949 Greatest k such that 3^k divides n. Or, 3-adic valuation of n.
 * @author Sean A. Irvine
 */
public class A007949 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007949() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    long m = ++mN;
    long c = 0;
    while (m % 3 == 0) {
      m /= 3;
      ++c;
    }
    return Z.valueOf(c);
  }
}
#!queue	A007968	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import irvine.factor.factor.Jaguar;
import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007968 Type of happy factorization of n.
 * @author Sean A. Irvine
 */
public class A007968 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007968() {
    super(0);
  }

  protected long mN = -1;

  @Override
  public Z next() {
    ++mN;
    final long s = LongUtils.sqrt(mN);
    if (s * s == mN) {
      return Z.ZERO;
    }
    final Z[] divisors = Jaguar.factor(mN).divisors();
    for (long r = 1; ; ++r) {
      for (final Z b : divisors) {
        final Z c = Z.valueOf(mN / b.longValue());
        final Z br2 = b.multiply(r * r);
        final Z br2p1 = br2.add(1);
        final Z[] qr1 = br2p1.divideAndRemainder(c);
        if (qr1[1].isZero() && qr1[0].isSquare()) {
          return Z.ONE;
        }
        final Z br2p2 = br2.add(2);
        final Z[] qr2 = br2p2.divideAndRemainder(c);
        if (qr2[1].isZero() && qr2[0].isSquare()) {
          return Z.TWO;
        }
      }
    }
  }
}
#!queue	A007975	4	->	4	AbstractSequence	--------------------------------
package irvine.oeis.a007;

import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A007975 Number of permutations that are 3 "block reversals" away from 12...n.
 * @author Sean A. Irvine
 */
public class A007975 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A007975() {
    super(4);
  }

  protected int mN = start();
  private final HashSet<String> mSeen = new HashSet<>();
  protected HashSet<String> mPrev = new HashSet<>();

  // Perform block reversals on all those at the current distance, disregarding
  // any permutations that have already been achieved.
  protected void step() {
    final HashSet<String> next = new HashSet<>();
    for (final String perm : mPrev) {
      final char[] p = perm.toCharArray();
      for (int start = 0; start < p.length; ++start) {
        for (int length = 2; length <= p.length - start; ++length) {
          A007972.reverse(p, start, length);
          final String key = new String(p);
          if (mSeen.add(key)) {
            next.add(key);
          }
          A007972.reverse(p, start, length); // undo
        }
      }
    }
    mPrev = next;
  }

  protected int start() {
    return 3;
  }

  protected void init() {
    final char[] p = new char[++mN];
    for (int k = 0; k < p.length; ++k) {
      p[k] = (char) k;
    }
    mSeen.clear();
    mPrev.clear();
    mSeen.add(new String(p));
    mPrev.add(new String(p));
  }

  @Override
  public Z next() {
    init();
    step(); // 1
    step(); // 2
    step(); // 3
    return Z.valueOf(mPrev.size());
  }
}
#!queue	A008277	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008277 Triangle of Stirling numbers of the second kind, S2(n,k), n &gt;= 1, 1 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A008277 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008277() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return Stirling.secondKind(mN, mM);
  }
}

#!queue	A008281	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008281 Triangle of Euler-Bernoulli or Entringer numbers read by rows.
 * @author Sean A. Irvine
 */
public class A008281 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 0) {
      return Z.ONE;
    }
    if (n == 1 && k == 1) {
      return Z.ONE;
    }
    if (k > n) {
      return Z.ZERO;
    }
    if (n.equals(k)) {
      return get(n, n - 1);
    }
    Z sum = Z.ZERO;
    for (long j = n - k; j < n; ++j) {
      sum = sum.add(get(n - 1, j));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A008287	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008287 Triangle of quadrinomial coefficients, row n is the sequence of coefficients of (1 + x + x^2 + x^3)^n.
 * @author Sean A. Irvine
 */
public class A008287 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008287() {
    super(0);
  }

  protected Z quadrinomial(final long n, final long k) {
    Z sum = Z.ZERO;
    for (long i = 0; i <= k / 2; ++i) {
      sum = sum.add(Binomial.binomial(n, i).multiply(Binomial.binomial(n, k - 2 * i)));
    }
    return sum;
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > 3 * mN) {
      ++mN;
      mM = 0;
    }
    return quadrinomial(mN, mM);
  }
}

#!queue	A008288	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008288 Square array of Delannoy numbers D(i,j) (i &gt;= 0, j &gt;= 0) read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A008288 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    return n == 0 || k == 0 ? Z.ONE : get(n, k - 1).add(get(n - 1, k - 1).add(get(n - 1, k)));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A008290	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Binomial;
import irvine.math.z.Z;

/**
 * A008290 Triangle T(n,k) of rencontres numbers (number of permutations of n elements with k fixed points).
 * @author Sean A. Irvine
 */
public class A008290 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After Alois P. Heinz

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k == 0) {
      return n < 2 ? Z.ONE.subtract(n) : get(n - 1, 0L).add(get(n - 2, 0L)).multiply(n - 1);
    } else {
      return get(n - k, 0L).multiply(Binomial.binomial(n, k));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A008292	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A008292 Triangle of Eulerian numbers T(n,k) (n &gt;= 1, 1 &lt;= k &lt;= n) read by rows.
 * @author Sean A. Irvine
 */
public class A008292 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  protected long mN = 0;
  protected long mM = 0;

  /** Construct the sequence. */
  public A008292() {
    super(1);
  }

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n <= 0 || k <= 0) {
      return Z.ZERO;
    }
    if (n == 1 && k == 1) {
      return Z.ONE;
    }
    return get(n - 1, k).multiply(k).add(get(n - 1, k - 1).multiply(n - k + 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A008298	1	->	1	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.factor.factor.Jaguar;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction1Sequence;

/**
 * A008298 Triangle of D'Arcais numbers.
 * @author Sean A. Irvine
 */
public class A008298 extends MemoryFunction1Sequence<Polynomial<Z>> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008298() {
    super(1);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int n) {
    if (n == 0) {
      return RING.one();
    }
    Polynomial<Z> sum = RING.zero();
    for (int k = 1; k <= n; ++k) {
      sum = RING.add(sum, RING.multiply(get(n - k).shift(1), mF.factorial(n - 1).divide(mF.factorial(n - k)).multiply(Jaguar.factor(k).sigma())));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN).coeff(mM);
  }
}
#!queue	A008300	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import java.util.HashMap;
import java.util.Map;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A008300 Triangle read by rows: T(n,k) (n &gt;= 0, 0 &lt;= k &lt;= n) gives number of {0,1} n X n matrices with all row and column sums equal to k.
 * @author Sean A. Irvine
 */
public class A008300 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008300() {
    super(0);
  }

  // After Andrew Howroyd

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;
  private int mM = 0;

  private void acc(final Map<Polynomial<Z>, Z> m, final Polynomial<Z> p, final Z v) {
    final Z t = m.get(p);
    m.put(p, t == null ? v : t.add(v));
  }

  private void recurse(final Map<Polynomial<Z>, Z> m, final int i, final Polynomial<Z> p, final Z v, final int e) {
    if (i < 0) {
      if (e == 0) {
        acc(m, p, v);
      }
    } else {
      final Z t = p.coeff(i);
      final int min = t.min(Z.valueOf(e)).intValueExact();
      for (int j = 0; j <= min; ++j) {
        recurse(m, i - 1, RING.add(p, Polynomial.create(-j, j).shift(i)), Binomial.binomial(t, Z.valueOf(j)).multiply(v), e - j);
      }
    }
  }

  protected Z t(final int n, final int k) {
    if (k > n) {
      return n == 0 ? Z.ONE : Z.ZERO;
    }
    HashMap<Polynomial<Z>, Z> m = new HashMap<>();
    m.put(Polynomial.create(n), Z.ONE);
    for (int r = 1; r <= n; ++r) {
      final HashMap<Polynomial<Z>, Z> res = new HashMap<>();
      for (final Map.Entry<Polynomial<Z>, Z> e : m.entrySet()) {
        recurse(res, k - 1, e.getKey(), e.getValue(), k);
      }
      m = res;
    }
    return ZUtils.sum(m.values());
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A008302	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A008302 Triangle of Mahonian numbers T(n,k): coefficients in expansion of Product_{i=0..n-1} (1 + x + ... + x^i), where k ranges from 0 to A000217(n-1). Also enumerates permutations by their major index.
 * @author Sean A. Irvine
 */
public class A008302 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008302() {
    super(1);
  }

  private long mN = 1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 1) {
      return k == 1 ? Z.ONE : Z.ZERO;
    }
    if (k < 0) {
      return Z.ZERO;
    }
    return get(n, k - 1).add(get(n - 1, k)).subtract(get(n - 1, k - n));
  }

  @Override
  public Z next() {
    if (++mM > mN * (mN - 1) / 2) {
      ++mN;
      mM = 0;
      return Z.ONE;
    }
    return get(mN, mM);
  }
}
#!queue	A008315	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008315 Catalan triangle read by rows. Also triangle of expansions of powers of x in terms of Chebyshev polynomials U_n(x).
 * @author Sean A. Irvine
 */
public class A008315 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008315() {
    super(0);
  }

  private long mN = -1;
  private long mM = 1;

  protected Z t(final long n, final long m) {
    return Binomial.binomial(n, m).subtract(Binomial.binomial(n, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN / 2) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A008352	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008352 a(n) is formed by concatenating a(n-2) and a(n-1), with a(0) = 1, a(1) = 2;.
 * @author Sean A. Irvine
 */
public class A008352 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008352() {
    super(0);
  }

  private String mA = null;
  private String mB = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = "1";
      return Z.ONE;
    }
    if (mB == null) {
      mB = "2";
      return Z.TWO;
    }
    final String t = mA + mB;
    mA = mB;
    mB = t;
    return new Z(t);
  }
}

#!queue	A008410	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008410 a(0) = 1, a(n) = 480*sigma_7(n).
 * @author Sean A. Irvine
 */
public class A008410 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008410() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return Jaguar.factor(mN).sigma(7).multiply(480);
  }
}
#!queue	A008778	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008778 a(n) = (n+1)*(n^2 +8*n +6)/6. Number of n-dimensional partitions of 4. Number of terms in 4th derivative of a function composed with itself n times.
 * @author Sean A. Irvine
 */
public class A008778 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008778() {
    super(0);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.add(8).multiply(mN).add(6).multiply(mN.add(1)).divide(6);
  }
}
#!queue	A008826	2	->	2	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction1Sequence;

/**
 * A008826 Triangle of coefficients from fractional iteration of e^x - 1.
 * @author Sean A. Irvine
 */
public class A008826 extends MemoryFunction1Sequence<Polynomial<Z>> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008826() {
    super(2);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = 1;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final int n) {
    if (n < 1) {
      return RING.zero();
    }
    if (n == 1) {
      return RING.one();
    }
    Polynomial<Z> sum = RING.zero();
    for (int k = 1; k < n; ++k) {
      sum = RING.add(sum, RING.multiply(get(k).shift(1), Stirling.secondKind(n, k)));
    }
    return sum;
  }

  @Override
  public Z next() {
    Polynomial<Z> row = get(mN);
    if (++mM > row.degree()) {
      ++mN;
      mM = 1;
      row = get(mN);
    }
    return row.coeff(mM);
  }

}

#!queue	A008865	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008865 a(n) = n^2 - 2.
 * @author Sean A. Irvine
 */
public class A008865 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008865() {
    super(1);
  }

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.square().subtract(2);
  }
}

#!queue	A008867	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A008867 Triangle of truncated triangular numbers: k-th term in n-th row is number of dots in hexagon of sides k, n-k, k, n-k, k, n-k.
 * @author Sean A. Irvine
 */
public class A008867 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008867() {
    super(2);
  }

  private long mN = 1;
  private long mM = 1;

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    final Z n = Z.valueOf(mN);
    return n.multiply(mN - 3).divide2().add(n.multiply(mM)).subtract(Z.valueOf(mM).square()).add(1);
  }
}

#!queue	A008970	2	->	2	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A008970 Triangle T(n,k) = P(n,k)/2, n &gt;= 2, 1 &lt;= k &lt; n, of one-half of number of permutations of 1..n such that the differences have k runs with the same signs.
 * @author Sean A. Irvine
 */
public class A008970 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A008970() {
    super(2);
  }

  private int mRow = 0;
  private int mPos = 2;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    if (k <= 0 || k > n) {
      return Z.ZERO;
    } else if (k == 1) {
      return Z.TWO;
    } else {
      return get(n - 1, k).multiply(k).add(get(n - 1, k - 1).multiply2()).add(get(n - 1, k - 2).multiply(n - k + 1));
    }
  }

  @Override
  public Z next() {
    if (mPos > mRow) {
      ++mRow;
      mPos = 1;
    }
    return get(mRow, mPos++).divide2();
  }

}

#!queue	A008971	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a008;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A008971 Triangle read by rows: T(n,k) is the number of permutations of [n] with k increasing runs of length at least 2.
 * @author Sean A. Irvine
 */
public class A008971 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mRow = -1;
  private int mPos = 2;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    final Z w;
    if (k < 0 || k >= 1 + n / 2) {
      w = Z.ZERO;
    } else if (n == 0) {
      w = Z.ONE;
    } else {
      w = get(n - 1, k).multiply(2 * k + 1).add(get(n - 1, k - 1).multiply(n - 2 * k + 1));
    }
    return w;
  }

  @Override
  public Z next() {
    if (mPos >= 1 + mRow / 2) {
      ++mRow;
      mPos = 0;
    }
    return get(mRow, mPos++);
  }

}

#!queue	A009475	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a009;

import java.util.TreeSet;

import irvine.math.q.Q;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A009475 "Pascal sweep" for k=6: draw a horizontal line through the 1 at C(k,0) in Pascal's triangle; rotate this line and record the sum of the numbers on it (excluding the initial 1).
 * @author Sean A. Irvine
 */
public class A009475 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A009475() {
    super(1);
  }

  private final TreeSet<Q> mNext = new TreeSet<>();
  private long mNextY = 2;

  protected long row() {
    return 6;
  }

  {
    for (long k = row() + 1; k >= 2; --k) {
      mNext.add(new Q(k, 1));
    }
  }

  private Z line(final long start, final long x, final long y) {
    Z sum = Z.ZERO;
    for (long n = start + y, m = x; m <= n; n += y, m += x) {
      sum = sum.add(Binomial.binomial(n, m));
    }
    return sum;
  }

  @Override
  public Z next() {
    Q w;
    while ((w = new Q(row() + mNextY, mNextY)).compareTo(mNext.last()) > 0) {
      final Q delta = new Q(1, mNextY);
      while (w.compareTo(Q.ONE) > 0) {
        if (w.den().longValue() == mNextY) {
          mNext.add(w);
        }
        w = w.subtract(delta);
      }
      ++mNextY;
    }
    final Q t = mNext.pollLast();
    final long x = t.num().longValue();
    final long y = t.den().longValue();
    return line(row(), x, y);
  }
}
#!queue	A010052	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A010052 Characteristic function of squares: a(n) = 1 if n is a square, otherwise 0.
 * @author Sean A. Irvine
 */
public class A010052 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A010052() {
    super(0);
  }

  private long mNext = 0;
  private long mM = 0;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == mNext) {
      mNext = ++mM * mM;
      return Z.ONE;
    }
    return Z.ZERO;
  }
}

#!queue	A010054	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A010054 a(n) = 1 if n is a triangular number, otherwise 0.
 * @author Sean A. Irvine
 */
public class A010054 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A010054() {
    super(0);
  }

  private long mNext = 0;
  private long mM = 0;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == mNext) {
      mNext = ++mM * (mM + 1) / 2;
      return Z.ONE;
    }
    return Z.ZERO;
  }
}

#!queue	A010785	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.string.StringUtils;

/**
 * A010785 Repdigit numbers, or numbers with repeated digits.
 * @author Sean A. Irvine
 */
public class A010785 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A010785() {
    super(0);
  }

  private char mN = '/';
  private int mLength = 1;

  @Override
  public Z next() {
    if (++mN > '9') {
      ++mLength;
      mN = '1';
    }
    return new Z(StringUtils.rep(mN, mLength));
  }
}
#!queue	A010790	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a010;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A010790 a(n) = n!*(n+1)!.
 * @author Sean A. Irvine
 */
public class A010790 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A010790() {
    super(0);
  }

  private long mN = 0;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    final Z r = mF;
    mF = mF.multiply(++mN);
    return r.multiply(mF);
  }
}
#!queue	A011545	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a011;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A011545 Decimal expansion of Pi truncated to n places.
 * @author Sean A. Irvine
 */
public class A011545 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A011545() {
    super(0);
  }

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ONE : mA.multiply(10);
    return CR.PI.multiply(mA).floor();
  }
}
#!queue	A013697	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a013;

import irvine.math.cr.CR;
import irvine.math.cr.Zeta;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A013697 Second term in continued fraction for zeta(n).
 * @author Sean A. Irvine
 */
public class A013697 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A013697() {
    super(2);
  }

  private int mN = 1;

  @Override
  public Z next() {
    return Zeta.zeta(++mN).subtract(CR.ONE).inverse().floor();
  }
}
#!queue	A013924	4	->	4	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a013;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.PrependSequence;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A013924 Number of labeled connected graphs with n nodes and 2 cutpoints.
 * @author Sean A. Irvine
 */
public class A013924 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A013924() {
    super(4);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private final MemorySequence mB = MemorySequence.cachedSequence(new PrependSequence(new A013922(), 0));

  // [x^m z^n]{(\PhiS(x,z))}^q=\sum_{j,k}[x^j z^k]\Phi S(x,z)[x^{m-j}z^{n-k}]{(\Phi S(x,z))}^{q-1}
  // Not particularly efficient
  private Q coeffSmnq(final int m, final int n, final int q) {
    assert q >= 1;
    if (q == 1) {
      return new Q(get(m, n).multiply(m).add(get(m - 1, n).multiply(n - m + 1)), mF.factorial(n));
    }
    Q u = Q.ZERO;
    for (int k = 1; k < n; ++k) {
      for (int j = 1; j < m; ++j) {
        final Q t = coeffSmnq(j, k, 1).multiply(coeffSmnq(m - j, n - k, q - 1));
        u = u.add(t);
      }
    }
    return u;
  }

  @Override
  protected Z compute(final Integer m, final Integer n) {
    if (m == 0) {
      return mB.a(n);
    }
    if (n.equals(m)) {
      return Z.ZERO;
    }
    Q smn = Q.ZERO;
    for (int k = 2; k <= n - m; ++k) {
      Q t = Q.ZERO;
      for (int q = 1; q <= Math.min(k - 1, m); ++q) {
        final Q u = coeffSmnq(m, n + q - k, q)
          .divide(mF.factorial(q))
          .divide(mF.factorial(k - 1 - q));
        t = t.add(u);
      }
      smn = smn.add(t.multiply(mB.a(k)));
    }
    return smn.multiply(mF.factorial(n)).divide(n - m).toZ();
  }

  private int mN = 3;

  @Override
  public Z next() {
    return get(2, ++mN);
  }
}
#!queue	A013959	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a013;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A013959 a(n) = sigma_11(n), the sum of the 11th powers of the divisors of n.
 * @author Sean A. Irvine
 */
public class A013959 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A013959() {
    super(1);
  }

  protected long mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(++mN).sigma(11);
  }
}
#!queue	A013963	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a013;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A013963 a(n) = sigma_15(n), the sum of the 15th powers of the divisors of n.
 * @author Sean A. Irvine
 */
public class A013963 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A013963() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(++mN).sigma(15);
  }
}
#!queue	A013967	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a013;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A013967 a(n) = sigma_19(n), the sum of the 19th powers of the divisors of n.
 * @author Sean A. Irvine
 */
public class A013967 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A013967() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(++mN).sigma(19);
  }
}
#!queue	A013971	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a013;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A013971 a(n) = sum of 23rd powers of divisors of n.
 * @author Sean A. Irvine
 */
public class A013971 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A013971() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(++mN).sigma(23);
  }
}
#!queue	A013973	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a013;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A013973 Expansion of Eisenstein series E_6(q) (alternate convention E_3(q)).
 * @author Sean A. Irvine
 */
public class A013973 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A013973() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : Jaguar.factor(mN).sigma(5).multiply(-504);
  }
}
#!queue	A013974	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a013;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A013974 Eisenstein series E_10(q) (alternate convention E_5(q)).
 * @author Sean A. Irvine
 */
public class A013974 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A013974() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : Jaguar.factor(mN).sigma(9).multiply(-264);
  }
}
#!queue	A014068	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014068 a(n) = binomial(n*(n+1)/2, n).
 * @author Sean A. Irvine
 */
public class A014068 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014068() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return Binomial.binomial(++mN * (mN + 1) / 2, mN);
  }
}
#!queue	A014221	-1	->	-1	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014221 a(n+1) = 2^a(n) with a(-1) = 0.
 * @author Sean A. Irvine
 */
public class A014221 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014221() {
    super(-1);
  }

  private Z mA = null;

  @Override
  public Z next() {
    mA = mA == null ? Z.ZERO : Z.ONE.shiftLeft(mA.longValueExact());
    return mA;
  }
}
#!queue	A014413	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014413 Triangular array formed from elements to right of middle of Pascal's triangle.
 * @author Sean A. Irvine
 */
public class A014413 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014413() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = (mN + 2) / 2;
    }
    return Binomial.binomial(mN, mM);
  }
}
#!queue	A014486	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import java.util.Map;
import java.util.TreeMap;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A014486 List of totally balanced sequences of 2n binary digits written in base 10. Binary expansion of each term contains n 0's and n 1's and reading from left to right (the most significant to the least significant bit), the number of 0's never exceeds the number of 1's.
 * @author Sean A. Irvine
 */
public class A014486 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014486() {
    super(0);
  }

  private final TreeMap<Z, Pair<Integer, Integer>> mState = new TreeMap<>();

  @Override
  public Z next() {
    if (mState.isEmpty()) {
      mState.put(Z.ONE, new Pair<>(0, 1));
      return Z.ZERO;
    }
    while (true) {
      final Map.Entry<Z, Pair<Integer, Integer>> e = mState.pollFirstEntry();
      final Pair<Integer, Integer> value = e.getValue();
      final int zeros = value.left();
      final int ones = value.right();
      final Z m = e.getKey().multiply2();
      mState.put(m.add(1), new Pair<>(zeros, ones + 1));
      if (zeros < ones) {
        mState.put(m, new Pair<>(zeros + 1, ones));
      }
      if (zeros == ones) {
        return e.getKey();
      }
    }
  }
}
#!queue	A014493	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014493 Odd triangular numbers.
 * @author Sean A. Irvine
 */
public class A014493 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014493() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(2 * ++mN - 1).multiply(2 * (mN - 1 + (mN & 1))).divide2();
  }
}
#!queue	A014634	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014634 a(n) = (2*n+1)*(4*n+1).
 * @author Sean A. Irvine
 */
public class A014634 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014634() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(2 * ++mN + 1).multiply(4 * mN + 1);
  }
}
#!queue	A014635	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014635 a(n) = 2*n*(4*n - 1).
 * @author Sean A. Irvine
 */
public class A014635 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014635() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    return Z.valueOf(++mN).multiply(4 * mN - 1).multiply2();
  }
}
#!queue	A014817	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014817 a(n) = Sum_{k=1..n} floor(k^2/n).
 * @author Sean A. Irvine
 */
public class A014817 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014817() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 1; k <= mN; ++k) {
      sum = sum.add(Z.valueOf(k).square().divide(mN));
    }
    return sum;
  }
}
#!queue	A014824	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a014;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A014824 a(0) = 0; for n&gt;0, a(n) = 10*a(n-1) + n.
 * @author Sean A. Irvine
 */
public class A014824 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A014824() {
    super(0);
  }

  private Z mA = Z.ZERO;
  protected long mN = -1;

  @Override
  public Z next() {
    if (++mN > 0) {
      mA = mA.multiply(10).add(mN);
    }
    return mA;
  }
}
#!queue	A015622	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015622 Quadruples of different integers from [ 1,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015622 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015622() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a < n - 2; ++a) {
      final long d = LongUtils.gcd(a, n);
      for (long b = a + 1; b < n - 1; ++b) {
        final long e = LongUtils.gcd(d, b);
        for (long c = b + 1; c < n; ++c) {
          if (LongUtils.gcd(e, c) == 1) {
            ++count;
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015623	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015623 Quadruples of different integers from [ 1,n ] with no common factors between pairs.
 * @author Sean A. Irvine
 */
public class A015623 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015623() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a < n - 2; ++a) {
      if (LongUtils.gcd(a, n) == 1) {
        for (long b = a + 1; b < n - 1; ++b) {
          if (LongUtils.gcd(b, a) == 1 && LongUtils.gcd(b, n) == 1) {
            for (long c = b + 1; c < n; ++c) {
              if (LongUtils.gcd(c, b) == 1 && LongUtils.gcd(c, a) == 1 && LongUtils.gcd(c, n) == 1) {
                ++count;
              }
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015625	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015625 Quadruples of different integers from [ 1,n ] with no common factors between triples.
 * @author Sean A. Irvine
 */
public class A015625 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015625() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a < n - 2; ++a) {
      final long d = LongUtils.gcd(a, n);
      for (long b = a + 1; b < n - 1; ++b) {
        final long e = LongUtils.gcd(a, b);
        if (LongUtils.gcd(d, e) == 1) {
          for (long c = b + 1; c < n; ++c) {
            final long f = LongUtils.gcd(b, c);
            if (LongUtils.gcd(e, f) == 1 && LongUtils.gcd(d, c) == 1 && LongUtils.gcd(f, n) == 1) {
              ++count;
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015634	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015634 Number of ordered quadruples of integers from [ 1..n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015634 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015634() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a <= n; ++a) {
      final long d = LongUtils.gcd(a, n);
      for (long b = a; b <= n; ++b) {
        final long e = LongUtils.gcd(d, b);
        for (long c = b; c <= n; ++c) {
          if (LongUtils.gcd(e, c) == 1) {
            ++count;
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015635	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015635 Number of ordered quadruples of integers from [ 1,n ] with no common factors between triples.
 * @author Sean A. Irvine
 */
public class A015635 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015635() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a <= n; ++a) {
      final long d = LongUtils.gcd(a, n);
      for (long b = a; b <= n; ++b) {
        final long e = LongUtils.gcd(a, b);
        if (LongUtils.gcd(d, e) == 1) {
          for (long c = b; c <= n; ++c) {
            final long f = LongUtils.gcd(b, c);
            if (LongUtils.gcd(e, f) == 1 && LongUtils.gcd(d, c) == 1 && LongUtils.gcd(f, n) == 1) {
              ++count;
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015640	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015640 Number of 5-tuples of different integers from [ 1,n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015640 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015640() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a < n - 3; ++a) {
      final long e = LongUtils.gcd(a, n);
      for (long b = a + 1; b < n - 2; ++b) {
        final long f = LongUtils.gcd(e, b);
        for (long c = b + 1; c < n - 1; ++c) {
          final long g = LongUtils.gcd(f, c);
          for (long d = c + 1; d < n; ++d) {
            if (LongUtils.gcd(g, d) == 1) {
              ++count;
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015644	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015644 Number of 5-tuples of different integers from [ 1,n ] with no common factors among quadruples.
 * @author Sean A. Irvine
 */
public class A015644 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015644() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a < n - 3; ++a) {
      final long e = LongUtils.gcd(a, n);
      for (long b = a + 1; b < n - 2; ++b) {
        final long f = LongUtils.gcd(a, b);
        for (long c = b + 1; c < n - 1; ++c) {
          final long g = LongUtils.gcd(b, c);
          if (LongUtils.gcd(g, e) == 1) { // (a,b,c,n) != 1
            for (long d = c + 1; d < n; ++d) {
              final long h = LongUtils.gcd(c, d);
              if (LongUtils.gcd(e, h) == 1 && LongUtils.gcd(e, b, d) == 1 && LongUtils.gcd(h, b, n) == 1 && LongUtils.gcd(h, f) == 1) {
                ++count;
              }
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015646	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015646 Number of 5-tuples of different integers from [ 1,n ] with no common factors among triples.
 * @author Sean A. Irvine
 */
public class A015646 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015646() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a < n - 3; ++a) {
      final long e = LongUtils.gcd(a, n);
      for (long b = a + 1; b < n - 2; ++b) {
        if (LongUtils.gcd(e, b) == 1) {
          final long f = LongUtils.gcd(a, b);
          for (long c = b + 1; c < n - 1; ++c) {
            if (LongUtils.gcd(e, c) == 1 && LongUtils.gcd(f, c) == 1 && LongUtils.gcd(n, b, c) == 1) {
              for (long d = c + 1; d < n; ++d) {
                if (LongUtils.gcd(e, d) == 1 && LongUtils.gcd(f, d) == 1 && LongUtils.gcd(n, b, d) == 1 && LongUtils.gcd(n, c, d) == 1 && LongUtils.gcd(a, c, d) == 1 && LongUtils.gcd(b, c, d) == 1) {
                  ++count;
                }
              }
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015650	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015650 Number of ordered 5-tuples of integers from [ 1..n ] with no global factor.
 * @author Sean A. Irvine
 */
public class A015650 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015650() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a <= n; ++a) {
      final long e = LongUtils.gcd(a, n);
      for (long b = a; b <= n; ++b) {
        final long f = LongUtils.gcd(e, b);
        for (long c = b; c <= n; ++c) {
          final long g = LongUtils.gcd(f, c);
          for (long d = c; d <= n; ++d) {
            if (LongUtils.gcd(g, d) == 1) {
              ++count;
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015653	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015653 Number of ordered 5-tuples of integers from [ 1,n ] with no common factors among quadruples.
 * @author Sean A. Irvine
 */
public class A015653 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015653() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a <= n; ++a) {
      final long e = LongUtils.gcd(a, n);
      for (long b = a; b <= n; ++b) {
        final long f = LongUtils.gcd(a, b);
        for (long c = b; c <= n; ++c) {
          final long g = LongUtils.gcd(b, c);
          if (LongUtils.gcd(g, e) == 1) { // (a,b,c,n) != 1
            for (long d = c; d <= n; ++d) {
              final long h = LongUtils.gcd(c, d);
              if (LongUtils.gcd(e, h) == 1 && LongUtils.gcd(e, b, d) == 1 && LongUtils.gcd(h, b, n) == 1 && LongUtils.gcd(h, f) == 1) {
                ++count;
              }
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015656	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015656 Number of ordered 5-tuples of integers from [ 1,n ] with no common factors among triples.
 * @author Sean A. Irvine
 */
public class A015656 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015656() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a <= n; ++a) {
      final long e = LongUtils.gcd(a, n);
      for (long b = a; b <= n; ++b) {
        if (LongUtils.gcd(e, b) == 1) {
          final long f = LongUtils.gcd(a, b);
          for (long c = b; c <= n; ++c) {
            if (LongUtils.gcd(e, c) == 1 && LongUtils.gcd(f, c) == 1 && LongUtils.gcd(n, b, c) == 1) {
              for (long d = c; d <= n; ++d) {
                if (LongUtils.gcd(e, d) == 1 && LongUtils.gcd(f, d) == 1 && LongUtils.gcd(n, b, d) == 1 && LongUtils.gcd(n, c, d) == 1 && LongUtils.gcd(a, c, d) == 1 && LongUtils.gcd(b, c, d) == 1) {
                  ++count;
                }
              }
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015698	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A015698 Number of 5-tuples of different integers from [ 1,n ] with no common factors among pairs.
 * @author Sean A. Irvine
 */
public class A015698 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015698() {
    super(1);
  }

  private long mN = start() - 1;
  private Z mA = Z.ZERO;

  protected long start() {
    return 1;
  }

  private long count(final long n) {
    long count = 0;
    for (long a = start(); a < n - 3; ++a) {
      if (LongUtils.gcd(a, n) == 1) {
        for (long b = a + 1; b < n - 2; ++b) {
          if (LongUtils.gcd(a, b) == 1 && LongUtils.gcd(b, n) == 1) {
            for (long c = b + 1; c < n - 1; ++c) {
              if (LongUtils.gcd(c, b) == 1 && LongUtils.gcd(c, a) == 1 && LongUtils.gcd(c, n) == 1) {
                for (long d = c + 1; d < n; ++d) {
                  if (LongUtils.gcd(d, c) == 1 && LongUtils.gcd(d, b) == 1 && LongUtils.gcd(d, a) == 1 && LongUtils.gcd(d, n) == 1) {
                    ++count;
                  }
                }
              }
            }
          }
        }
      }
    }
    return count;
  }

  @Override
  public Z next() {
    mA = mA.add(count(++mN));
    return mA;
  }
}
#!queue	A015977	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a015;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;
import irvine.util.string.StringUtils;

/**
 * A015977 Two iterations of Reverse and Add are needed to reach a palindrome.
 * @author Sean A. Irvine
 */
public class A015977 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A015977() {
    super(0);
  }

  private long mN = 0;

  protected int iterations() {
    return 2;
  }

  @Override
  public Z next() {
    outer:
    while (true) {
      Z a = Z.valueOf(++mN);
      for (int k = iterations(); k > 0; --k) {
        a = ZUtils.reverse(a).add(a);
        if (StringUtils.isPalindrome(a.toString())) {
          if (k == 1) {
            return Z.valueOf(mN);
          }
          continue outer;
        }
      }
    }
  }
}
#!queue	A016017	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a016;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A016017 Smallest k such that 1/k can be written as a sum of exactly 2 unit fractions in n ways.
 * @author Sean A. Irvine
 */
public class A016017 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A016017() {
    super(1);
  }

  protected long mN = 0;

  protected int v() {
    return 2;
  }

  @Override
  public Z next() {
    mN += v();
    long k = 0;
    while (true) {
      final FactorSequence fs = new FactorSequence();
      fs.add(++k, FactorSequence.UNKNOWN, v());
      Jaguar.factor(fs);
      if (fs.sigma0AsLong() + v() - 1 == mN) {
        return Z.valueOf(k);
      }
    }
  }
}
#!queue	A016047	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a016;

import irvine.factor.factor.Jaguar;
import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A016047 Smallest prime factor of Mersenne numbers.
 * @author Sean A. Irvine
 */
public class A016047 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A016047() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  protected long mP = 1;

  @Override
  public Z next() {
    mP = mPrime.nextPrime(mP);
    return Jaguar.factor(Z.ONE.shiftLeft(mP).subtract(1)).leastPrimeFactor();
  }
}
#!queue	A016057	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a016;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A016057 Pseudo-powers to base 3: numbers k that are not powers of 3 such that k divides 2^k + 1.
 * @author Sean A. Irvine
 */
public class A016057 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A016057() {
    super(1);
  }

  private Z mN = Z.valueOf(170);

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (Z.TWO.modPow(mN, mN).equals(mN.subtract(1))) {
        final Z base = mN.isPower();
        if (!Z.THREE.equals(base)) {
          return mN;
        }
      }
    }
  }
}
#!queue	A019268	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a001.A001615;
import irvine.util.array.LongDynamicByteArray;

/**
 * A019268 Let Dedekind's psi(m) = product of (p+1)p^(e-1) for primes p, where p^e is a factor of m. Iterating psi(m) eventually results in a number of form 2^a*3^b. a(n) is the smallest number that requires n steps to reach such a number.
 * @author Sean A. Irvine
 */
public class A019268 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A019268() {
    super(0);
  }

  // 16 GB table
  private static final long TABLE_LIMIT = 1L << 34;

  // Keep historical values (increased by 1 so 0 can be sentinel)
  private final LongDynamicByteArray mCache = new LongDynamicByteArray();
  private int mN = -1;
  private long mM = 1;

  private boolean isTerminal(final long n) {
    long m = n;
    while ((m & 1) == 0) {
      m >>= 1;
    }
    while (m % 3 == 0) {
      m /= 3;
    }
    return m == 1;
  }

  protected int count(final long n) {
    if (n > TABLE_LIMIT) {
      // For large values recompute to avoid excessive table size
      return isTerminal(n) ? 0 : count(A001615.dedekindPsi(n).longValueExact()) + 1;
    }
    final int res = mCache.get(n);
    if (res != 0) {
      return res - 1;
    }
    if (isTerminal(n)) {
      mCache.set(n, (byte) 1);
      return 0;
    }
    final int r = count(A001615.dedekindPsi(n).longValue()) + 1;
    mCache.set(n, (byte) (r + 1));
    return r;
  }

  @Override
  public Z next() {
    ++mN;
    while (count(mM) < mN) {
      ++mM;
    }
    return Z.valueOf(mM);
  }
}
#!queue	A019538	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a019;

import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A019538 Triangle of numbers T(n,k) = k!*Stirling2(n,k) read by rows (n &gt;= 1, 1 &lt;= k &lt;= n).
 * @author Sean A. Irvine
 */
public class A019538 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A019538() {
    super(1);
  }

  private long mN = 0;
  private long mK = 0;
  private Z mFactorialK = Z.ONE;

  @Override
  public Z next() {
    if (++mK > mN) {
      ++mN;
      mK = 1;
      mFactorialK = Z.ONE;
    }
    mFactorialK = mFactorialK.multiply(mK);
    return mFactorialK.multiply(Stirling.secondKind(mN, mK));
  }
}
#!queue	A019575	1	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a019;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A019575 Place n distinguishable balls in n boxes (in n^n ways); let T(n,k) = number of ways that the maximum in any box is k, for 1 &lt;= k &lt;= n; sequence gives triangle of numbers T(n,k).
 * @author Sean A. Irvine
 */
public class A019575 extends MemoryFunctionInt3Sequence<Q> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A019575() {
    super(1);
  }

  private int mN = 0;
  private Z mF = Z.ONE;
  private int mM = 0;

  @Override
  protected Q compute(final int n, final int i, final int k) {
    if (n == 0) {
      return Q.ONE;
    }
    Q sum = Q.ZERO;
    if (i >= 1) {
      Z jf = Z.ONE;
      for (int j = 0; j <= Math.min(k, n); ++j) {
        if (j > 1) {
          jf = jf.multiply(j);
        }
        sum = sum.add(get(n - j, i - 1, k).divide(jf));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      mF = mF.multiply(++mN);
      mM = 1;
    }
    return get(mN, mN, mM).subtract(get(mN, mN, mM - 1)).multiply(mF).toZ();
  }
}
#!queue	A019654	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a019;

import java.util.Arrays;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A019654 Consider problem of placing N queens on an n X n board so that each queen attacks precisely k others. Here k=4 and sequence gives number of different solutions when N takes its maximal value.
 * @author Sean A. Irvine
 */
public class A019654 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A019654() {
    super(3);
  }

  // Placing queens so that they attack a precise number of other queens.
  // In general, we want to count the number of solutions for the maximal number of queens
  // that satisfy the other constraints.
  //
  // Solutions are built up incrementally by adding queens one at a time, truncating the
  // search whenever a violation of some constraint is detected.
  //
  // We keep track of the number of queens attacking each square on the board; in fact,
  // we actually use bit sets so we can also tell the directions those attacks are
  // coming from.  This makes it easier to incrementally add a new queen.
  //
  // Partially inspired by C code by Manfred Scheucher

  protected static final int QUEEN_BIT = 1 << 9; // first 8 bits used for directions

  protected final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  protected int mSize = 0;
  protected int mExactAttack = 0;
  protected long mMaximalQueens = 0;
  protected long mMaximalCount = 0;
  // Follow arrays used to avoid churn
  private int[] mWorkspace1 = null;
  private int[] mWorkspace2 = null;

  private int get(final int[] attacks, final int x, final int y) {
    return attacks[y * mSize + x];
  }

  private void set(final int[] attacks, final int x, final int y, final int v) {
    attacks[y * mSize + x] = v;
  }

  protected void or(final int[] attacks, final int x, final int y, final int bit) {
    attacks[y * mSize + x] |= bit;
  }

  protected int pop(final int[] attacks, final int x, final int y) {
    return Integer.bitCount(get(attacks, x, y) & 0xFF); // mask out queen bit
  }

  private int compare(final int[] board1, final int[] board2) {
    for (int k = 0; k < board1.length; ++k) {
      final int c = Integer.compare(board1[k] & QUEEN_BIT, board2[k] & QUEEN_BIT);
      if (c != 0) {
        return c;
      }
    }
    return 0;
  }

  private void flip(final int[] src, final int[] dest) {
    for (int y = 0; y < mSize; ++y) {
      for (int x = 0; x < mSize; ++x) {
        set(dest, y, x, get(src, x, y));
      }
    }
  }

  private void rotate(final int[] src, final int[] dest) {
    for (int y = 0; y < mSize; ++y) {
      for (int x = 0; x < mSize; ++x) {
        set(dest, mSize - 1 - y, x, get(src, x, y));
      }
    }
  }

  protected boolean isCanonical(final int[] board) {
    // rotate 90
    rotate(board, mWorkspace1);
    if (compare(board, mWorkspace1) > 0) {
      return false;
    }

    // rotate 180
    rotate(mWorkspace1, mWorkspace2);
    if (compare(board, mWorkspace2) > 0) {
      return false;
    }

    // rotate 270
    rotate(mWorkspace2, mWorkspace1);
    if (compare(board, mWorkspace1) > 0) {
      return false;
    }

    // mirrored 0
    flip(board, mWorkspace1);
    if (compare(board, mWorkspace1) > 0) {
      return false;
    }

    // mirrored 90
    rotate(mWorkspace1, mWorkspace2);
    if (compare(board, mWorkspace2) > 0) {
      return false;
    }

    // mirrored 180
    rotate(mWorkspace2, mWorkspace1);
    if (compare(board, mWorkspace1) > 0) {
      return false;
    }

    // mirrored 270
    rotate(mWorkspace1, mWorkspace2);
    return compare(board, mWorkspace2) <= 0;
  }

  protected boolean markAndCheck(final int[] attacks, final int x0, final int y0, final int dx, final int dy, final int bit) {
    // Placing queen at (x0,y0), fail if the count for an existing queen goes too high
    for (int x = x0 + dx, y = y0 + dy; x >= 0 && y >= 0 && x < mSize && y < mSize; x += dx, y += dy) {
      or(attacks, x, y, bit);
      final int sq = get(attacks, x, y);
      if (sq >= QUEEN_BIT && Integer.bitCount(sq & 0xFF) > mExactAttack) {
        return false;
      }
    }
    return true;
  }

  protected boolean isExact(final int[] attacks) {
    // Check that each queen attacks the required number of other queens, this
    // is actually done by checking that each queen is attacked by the required
    // number of queens.
    for (final int v : attacks) {
      if (v >= QUEEN_BIT && Integer.bitCount(v & 0xFF) != mExactAttack) {
        return false;
      }
    }
    return true;
  }

  private String dump(final int[] attacks) {
    final StringBuilder sb = new StringBuilder();
    for (final int attack : attacks) {
      sb.append(attack >= QUEEN_BIT ? "Q" : ".");
    }
    return sb.toString();
  }

  protected long solve(final int n, final int queens, final int attack) {
    if (mVerbose) {
      System.out.println("Solving for board size " + n + " with " + queens + " queens");
    }
    mSize = n;
    mMaximalQueens = queens;
    mMaximalCount = 0;
    mExactAttack = attack;
    mWorkspace1 = new int[n * n];
    mWorkspace2 = new int[n * n];
    search(new int[n * n], 0, 0, 0, n * n);
    return mMaximalCount;
  }

  protected void search(final int[] attacks, final int queen, final int x, final int y, final int remaining) {
    if (y >= mSize) {
      // Search is done
      if (queen >= mMaximalQueens && isExact(attacks)) {
        if (isCanonical(attacks)) {
          if (queen > mMaximalQueens) {
            mMaximalQueens = queen;
            mMaximalCount = 1;
            if (mVerbose) {
              System.out.println("Maximal queens now " + mMaximalQueens);
            }
          } else {
            ++mMaximalCount;
          }
          if (mVerbose) {
            System.out.println("Search: queens=" + queen + " " + dump(attacks));
          }
        }
      }
      return;
    }
    if (remaining < mMaximalQueens - queen) {
      return; // Insufficient remaining squares to achieve current best
    }
    if (x >= mSize) {
      // Move to next row
      search(attacks, queen, 0, y + 1, remaining);
      return;
    }
    // Consider placing at queen at (x,y)
    if (pop(attacks, x, y) <= mExactAttack) {
      final int[] newBits = Arrays.copyOf(attacks, attacks.length);
      // Mark all consequences by expanding in all 8 directions from (x,y)
      or(newBits, x, y, QUEEN_BIT);
      if (markAndCheck(newBits, x, y, 1, 0, 1)
        && markAndCheck(newBits, x, y, -1, 0, 2)
        && markAndCheck(newBits, x, y, 0, 1, 4)
        && markAndCheck(newBits, x, y, 0, -1, 8)
        && markAndCheck(newBits, x, y, 1, 1, 16)
        && markAndCheck(newBits, x, y, 1, -1, 32)
        && markAndCheck(newBits, x, y, -1, 1, 64)
        && markAndCheck(newBits, x, y, -1, -1, 128)) {
        // Placement looks ok, try another queen
        search(newBits, queen + 1, x + 1, y, remaining - 1);
      }
    }
    search(attacks, queen, x + 1, y, remaining - 1);
  }

  protected long solve(final int n, final int attack) {
    if (mVerbose) {
      System.out.println("Solving for board size " + n);
    }
    mSize = n;
    mMaximalQueens = 1; // It could be argued that placing no queens is a solution -- but we avoid that here for consistency with the OEIS
    if (attack == 4 && n > 5) {
      // Known result from theory, see A063724
      mMaximalQueens = 3L * n - 3;
    }
    mMaximalCount = 0;
    mExactAttack = attack;
    mWorkspace1 = new int[n * n];
    mWorkspace2 = new int[n * n];
    search(new int[n * n], 0, 0, 0, n * n);
    return mMaximalCount;
  }

  private int mN = 2;

  @Override
  public Z next() {
    return Z.valueOf(solve(++mN, 4));
  }
}
#!queue	A020985	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a020;

import java.util.ArrayList;
import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A020985 The Rudin-Shapiro or Golay-Rudin-Shapiro sequence (coefficients of the Shapiro polynomials).
 * @author Sean A. Irvine
 */
public class A020985 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A020985() {
    super(0);
  }

  protected long mN = -1;
  protected final LongDynamicBooleanArray mA = new LongDynamicBooleanArray();

  @Override
  public Z next() {
    final boolean a;
    if (++mN == 0) {
      a = true;
    } else if ((mN & 3) == 3) {
      a = !mA.isSet(mN / 2);
    } else {
      a = mA.isSet(mN / 2);
    }
    if (a) {
      mA.set(mN);
      return Z.ONE;
    } else {
      return Z.NEG_ONE;
    }
  }

  /**
   * This main actually does computation for A005943.
   * @param args limit in bits for number of terms in A020985, term limit for A005943
   */
  public static void main(final String[] args) {
    final A020985 seq = new A020985();
    final int termLimit = Integer.parseInt(args[1]);
    if (termLimit > 63) {
      throw new UnsupportedOperationException();
    }
    final ArrayList<HashSet<Long>> seen = new ArrayList<>();
    for (int k = 0; k < termLimit; ++k) {
      seen.add(new HashSet<>());
    }
    final long steps = 1L << Integer.parseInt(args[0]);
    for (long u = 0, v = 0; u < steps; ++u) {
      v <<= 1;
      if (seq.next().signum() > 0) {
        v |= 1;
      }
      long m = 1;
      for (int k = 0; k < Math.min(u, termLimit); ++k, m <<= 1, m |= 1) {
        seen.get(k).add(v & m);
      }
    }
    for (int k = 0; k < termLimit; ++k) {
      System.out.println(k + " " + seen.get(k).size());
    }
  }
}
#!queue	A022300	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A022300 The sequence a of 1's and 2's starting with (1,1,2,1) such that a(n) is the length of the (n+2)nd run of a.
 * @author Sean A. Irvine
 */
public class A022300 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A022300() {
    super(1);
  }

  private final LongDynamicBooleanArray mA = new LongDynamicBooleanArray();

  {
    mA.set(2);
  }

  protected long mN = -1;
  private long mS = 0;
  private long mT = 3;

  @Override
  public Z next() {
    if (++mN == mT) {
      final boolean next = !mA.isSet(mT - 1);
      final boolean b = mA.isSet(mS++);
      if (b) {
        // i.e. a "2"
        if (next) {
          mA.set(mT);
          mA.set(mT + 1);
        }
        mT += 2;
      } else {
        // i.e. a "1"
        if (next) {
          mA.set(mT);
        }
        ++mT;
      }
    }
    return mA.isSet(mN) ? Z.TWO : Z.ONE;
  }
}
#!queue	A022303	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A022303 The sequence a of 1's and 2's starting with (1,2,1) such that a(n) is the length of the (n+2)nd run of a.
 * @author Sean A. Irvine
 */
public class A022303 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A022303() {
    super(1);
  }

  protected final LongDynamicBooleanArray mA = new LongDynamicBooleanArray();

  {
    mA.set(1);
  }

  protected long mN = -1;
  private long mS = 0;
  private long mT = 2;

  protected void ensure(final long n) {
    if (n == mT) {
      final boolean next = !mA.isSet(mT - 1);
      final boolean b = mA.isSet(mS++);
      if (b) {
        // i.e. a "2"
        if (next) {
          mA.set(mT);
          mA.set(mT + 1);
        }
        mT += 2;
      } else {
        // i.e. a "1"
        if (next) {
          mA.set(mT);
        }
        ++mT;
      }
    }
  }

  @Override
  public Z next() {
    ensure(++mN);
    return mA.isSet(mN) ? Z.TWO : Z.ONE;
  }
}

#!queue	A022811	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a022;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.MemoryFunction3;
import irvine.math.z.Z;

/**
 * A022811 Number of terms in n-th derivative of a function composed with itself 3 times.
 * @author Sean A. Irvine
 */
public class A022811 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After Jean-Fran&ccedil;ois Alcover, after Alois P. Heinz

  private final MemoryFunction3<Long, Z> mB = new MemoryFunction3<Long, Z>() {
    @Override
    protected Z compute(final Long n, final Long i, final Long k) {
      if (n < k) {
        return Z.ZERO;
      }
      if (n == 0) {
        return Z.ONE;
      }
      if (i < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      for (long j = 0; j <= Math.min(n / i, k); ++j) {
        sum = sum.add(get(n - i * j, i - 1, k - j));
      }
      return sum;
    }
  };

  private long mN = -1;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long i = 0; i <= n; ++i) {
      sum = sum.add(mB.get(n, n, i).multiply(get(i, k - 1)));
    }
    return sum;
  }

  @Override
  public Z next() {
    return get(++mN, 3L);
  }
}
#!queue	A022821	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a022;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A022821 [ (n+1)/(n-1) ] + [ (n+2)/(n-2) ] + ... + [ (2n-1)/1 ].
 * @author Sean A. Irvine
 */
public class A022821 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A022821() {
    super(2);
  }

  protected long mN = 1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 1; k < mN; ++k) {
      sum = sum.add((2 * mN - k) / k);
    }
    return sum;
  }
}
#!queue	A022894	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a022;

import java.util.ArrayList;

import irvine.factor.prime.Fast;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;
import irvine.util.array.LongDynamicLongArray;

/**
 * A022894 Number of solutions to c(1)*prime(1) +...+ c(2n+1)*prime(2n+1) = 0, where c(i) = +-1 for i &gt; 1, c(1) = 1.
 * @author Sean A. Irvine
 */
public class A022894 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After Alois P. Heinz

  private long mN = -1;
  private final Fast mPrime = new Fast();
  private final LongDynamicLongArray mPrimes = new LongDynamicLongArray();
  private final ArrayList<Z> mSumPrimes = new ArrayList<>();
  {
    mPrimes.set(0, start());
    mSumPrimes.add(Z.ZERO);
    mSumPrimes.add(Z.ZERO);
  }

  protected long start() {
    return 0;
  }

  private long p(final long n) {
    while (n >= mPrimes.length()) {
      mPrimes.set(mPrimes.length(), mPrime.nextPrime(mPrimes.get(mPrimes.length() - 1)));
    }
    return mPrimes.get(n);
  }

  private Z sp(final int n) {
    while (n >= mSumPrimes.size()) {
      mSumPrimes.add(mSumPrimes.get(mSumPrimes.size() - 1).add(p(mSumPrimes.size())));
    }
    return mSumPrimes.get(n);
  }

  @Override
  protected Z compute(final Long n, final Long i) {
    if (Z.valueOf(n).compareTo(sp(i.intValue())) > 0) {
      return Z.ZERO;
    }
    if (i == 1) {
      return Z.ONE;
    }
    return get(n + p(i), i - 1).add(get(Math.abs(n - p(i)), i - 1));
  }

  @Override
  public Z next() {
    mN += 2;
    return get(2L, mN);
  }
}
#!queue	A023024	4	->	4	AbstractSequence	--------------------------------
package irvine.oeis.a023;

import irvine.math.Mobius;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A023024 Number of partitions of n into 4 unordered relatively prime parts.
 * @author Sean A. Irvine
 */
public class A023024 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A023024() {
    super(4);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = parts() - 1;

  protected int parts() {
    return 4;
  }

  private Polynomial<Z> den(final int k, final int n) {
    Polynomial<Z> prod = RING.one();
    for (int i = 1; i <= parts(); ++i) {
      prod = RING.multiply(prod, RING.oneMinusXToTheN(i * k), n);
    }
    return prod;
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 1; parts() * k <= mN; ++k) {
      final int m = Mobius.mobius(k);
      if (m != 0) {
        final int t = mN - parts() * k;
        sum = sum.signedAdd(m > 0, RING.coeff(RING.one(), den(k, t), t));
      }
    }
    return sum;
  }
}
#!queue	A023094	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a023;

import java.util.ArrayList;
import java.util.Collections;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A023094 a(n) is least k such that k and 2k are anagrams in base n (written in base 10).
 * @author Sean A. Irvine
 */
public class A023094 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A023094() {
    super(3);
  }

  private int mBase = multiple();

  private ArrayList<Integer> syndrome(long n, final int base) {
    final ArrayList<Integer> res = new ArrayList<>();
    while (n != 0) {
      res.add((int) (n % base));
      n /= base;
    }
    Collections.sort(res);
    return res;
  }

  protected int multiple() {
    return 2;
  }

  @Override
  public Z next() {
    ++mBase;
    long k = 0;
    while (true) {
      ++k;
      if (syndrome(k, mBase).equals(syndrome(multiple() * k, mBase))) {
        return Z.valueOf(k);
      }
    }
  }
}
#!queue	A023416	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a023;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A023416 Number of 0's in binary expansion of n.
 * @author Sean A. Irvine
 */
public class A023416 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A023416() {
    super(0);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    mN = mN.add(1);
    return mN.isZero() ? Z.ONE : Z.valueOf(mN.bitLength() - mN.bitCount());
  }
}
#!queue	A023847	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a023;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A023847 Sum of exponents in prime-power factorization of binomial(5n, 2n).
 * @author Sean A. Irvine
 * @author Georg FIscher
 */
public class A023847 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN;
  private int mNf;
  private int mMf;
  private int mMa;

  /** Construct the sequence. */
  public A023847() {
    this(0, 5, 2, 0);
  }

  /**
   * Generic constructor with parameters.
   * @param offset first index
   * @param nf factor of n
   * @param mf factor of m
   * @param ma add this to mf * m
   */
  public A023847(final int offset, final int nf, final int mf, final int ma) {
    super(offset);
    mN = offset - 1;
    mNf = nf;
    mMf = mf;
    mMa = ma;
  }

  protected long binomialOmega(final long n, final long m) {
    final FactorSequence fsTop = new FactorSequence();
    for (long k = m + 1; k <= n; ++k) {
      fsTop.add(k, FactorSequence.UNKNOWN, 1);
    }
    final FactorSequence fsBot = new FactorSequence();
    for (long k = 2; k <= n - m; ++k) {
      fsBot.add(k, FactorSequence.UNKNOWN, 1);
    }
    Jaguar.factor(fsTop);
    Jaguar.factor(fsBot);
    return fsTop.bigOmega() - fsBot.bigOmega();
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(binomialOmega(mNf * mN, mMf * mN + mMa));
  }
}

#!queue	A024670	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A024670 Numbers that are sums of 2 distinct positive cubes.
 * @author Sean A. Irvine
 */
public class A024670 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A024670() {
    super(1);
  }

  private long mN = 8;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      for (long k = 1; k * k * k * 2 < mN; ++k) {
        if (ZUtils.isCube(Z.valueOf(mN - k * k * k))) {
          return Z.valueOf(mN);
        }
      }
    }
  }
}
#!queue	A024814	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a024;

import irvine.math.cr.CR;
import irvine.math.cr.ComputableReals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A024814 Least k such that tan(k) &gt; tan(a(n-1)), for n &gt;= 1, where a(0) = 0.
 * @author Sean A. Irvine
 */
public class A024814 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A024814() {
    super(0);
  }

  private long mN = -1;
  private CR mTan = CR.valueOf(-1);

  @Override
  public Z next() {
    while (true) {
      final CR tan = ComputableReals.SINGLETON.tan(CR.valueOf(++mN));
      if (tan.compareTo(mTan) > 0) {
        mTan = tan;
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A024941	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a024;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a002.A002144;

/**
 * A024941 Number of partitions of n into distinct primes of the form 4k + 1.
 * @author Sean A. Irvine
 */
public class A024941 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A024941() {
    super(0);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = -1;

  protected Sequence seq() {
    return new A002144();
  }

  @Override
  public Z next() {
    ++mN;
    final Sequence primes = seq();
    Polynomial<Z> prod = RING.one();
    int p;
    while ((p = primes.next().intValueExact()) <= mN) {
      prod = RING.multiply(prod, p == 0 ? RING.one() : RING.onePlusXToTheN(p), mN);
    }
    return prod.coeff(mN);
  }
}
#!queue	A024975	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a024;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A024975 Sums of three distinct positive cubes.
 * @author Sean A. Irvine
 */
public class A024975 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A024975() {
    super(1);
  }

  private long mN = 1;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      for (long x = 1; 3 * x * x * x < mN; ++x) {
        final long u = mN - x * x * x;
        for (long y = x + 1; 2 * y * y * y < u; ++y) {
          final long v = u - y * y * y;
          final long s = Z.valueOf(v).root(3).longValueExact();
          if (s * s * s == v) {
            return Z.valueOf(mN);
          }
        }
      }
    }
  }
}
#!queue	A024996	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a024;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A024996 Triangular array, read by rows: second differences in n,n direction of trinomial array A027907.
 * @author Sean A. Irvine
 */
public class A024996 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mM = 0;
  private long mN = -1;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 0 || m < 0 || m > 2 * n) {
      return Z.ZERO;
    } else if (n <= 2) {
      if (m == 0 || m == 2 * n) {
        return Z.ONE;
      } else if (m == 1 || m == 2 * n - 1) {
        return Z.ZERO;
      } else {
        return Z.TWO;
      }
    }
    return get(n - 1, m - 1).add(get(n - 1, m - 2).add(get(n - 1, m)));
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A025134	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025134 a(n) = n-th elementary symmetric function of C(n,0), C(n,1), ..., C(n,n).
 * @author Sean A. Irvine
 */
public class A025134 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025134() {
    super(0);
  }

  private long mN = -1;

  protected Z sym(final Z prod, final long a, final long max, final long upper, final long n) {
    if (n == 0) {
      return prod;
    }
    Z sum = Z.ZERO;
    for (long b = a; b <= max; ++b) {
      sum = sum.add(sym(prod.multiply(Binomial.binomial(upper, b)), b + 1, max, upper, n - 1));
    }
    return sum;
  }

  @Override
  public Z next() {
    return sym(Z.ONE, 0, ++mN, mN, mN);
  }
}
#!queue	A025177	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A025177 Triangular array, read by rows: first differences in n,n direction of trinomial array A027907.
 * @author Sean A. Irvine
 */
public class A025177 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 0 || m > 2 * n) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    if (n == 1) {
      return m == 1 ? Z.ZERO : Z.ONE;
    }
    return get(n - 1, m - 2).add(get(n - 1, m - 1).add(get(n - 1, m)));
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A025179	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025179 a(n) = number of (s(0), s(1), ..., s(n)) such that s(i) is an integer, s(0) = 0, |s(1)| = 1, |s(i) - s(i-1)| &lt;= 1 for i &gt;= 2, s(n) = 1. Also a(n) = T(n,n-1), where T is the array defined in A025177.
 * @author Sean A. Irvine
 */
public class A025179 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025179() {
    super(2);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN / 2; ++k) {
      sum = sum.add(Binomial.binomial(mN, 2 * k).multiply(Binomial.binomial(2 * k + 1, k + 1)));
    }
    return sum;
  }
}
#!queue	A025194	3	->	3	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a025;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionSequence;

/**
 * A025194 a(n) = [ 3rd elementary symmetric function of {sqrt(k)} ], k = 1,2,...,n.
 * @author Sean A. Irvine
 */
public class A025194 extends MemoryFunctionSequence<Long, CR> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025194() {
    super(3);
  }

  private long mN = 2;
  private CR mSum = CR.ZERO;

  @Override
  protected CR compute(final Long key) {
    return CR.valueOf(key).sqrt();
  }

  @Override
  public Z next() {
    final Long key = ++mN;
    final CR sk = get(key);
    for (long j = 2; j < mN; ++j) {
      final CR sj = sk.multiply(get(j));
      for (long i = 1; i < j; ++i) {
        mSum = mSum.add(sj.multiply(get(i)));
      }
    }
    return mSum.floor();
  }
}
#!queue	A025564	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a025;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A025564 Triangular array, read by rows: pairwise sums of trinomial array A027907.
 * @author Sean A. Irvine
 */
public class A025564 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private static final Z[] N2 = {Z.ONE, Z.THREE, Z.FOUR, Z.THREE, Z.ONE};
  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 0 || m > 2 * n) {
      return Z.ZERO;
    }
    if (n <= 2) {
      if (n == 0) {
        return Z.ONE;
      }
      if (n == 1) {
        return m == 1 ? Z.TWO : Z.ONE;
      }
      return N2[m.intValue()];
    }
    return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }

}
#!queue	A025610	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025610 Numbers of form 2^i*6^j, with i, j &gt;= 0; equivalently, numbers of the form 2^i*3^j with 0 &lt;= j &lt;= i.
 * @author Sean A. Irvine
 */
public class A025610 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025610() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply2());
    mPriority.add(r.multiply(6));
    return r;
  }
}
#!queue	A025611	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025611 Numbers of form 2^i*9^j, with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A025611 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025611() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply2());
    mPriority.add(r.multiply(9));
    return r;
  }
}
#!queue	A025617	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025617 Numbers of form 4^i*5^j, with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A025617 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025617() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply(4));
    mPriority.add(r.multiply(5));
    return r;
  }
}
#!queue	A025618	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025618 Numbers of form 4^i*6^j, with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A025618 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025618() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply(4));
    mPriority.add(r.multiply(6));
    return r;
  }
}
#!queue	A025621	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025621 Numbers of form 4^i*10^j, with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A025621 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025621() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply(4));
    mPriority.add(r.multiply(10));
    return r;
  }
}
#!queue	A025622	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025622 Numbers of form 5^i*6^j, with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A025622 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025622() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply(5));
    mPriority.add(r.multiply(6));
    return r;
  }
}
#!queue	A025635	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a025;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A025635 Numbers of form 9^i*10^j, with i, j &gt;= 0.
 * @author Sean A. Irvine
 */
public class A025635 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A025635() {
    super(1);
  }

  private final TreeSet<Z> mPriority = new TreeSet<>();

  {
    mPriority.add(Z.ONE);
  }

  @Override
  public Z next() {
    final Z r = mPriority.pollFirst();
    mPriority.add(r.multiply(9));
    mPriority.add(r.multiply(10));
    return r;
  }
}
#!queue	A026009	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026009 Triangular array T read by rows: T(n,0) = 1 for n &gt;= 0; T(1,1) = 1; and for n &gt;= 2, T(n,k) = T(n-1,k-1) + T(n-1,k) for k = 1,2,...,[(n+1)/2]; T(n,n/2 + 1) = T(n-1,n/2) if n is even.
 * @author Sean A. Irvine
 */
public class A026009 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026009() {
    super(0);
  }

  private long mN = 0;
  private long mM = 0;

  protected Z t(final long n, final long m) {
    return Binomial.binomial(n, m).subtract(Binomial.binomial(n, m - 3)).max(Z.ONE);
  }

  @Override
  public Z next() {
    if (++mM > mN / 2 + 1) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}

#!queue	A026022	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026022 Triangular array T read by rows: T(n,0) = 1 for n &gt;= 0; T(n,k) = C(n,k) for k = 1,2,...,n, for n = 1,2,3; and for n &gt;= 4, T(n,k) = T(n-1,k-1) + T(n-1,k) for k = 1,2,...,[ (n+2)/2 ] and T(n,(n+3)/2) = T(n-1,(n+1)/2) if n is odd.
 * @author Sean A. Irvine
 */
public class A026022 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026022() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  protected Z t(final long n, final long m) {
    return Binomial.binomial(n, m).subtract(Binomial.binomial(n, m - 4)).max(Z.ONE);
  }

  @Override
  public Z next() {
    final long lim = mN >= 3 ? (mN + 1) / 2 + 1 : mN;
    if (++mM > lim) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}

#!queue	A026082	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026082 Irregular triangular array T read by rows: T(n,k) = C(n,k) for k=0..n for n = 0,1,2,3. For n &gt;= 4, T(n,0) = T(n,2n)=1, T(n,1) = T(n,2n-1) = n - 3, T(4,2) = 4, T(4,3) = 3, T(4,4) = 6; T(4,5) = 3, T(4,6)=4; for n &gt;= 5, T(n,k) = T(n-1,k-2) + T(n-1,k-1) + T(n-1,k) for k=2..2n-2.
 * @author Sean A. Irvine
 */
public class A026082 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026082() {
    super(1);
  }

  private static final Z[] N4 = {Z.ONE, Z.ONE, Z.FOUR, Z.THREE, Z.SIX, Z.THREE, Z.FOUR, Z.ONE, Z.ONE};
  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 0 || m < 0 || m > 2 * n) {
      return Z.ZERO;
    } else if (n <= 3) {
      return Binomial.binomial(n, m);
    } else if (n == 4) {
      return N4[m.intValue()];
    } else if (m == 0 || m == 2 * n) {
      return Z.ONE;
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    do {
      if (++mM > 2 * mN) {
        ++mN;
        mM = 0;
      }
    } while (get(mN, mM).isZero());
    return get(mN, mM);
  }
}

#!queue	A026148	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026148 Irregular triangular array T read by rows: T(n,0) = 1 for i &gt;= 0, T(1,1) = 1,T(2,1) = 1, T(2,2) = 2, T(2,3) = 1, T(2,4) = 1 and for n &gt;= 3, T(n,1) = n-1,  T(n,k) = T(n-1,k-2) + T(n-1,k-1) + T(n-1,k) for k=2,...,n+1, and T(n, k+2) = T(n-1, k) + T(n-1, k+1).
 * @author Sean A. Irvine
 */
public class A026148 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026148() {
    super(1);
  }

  private long mN = -1;
  private long mM = -1;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || n == 1) {
      return Z.ONE;
    }
    if (n == 2) {
      return m == 2 ? Z.TWO : Z.ONE;
    }
    if (m == 1) {
      return Z.valueOf(n - 1);
    }
    if (m == n + 2) {
      return get(n - 1, m - 2).add(get(n - 1, m - 1));
    }
    return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (mN < 2) {
      ++mN;
      return Z.ONE;
    }
    if (++mM > mN + 2) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026268	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026268 Triangle, T(n, k): T(n,k) = 1 for n &lt; 3, T(3,1) = T(3,2) = T(3,3) = 2, T(n,0) = 1, T(n,1) = n-1, T(n,n) = T(n-1,n-2) + T(n-1,n-1), otherwise T(n,k) = T(n-1,k-2) + T(n-1,k-1) + T(n-1,k), read by rows.
 * @author Sean A. Irvine
 */
public class A026268 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || n <= 2) {
      return Z.ONE;
    }
    if (n == 3) {
      return Z.TWO;
    }
    if (m == 1) {
      return Z.valueOf(n - 1);
    }
    if (m.equals(n)) {
      return get(n - 1, n - 2).add(get(n - 1, n - 1));
    }
    return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026300	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026300 Motzkin triangle, T, read by rows; T(0,0) = T(1,0) = T(1,1) = 1; for n &gt;= 2, T(n,0) = 1, T(n,k) = T(n-1,k-2) + T(n-1,k-1) + T(n-1,k) for k = 1,2,...,n-1 and T(n,n) = T(n-1,n-2) + T(n-1,n-1).
 * @author Sean A. Irvine
 */
public class A026300 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026300() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  protected Z t(final long n, final long m) {
    Z sum = Z.ZERO;
    for (long k = 0; k <= m / 2; ++k) {
      final long u = 2 * k + n - m;
      sum = sum.add(Binomial.binomial(n, u).multiply(Binomial.binomial(u, k).subtract(Binomial.binomial(u, k - 1))));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A026323	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026323 Irregular triangular array T read by rows: T(0,0) = 1, T(0,1) = T(0,2) = 0; T(1,0) = T(1,1) = T(1,2) = 1, T(1,3) = 0; for n &gt;= 2, T(n,0) = 1, T(n,1) = T(n-1,0) + T(n-1,1), T(n,k) = T(n-1,k-2) + T(n-1,k-1) + T(n-1,k) for k = 2,3,...,n+1 and T(n,n+2) = T(n-1,n) + T(n-1,n+1).
 * @author Sean A. Irvine
 */
public class A026323 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026323() {
    super(1);
  }

  private long mN = -1;
  private long mM = 1;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0) {
      return m == 0 ? Z.ONE : Z.ZERO;
    }
    if (n == 1) {
      return m <= 2 ? Z.ONE : Z.ZERO;
    }
    if (m == 0) {
      return Z.ONE;
    }
    if (m == 1) {
      return get(n - 1, 0L).add(get(n - 1, 1L));
    }
    if (m == n + 2) {
      return get(n - 1, n).add(get(n - 1, n + 1));
    }
    return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN + 2) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026374	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026374 Triangular array T read by rows: T(n,0) = T(n,n) = 1 for all n &gt;= 0, T(n,k) = T(n-1,k-1) + T(n-1,k) for odd n and 1&lt; = k &lt;= n-1, T(n,k) = T(n-1,k-1) + T(n-1,k) + T(n-2,k-1) for even n and 1 &lt;= k &lt;= n-1.
 * @author Sean A. Irvine
 */
public class A026374 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026374() {
    super(0);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private static final Polynomial<Z> EVEN = Polynomial.create(1, 3, 1);
  protected Polynomial<Z> mGfRow = RING.zero();
  protected int mN = -1;
  private int mM = 0;

  protected void nextRow() {
    if ((++mN & 1) == 0) {
      mGfRow = RING.pow(EVEN, mN / 2);
    } else {
      mGfRow = RING.multiply(mGfRow, RING.onePlusXToTheN(1));
    }
  }

  @Override
  public Z next() {
    if (++mM > mGfRow.degree()) {
      mM = 0;
      nextRow();
    }
    return mGfRow.coeff(mM);
  }

}
#!queue	A026386	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026386 Triangular array T read by rows: T(n,0) = T(n,n) = 1 for all n &gt;= 0; T(n,k) = T(n-1,k-1) + T(n-1,k) for even n and k = 1..n-1; T(n,k) = T(n-1,k-1) + T(n-1,k) + T(n-2,k-1) for odd n and k = 1 ..n-1.
 * @author Sean A. Irvine
 */
public class A026386 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    } else if (m < 0 || m > n) {
      return Z.ZERO;
    } else if ((n & 1) == 0) {
      return get(n - 1, m - 1).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026400	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a026;

import java.util.TreeMap;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026400 For n &gt;= 1, n n's take places at stage n: the first n takes the least untaken place (l.u.p.) and for 2&lt;=k&lt;=n, the k-th n takes the l.u.p. at least (k-1)*n places past the place of the first n.
 * @author Sean A. Irvine
 */
public class A026400 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026400() {
    super(1);
  }

  protected final TreeMap<Long, Long> mMap = new TreeMap<>();
  private long mM = 0; // Number to be inserted
  private long mN = 0; // Position we want output for

  protected void step(final long n) {
    ++mM;
    mMap.put(n, mM);
    for (long k = 2; k <= mM; ++k) {
      long s = (k - 1) * mM + n;
      while (mMap.containsKey(s)) {
        ++s;
      }
      mMap.put(s, mM);
    }
  }

  @Override
  public Z next() {
    ++mN;
    while (!mMap.containsKey(mN)) {
      step(mN);
    }
    return Z.valueOf(mMap.pollFirstEntry().getValue());
  }
}
#!queue	A026409	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a026;

import java.util.TreeMap;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026409 For n &gt;= 1, n n's take places at stage n: the first takes the least untaken place (l.u.p) and for 2&lt;=k&lt;=n, the k-th n takes the l.u.p. more than n-1 places past the place of the (k-1)st n.
 * @author Sean A. Irvine
 */
public class A026409 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026409() {
    super(1);
  }

  protected final TreeMap<Long, Long> mMap = new TreeMap<>();
  private long mM = 0; // Number to be inserted
  private long mN = 0; // Position we want output for

  protected void step(final long n) {
    ++mM;
    mMap.put(n, mM);
    for (long k = 2, s = n; k <= mM; ++k) {
      s += mM;
      while (mMap.containsKey(s)) {
        ++s;
      }
      mMap.put(s, mM);
    }
  }

  @Override
  public Z next() {
    ++mN;
    while (!mMap.containsKey(mN)) {
      step(mN);
    }
    return Z.valueOf(mMap.pollFirstEntry().getValue());
  }
}
#!queue	A026519	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026519 Irregular triangular array T read by rows: T(n, k) = T(n-1, k-2) + T(n-1, k) if (n mod 2) = 0, otherwise T(n-1, k-2) + T(n-1, k-1) + T(n-1, k), with T(n, 0) = T(n, 2*n) = 1, T(n, 1) = T(n, 2*n-1) = floor((n+1)/2).
 * @author Sean A. Irvine
 */
public class A026519 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m == 2 * n) {
      return Z.ONE;
    }
    if (m == 1 || m == 2 * n - 1) {
      return Z.valueOf((n + 1) / 2);
    }
    if ((n & 1) == 0) {
      return get(n - 1, m - 2).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026536	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026536 Irregular triangular array T read by rows: T(i,0 ) = T(i,2i) = 1 for i &gt;= 0; T(i,1) = T(i,2i-1) = floor(i/2) for i &gt;= 1; for even n &gt;= 2, T(i,j) = T(i-1,j-2) + T(i-1,j-1) + T(i-1,j) for j = 2..2i-2, for odd n &gt;= 3, T(i,j) = T(i-1,j-2) + T(i-1,j) for j = 2..2i-2.
 * @author Sean A. Irvine
 */
public class A026536 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m == 2 * n) {
      return Z.ONE;
    }
    if (m == 1 || m == 2 * n - 1) {
      return Z.valueOf(n / 2);
    }
    if ((n & 1) == 0) {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026552	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026552 Irregular triangular array T read by rows: T(n, 0) = T(n, 2*n) = 1, T(n, 1) = T(n, 2*n-1) = floor(n/2 + 1), for even n &gt;= 2, T(n, k) = T(n-1, k-2) + T(n-1, k-1) + T(n-1, k), otherwise T(n, k) = T(n-1, k-2) + T(n-1, k).
 * @author Sean A. Irvine
 */
public class A026552 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m == 2 * n) {
      return Z.ONE;
    }
    if (m == 1 || m == 2 * n - 1) {
      return Z.valueOf(n / 2 + 1);
    }
    if ((n & 1) == 0) {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026568	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026568 Irregular triangular array T read by rows: T(i,0) = T(i,2i) = 1 for i &gt;= 0; T(i,1) = T(i,2i-1) = [ (i+1)/2 ] for i &gt;= 1; and for i &gt;= 2 and 2 &lt;=j &lt;= i - 2, T(i,j) = T(i-1,j-2) + T(i-1,j-1) + T(i-1,j) if i + j is even, T(i,j) = T(i-1,j-2) + T(i-1,j) if i + j is odd.
 * @author Sean A. Irvine
 */
public class A026568 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026568() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m == 2 * n) {
      return Z.ONE;
    }
    if (m == 1 || m == 2 * n - 1) {
      return Z.valueOf((n + 1) / 2);
    }
    if (((n + m) & 1) == 0) {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026584	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026584 Irregular triangular array T read by rows: T(i,0) = T(i,2i) = 1 for i &gt;= 0; T(i,1) = T(i,2i-1) = floor(i/2) for i &gt;= 1; and for i &gt;= 2 and j = 2..2i-2, T(i,j) = T(i-1,j-2) + T(i-1,j-1) + T(i-1,j) if i+j is odd, and T(i,j) = T(i-1,j-2) + T(i-1,j) if i+j is even.
 * @author Sean A. Irvine
 */
public class A026584 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026584() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m == 2 * n) {
      return Z.ONE;
    }
    if (m == 1 || m == 2 * n - 1) {
      return Z.valueOf(n / 2);
    }
    if (((n + m) & 1) == 0) {
      return get(n - 1, m - 2).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m - 1)).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026615	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026615 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; T(n,1)=T(n,n-1)=2n-1 for n &gt;= 1; T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=k&lt;=n-2, n &gt;= 4.
 * @author Sean A. Irvine
 */
public class A026615 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026615() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == 1 || m == n - 1) {
      return Z.valueOf(2 * n - 1);
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026626	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026626 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; T(n,1)=T(n,n-1)=[ 3n/2 ] for n &gt;= 1; T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=k&lt;=n-2, n &gt;= 4.
 * @author Sean A. Irvine
 */
public class A026626 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026626() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == 1 || m == n - 1) {
      return Z.valueOf(3 * n / 2);
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026637	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026637 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; T(n,1)=T(n,n-1)=[ (3n-1)/2 ] for n &gt;= 1; T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=k&lt;=n-2, n &gt;= 4.
 * @author Sean A. Irvine
 */
public class A026637 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == 1 || m == n - 1) {
      return Z.valueOf((3 * n - 1) / 2);
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026648	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026648 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k) if n is even and k is odd, else T(n,k)=t(n-1,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026648 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026648() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if ((n & 1) == 0 && (m & 1) == 1) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026659	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026659 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, if n is odd, then T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k) if k is odd and &lt;=[ n/2 ] or if k is even and &gt;[ n/2 ]; in all other cases, T(n,k)=T(n-1,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026659 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026659() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if ((n & 1) == 1 && ((m <= n / 2 && (m & 1) == 1) || (m > n / 2 && (m & 1) == 0))) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026670	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026670 Triangular array T read by rows: T(n,0) = T(n,n) = 1 for n &gt;= 0; for n &gt;= 1, T(n,1) = T(n,n-1) = n+1; for n &gt;= 2, T(n,k) = T(n-1,k-1) + T(n-2,k-1) + T(n-1,k) if n is even and k = n/2, else T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026670 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == 1 || m == n - 1) {
      return Z.valueOf(n + 1);
    }
    if ((n & 1) == 0 && 2 * m == n) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026681	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026681 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k)=T(n-1,k-1)+T(n-1,k) if k or n-k is of form 2h for h=1,2,...,[ n/4 ], else T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026681 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026681() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (((m & 1) == 0 && m / 2 <= n / 4) || (((n - m) & 1) == 0 && (n - m) / 2 <= n / 4)) {
      return get(n - 1, m - 1).add(get(n - 1, m));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026692	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026692 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k) if k or n-k is of form 2h for h=1,2,...,[ n/4 ], else T(n,k)=T(n-1,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026692 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026692() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (((m & 1) == 0 && m / 2 <= n / 4) || (((n - m) & 1) == 0 && (n - m) / 2 <= n / 4)) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026703	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026703 Triangular array T read by rows: T(n,1) = T(n,n) = 1, T(n,k) = T(n-1, k-1) + T(n-2,k-1) + T(n-1,k) if k=(n/2) or k=((n+1)/2), otherwise T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026703 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026703() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == n / 2 || m == (n + 1) / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026714	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A026714 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k)=T(n-1,k-1)+T(n-2,k-1)+T(n-1,k) if k=[ (n-1)/2 ] or k=[ n/2 ] or k=[ (n+2)/2 ], else T(n,k)=T(n-1,k-1)+T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026714 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026714() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m == n / 2 || m == (n - 1) / 2 || m == (n + 2) / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026725	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026725 Triangular array, T, read by rows: T(n,0) = T(n,n) = 1. For n &gt;= 2 and 1&lt;=k&lt;=n-1, T(n,k) = T(n-1,k-1) + T(n-2,k-1) + T(n-1,k) if n is odd and k=n/2, otherwise T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026725 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (2 * m == n - 1) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026736	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026736 Triangular array T read by rows: T(n,0) = T(n,n) = 1 for n &gt;= 0; for n &gt;= 2 and 1 &lt;= k &lt;= n-1, T(n,k) = T(n-1,k-1) + T(n-2,k-1) + T(n-1,k) if n is even and k=(n-2)/2, otherwise T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026736 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if ((n & 1) == 0 && m == (n - 2) / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026747	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026747 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1 &lt;= k &lt;= n-1, T(n,k) = T(n-1,k-1) + T(n-2,k-1) + T(n-1,k) if n is even and 1 &lt;= k &lt;= n/2, else T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026747 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if ((n & 1) == 0 && m <= n / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026758	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026758 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1 &lt;= k &lt;= n-1, T(n,k) = T(n-1,k-1) + T(n-2,k-1) + T(n-1,k) if n is odd and 1 &lt;= k &lt;= (n-1)/2, else T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026758 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if ((n & 1) == 1 && m <= (n - 1) / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026769	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026769 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; T(2,1)=2; for n &gt;= 3 and 1&lt;=k&lt;=n-1, T(n,k) = T(n-1,k-1) + T(n-2,k-1) + T(n-1,k) if 1&lt;=k&lt;=(n-1)/2, else T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026769 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (n == 2) {
      return Z.TWO;
    }
    if (m <= (n - 1) / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026780	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a026;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A026780 Triangular array T read by rows: T(n,0)=T(n,n)=1 for n &gt;= 0; for n &gt;= 2 and 1 &lt;= k &lt;= n-1, T(n,k) = T(n-1,k-1) + T(n-2,k-1) + T(n-1,k) if 1 &lt;= k &lt;= floor(n/2), else T(n,k) = T(n-1,k-1) + T(n-1,k).
 * @author Sean A. Irvine
 */
public class A026780 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m.equals(n)) {
      return Z.ONE;
    }
    if (m <= n / 2) {
      return get(n - 1, m - 1).add(get(n - 1, m)).add(get(n - 2, m - 1));
    } else {
      return get(n - 1, m - 1).add(get(n - 1, m));
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A026907	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a026;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A026907 Triangular array T read by rows (9-diamondization of Pascal's triangle). Step 1: t(n,k) = sum of 9 entries in diamond-shaped subarray of Pascal's triangle having vertices C(n,k), C(n+4,k+2), C(n+2,k), C(n+2,k+2). Step 2: T(n,k) = t(n,k) - t(0,0) + 1.
 * @author Sean A. Irvine
 */
public class A026907 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A026907() {
    super(0);
  }

  // After Michel Marcus

  private static final Z T0 = diamond(0, 0).subtract(1);

  private long mN = -1;
  private long mM = 0;

  private static Z diamond(final long n, final long k) {
    return Binomial.binomial(n + 4, k + 2)
      .add(Binomial.binomial(n + 3, k + 1))
      .add(Binomial.binomial(n + 3, k + 2))
      .add(Binomial.binomial(n + 2, k))
      .add(Binomial.binomial(n + 2, k + 1))
      .add(Binomial.binomial(n + 2, k + 2))
      .add(Binomial.binomial(n + 1, k))
      .add(Binomial.binomial(n + 1, k + 1))
      .add(Binomial.binomial(n, k));
  }

  protected Z t(final long n, final long k) {
    return diamond(n, k).subtract(T0);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A027023	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A027023 Tribonacci array: triangular array T read by rows: T(n,0)=1 for n &gt;= 0, T(n,1) = T(n,2n) = 1 for n &gt;= 1, T(n,2)=1 for n &gt;= 2 and for n &gt;= 3, T(n,k) = T(n-1,k-3) + T(n-1,k-2) + T(n-1,k-1) for 3 &lt;= k &lt;= 2n-1.
 * @author Sean A. Irvine
 */
public class A027023 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 0 || m > 2 * n) {
      return Z.ZERO;
    }
    if (m < 3 || m == 2 * n) {
      return Z.ONE;
    }
    return get(n - 1, m - 3).add(get(n - 1, m - 2)).add(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A027052	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A027052 Triangular array T read by rows: T(n,0) = T(n,2n) = 1 for n &gt;= 0, T(n,1)=0 for n &gt;= 1, T(n,2)=1 for n &gt;= 2 and for n &gt;= 3, T(n,k) = T(n-1,k-3) + T(n-1, k-2) + T(n-1,k-1) for 3 &lt;= k &lt;= 2n-1. T(n,k)=0 for k &lt; 0 or k &gt; 2n.
 * @author Sean A. Irvine
 */
public class A027052 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 0 || m == 1 || m > 2 * n) {
      return Z.ZERO;
    }
    if (m == 0 || m == 2 || m == 2 * n) {
      return Z.ONE;
    }
    return get(n - 1, m - 3).add(get(n - 1, m - 2)).add(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A027082	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A027082 Irregular triangular array: T(n,0) = 1 for n &gt;= 1; T(n,1) = T(n,2) = 1 for n &gt;= 1; T(n,k) = T(n-1,k-3) + T(n-1,k-2) + T(n-1,k-1) for 3 &lt;= k &lt;= 2n-1 and n &gt;= 2; and T(n,2n) = T(n-1,2n-3) + T(n-1,2n-2) for n &gt;= 2.
 * @author Sean A. Irvine
 */
public class A027082 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 0 || m > 2 * n) {
      return Z.ZERO;
    }
    if (m <= 2) {
      return Z.ONE;
    }
    if (m == 2 * n) {
      return get(n - 1, 2 * n - 3).add(get(n - 1, 2 * n - 2));
    }
    return get(n - 1, m - 3).add(get(n - 1, m - 2)).add(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A027144	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A027144 Triangular array T given by rows: T(n,0)=1 for n &gt;= 0, T(1,1)=2; for even n &gt;= 2, T(n,k)=T(n-2,k-1)+T(n-1,k-1)+T(n-1,k) for 1&lt;=(odd k)&lt;=n-1 and T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=(even k)&lt;=n-2, T(n,n)=T(n-1,n-1); for odd n&lt;=3, T(n,k)=T(n,k-1)+T(n-1,k-1)+T(n-1,k) for 1&lt;=(odd k)&lt;=n-2 and T(n,k)=T(n-1,k-1)+T(n-1,k) for 2&lt;=(even k)&lt;=n-1, T(n,n)=T(n-1,n-1)+T(n,n-1).
 * @author Sean A. Irvine
 */
public class A027144 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027144() {
    super(1);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0) {
      return Z.ONE;
    }
    if (m == 1 && n == 1) {
      return Z.TWO;
    }
    if (n <= 1) {
      return Z.ZERO;
    }
    if ((n & 1) == 0) {
      if (n.equals(m)) {
        return get(n - 1, m - 1);
      }
      if ((m & 1) == 0) {
        return get(n - 1, m - 1).add(get(n - 1, m));
      } else {
        return get(n - 2, m - 1).add(get(n - 1, m - 1)).add(get(n - 1, m));
      }
    } else {
      // odd n
      if (n.equals(m)) {
        return get(n - 1, m - 1).add(get(n, n - 1));
      }
      if ((m & 1) == 0) {
        return get(n - 1, m - 1).add(get(n - 1, m));
      } else {
        return get(n, m - 1).add(get(n - 1, m - 1)).add(get(n - 1, m));
      }
    }
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A027170	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027170 Triangular array T read by rows (4-diamondization of Pascal's triangle). Step 1: t(n,k) = C(n+2,k+1) + C(n+1,k) + C(n+1,k+1) + C(n,k). Step 2: T(n,k) = t(n,k) - t(0,0) + 1. Domain: 0 &lt;= k &lt;= n, n &gt;= 0.
 * @author Sean A. Irvine
 */
public class A027170 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027170() {
    super(0);
  }

  private static final Z T0 = diamond(0, 0).subtract(1);

  private long mN = -1;
  private long mM = 0;

  private static Z diamond(final long n, final long k) {
    return Binomial.binomial(n + 2, k + 1)
      .add(Binomial.binomial(n + 1, k))
      .add(Binomial.binomial(n + 1, k + 1))
      .add(Binomial.binomial(n, k));
  }

  protected Z t(final long n, final long k) {
    return diamond(n, k).subtract(T0);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A027188	0	->	0	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A027188 a(n) = number of partitions of n into an odd number of parts, the least being 2; also a(n+2) = number of partitions of n into an even number of parts, each &gt;=2.
 * @author Sean A. Irvine
 */
public class A027188 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After Alois P. Heinz

  private int mN = start();

  protected int start() {
    return -3;
  }

  protected int leastPart() {
    return 2;
  }

  @Override
  protected Z compute(final int n, final int m, final int t) {
    if (n == 0) {
      return Z.valueOf(t);
    }
    if (m < leastPart()) {
      return Z.ZERO;
    }
    final Z r = get(n, m - 1, t);
    return m > n ? r : r.add(get(n - m, m, 1 - t));
  }

  @Override
  public Z next() {
    return get(++mN, mN, 1);
  }
}
#!queue	A027376	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A027376 Number of ternary irreducible monic polynomials of degree n; dimensions of free Lie algebras.
 * @author Sean A. Irvine
 */
public class A027376 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027376() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(mN).divisors()) {
      final int d = dd.intValue();
      final Z z = Z.THREE.pow(d);
      sum = ZUtils.mobiusAdd(Mobius.mobius(mN / d), sum, z);
    }
    return sum.divide(mN);
  }
}
#!queue	A027377	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A027377 Number of irreducible polynomials of degree n over GF(4); dimensions of free Lie algebras.
 * @author Sean A. Irvine
 */
public class A027377 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027377() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(mN).divisors()) {
      final int d = dd.intValue();
      final Z z = Z.ONE.shiftLeft(2 * d);
      sum = ZUtils.mobiusAdd(Mobius.mobius(mN / d), sum, z);
    }
    return sum.divide(mN);
  }
}
#!queue	A027384	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027384 Number of distinct products ij with 0 &lt;= i, j &lt;= n.
 * @author Sean A. Irvine
 */
public class A027384 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027384() {
    super(0);
  }

  private final TreeSet<Long> mSeen = new TreeSet<>();
  protected long mN = -1;

  @Override
  public Z next() {
    ++mN;
    for (long k = 0; k <= mN; ++k) {
      mSeen.add(k * mN);
    }
    return Z.valueOf(mSeen.size());
  }
}
#!queue	A027423	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.factor.factor.PrimeDivision;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027423 Number of divisors of n!.
 * @author Sean A. Irvine
 */
public class A027423 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027423() {
    super(0);
  }

  private final FactorSequence mFactorSequence = new FactorSequence();
  private final PrimeDivision mFactor = new PrimeDivision();
  protected int mN = -1;

  @Override
  public Z next() {
    mFactorSequence.merge(mFactor.factorize(Z.valueOf(++mN)));
    return mFactorSequence.sigma0();
  }
}
#!queue	A027434	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027434 a(1) = 2; then defined by property that a(n) = smallest number &gt;= a(n-1) such that successive runs have lengths 1,1,2,2,3,3,4,4.
 * @author Sean A. Irvine
 */
public class A027434 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027434() {
    super(1);
  }

  private long mN = -3;

  @Override
  public Z next() {
    mN += 4;
    return Z.ONE.add(LongUtils.sqrt(mN));
  }
}
#!queue	A027446	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.api.Matrix;
import irvine.math.group.MatrixField;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027446 Triangle read by rows: square of the lower triangular mean matrix.
 * @author Sean A. Irvine
 */
public class A027446 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027446() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;
  protected Matrix<Q> mMatrix = null;
  protected Z mLcm = null;

  protected int power() {
    return 2;
  }

  protected void step() {
    final MatrixField<Q> field = new MatrixField<>(++mN, Rationals.SINGLETON);
    final Matrix<Q> m = new DefaultMatrix<>(mN, mN, Q.ZERO);
    for (long k = 0; k < mN; ++k) {
      final Q q = new Q(1, k + 1);
      for (long j = 0; j <= k; ++j) {
        m.set(k, j, q);
      }
    }
    mMatrix = field.pow(m, power());
    mLcm = Z.ONE;
    for (long k = 0; k < mN; ++k) {
      mLcm = mLcm.lcm(mMatrix.get(mN - 1, k).den());
    }
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      mM = 0;
      step();
    }
    return mMatrix.get(mN - 1, mM).multiply(mLcm).toZ();
  }
}
#!queue	A027477	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.api.Matrix;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.MatrixField;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027477 Triangle of the square of the normalized, unsigned Stirling matrix of the first kind.
 * @author Sean A. Irvine
 */
public class A027477 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027477() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;
  protected final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  protected Matrix<Q> mMatrix = null;

  protected int power() {
    return 2;
  }

  protected void step() {
    final MatrixField<Q> field = new MatrixField<>(++mN, Rationals.SINGLETON);
    final Matrix<Q> m = new DefaultMatrix<>(mN, mN, Q.ZERO);
    for (int k = 0; k < mN; ++k) {
      for (int j = 0; j <= k; ++j) {
        m.set(k, j, new Q(Stirling.firstKind(k + 1, j + 1).abs(), mF.factorial(k + 1)));
      }
    }
    mMatrix = field.pow(m, power());
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      mM = 0;
      step();
    }
    final Z f = mF.factorial(mN).pow(power());
    return mMatrix.get(mN - 1, mM).multiply(f).toZ();
  }
}
#!queue	A027495	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.api.Matrix;
import irvine.math.group.MatrixField;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.BellNumbers;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027495 Square of lower triangular normalized 2nd kind Stirling matrix.
 * @author Sean A. Irvine
 */
public class A027495 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027495() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;
  protected Matrix<Q> mMatrix = null;
  protected Z mLcm = null;

  protected int power() {
    return 2;
  }

  protected void step() {
    final MatrixField<Q> field = new MatrixField<>(++mN, Rationals.SINGLETON);
    final Matrix<Q> m = new DefaultMatrix<>(mN, mN, Q.ZERO);
    for (int k = 0; k < mN; ++k) {
      for (int j = 0; j <= k; ++j) {
        m.set(k, j, new Q(Stirling.secondKind(k + 1, j + 1), BellNumbers.bell(k + 1)));
      }
    }
    mMatrix = field.pow(m, power());
    mLcm = Z.ONE;
    for (int k = 0; k < mN; ++k) {
      mLcm = mLcm.lcm(mMatrix.get(mN - 1, k).den());
    }
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      mM = 0;
      step();
    }
    return mMatrix.get(mN - 1, mM).multiply(mLcm).toZ();
  }
}
#!queue	A027594	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027594 Sequence satisfies T^2(a)=a, where T is defined below.
 * @author Sean A. Irvine
 */
public class A027594 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027594() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private Polynomial<Z> mA = Polynomial.create(0, 1, 2, 3, 4);
  private int mN = 0;

  static Polynomial<Z> specialPartitionTransform(final Polynomial<Z> a, final int n) {
    Polynomial<Z> num = RING.one();
    Polynomial<Z> den = RING.one();
    int prev = 0;
    for (final Z z : a) {
      final int u = z.intValueExact();
      if (u > prev) { // distinct values
        if ((u % 5) == 0) {
          num = RING.multiply(num, RING.onePlusXToTheN(u), n);  // u occurs at most one
        } else {
          den = RING.multiply(den, RING.oneMinusXToTheN(u), n); // u any number of times
        }
        prev = u;
      }
    }
    return RING.series(num, den, n);
  }

  protected Z select(final Z a, final Z b) {
    return a;
  }

  @Override
  public Z next() {
    final Polynomial<Z> b = specialPartitionTransform(mA, mN + 1);
    if (++mN > mA.degree()) {
      mA = specialPartitionTransform(b, mN);
    }
    return select(mA.coeff(mN), b.coeff(mN));
  }
}
#!queue	A027935	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a027;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A027935 Triangular array T read by rows: T(n,k)=t(n,2k), t given by A027926; 0 &lt;= k &lt;= n, n &gt;= 0.
 * @author Sean A. Irvine
 */
public class A027935 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A027935() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return A027926.t(mN, 2 * mM);
  }

}
#!queue	A027960	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a027;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A027960 'Lucas array': triangular array T read by rows.
 * @author Sean A. Irvine
 */
public class A027960 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m == 2 * n) {
      return Z.ONE;
    } else if (m == 1) {
      return Z.THREE;
    } else {
      return get(n - 1, m - 2).add(get(n - 1, m - 1));
    }
  }

  @Override
  public Z next() {
    if (++mM > 2 * mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A028338	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a028;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;

/**
 * A028338 Triangle of coefficients in expansion of (x+1)*(x+3)*...*(x + 2n - 1) in rising powers of x.
 * @author Sean A. Irvine
 */
public class A028338 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n.equals(m)) {
      return Z.ONE;
    }
    if (m == 0) {
      return mF.doubleFactorial(2 * n - 1);
    }
    return get(n - 1, m).multiply(2L * n - 1).add(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A028366	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a028;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A028366 a(n) = (2^n - 1)!.
 * @author Sean A. Irvine
 */
public class A028366 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A028366() {
    super(0);
  }

  private int mN = -1;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 0) {
      for (long n = 1 << (mN - 1); n < 1 << mN; ++n) {
        mF = mF.multiply(n);
      }
    }
    return mF;
  }
}
#!queue	A028657	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a028;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import irvine.math.IntegerUtils;
import irvine.math.MemoryFunction2;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Integers;
import irvine.math.z.Z;

/**
 * A028657 Triangle read by rows: T(n,k) = number of n-node graphs with k nodes in distinguished bipartite block, k = 0..n.
 * @author Sean A. Irvine
 */
public class A028657 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After Alois P. Heinz

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  private MemoryFunction2<Integer, List<Polynomial<Z>>> mB = new MemoryFunction2<>() {
    @Override
    protected List<Polynomial<Z>> compute(final Integer n, final Integer m) {
      if (n == 0) {
        return Collections.singletonList(RING.zero());
      }
      if (m < 1) {
        return Collections.emptyList();
      }
      final List<Polynomial<Z>> res = new ArrayList<>();
      for (int j = 0; j <= n / m; ++j) {
        for (final Polynomial<Z> p : get(n - m * j, m - 1)) {
          res.add(RING.add(p, RING.monomial(Z.valueOf(j), m)));
        }
      }
      return res;
    }
  };

  private Z prod(final Polynomial<Z> p) {
    Z prod = Z.ONE;
    for (int k = 1; k <= p.degree(); ++k) {
      prod = prod.multiply(Z.valueOf(k).pow(p.coeff(k))).multiply(mF.factorial(p.coeff(k)));
    }
    return prod;
  }

  @Override
  protected Z compute(final Integer n, final Integer k) {
    Q sum = Q.ZERO;
    for (final Polynomial<Z> s : mB.get(n, n)) {
      final Z s2 = prod(s);
      for (final Polynomial<Z> t : mB.get(n + k, n + k)) {
        final Z t2 = prod(t);
        Z u = Z.ZERO;
        for (int j = 1; j <= t.degree(); ++j) {
          for (int i = 1; i <= s.degree(); ++i) {
            final int g = IntegerUtils.gcd(i, j);
            u = u.add(s.coeff(i).multiply(t.coeff(j)).multiply(g));
          }
        }
        final Z r = Z.ONE.shiftLeft(u.longValueExact());
        sum = sum.add(new Q(r, t2.multiply(s2)));
      }
    }
    return sum.toZ();
  }

  protected Z a(final int n, final int k) {
    return get(Math.min(n, k), Math.abs(n - k));
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return a(mM, mN - mM);
  }
}
#!queue	A029635	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a029;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A029635 The (1,2)-Pascal triangle (or Lucas triangle) read by rows.
 * @author Sean A. Irvine
 */
public class A029635 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n.equals(m)) {
      return Z.TWO;
    }
    if (m == 0) {
      return Z.ONE;
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A029653	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a029;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A029653 Numbers in (2,1)-Pascal triangle (by row).
 * @author Sean A. Irvine
 */
public class A029653 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n.equals(m)) {
      return Z.ONE;
    }
    if (m == 0) {
      return Z.TWO;
    }
    return get(n - 1, m - 1).add(get(n - 1, m));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A029776	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A029776 Digits of n appear in n^3.
 * @author Sean A. Irvine
 */
public class A029776 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A029776() {
    super(1);
  }

  private Z mN = Z.NEG_ONE;

  private static boolean isDigitMatch(final Z n) {
    final int[] sn = ZUtils.digitCounts(n);
    final int[] sn3 = ZUtils.digitCounts(n.pow(3));
    for (int k = 0; k < sn.length; ++k) {
      if (sn[k] > 0 && sn3[k] == 0) {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (isDigitMatch(mN)) {
        return mN;
      }
    }
  }
}
#!queue	A029790	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;
import irvine.util.string.StringUtils;

/**
 * A029790 None of the digits in n is present in n^2 or n^3.
 * @author Sean A. Irvine
 */
public class A029790 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A029790() {
    super(1);
  }

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private Z mN = Z.NEG_ONE;

  private static boolean isExcludedDigits(final Z n) {
    final int[] sn = ZUtils.digitCounts(n);
    final int[] sn2 = ZUtils.digitCounts(n.square());
    final int[] sn3 = ZUtils.digitCounts(n.pow(3));
    for (int k = 0; k < sn2.length; ++k) {
      if (sn[k] > 0 && (sn2[k] != 0 || sn3[k] != 0)) {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (mVerbose && mN.mod(1000000) == 0) {
        StringUtils.message("n=" + mN);
      }
      if (isExcludedDigits(mN)) {
        return mN;
      }
    }
  }
}
#!queue	A029795	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A029795 Numbers k such that k and k^3 have the same set of digits.
 * @author Sean A. Irvine
 */
public class A029795 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A029795() {
    super(1);
  }

  private Z mN = Z.NEG_ONE;

  private static boolean isDigitMatch(final Z n) {
    final int[] sn = ZUtils.digitCounts(n);
    final int[] sn3 = ZUtils.digitCounts(n.pow(3));
    for (int k = 0; k < sn.length; ++k) {
      if (sn[k] > 0 ^ sn3[k] > 0) {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (isDigitMatch(mN)) {
        return mN;
      }
    }
  }
}
#!queue	A029797	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A029797 Numbers k such that k^2 and k^3 have the same set of digits.
 * @author Sean A. Irvine
 */
public class A029797 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A029797() {
    super(1);
  }

  private Z mN = Z.NEG_ONE;

  private static boolean isDigitMatch(final Z n) {
    final int[] sn2 = ZUtils.digitCounts(n.square());
    final int[] sn3 = ZUtils.digitCounts(n.pow(3));
    for (int k = 0; k < sn2.length; ++k) {
      if (sn2[k] > 0 ^ sn3[k] > 0) {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (isDigitMatch(mN)) {
        return mN;
      }
    }
  }
}
#!queue	A029887	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a029;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a000.A000108;

/**
 * A029887 A sum over scaled A000531 related to Catalan numbers C(n).
 * @author Sean A. Irvine
 */
public class A029887 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A029887() {
    super(0);
  }

  private int mN = -1;
  private final A000108 mSeq = new A000108();

  @Override
  public Z next() {
    ++mN;
    final int u = 2 * mN + 1;
    return mSeq.next().multiply(u).multiply(u + 2).multiply(u + 4)
      .divide(3)
      .subtract(Z.valueOf(mN + 2).shiftLeft(u));
  }
}

#!queue	A029889	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a029;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A029889 Number of graphical partitions (degree-vectors for graphs with n vertices, allowing self-loops which count as degree 1; or possible ordered row-sum vectors for a symmetric 0-1 matrix).
 * @author Sean A. Irvine
 */
public class A029889 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A029889() {
    super(0);
  }

  // A matrix based approach, only good for a few terms

  protected int mN = -1;
  private long mCount;
  private final HashSet<List<Integer>> mSeen = new HashSet<>();
  private int[] mRowSums;

  protected boolean accept(final int[] rowSums) {
    return true;
  }

  protected long count(final HashSet<List<Integer>> seen) {
    return seen.size();
  }

  private void search(final int row) {
    // We use swizzle so we can generate possible graphical partitions in increasing order
    if (row == mN) {
      //System.out.println(Arrays.toString(mRowSums));
      if (accept(mRowSums)) {
        mSeen.add(Arrays.stream(mRowSums).boxed().collect(Collectors.toList()));
      }
      return;
    }
    final int prev = row == 0 ? mN : mRowSums[row - 1];
    for (int setBits = 0; setBits + mRowSums[row] <= prev; ++setBits) {
      if (setBits == 0) {
        if (mRowSums[row] <= prev) {
          search(row + 1);
        }
      } else {
        final long limit = 1L << (mN - row);
        mRowSums[row] += setBits;
        for (long r = (1L << setBits) - 1; r < limit; r = LongUtils.swizzle(r)) {
          // mirror the bits
          long t = r;
          for (int k = 1; k < mN - row; ++k) {
            if ((t & 1) == 1) {
              ++mRowSums[mN - k];
            }
            t >>>= 1;
          }
          search(row + 1);
          // unmirror the bits
          t = r;
          for (int k = 1; k < mN - row; ++k) {
            if ((t & 1) == 1) {
              --mRowSums[mN - k];
            }
            t >>>= 1;
          }
        }
        mRowSums[row] -= setBits;
      }
      if (row == 0) {
        // We always find the first row sums in order, so we can count them as
        // soon as we are done with a particular first row sum.
        mCount += count(mSeen);
        mSeen.clear();
      }
    }
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    mCount = 0;
    mRowSums = new int[mN];
    search(0);
    return Z.valueOf(mCount);
  }
}
#!queue	A030069	8	->	8	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import java.util.HashSet;
import java.util.Set;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030069 Size of lexicographic code of length n, Hamming distance 8 and weight 8.
 * @author Sean A. Irvine
 */
public class A030069 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030069() {
    super(8);
  }

  private int mN = 7;

  private boolean isOk(final HashSet<Long> res, final long w, final int hammingDistance) {
    for (final long c : res) {
      if (Long.bitCount(c ^ w) < hammingDistance) {
        return false;
      }
    }
    return true;
  }

  protected Set<Long> buildLexicographicCode(final int length, final int hammingDistance, final int weight) {
    final HashSet<Long> res = new HashSet<>();
    final long limit = 1L << length;
    for (long w = (1L << weight) - 1; w < limit; w = LongUtils.swizzle(w)) {
      if (isOk(res, w, hammingDistance)) {
        res.add(w);
      }
    }
    return res;
  }

  @Override
  public Z next() {
    if (++mN > 63) {
      throw new UnsupportedOperationException();
    }
    return Z.valueOf(buildLexicographicCode(mN, 8, 8).size());
  }
}
#!queue	A030076	0	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.Sequence1;
import irvine.oeis.a054.A054055;

/**
 * A030076 a(n) = 10 - m, where m = maximal digit of n.
 * @author Sean A. Irvine
 */
public class A030076 extends Sequence1 {

  private final A054055 mSeq = new A054055();

  /** Construct the sequence. */
  public A030076 () {
    mSeq.next(); // skip 0
  }

  @Override
  public Z next() {
    return Z.TEN.subtract(mSeq.next());
  }
}

#!queue	A030101	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030101 a(n) is the number produced when n is converted to binary digits, the binary digits are reversed and then converted back into a decimal number.
 * @author Sean A. Irvine
 */
public class A030101 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030101() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    long r = 0;
    long s = ++mN;
    while (s != 0) {
      r <<= 1;
      r |= s & 1;
      s >>>= 1;
    }
    return Z.valueOf(r);
  }
}
#!queue	A030177	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030177 When squared gives number composed of digits {4,5,6}.
 * @author Sean A. Irvine
 */
public class A030177 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030177() {
    super(0);
  }

  // n^2 only ends with 4, 5, 6, if n ends with 2, 4, 5, 6, or 8
  private static final long[] SHIFT = {4, 2, 1, 1, 2};

  private Z mN = Z.valueOf(-2);
  private int mIndex = -1;

  private boolean is456(Z n) {
    while (!n.isZero()) {
      final Z[] qr = n.divideAndRemainder(Z.TEN);
      if (qr[1].compareTo(Z.THREE) <= 0 || qr[1].compareTo(Z.SIX) > 0) {
        return false;
      }
      n = qr[0];
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      if (++mIndex == SHIFT.length) {
        mIndex = 0;
      }
      mN = mN.add(SHIFT[mIndex]);
      if (is456(mN.square())) {
        return mN;
      }
    }
  }
}
#!queue	A030308	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a030;
// Generated by gen_seq4.pl juxnrev 2 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030308 Triangle T(n, k): Write n in base 2, reverse order of digits, to get the n-th row.
 * @author Georg Fischer
 */
public class A030308 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030308() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(2)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A030320	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.util.array.LongDynamicBooleanArray;

/**
 * A030320 Least k such that the base-2 representation of n begins at s(k), where s=A030317.
 * @author Sean A. Irvine
 */
public class A030320 extends AbstractSequence {

  private final LongDynamicBooleanArray mA = new LongDynamicBooleanArray();
  private long mM;
  private long mN = first();
  private final Sequence mUnder;

  protected A030320(final Sequence under, final int start) {
    super(start + 1);
    mUnder = under;
    mM = start;
  }

  /** Construct the sequence. */
  public A030320() {
    this(new A030317(), 0);
  }

  protected long first() {
    return 0;
  }

  private boolean isSet(final long n) {
    while (n > mM) {
      ++mM;
      if (Z.ONE.equals(mUnder.next())) {
        mA.set(mM);
      }
    }
    return mA.isSet(n);
  }

  private boolean isMatch(long n, final long pos, final long len) {
    for (long k = len - 1; k >= 0; --k) {
      if (isSet(pos + k) != ((n & 1) == 1)) {
        return false;
      }
      n >>>= 1;
    }
    return true;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    long k = first();
    while (true) {
      final long len = LongUtils.lg(mN) + 1;
      if (isMatch(mN, ++k, len)) {
        return Z.valueOf(k);
      }
    }
  }
}

#!queue	A030341	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a030;
// Generated by gen_seq4.pl juxnrev 3 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030341 Triangle T(n,k): write n in base 3, reverse order of digits.
 * @author Georg Fischer
 */
public class A030341 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030341() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(3)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A030378	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.util.array.LongDynamicIntArray;

/**
 * A030378 Least k such that base 4 representation of n begins at s(k), where s=A030373.
 * @author Sean A. Irvine
 */
public class A030378 extends AbstractSequence {

  private final LongDynamicIntArray mA = new LongDynamicIntArray();
  private long mM;
  private long mN = first();
  private long mLim = 4;
  private long mLen = 1;
  private final Sequence mUnder;

  protected A030378(final Sequence under, final int start) {
    super(start + 1);
    mUnder = under;
    mM = start;
  }

  /** Construct the sequence. */
  public A030378() {
    this(new A030373(), 0);
  }

  protected long first() {
    return 0;
  }

  private int get(final long n) {
    while (n > mM) {
      mA.set(++mM, mUnder.next().intValue());
    }
    return mA.get(n);
  }

  private boolean isMatch(long n, final long pos, final long len) {
    for (long k = len - 1; k >= 0; --k) {
      if (get(pos + k) != (n & 3)) {
        return false;
      }
      n >>>= 2;
    }
    return true;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    if (mN == mLim) {
      ++mLen;
      mLim *= 4;
    }
    long k = first();
    while (true) {
      if (isMatch(mN, ++k, mLen)) {
        return Z.valueOf(k);
      }
    }
  }
}

#!queue	A030386	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a030;
// Generated by gen_seq4.pl juxnrev 4 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030386 Triangle T(n,k): write n in base 4, reverse order of digits.
 * @author Georg Fischer
 */
public class A030386 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030386() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(4)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A030478	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030478 Numbers k such that k^3 has property that all even digits occur together and all odd digits occur together.
 * @author Sean A. Irvine
 */
public class A030478 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030478() {
    super(1);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (!A030475.isMixed(mN.pow(3))) {
        return mN;
      }
    }
  }
}
#!queue	A030484	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030484 Squares composed of digits {2,5,6}.
 * @author Sean A. Irvine
 */
public class A030484 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030484() {
    super(1);
  }

  // 1 -> 2, 2 -> 5, 0 -> 6

  private static final long[] MAP = {6, 2, 5};
  private long mN = 0;

  private Z to256(final long n) {
    long m = n;
    Z t = Z.ONE;
    Z a = Z.ZERO;
    while (m > 0) {
      final int r = (int) (m % 3);
      m /= 3;
      if (r == 0) {
        --m;
      }
      a = t.multiply(MAP[r]).add(a);
      t = t.multiply(10);
    }
    return a;
  }

  @Override
  public Z next() {
    while (true) {
      final Z a = to256(++mN);
      final long r = a.mod(100);
      if ((r == 25 || r == 56) && a.isSquare()) {
        return a;
      }
    }
  }
}
#!queue	A030485	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030485 Squares composed of digits {2, 5, 7}.
 * @author Sean A. Irvine
 */
public class A030485 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030485() {
    super(1);
  }

  // 1 -> 2, 2 -> 5, 0 -> 7
  // all terms of form ...25

  private static final long[] MAP = {7, 2, 5};
  private long mN = -1;

  private Z to257(final long n) {
    long m = n;
    Z t = Z.ONE;
    Z a = Z.ZERO;
    while (m > 0) {
      final int r = (int) (m % 3);
      m /= 3;
      if (r == 0) {
        --m;
      }
      a = t.multiply(MAP[r]).add(a);
      t = t.multiply(10);
    }
    return a.multiply(100).add(25);
  }

  @Override
  public Z next() {
    while (true) {
      final Z a = to257(++mN);
      final long r = a.mod(100);
      if ((r == 25 || r == 56) && a.isSquare()) {
        return a;
      }
    }
  }
}
#!queue	A030503	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030503 Graham-Sloane-type lower bound on the size of a ternary (n,3,3) constant-weight code.
 * @author Sean A. Irvine
 */
public class A030503 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030503() {
    super(3);
  }

  private int mN = w() - 1;

  protected int w() {
    return 3;
  }

  @Override
  public Z next() {
    return Binomial.binomial(++mN, w()).shiftLeft(w()).add(2 * mN).divide(2 * mN + 1);
  }
}

#!queue	A030567	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a030;
// Generated by gen_seq4.pl juxnrev 6 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030567 Triangle T(n,k): Write n in base 6, reverse order of digits, to get row n.
 * @author Georg Fischer
 */
public class A030567 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030567() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(6)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A030664	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a030;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030664 Product of largest prime &lt;= n and smallest prime &gt;= n.
 * @author Sean A. Irvine
 */
public class A030664 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030664() {
    super(0);
  }

  private final Fast mPrime = new Fast();
  protected long mN = -1;

  @Override
  public Z next() {
    return ++mN < 2 ? Z.ONE : Z.valueOf(mPrime.prevPrime(mN + 1)).multiply(mPrime.nextPrime(mN - 1));
  }
}

#!queue	A030998	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a030;
// Generated by gen_seq4.pl juxn 7 at 2019-07-05 09:34

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A030998 Write n in base 7 and juxtapose.
 * @author Georg Fischer
 */
public class A030998 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A030998() {
    super(0);
  }

  private String mS = "";
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = mN.toString(7);
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A031007	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;
// Generated by gen_seq4.pl juxnrev 7 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031007 Triangle T(n,k): Write n in base 7, reverse order of digits, to get row n.
 * @author Georg Fischer
 */
public class A031007 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031007() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(7)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A031045	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;
// Generated by gen_seq4.pl juxnrev 8 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031045 Triangle T(n,k): write n in base 8, reverse order of digits.
 * @author Georg Fischer
 */
public class A031045 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031045() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(8)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A031087	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;
// Generated by gen_seq4.pl juxnrev 9 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031087 Triangle T(n,k): write n in base 9, reverse order of digits.
 * @author Georg Fischer
 */
public class A031087 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031087() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(9)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A031178	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031178 Periods of sum of cubes of digits iterated until the sequence becomes periodic.
 * @author Sean A. Irvine
 */
public class A031178 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031178() {
    super(0);
  }

  protected long mN = -1;

  /**
   * Return the sums of the cubes of the digits of a number
   * @param n the number
   * @return sum of cubes of digits of <code>n</code>
   */
  public static long digitSumCubes(final long n) {
    long m = Math.abs(n);
    long sum = 0;
    while (m != 0) {
      final long r = m % 10;
      sum += r * r * r;
      m /= 10;
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    long a = mN;
    long b = mN;
    do {
      a = digitSumCubes(a);
      b = digitSumCubes(digitSumCubes(b));
    } while (a != b);
    // a is definitely inside the period, so now count until we see it again
    long c = 0;
    do {
      a = digitSumCubes(a);
      ++c;
    } while (a != b);
    return Z.valueOf(c);
  }
}
#!queue	A031182	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031182 Periods of sum of fourth powers of digits iterated until the sequence becomes periodic.
 * @author Sean A. Irvine
 */
public class A031182 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031182() {
    super(0);
  }

  protected long mN = -1;

  private static long digitSum4(final long n) {
    long m = Math.abs(n);
    long sum = 0;
    while (m != 0) {
      final long r = m % 10;
      sum += r * r * r * r;
      m /= 10;
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    long a = mN;
    long b = mN;
    do {
      a = digitSum4(a);
      b = digitSum4(digitSum4(b));
    } while (a != b);
    // a is definitely inside the period, so now count until we see it again
    long c = 0;
    do {
      a = digitSum4(a);
      ++c;
    } while (a != b);
    return Z.valueOf(c);
  }
}
#!queue	A031186	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031186 Periods of sum of 5th powers of digits iterated until the sequence becomes periodic.
 * @author Sean A. Irvine
 */
public class A031186 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031186() {
    super(0);
  }

  protected long mN = -1;

  private static long digitSum5(final long n) {
    long m = Math.abs(n);
    long sum = 0;
    while (m != 0) {
      final long r = m % 10;
      sum += r * r * r * r * r;
      m /= 10;
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    long a = mN;
    long b = mN;
    do {
      a = digitSum5(a);
      b = digitSum5(digitSum5(b));
    } while (a != b);
    // a is definitely inside the period, so now count until we see it again
    long c = 0;
    do {
      a = digitSum5(a);
      ++c;
    } while (a != b);
    return Z.valueOf(c);
  }
}
#!queue	A031195	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031195 Periods of sum of 6th powers of digits iterated until the sequence becomes periodic.
 * @author Sean A. Irvine
 */
public class A031195 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031195() {
    super(0);
  }

  protected long mN = -1;

  private static long digitSum6(final long n) {
    long m = Math.abs(n);
    long sum = 0;
    while (m != 0) {
      final long r = m % 10;
      final long s = r * r;
      sum += s * s * s;
      m /= 10;
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    long a = mN;
    long b = mN;
    do {
      a = digitSum6(a);
      b = digitSum6(digitSum6(b));
    } while (a != b);
    // a is definitely inside the period, so now count until we see it again
    long c = 0;
    do {
      a = digitSum6(a);
      ++c;
    } while (a != b);
    return Z.valueOf(c);
  }
}
#!queue	A031200	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031200 Periods of sum of 7th powers of digits iterated until the sequence becomes periodic.
 * @author Sean A. Irvine
 */
public class A031200 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031200() {
    super(0);
  }

  protected long mN = -1;

  private static long digitSum7(final long n) {
    long m = Math.abs(n);
    long sum = 0;
    while (m != 0) {
      final long r = m % 10;
      final long s = r * r;
      sum += s * s * s * r;
      m /= 10;
    }
    return sum;
  }

  @Override
  public Z next() {
    ++mN;
    long a = mN;
    long b = mN;
    do {
      a = digitSum7(a);
      b = digitSum7(digitSum7(b));
    } while (a != b);
    // a is definitely inside the period, so now count until we see it again
    long c = 0;
    do {
      a = digitSum7(a);
      ++c;
    } while (a != b);
    return Z.valueOf(c);
  }
}
#!queue	A031235	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;
// Generated by gen_seq4.pl juxnrev 5 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031235 Triangle T(n,k): write n in base 5, reverse order of digits.
 * @author Georg Fischer
 */
public class A031235 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031235() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(5)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A031298	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a031;
// Generated by gen_seq4.pl juxnrev 10 at 2019-07-04 11:13

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031298 Triangle T(n,k): write n in base 10, reverse order of digits.
 * @author Georg Fischer
 */
public class A031298 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A031298() {
    super(0);
  }

  private StringBuilder mS = new StringBuilder();
  private int mPos = 0;
  private Z mN = Z.valueOf(0 - 1);

  @Override
  public Z next() {
    ++mPos;
    if (mPos >= mS.length()) {
      mN = mN.add(1);
      mS = new StringBuilder(mN.toString(10)).reverse();
      mPos = 0;
    }
    return Z.valueOf(mS.charAt(mPos) - '0');
  }
}
#!queue	A031941	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a031;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A031941 Numbers without consecutive equal base 3 digits.
 * @author Sean A. Irvine
 */
public class A031941 extends AbstractSequence {

  private final long mBase;
  private long mN;

  protected A031941(final long base, final int start) {
    super(start);
    mBase = base;
    mN = start - 1;
  }

  /** Construct the sequence. */
  public A031941() {
    this(3, 1);
  }

  private boolean isConecutiveDigits(long n) {
    long r = -1;
    while (n != 0) {
      final long t = n % mBase;
      n /= mBase;
      if (t == r) {
        return true;
      }
      r = t;
    }
    return false;
  }

  @Override
  public Z next() {
    while (isConecutiveDigits(++mN)) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A032428	5	->	5	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A032428 Coefficients of Jacobi elliptic function c(5,m).
 * @author Sean A. Irvine
 */
public class A032428 extends MemoryFunctionInt3Sequence<Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A032428() {
    super(5);
  }

  // Based on (2) in Dominique Dumont
  // A Combinatorial Interpretation for the Schett Recurrence on the Jacobian Elliptic Functions

  private int mN = j() - 1;

  @Override
  protected Z compute(final int m, final int i, final int j) {
    if (m == 1 && i == 0 && j == 0) {
      return Z.ONE;
    }
    if (i + j < 0 || i + j > m / 2) {
      return Z.ZERO;
    }
    if ((m & 1) == 0) {
      return get(m - 1, i, j).multiply(2 * j + 1)
        .add(get(m - 1, i + 1, j - 1).multiply(2 * i + 2))
        .add(get(m - 1, i, j - 1).multiply(m - 2 * i - 2 * j + 1));
    } else {
      return get(m - 1, i, j).multiply(2 * i + 1)
        .add(get(m - 1, i - 1, j + 1).multiply(2 * j + 2))
        .add(get(m - 1, i - 1, j).multiply(m - 1 - 2 * i - 2 * j + 2));
    }
  }

  protected int j() {
    return 5;
  }

  @Override
  public Z next() {
    return get(2 * ++mN + 1, 0, j());
  }
}
#!queue	A032734	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a032;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A032734 All 81 combinations of prefixing and following a(n) by a single digit are nonprime.
 * @author Sean A. Irvine
 */
public class A032734 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A032734() {
    super(1);
  }

  private static final String[] PREFIXES = {"1", "2", "3", "4", "5", "6", "7", "8", "9"};
  private static final String[] SUFFIXES = {"1", "3", "7", "9"};
  private long mN = 2436;

  protected String[] prefixes() {
    return PREFIXES;
  }

  protected String[] suffixes() {
    return SUFFIXES;
  }

  private boolean isVeryComposite(final long n) {
    for (final String prefix : prefixes()) {
      for (final String suffix : suffixes()) {
        if (new Z(prefix + n + suffix).isProbablePrime()) {
          return false;
        }
      }
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      if (isVeryComposite(++mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A033068	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a033;

import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A033068 Numbers with the property that all pairs of consecutive base-3 digits differ by 1.
 * @author Sean A. Irvine
 */
public class A033068 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A033068() {
    super(1);
  }

  private final TreeSet<Z> mA = new TreeSet<>();

  {
    for (long k = start(); k < base(); ++k) {
      mA.add(Z.valueOf(k));
    }
  }

  protected long start() {
    return 1;
  }

  protected int base() {
    return 3;
  }

  protected long diff() {
    return 1;
  }

  @Override
  public Z next() {
    final Z res = mA.pollFirst();
    final long d = res.mod(base());
    final Z t = res.multiply(base());
    if (!t.isZero()) {
      for (long k = 0; k < base(); ++k) {
        if (Math.abs(d - k) == diff()) {
          mA.add(t.add(k));
        }
      }
    }
    return res;
  }
}
#!queue	A033178	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a033;

import java.util.Arrays;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A033178 Number of multisets of n positive integers with equal sum and product.
 * @author Sean A. Irvine
 */
public class A033178 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A033178() {
    super(2);
  }

  private long mCount = 0;
  protected int mN = 1;

  private Z prod(final int[] v) {
    Z prod = Z.ONE;
    for (int k = v.length - 1; k >= 0 && v[k] != 1; --k) {
      prod = prod.multiply(v[k]);
    }
    return prod;
  }

  private boolean bump(final int[] v) {
    for (int k = v.length - 1; k >= 0; --k) {
      Arrays.fill(v, k, v.length, v[k] + 1);
      final Z sum = Z.valueOf(IntegerUtils.sum(v));
      final Z prod = prod(v);
      final int c = prod.compareTo(sum);
      if (c == 0) {
        ++mCount;
      }
      if (c <= 0) {
        return true;
      }
    }
    return false;
  }

  private void search(final int[] v) {
    while (bump(v)) {
      // do nothing
    }
  }

  @Override
  public Z next() {
    ++mN;
    mCount = 1; // initial condition is always a solution
    final int[] v = new int[mN];
    Arrays.fill(v, 1);
    v[mN - 2] = 2;
    v[mN - 1] = mN;
    search(v);
    return Z.valueOf(mCount);
  }
}
#!queue	A033185	1	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a033;

import java.util.ArrayList;
import java.util.List;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000081;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A033185 Rooted tree triangle read by rows: a(n,k) = number of forests with n nodes and k rooted trees.
 * @author Sean A. Irvine
 */
public class A033185 extends MemoryFunctionInt3Sequence<Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A033185() {
    super(1);
  }

  // After Alois P. Heinz

  private final Sequence mA55 = new A000081(0);
  private final List<Z> mT = new ArrayList<>();

  private Z getT(final int i) {
    if (i < 0) {
      return Z.ZERO;
    }
    while (i >= mT.size()) {
      mT.add(mA55.next());
    }
    return mT.get(i);
  }

  // b function
  @Override
  protected Z compute(final int n, final int i, final int p) {
    if (p > n) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    if (Math.min(i, p) < 1) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = 0; j <= Math.min(n / i, p); ++j) {
      sum = sum.add(get(n - i * j, i - 1, p - j).multiply(Binomial.binomial(getT(i).add(j - 1), Z.valueOf(j))));
    }
    return sum;
  }

  private int mN = 0;
  private int mK = 0;

  @Override
  public Z next() {
    if (++mK > mN) {
      ++mN;
      mK = 1;
    }
    return get(mN, mN, mK);
  }
}
#!queue	A033502	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a033;

import irvine.factor.prime.Fast;
import irvine.math.z.Carmichael;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A033502 Carmichael numbers of the form (6*k+1)*(12*k+1)*(18*k+1), where 6*k+1, 12*k+1 and 18*k+1 are all primes.
 * @author Sean A. Irvine
 */
public class A033502 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A033502() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      ++mN;
      final Z a = Z.valueOf(6 * mN + 1);
      if (mPrime.isPrime(a)) {
        final Z b = Z.valueOf(12 * mN + 1);
        if (mPrime.isPrime(b)) {
          final Z c = Z.valueOf(18 * mN + 1);
          if (mPrime.isPrime(c)) {
            final Z n = a.multiply(b).multiply(c);
            if (!mPrime.isPrime(n) && n.mod(Carmichael.lambda(n)).equals(Z.ONE)) {
              return n;
            }
          }
        }
      }
    }
  }
}
#!queue	A033630	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A033630 Number of partitions of n into distinct divisors of n.
 * @author Sean A. Irvine
 */
public class A033630 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A033630() {
    super(0);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN < 6) {
      return Z.ONE;
    }
    Polynomial<Z> gf = RING.one();
    for (final Z d : Jaguar.factor(mN).divisors()) {
      gf = RING.multiply(gf, RING.onePlusXToTheN(d.intValue()), mN);
    }
    return gf.coeff(mN);
  }
}
#!queue	A033879	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A033879 Deficiency of n, or 2n - (sum of divisors of n).
 * @author Sean A. Irvine
 */
public class A033879 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A033879() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(2 * ++mN).subtract(Jaguar.factor(mN).sigma());
  }
}
#!queue	A033880	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A033880 Abundance of n, or (sum of divisors of n) - 2n.
 * @author Sean A. Irvine
 */
public class A033880 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A033880() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    return Jaguar.factor(++mN).sigma().subtract(2 * mN);
  }
}
#!queue	A033950	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a033;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A033950 Refactorable numbers: number of divisors of k divides k. Also known as tau numbers.
 * @author Sean A. Irvine
 */
public class A033950 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A033950() {
    super(1);
  }

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (mN.mod(Jaguar.factor(mN).sigma0()).isZero()) {
        return mN;
      }
    }
  }
}
#!queue	A034261	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A034261 Infinite square array f(a,b) = C(a+b,b+1)*(a*b+a+1)/(b+2), a, b &gt;= 0, read by antidiagonals. Equivalently, triangular array T(n,k) = f(k,n-k), 0 &lt;= k &lt;= n, read by rows.
 * @author Sean A. Irvine
 */
public class A034261 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A034261() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  protected Z f(final long n, final long m) {
    return Binomial.binomial(n + m, m + 1).multiply(n * m + n + 1).divide(m + 2);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return f(mM, mN - mM);
  }
}

#!queue	A034386	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a034;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A034386 Primorial numbers (second definition): n# = product of primes &lt;= n.
 * @author Sean A. Irvine
 */
public class A034386 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A034386() {
    super(0);
  }

  private final Fast mPrime = new Fast();
  private Z mPrimorial = Z.ONE;
  private long mN = -1;

  @Override
  public Z next() {
    if (mPrime.isPrime(++mN)) {
      mPrimorial = mPrimorial.multiply(mN);
    }
    return mPrimorial;
  }
}
#!queue	A034781	2	->	2	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a034;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A034781 Triangle of number of rooted trees with n &gt;= 2 nodes and height h &gt;= 1.
 * @author Sean A. Irvine
 */
public class A034781 extends MemoryFunctionInt3Sequence<Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A034781() {
    super(2);
  }

  // After Alois P. Heinz

  @Override
  protected Z compute(final int n, final int i, final int k) {
    if (n == 0) {
      return Z.ONE;
    }
    if (i < 1 || k < 1) {
      return Z.ZERO;
    }
    Z s = Z.ZERO;
    for (int j = 0; j <= n / i; ++j) {
      s = s.add(Binomial.binomial(get(i - 1, i - 1, k - 1).add(j - 1), Z.valueOf(j)).multiply(get(n - i * j, i - 1, k)));
    }
    return s;
  }

  protected Z t(final int n, final int d) {
    return get(n - 1, n - 1, d).subtract(get(n - 1, n - 1, d - 1));
  }

  private int mN = 1;
  private int mD = 0;

  @Override
  public Z next() {
    if (++mD >= mN) {
      ++mN;
      mD = 1;
    }
    return t(mN, mD);
  }

}
#!queue	A034855	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a034;

import java.util.ArrayList;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A034855 Triangle read by rows giving number of rooted labeled trees with n &gt;= 2 nodes and height d &gt;= 1.
 * @author Sean A. Irvine
 */
public class A034855 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A034855() {
    super(2);
  }

  protected static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);

  protected final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private final ArrayList<Polynomial<Q>> mGF = new ArrayList<>();

  {
    mGF.add(RING.x());
  }

  protected Polynomial<Q> gf(final int k, final int n) {
    if (k <= 0) {
      return RING.x();
    } else if (mGF.size() > k && mGF.get(k).degree() >= n) {
      return mGF.get(k);
    } else {
      final Polynomial<Q> g = RING.exp(gf(k - 1, n - 1), n - 1).shift(1);
      if (k < mGF.size()) {
        mGF.set(k, g);
      } else {
        mGF.add(g);
      }
      return g;
    }
  }

  private Z a(final int n, final int k) {
    final Q c = gf(k, n).coeff(n);
    return c.multiply(mF.factorial(n)).toZ();
  }

  protected Z r(final int n, final int d) {
    return a(n, d).subtract(a(n, d - 1));
  }

  private int mN = 1;
  private int mD = 0;

  @Override
  public Z next() {
    if (++mD >= mN) {
      ++mN;
      mD = 1;
    }
    return r(mN, mD);
  }
}
#!queue	A034886	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a034;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A034886 Number of digits in n!.
 * @author Sean A. Irvine
 */
public class A034886 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A034886() {
    super(0);
  }

  private static final CR LOG10 = CR.TEN.log();
  protected long mN = -1;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    return CR.valueOf(mF).log().divide(LOG10).floor().add(1);
  }
}

#!queue	A035002	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A035002 Square array a(m,n) read by antidiagonals, where a(m,n) = sum(a(m-k,n), k=1..m-1) + sum(a(m,n-k), k=1..n-1).
 * @author Sean A. Irvine
 */
public class A035002 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A035002() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer m, final Integer n) {
    if (m == 1) {
      return n == 1 ? Z.ONE : Z.ONE.shiftLeft(n - 2);
    }
    if (n == 1) {
      return Z.ONE.shiftLeft(m - 2);
    }
    Z sum = Z.ZERO;
    for (int k = 1; k < m; ++k) {
      sum = sum.add(get(m - k, n));
    }
    for (int k = 1; k < n; ++k) {
      sum = sum.add(get(m, n - k));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM + 1, mM);
  }
}
#!queue	A035087	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a035;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A035087 Number of labeled rooted polygonal cacti (Husimi graphs) with n nodes.
 * @author Sean A. Irvine
 */
public class A035087 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A035087() {
    super(1);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> C2 = RING.monomial(Q.TWO, 0);
  private Polynomial<Q> mEgf = RING.x();
  private Z mF = Z.ONE;
  protected int mN = 0;

  @Override
  public Z next() {
    mF = mF.multiply(++mN);
    mEgf = RING.exp(RING.series(RING.pow(mEgf, 2, mN), RING.subtract(C2, RING.multiply(mEgf, Q.TWO)), mN), mN).shift(1);
    return mEgf.coeff(mN).multiply(mF).toZ();
  }
}
#!queue	A035143	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a035;
// Generated by gen_seq4.pl diriprod1 at 2020-09-02 21:31

import irvine.factor.factor.Jaguar;
import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A035143 Coefficients in expansion of Dirichlet series Product_p (1-(Kronecker(m,p)+1)*p^(-s)+Kronecker(m,p)*p^(-2s))^(-1) for m = -47.
 * @author Georg Fischer
 */
public class A035143 extends AbstractSequence {

  protected final int mM;
  protected int mN = 0;

  /** Construct the sequence. */
  public A035143() {
    super(1);
    mM = -47;
  }

  /** Constructor with m */
  public A035143(final int m) {
    super(1);
    mM = m;
  }

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (final Z d : Jaguar.factor(mN).divisors()) {
      sum = sum.add(LongUtils.kronecker(mM, d.longValueExact()));
    }
    return sum;
  }
}
#!queue	A035263	1	->	1	MorphismFixedPointSequence	--------------------------------
package irvine.oeis.a035;
// Generated by gen_seq4.pl morfps at 2021-05-27 23:03

import irvine.oeis.base.MorphismFixedPointSequence;

/**
 * A035263 Trajectory of 1 under the morphism 0 -&gt; 11, 1 -&gt; 10; parity of 2-adic valuation of 2n: a(n) = A000035(A001511(n)).
 * @author Georg Fischer
 */
public class A035263 extends MorphismFixedPointSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A035263() {
    super("0", "1011", "0->11, 1->10");
  }
}
#!queue	A035342	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a035;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A035342 The convolution matrix of the double factorial of odd numbers (A001147).
 * @author Sean A. Irvine
 */
public class A035342 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A035342() {
    super(1);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;
  private int mM = 0;

  protected Z t(final int n, final int k) {
    Z sum = Z.ZERO;
    for (int j = 0; j <= n - k; ++j) {
      sum = sum.add(Binomial.binomial(j + k - 1, k - 1).multiply(Binomial.binomial(2L * n - j - k - 1, n - 1)).multiply(j + k).shiftLeft(j));
    }
    return sum.multiply(mF.factorial(n - 1)).divide(mF.factorial(k)).shiftRight(n - k);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}

#!queue	A035485	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a035;

import java.util.Iterator;
import java.util.LinkedList;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A035485 Card on top of deck at n-th stage of R. K. Guy's shuffling problem.
 * @author Sean A. Irvine
 */
public class A035485 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A035485() {
    super(0);
  }

  // This works by keeping track of the initial part of the deck which is
  // different from ordered integers.  Once the end of the list is
  // reached can assume remainder is integers in order.

  protected LinkedList<Long> mDeck = new LinkedList<>();

  {
    mDeck.add(1L);
  }

  protected int mN = 0;

  @Override
  public Z next() {
    ++mN;
    final LinkedList<Long> next = new LinkedList<>();
    long m = 0;
    final Iterator<Long> existing = mDeck.iterator();
    if (mN >= mDeck.size()) {
      m = mDeck.size();
    } else {
      while (++m < mN) {
        existing.next(); // skip over the first part of the list
      }
    }
    final Iterator<Long> top = mDeck.iterator();
    for (int k = 0; k < mN; ++k) {
      next.add(m >= mDeck.size() ? m : existing.next());
      ++m;
      next.add(top.next());
    }
    mDeck = next;
    return Z.valueOf(mDeck.peekFirst());
  }
}

#!queue	A035529	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a035;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A035529 A convolution triangle of numbers obtained from A034171.
 * @author Sean A. Irvine
 */
public class A035529 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A035529() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  protected long degree() {
    return 3;
  }

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 0 || m > n) {
      return Z.ZERO;
    }
    if (n == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).multiply(degree()).multiply(degree() * (n - 1) + m).add(get(n - 1, m - 1).multiply(m)).divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}

#!queue	A036012	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A036012 a(n) = smallest number &gt; 1 such that a(1)a(2)...a(n) + 1 is prime.
 * @author Sean A. Irvine
 */
public class A036012 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A036012() {
    super(1);
  }

  private Z mA = null;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.TWO;
      return Z.TWO;
    }
    long k = 1;
    while (true) {
      final Z t = mA.multiply(++k);
      if (t.add(1).isProbablePrime()) {
        mA = t;
        return Z.valueOf(k);
      }
    }
  }
}

#!queue	A036044	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A036044 BCR(n): write in binary, complement, reverse.
 * @author Sean A. Irvine
 */
public class A036044 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A036044() {
    super(0);
  }

  protected long mN = -1;
  private long mMask = 1;

  @Override
  public Z next() {
    if (++mN > mMask) {
      mMask = mMask * 2 + 1;
    }
    return Z.valueOf(~Long.parseLong(new StringBuilder(Long.toString(mN, 2)).reverse().toString(), 2) & mMask);
  }
}

#!queue	A036046	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a036;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;

import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A036046 Product of the lengths of the cycle types of the permutation created by duality and reversal on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036046 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A036046() {
    super(0);
  }

  private int mN = -1;

  static final class Wrapper {
    private final int[] mPartition;

    Wrapper(final int[] partition) {
      mPartition = partition;
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(mPartition);
    }

    @Override
    public boolean equals(final Object obj) {
      return obj instanceof Wrapper && Arrays.equals(mPartition, ((Wrapper) obj).mPartition);
    }

    @Override
    public String toString() {
      return Arrays.toString(mPartition);
    }
  }

  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    Z prod = Z.ONE;
    for (final int s : set) {
      prod = prod.multiply(s);
    }
    return prod;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final LinkedHashMap<Wrapper, Integer> map = new LinkedHashMap<>();
    final IntegerPartition integerPartition = new IntegerPartition(mN);
    int[] p;
    int k = 0;
    while ((p = integerPartition.next()) != null) {
      map.put(new Wrapper(p), ++k);
    }
    final ArrayList<Integer> v = new ArrayList<>();
    for (final Map.Entry<Wrapper, Integer> e : map.entrySet()) {
      final int[] dual = IntegerPartition.dual(e.getKey().mPartition);
      v.add(map.get(new Wrapper(dual)));
    }
    Collections.reverse(v);
    //System.out.println(mN + " " + v + " " + map);
    return count(v);
  }
}

#!queue	A036052	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a036;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.TreeSet;

import irvine.math.Comparators;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A036052 Product of the lengths of the cycle types of the permutation created by length sorting on the partitions of n.
 * @author Sean A. Irvine
 */
public class A036052 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A036052() {
    super(0);
  }

  private int mN = -1;

  protected Z count(final List<Integer> v) {
    final TreeSet<Integer> set = new TreeSet<>();
    final boolean[] t = new boolean[v.size()];
    for (int k = 0; k < v.size(); ++k) {
      int c = 0;
      int j = k;
      while (!t[j]) {
        t[j] = true;
        j = v.get(j) - 1;
        ++c;
      }
      if (c > 0) {
        set.add(c);
      }
    }
    Z prod = Z.ONE;
    for (final int s : set) {
      prod = prod.multiply(s);
    }
    return prod;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final LinkedHashMap<A036046.Wrapper, Integer> map = new LinkedHashMap<>();
    final TreeSet<int[]> lex = new TreeSet<>(Comparators.INCREASING_LENGTH_DECREASING_VALUE);
    final IntegerPartition integerPartition = new IntegerPartition(mN);
    int[] p;
    int k = 0;
    while ((p = integerPartition.next()) != null) {
      map.put(new A036046.Wrapper(p), ++k);
      lex.add(p);
    }
    final ArrayList<Integer> v = new ArrayList<>();
    for (final int[] part : lex) {
      v.add(lex.size() + 1 - map.get(new A036046.Wrapper(part)));
    }
    Collections.reverse(v);
    return count(v);
  }
}

#!queue	A036370	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a036;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A036370 Triangle of coefficients of generating function of ternary rooted trees of height at most n.
 * @author Sean A. Irvine
 */
public class A036370 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mM = -1;
  private int mN = 0;

  // T_{i+1}(z) = 1 + z * (T_i(z)^3/6 + T_i(z^2)*T_i(z)/2 + T_i(z^3)/3); T_0(z) = 1.

  protected int max(final int n) {
    return Z.THREE.pow(n).add(1).divide2().intValueExact();
  }

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 0) {
      return Z.ONE;
    }
    if (n == 0) {
      return Z.ZERO;
    }

    final int k = m - 1;

    // [z^k] T_(n-1)(z)^3
    Z sum = Z.ZERO;
    for (int a = 0; a <= k; ++a) {
      for (int b = 0; a + b <= k; ++b) {
        final int c = k - b - a;
        sum = sum.add(get(n - 1, a).multiply(get(n - 1, b)).multiply(get(n - 1, c)));
      }
    }

    // 3[z^k] T_(n-1)(z^2)T_(n-1)(z)
    for (int j = 0; j <= k; j += 2) {
      sum = sum.add(get(n - 1, j / 2).multiply(get(n - 1, k - j)).multiply(3));
    }

    // [z^k] 2T_(n-1)(z^3)
    if (k % 3 == 0) {
      sum = sum.add(get(n - 1, k / 3).multiply2());
    }

    return sum.divide(6);
  }

  @Override
  public Z next() {
    if (++mM >= max(mN)) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A036831	4	->	4	AbstractSequence	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A036831 Schoenheim bound L_1(n,4,3).
 * @author Sean A. Irvine
 */
public class A036831 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A036831() {
    super(4);
  }

  private long mN = 3;

  protected Z l(final long v, final long k, final long t, final long l) {
    Z t1 = Z.valueOf(l);
    for (long i = v - t + 1; i <= v; ++i) {
      final long u = i - v + k;
      t1 = t1.multiply(i).add(u - 1).divide(u);
    }
    return t1;
  }

  @Override
  public Z next() {
    return l(++mN, 4, 3, 1);
  }
}
#!queue	A036917	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a036;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A036917 a(n) = (16*(n-1/2)*(2*n^2-2*n+1)*a(n-1)-256*(n-1)^3*a(n-2))/n^3.
 * @author Sean A. Irvine
 */
public class A036917 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A036917() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (long k = 0; k <= mN; ++k) {
      sum = sum.add(Binomial.binomial(2 * mN - 2 * k, mN - k).square().multiply(Binomial.binomial(2 * k, k).square()));
    }
    return sum;
  }
}
#!queue	A036918	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a036;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A036918 a(n) = floor(e*(n-1)*(n-1)!)).
 * @author Sean A. Irvine
 */
public class A036918 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A036918() {
    super(1);
  }

  private long mN = -1;
  private Z mF = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    return CR.E.multiply(mF).multiply(mN).floor();
  }
}
#!queue	A037040	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a037;

import irvine.factor.prime.Fast;
import irvine.factor.prime.Prime;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A037040 Number of odd nonprimes &lt; (2n+1)^2.
 * @author Sean A. Irvine
 */
public class A037040 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A037040() {
    super(0);
  }

  private Prime mPrime = new Fast();
  private long mM = -1;
  private long mN = -1;
  private long mCount = 0;

  @Override
  public Z next() {
    mN += 2;
    final long s = mN * mN;
    while (mM + 2 < s) {
      mM += 2;
      if (!mPrime.isPrime(mM)) {
        ++mCount;
      }
    }
    return Z.valueOf(mCount);
  }
}
#!queue	A037276	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a037;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A037276 Start with 1; for n&gt;1, replace n with the concatenation of its prime factors in increasing order.
 * @author Sean A. Irvine
 */
public class A037276 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A037276() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    final StringBuilder sb = new StringBuilder();
    final FactorSequence fs = Jaguar.factor(mN);
    for (final Z p : fs.toZArray()) {
      for (int k = 0; k < fs.getExponent(p); ++k) {
        sb.append(p);
      }
    }
    return new Z(sb);
  }
}

#!queue	A037454	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;

/**
 * A037454 a(n) = Sum_{i=0..m} d(i)*6^i, where Sum_{i=0..m} d(i)*3^i is the base 3 representation of n.
 * Implements the "rebase" notation of A000695: (3)[n](6).
 * For example: decimal 30 = 1010 in base 3 (=<code>baseFrom</code>) -&gt; 1010 in base 6 (=<code>baseTo</code>) = 222 in decimal.
 * @author Georg Fischer
 */
public class A037454 extends AbstractSequence {

  private Z mN; // current index
  private final int mBaseFrom;
  private final int mBaseTo;

  /**
   * Empty constructor
   */
  public A037454() {
    super(0);
    mN = Z.NEG_ONE; // offset 0
    mBaseFrom = 3;
    mBaseTo = 6;
  }

  /**
   * Constructor with parameters
   * @param offset index of first term
   * @param baseFrom convert from this base
   * @param baseTo convert to this base
   */
  public A037454(final int offset, final int baseFrom, final int baseTo) {
    super(offset);
    mN = Z.valueOf(offset).subtract(Z.ONE);
    mBaseFrom = baseFrom;
    mBaseTo = baseTo;
  }

  @Override
  public Z next() {
    mN = mN.add(Z.ONE);
    if (mBaseFrom < mBaseTo) {
      return new Z(mN.toString(mBaseFrom), mBaseTo);
    }  else {
      final String nFrom = mN.toString(mBaseFrom);
      Z sum = Z.ZERO;
      Z toPow = Z.ONE;
      for (int pos = nFrom.length() - 1; pos >= 0; --pos) {
        sum = sum.add(toPow.multiply(Character.digit(nFrom.charAt(pos), mBaseFrom)));
        toPow = toPow.multiply(mBaseTo);
      }
      return sum;
    }
  }

  /**
   * Test method, rebases from args[0] to args[1], prints args[2] terms.
   */
  public static void main(final String[] args) {
    final int[] parms = {3, 6, 48}; // default parameters
    int iarg     = 0;
    while (iarg < args.length && iarg < 3) { // with arguments
      try {
        parms[iarg] = Integer.parseInt(args[iarg]);
      } catch (final RuntimeException exc) {
        // ignored
      }
      ++iarg;
    } // with arguments
    final Sequence seq = new A037454(0, parms[0], parms[1]);
    for (int iterm = 0; iterm < parms[2]; ++iterm) { // b-file format
      System.out.print((iterm > 0 ? "," : "") + seq.next());
    } // for iterm
    System.out.println();
  } // main

}
#!queue	A037861	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a037;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A037861 (Number of 0's) - (number of 1's) in the base-2 representation of n.
 * @author Sean A. Irvine
 */
public class A037861 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A037861() {
    super(0);
  }

  private long mN = -1;

  protected long base() {
    return 2;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    long cnt = 0;
    long m = mN;
    while (m != 0) {
      final long b = m % base();
      m /= base();
      if (2 * b < base()) {
        ++cnt;
      } else {
        --cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A038049	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A038049 Number of labeled rooted trees with 2-colored leaves.
 * @author Sean A. Irvine
 */
public class A038049 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A038049() {
    super(1);
  }

  protected long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      sum = sum.add(Binomial.binomial(mN, k).multiply(Z.valueOf(mN - k).pow(mN - 1)));
    }
    return sum;
  }
}
#!queue	A038057	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A038057 a(n) = 2^n*n^(n-1).
 * @author Sean A. Irvine
 */
public class A038057 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A038057() {
    super(1);
  }

  protected int mN = 0;

  @Override
  public Z next() {
    return Z.valueOf(++mN).pow(mN - 1).shiftLeft(mN);
  }
}
#!queue	A038061	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A038061 a(n) = 3^n*n^(n-1).
 * @author Sean A. Irvine
 */
public class A038061 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A038061() {
    super(1);
  }

  protected int mN = 0;
  private Z mT = Z.ONE;

  @Override
  public Z next() {
    mT = mT.multiply(3);
    return Z.valueOf(++mN).pow(mN - 1).multiply(mT);
  }
}
#!queue	A038189	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A038189 Bit to left of least significant 1-bit in binary expansion of n.
 * @author Sean A. Irvine
 */
public class A038189 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A038189() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    long m = mN;
    while ((m & 1) != 1) {
      m >>>= 1;
    }
    return Z.valueOf((m >>> 1) & 1);
  }
}
#!queue	A038792	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a038;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A038792 Rectangular array defined by T(i,1) = T(1,j) = 1 for i &gt;= 1 and j &gt;= 1; T(i,j) = max(T(i-1,j) + T(i-1,j-1), T(i-1,j-1) + T(i,j-1)) for i &gt;= 2, j &gt;= 2, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A038792 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A038792() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 1 || m == 1) {
      return Z.ONE;
    }
    return get(n - 1, m).add(get(n - 1, m - 1)).max(get(n - 1, m - 1).add(get(n, m - 1)));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN + 1 - mM, mM);
  }
}
#!queue	A039658	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a039;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;
import irvine.oeis.a007.A007317;

/**
 * A039658 Related to enumeration of edge-rooted catafusenes.
 * @author Sean A. Irvine
 */
public class A039658 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A039658() {
    super(1);
  }

  private final MemorySequence mA = MemorySequence.cachedSequence(new A007317());
  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int k = 2; k <= mN; ++k) {
      sum = sum.add(mA.a((k - 2) / 2).multiply(mA.a((mN - k) / 2)));
    }
    return sum;
  }
}
#!queue	A039731	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a039;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A039731 a(n)=MAX{p(n) mod q, where prime q &lt; p(n)=n-th prime}.
 * @author Sean A. Irvine
 */
public class A039731 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A039731() {
    super(2);
  }

  private final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    mP = mPrime.nextPrime(mP);
    long max = 0;
    for (long q = 2; q < mP; q = mPrime.nextPrime(q)) {
      final long r = mP % q;
      if (r > max) {
        max = r;
      }
    }
    return Z.valueOf(max);
  }
}
#!queue	A039956	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a039;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A039956 Even squarefree numbers.
 * @author Sean A. Irvine
 */
public class A039956 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A039956() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    while (true) {
      mN += 2;
      if (LongUtils.isSquareFree(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A039957	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a039;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A039957 Squarefree numbers congruent to 3 mod 4.
 * @author Sean A. Irvine
 */
public class A039957 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A039957() {
    super(1);
  }

  private long mN = -1;

  @Override
  public Z next() {
    while (true) {
      mN += 4;
      if (LongUtils.isSquareFree(mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A039987	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a039;

import java.util.Comparator;
import java.util.TreeSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A039987 k th digit of a(n) = number of different digits within 2 places of k (not including k).
 * @author Sean A. Irvine
 */
public class A039987 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A039987() {
    super(0);
  }

  private final TreeSet<String> mA = new TreeSet<>(Comparator.comparingInt(String::length).thenComparing(o -> o));

  {
    for (int k = 1; k <= shift(); ++k) {
      mA.add(String.valueOf(k));
    }
  }

  protected int shift() {
    return 2;
  }

  private boolean isOk(final String s) {
    for (int k = 0; k < s.length(); ++k) {
      int pop = 0;
      for (int j = k - shift(); j <= k + shift(); ++j) {
        if (j != k && j >= 0 && j < s.length()) {
          pop |= 1 << (s.charAt(j) - '0');
        }
      }
      if (Integer.bitCount(pop) != s.charAt(k) - '0') {
        return false;
      }
    }
    return true;
  }

  @Override
  public Z next() {
    while (true) {
      final String s = mA.pollFirst();
      mA.add(s + "1");
      mA.add(s + "2");
      mA.add(s + "3");
      if (isOk(s)) {
        return new Z(s);
      }
    }
  }
}

#!queue	A042942	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a042;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicIntArray;

/**
 * A042942 From substitutional generation of Kolakoski sequence (A000002).
 * @author Sean A. Irvine
 */
public class A042942 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A042942() {
    super(1);
  }

  protected long mN = -1;
  protected LongDynamicIntArray mSeq = new LongDynamicIntArray();
  protected long mLimit = 1;

  protected void rewrite() {
    // Rewrite entire sequence.  There are probably much more space
    // efficient solutions for this, but this should enable us to get
    // lots of sequence reasonably quickly.  Uses single bits to
    // represent sequence 0 = '1', 1 = '2'.
    final LongDynamicIntArray newArray = new LongDynamicIntArray();
    long p = 0;
    long limit = 0;
    int w = 0;
    long q = 0;
    int used = 0;
    for (long k = 0, j = 0, i = 0; j < mLimit; j += 2, --i) {
      if (i == 0) {
        w = mSeq.get(k++);
        i = 16; // number of pairs left in word
      }
      switch (w & 3) {
        case 0:
          q += 1L << used;
          if (j == mLimit - 1) {
            // i.e. trailing "1"
            used += 1;
            limit += 1;
          } else {
            used += 2;
            limit += 2;
          }
          break;
        case 1:
          q += 3L << used;
          if (j == mLimit - 1) {
            // i.e. trailing "2"
            used += 2;
            limit += 2;
          } else {
            used += 3;
            limit += 3;
          }
          break;
        case 2:
          q += 1L << used;
          used += 3;
          limit += 3;
          break;
        default: // i.e. 3
          q += 3L << used;
          used += 4;
          limit += 4;
          break;
      }
      if (used >= 32) {
        newArray.set(p++, (int) q);
        q >>>= 32;
        used -= 32;
      }
      w >>>= 2;
    }
    newArray.set(p, (int) q);
    mSeq = newArray;
    mLimit = limit;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      mSeq.set(0, 1);
      return Z.ONE;
    }
    rewrite();
    return Z.valueOf(mLimit);
  }
}
#!queue	A043000	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A043000 Number of digits in all base-b representations of n, for 2 &lt;= b &lt;= n.
 * @author Sean A. Irvine
 */
public class A043000 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A043000() {
    super(2);
  }

  private long mN = 1;

  @Override
  public Z next() {
    Z sum = Z.ZERO;
    final Z n = Z.valueOf(++mN);
    for (int k = 1; k < mN; ++k) {
      sum = sum.add(n.root(k));
    }
    return sum;
  }
}
#!queue	A043306	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a043;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A043306 Sum of all digits in all base-b representations for n, for 2 &lt;= b &lt;= n.
 * @author Sean A. Irvine
 */
public class A043306 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A043306() {
    super(2);
  }

  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    long sum = 0;
    for (long base = 2; base <= mN; ++base) {
      sum += ZUtils.digitSum(mN, base);
    }
    return Z.valueOf(sum);
  }
}

#!queue	A045812	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a045;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A045812 Number of times the digits are repeated in A045811.
 * @author Sean A. Irvine
 */
public class A045812 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A045812() {
    super(0);
  }

  private long mN = 0;

  protected int base() {
    return 3;
  }

  @Override
  public Z next() {
    while (true) {
      final long[] cnt = new long[base()];
      for (final Z dd : Jaguar.factor(++mN).divisors()) {
        long d = dd.longValue();
        while (d != 0) {
          ++cnt[(int) (d % base())];
          d /= base();
        }
      }
      if (A045811.isConstant(cnt)) {
        return Z.valueOf(cnt[0]);
      }
    }
  }
}

#!queue	A045906	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a045;

import java.util.Arrays;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A045906 Numbers of nonisomorphic systems of catafusenes (see Cyvin et al. (1994) for precise definition).
 * @author Sean A. Irvine
 */
public class A045906 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A045906() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> C1 = RING.multiply(RING.create(Arrays.asList(Q.ONE, Q.ZERO, Q.ONE, new Q(-6), Q.NEG_ONE)), Q.EIGHT);
  private static final Polynomial<Q> C2 = RING.create(Arrays.asList(Q.ONE, new Q(-3)));
  private static final Polynomial<Q> C3 = RING.create(Arrays.asList(Q.ONE, new Q(-5)));
  private static final Polynomial<Q> C4 = RING.create(Arrays.asList(Q.FIVE, Q.THREE, new Q(-5), new Q(-7)));
  private static final Polynomial<Q> C5 = RING.create(Arrays.asList(Q.ONE, Q.ZERO, new Q(-5)));
  private static final Polynomial<Q> C6 = RING.create(Arrays.asList(Q.ONE, Q.ZERO, Q.ZERO, Q.ZERO, new Q(-5)));
  private static final Polynomial<Q> X1 = RING.oneMinusXToTheN(1);
  private static final Polynomial<Q> X2 = RING.oneMinusXToTheN(2);
  private static final Polynomial<Q> X4 = RING.oneMinusXToTheN(4);
  private static final Polynomial<Q> X1_5 = RING.pow(X1, 5);
  private int mN = 3;

  @Override
  public Z next() {
    ++mN;
    final Polynomial<Q> f1 = RING.multiply(RING.multiply(RING.sqrt(X1_5, mN), C2, mN), RING.sqrt(C3, mN), mN);
    final Polynomial<Q> f2 = RING.series(RING.multiply(RING.multiply(C4, RING.sqrt(X2, mN), mN), RING.sqrt(C5, mN), mN), X1, mN);
    final Polynomial<Q> f3 = RING.multiply(RING.multiply(RING.sqrt(X4, mN), Q.TWO), RING.sqrt(C6, mN), mN);
    final Polynomial<Q> gf = RING.subtract(RING.subtract(RING.subtract(C1, f1), f2), f3);
    return gf.coeff(mN).toZ().divide(16);
  }
}
#!queue	A046019	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A046019 a(n) gives the number of different powers m^n for which the sum of the digits is equal to m.
 * @author Sean A. Irvine
 */
public class A046019 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A046019() {
    super(0);
  }

  private static final long HEURISTIC = 300;
  private long mN = -1;

  private long upper(final long n) {
    // Empirical upper bound
    return (long) (3 * n * Math.log(n) + HEURISTIC);
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    long k = 0;
    long cnt = 0;
    final long lim = upper(mN);
    while (k <= lim) {
      if (ZUtils.digitSum(Z.valueOf(++k).pow(mN)) == k) {
        ++cnt;
      }
    }
    return Z.valueOf(cnt);
  }
}
#!queue	A046080	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a046;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A046080 a(n) is the number of integer-sided right triangles with hypotenuse n.
 * @author Sean A. Irvine
 */
public class A046080 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A046080() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    long m = mN;
    while ((m & 1) == 0) {
      m >>>= 1;
    }
    Z prod = Z.ONE;
    final FactorSequence fs = Jaguar.factor(m);
    for (final Z p : fs.toZArray()) {
      final int e = fs.getExponent(p);
      if (p.mod(4) == 1) {
        prod = prod.multiply(2L * e + 1);
      }
    }
    return prod.subtract(1).divide2();
  }
}
#!queue	A046094	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a046;

import irvine.math.group.IntegersModMul;
import irvine.math.q.BernoulliSequence;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A046094 Agoh's congruence; a(n) is conjectured to be 1 iff n is prime.
 * @author Sean A. Irvine
 */
public class A046094 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A046094() {
    super(1);
  }

  private final BernoulliSequence mB = new BernoulliSequence(0);
  private long mN = 0;

  @Override
  public Z next() {
    final Q b = mB.nextQ().multiply(-++mN);
    if (mN == 1) {
      return Z.ZERO;
    }
    final IntegersModMul r = new IntegersModMul(mN);
    return r.add(b.num(), r.negate(b.den()));
  }
}
#!queue	A046232	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a046;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.string.StringUtils;

/**
 * A046232 Cubes which are palindromes in base 4.
 * @author Sean A. Irvine
 */
public class A046232 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A046232() {
    super(1);
  }

  private long mN = -1;

  protected int base() {
    return 4;
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = Z.valueOf(++mN).pow(3);
      if (StringUtils.isPalindrome(t.toString(base()))) {
        return t;
      }
    }
  }
}
#!queue	A046432	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a046;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A046432 2 steps needed to reach a prime under "Sum of digits raised to its digits' powers" procedure.
 * @author Sean A. Irvine
 */
public class A046432 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A046432() {
    super(1);
  }

  private long mN = 0;

  static Z sumOfDigitPowers(Z n) {
    Z sum = Z.ZERO;
    while (!n.isZero()) {
      final Z[] qr = n.divideAndRemainder(Z.TEN);
      final long r = qr[1].longValue();
      n = qr[0];
      sum = sum.add(LongUtils.pow(r, r));
    }
    return sum;
  }

  protected int steps() {
    return 2;
  }

  private boolean is(final long n) {
    Z m = Z.valueOf(n);
    for (int k = 1; k < steps(); ++k) {
      m = sumOfDigitPowers(m);
      if (m.isProbablePrime()) {
        return false;
      }
    }
    return sumOfDigitPowers(m).isProbablePrime();
  }

  @Override
  public Z next() {
    while (!is(++mN)) {
      // do nothing
    }
    return Z.valueOf(mN);
  }
}
#!queue	A047000	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047000 Array T read by diagonals; T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no step touches the line y=x/2 except at the endpoints.
 * @author Sean A. Irvine
 */
public class A047000 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    if (n - 1 != 2 * m) {
      s = s.add(get(n - 1, m));
    }
    if (n != 2 * m - 2 && n != 2 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047010	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047010 Array T read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no step touches the line y=x/3 unless x=0 or x=h.
 * @author Sean A. Irvine
 */
public class A047010 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    if (n - 1 != 3 * m) {
      s = s.add(get(n - 1, m));
    }
    if (n != 3 * m - 3 && n != 3 * m - 2 && n != 3 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047020	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047020 Array T read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no step touches the line y=2x/3 unless x=0 or x=h.
 * @author Sean A. Irvine
 */
public class A047020 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    if (2 * n - 1 != 3 * m && 2 * n - 2 != 3 * m) {
      s = s.add(get(n - 1, m));
    }
    if (2 * n != 3 * m - 3 && 2 * n != 3 * m - 2 && 2 * n != 3 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047030	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047030 Array T read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no step touches the line y=x/4 unless x=0 or x=h.
 * @author Sean A. Irvine
 */
public class A047030 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    if (n - 1 != 4 * m) {
      s = s.add(get(n - 1, m));
    }
    if (n != 4 * m - 4 && n != 4 * m - 3 && n != 4 * m - 2 && n != 4 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047040	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047040 Array T read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no step touches the line y=3x/4 unless x=0 or x=h.
 * @author Sean A. Irvine
 */
public class A047040 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    if (3 * n - 1 != 4 * m && 3 * n - 2 != 4 * m && 3 * n - 3 != 4 * m) {
      s = s.add(get(n - 1, m));
    }
    if (3 * n != 4 * m - 4 && 3 * n != 4 * m - 3 && 3 * n != 4 * m - 2 && 3 * n != 4 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047060	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047060 Array T read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no step touches the line y=5x/3 unless x=0 or x=h.
 * @author Sean A. Irvine
 */
public class A047060 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    if (5 * n - 1 != 3 * m && 5 * n - 2 != 3 * m && 5 * n - 3 != 3 * m && 5 * n - 4 != 3 * m && 5 * n - 5 != 3 * m) {
      s = s.add(get(n - 1, m));
    }
    if (5 * n != 3 * m - 3 && 5 * n != 3 * m - 2 && 5 * n != 3 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047080	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047080 Triangular array T read by rows: T(h,k)=number of paths from (0,0) to (k,h-k) using step-vectors (0,1), (1,0), (1,1) with no right angles between pairs of consecutive steps.
 * @author Sean A. Irvine
 */
public class A047080 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n < 0 || m > n) {
      return Z.ZERO;
    }
    if (n < 3) {
      return Z.ONE;
    }
    if (2 * m < n) {
      return get(n, n - m);
    }
    return get(n - 1, m - 1).add(get(n - 1, m)).subtract(get(n - 4, m - 2));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A047089	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047089 Array T read by antidiagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and touches the line y=x/2 only at lattice points.
 * @author Sean A. Irvine
 */
public class A047089 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m < 0 || m > n) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    Z s = get(n - 1, m - 1);
    if ((n + 1) % 3 != 0 || n != m + (n + 1) / 3) {
      s = s.add(get(n - 1, m));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A047098	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A047098 a(n) = 2*binomial(3*n, n) - Sum_{k=0..n} binomial(3*n, k).
 * @author Sean A. Irvine
 */
public class A047098 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A047098() {
    super(0);
  }

  private long mN = -1;

  @Override
  public Z next() {
    Z sum = Binomial.binomial(3 * ++mN, mN).multiply2();
    for (long k = 0; k <= mN; ++k) {
      sum = sum.subtract(Binomial.binomial(3 * mN, k));
    }
    return sum;
  }
}
#!queue	A047100	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047100 Array T read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and touches the line y=x/3 only at lattice points.
 * @author Sean A. Irvine
 */
public class A047100 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = get(n - 1, m);
    if (n != 3 * m - 2 && n != 3 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047110	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047110 Array read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no up-step crosses the line y=2x/3. (Thus a path crosses the line only at lattice points and on right-steps.).
 * @author Sean A. Irvine
 */
public class A047110 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = get(n - 1, m);
    if (2 * n != 3 * m - 2 && 2 * n != 3 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047120	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047120 Array T read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and touches the line y=x/4 only at lattice points.
 * @author Sean A. Irvine
 */
public class A047120 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = get(n - 1, m);
    if (n != 4 * m - 3 && n != 4 * m - 2 && n != 4 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047130	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047130 Array read by descending antidiagonals: T(h,k) is the number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no up-step crosses the line y = 3x/4. (Thus a path crosses the line only at lattice points and on right-steps.).
 * @author Sean A. Irvine
 */
public class A047130 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = get(n - 1, m);
    if (3 * n != 4 * m - 3 && 3 * n != 4 * m - 2 && 3 * n != 4 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047140	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047140 Array read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no up-step crosses the line y=4x/3. (Thus a path crosses the line only at lattice points and on right-steps.).
 * @author Sean A. Irvine
 */
public class A047140 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = get(n - 1, m);
    if (4 * n != 3 * m - 2 && 4 * n != 3 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047150	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A047150 Array read by diagonals: T(h,k)=number of paths consisting of steps from (0,0) to (h,k) such that each step has length 1 directed up or right and no up-step crosses the line y=5x/3. (Thus a path crosses the line only at lattice points and on right-steps.).
 * @author Sean A. Irvine
 */
public class A047150 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z s = get(n - 1, m);
    if (5 * n != 3 * m - 2 && 5 * n != 3 * m - 1) {
      s = s.add(get(n, m - 1));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A047161	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A047161 Number of nonempty subsets of {1,2,...,n} in which exactly 1/3 of the elements are &lt;= n/2.
 * @author Georg Fischer
 */
public class A047161 extends AbstractSequence {

  protected int mN; // current index
  protected int mNum; // numerator
  protected int mDen; // denominator
  protected int mAdd; // n + a
  protected int mDiv; // (n + a)/d

  /** Construct the sequence. */
  public A047161() {
    this(1, 1, 3, 0, 2);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param num numerator of fraction
   * @param den denominator of fraction
   * @param add additional term a for n
   * @param div divisor of (n+a)
   */
  public A047161(final int offset, final int num, final int den, final int add, final int div) {
    super(offset);
    mN = offset - 1;
    mNum = num;
    mDen = den;
    mAdd = add;
    mDiv = div;
  }

  @Override
  public Z next() {
    ++mN;
    /*
      A048046 (Maple):
      f:= proc(n) local k, j;
        k:= floor((n+1)/3);
        add(binomial(k, 4/5*j)*binomial(n-k, 1/5*j), j=5..n, 5)
      end proc:
      map(f, [$1..100]); # Robert Israel, Apr 16 2019
    */
    final int k = (mN + mAdd) / mDiv;
    Z sum = Z.ZERO;
    for (int j = mDen; j <= mN; j += mDen) {
      sum = sum.add(Binomial.binomial(k, j * mNum / mDen).multiply(Binomial.binomial(mN - k, j * (mDen - mNum) / mDen)));
    }
    return sum;
  }
}
#!queue	A047675	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A047675 Square array a(n,k) read by antidiagonals: a(n,1)=n, a(1,k)=k, a(n,k) = a(n-1,k-1)*a(n-1,k)*a(n,k-1).
 * @author Sean A. Irvine
 */
public class A047675 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A047675() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n == 1) {
      return Z.valueOf(k);
    }
    if (k == 1) {
      return Z.valueOf(n);
    }
    return get(n - 1, k - 1).multiply(get(n, k - 1)).multiply(get(n - 1, k));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM + 1, mM);
  }
}
#!queue	A047812	1	->	1	MemoryFunctionSequence	--------------------------------
package irvine.oeis.a047;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionSequence;

/**
 * A047812 Parker's partition triangle T(n,k) read by rows (n &gt;= 1 and 0 &lt;= k &lt;= n-1).
 * @author Sean A. Irvine
 */
public class A047812 extends MemoryFunctionSequence<Integer, Polynomial<Z>> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A047812() {
    super(1);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Polynomial<Z> compute(final Integer n) {
    final int n2 = n * n;
    Polynomial<Z> prod = RING.one();
    for (int k = 0; k < n; ++k) {
      prod = RING.multiply(prod, RING.series(RING.oneMinusXToTheN(2 * n - k), RING.oneMinusXToTheN(k + 1), n2), n2);
    }
    return prod;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN).coeff(mM * (mN + 1));
  }
}
#!queue	A047844	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000040;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A047844 Patrick De Geest's "Generations" array read by antidiagonals: a(n,1) = n-th prime, a(1,k+1) = a(2,k), a(n,k+1) = a(n-1,k) + a(n+1,k).
 * @author Sean A. Irvine
 */
public class A047844 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A047844() {
    super(1);
  }

  private final MemorySequence mPrime = MemorySequence.cachedSequence(new A000040());
  private long mN = 1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (m == 1) {
      return mPrime.a((int) (n - 1));
    }
    return n == 1 ? get(2L, m - 1) : get(n - 1, m - 1).add(get(n + 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM, mM);
  }
}
#!queue	A047863	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a047;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A047863 Number of labeled graphs with 2-colored nodes where black nodes are only connected to white nodes and vice versa.
 * @author Sean A. Irvine
 */
public class A047863 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A047863() {
    super(0);
  }

  protected int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 0; k <= mN; ++k) {
      s = s.add(Binomial.binomial(mN, k).shiftLeft(k * (mN - k)));
    }
    return s;
  }
}
#!queue	A047874	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a047;

import java.util.ArrayList;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A047874 Triangle of numbers T(n,k) = number of permutations of (1,2,...,n) with longest increasing subsequence of length k (1&lt;=k&lt;=n).
 * @author Sean A. Irvine
 */
public class A047874 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A047874() {
    super(1);
  }

  private final MemoryFactorial mFactorial = MemoryFactorial.SINGLETON;

  private Z h(final ArrayList<Integer> l) {
    int s = 0;
    for (final int v : l) {
      s += v;
    }
    final Z f = mFactorial.factorial(s);
    Z p = Z.ONE;
    for (int i = 0; i < l.size(); ++i) {
      for (int j = 1; j <= l.get(i); ++j) {
        long t = 1 + l.get(i) - j;
        for (int k = i + 1; k < l.size(); ++k) {
          if (l.get(k) >= j) {
            ++t;
          }
        }
        p = p.multiply(t);
      }
    }
    return f.divide(p);
  }

  protected Z g(final int n, final int i, final ArrayList<Integer> l) {
    if (n == 0 || i == 1) {
      final ArrayList<Integer> h = new ArrayList<>(l);
      for (int k = 0; k < n; ++k) {
        h.add(1);
      }
      return h(h).square();
    } else {
      Z s = Z.ZERO;
      if (i > 1) {
        for (int j = 0; j <= n / i; ++j) {
          final ArrayList<Integer> h = new ArrayList<>(l);
          for (int k = 0; k < j; ++k) {
            h.add(i);
          }
          s = s.add(g(n - i * j, i - 1, h));
        }
      }
      return s;
    }
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    final ArrayList<Integer> l = new ArrayList<>();
    l.add(mM);
    return g(mN - mM, Math.min(mN - mM, mM), l);
  }
}
#!queue	A048113	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A048113 Triangular array T read by rows: T(h,k) = number of paths consisting of steps from (1,1) to (h,k) such that each step has length 1 directed up or right and each vertex (i,j) satisfies i/2&lt;=j&lt;=2i, for h=0,1,2,... and k=0,1,2,...
 * @author Sean A. Irvine
 */
public class A048113 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After Jean-Fran&ccedil;ois Alcover

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n <= 0 || (n == 1 && m == 0)) {
      return Z.ZERO;
    }
    if (2 * m < n || m > 2 * n) {
      return Z.ZERO;
    }
    if (n == 1 || (n == 2 && m == 1)) {
      return Z.ONE;
    }
    Z res = Z.ZERO;
    if (2 * (n - 1) >= m) {
      res = res.add(get(n - 1, m));
    }
    if (2 * (m - 1) >= n) {
      res = res.add(get(n, m - 1));
    }
    return res;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A048141	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import irvine.math.partitions.DistinctOddPartsPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048141 Number of symmetrical planar partitions of n: planar partitions (A000219) that when regarded as 3-D objects have a threefold axis of symmetry that is the intersection of 3 mirror planes, i.e., C3v symmetry.
 * @author Sean A. Irvine
 */
public class A048141 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048141() {
    super(1);
  }

  private int mN = 0;
  private final List<Map<int[], Long>> mCache = new ArrayList<>();
  private final List<List<int[]>> mPerfectlyBalanced = new ArrayList<>();

  {
    mPerfectlyBalanced.add(Collections.emptyList()); // 0
  }

  private static final Comparator<int[]> ARRAY_COMPARATOR = (o1, o2) -> {
    final int c = Integer.compare(o1.length, o2.length);
    if (c != 0) {
      return c;
    }
    for (int k = 0; k < o1.length; ++k) {
      final int d = Integer.compare(o1[k], o2[k]);
      if (d != 0) {
        return d;
      }
    }
    return 0;
  };

  private boolean isOverMajored(final int[] outer, final int[] inner) {
    if (inner.length > outer.length) {
      return false;
    }
    for (int k = 0; k < inner.length; ++k) {
      if (inner[k] >= outer[k]) {
        return false;
      }
    }
    return true;
  }

//  private boolean isSelfConjugate(final int[] p) {
//    for (int k = 0; k < p.length; ++k) {
//      if (p[k] > p.length || p[p[k] - 1] <= k) {
//        return false;
//      }
//    }
//    return true;
//  }

  private List<int[]> getSelfConjugate(final int n) {
    while (n >= mPerfectlyBalanced.size()) {
      final int arm = mPerfectlyBalanced.size();
      // There is a 1-1 correspondence between partitions into distinct odd parts and self-conjugate partitions
      final List<int[]> distinct = DistinctOddPartsPartition.partitions(arm);
      final ArrayList<int[]> balanced = new ArrayList<>(distinct.size());
      mPerfectlyBalanced.add(balanced);
      // bend them
      for (final int[] d : distinct) {
        final int[] b = new int[(d[0] + 1) / 2];
        for (int k = 0; k < d.length; ++k) {
          final int t = (d[k] - 1) / 2;
          b[k] += t;
          for (int j = 0; j <= t; ++j) {
            ++b[k + j];
          }
        }
        balanced.add(b);
      }
    }
    return mPerfectlyBalanced.get(n);
  }

  private long count(final int n, final int[] majors) {
    long c = 0;
    if (majors.length != 0) {
      for (Map.Entry<int[], Long> e : mCache.get(n).entrySet()) {
        if (isOverMajored(majors, e.getKey())) {
          c += e.getValue();
        }
      }
    }
    return c;
  }

//  private void printCache(final int n) {
//    System.out.print("n=" + n + ": ");
//    for (Map.Entry<int[], Long> e : mCache.get(n).entrySet()) {
//      System.out.print(Arrays.toString(e.getKey()) + " -> " + e.getValue() + ", ");
//    }
//    System.out.println();
//  }

  @Override
  public Z next() {
    if (++mN == 1) {
      mCache.add(Collections.singletonMap(new int[] {}, 1L)); // n = 0
      mCache.add(Collections.singletonMap(new int[] {1}, 1L));
      return Z.ONE;
    }
    long count = 0;
    final TreeMap<int[], Long> map = new TreeMap<>(ARRAY_COMPARATOR);
    mCache.add(map);
    for (int arm = mN; arm > 0; --arm) {
      long c = 0;
      for (final int[] p : getSelfConjugate(arm)) {
        final int residue = mN - 3 * (arm - p[0]) - 1;
        if (residue < 0) {
          continue;
        }
        final long pc = count(residue, Arrays.copyOfRange(p, 1, p.length));
        if (pc != 0) {
          map.put(p, pc);
        }
        c += pc;
      }
      count += c;
    }
    //printCache(mN);
    return Z.valueOf(count);
  }
}
#!queue	A048380	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048380 Digits d in decimal expansion of n replaced with d-th prime (replacing each 0 digit with a 1).
 * @author Sean A. Irvine
 */
public class A048380 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048380() {
    super(0);
  }

  static final String[] EXPANSIONS = {
    "1",
    "2",
    "3",
    "5",
    "7",
    "11",
    "31", // we do a reverse later!
    "71",
    "91",
    "32"
  };
  private long mN = -1;

  @Override
  public Z next() {
    final StringBuilder sb = new StringBuilder();
    long m = ++mN;
    do {
      sb.append(EXPANSIONS[(int) (m % 10)]);
      m /= 10;
    } while (m != 0);
    return new Z(sb.reverse());
  }
}
#!queue	A048385	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048385 In base-10 notation replace digits of n with their squared values (Version 1).
 * @author Sean A. Irvine
 */
public class A048385 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048385() {
    super(0);
  }

  static final String[] EXPANSIONS = {
    "0",
    "1",
    "4",
    "9",
    "61", // we do a reverse later!
    "52",
    "63",
    "94",
    "46",
    "18"
  };
  private long mN = -1;

  @Override
  public Z next() {
    final StringBuilder sb = new StringBuilder();
    long m = ++mN;
    do {
      sb.append(EXPANSIONS[(int) (m % 10)]);
      m /= 10;
    } while (m != 0);
    return new Z(sb.reverse());
  }
}
#!queue	A048390	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048390 Digits d in decimal expansion of n replaced with d^3.
 * @author Sean A. Irvine
 */
public class A048390 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048390() {
    super(0);
  }

  static final String[] EXPANSIONS = {
    "0",
    "1",
    "8",
    "72", // we do a reverse later!
    "46",
    "521",
    "612",
    "343",
    "215",
    "927"
  };
  private long mN = -1;

  @Override
  public Z next() {
    final StringBuilder sb = new StringBuilder();
    long m = ++mN;
    do {
      sb.append(EXPANSIONS[(int) (m % 10)]);
      m /= 10;
    } while (m != 0);
    return new Z(sb.reverse());
  }
}
#!queue	A048549	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048549 a(n+1) is next smallest prime beginning with a(n), initial prime is 2.
 * @author Sean A. Irvine
 */
public class A048549 extends AbstractSequence {

  private String mPrefix = null;
  private final String mStart;
  private final int mBase;

  protected A048549(final String start, final int base) {
    super(start.equals("2") ? 1 : 0);
    mStart = start;
    mBase = base;
  }

  protected A048549(final String start) {
    this(start, 10);
  }

  /** Construct the sequence. */
  public A048549() {
    this("2", 10);
  }

  private Z makeNumber(final String prefix, final StringBuilder zeros, final long m) {
    final String t = zeros.toString() + Long.toString(m, mBase);
    return new Z(prefix + t.substring(t.length() - zeros.length() - 1), mBase);
  }

  @Override
  public Z next() {
    if (mPrefix == null) {
      mPrefix = mStart;
    } else {
      // Complicated by the possibility of leading zeros in the suffix
      final StringBuilder zeros = new StringBuilder();
      long lim = mBase;
      long m = 1;
      Z t;
      while (!(t = makeNumber(mPrefix, zeros, m)).isProbablePrime()) {
        m += 2;
        if (m > lim) {
          lim *= mBase;
          m = 1;
          zeros.append('0');
        }
      }
      mPrefix = t.toString(mBase);
    }
    return new Z(mPrefix, mBase);
  }
}
#!queue	A048601	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048601 Robbins triangle read by rows: T(n,k) = number of alternating sign n X n matrices with a 1 at top of column k (n &gt;= 1, 1&lt;=k&lt;=n).
 * @author Sean A. Irvine
 */
public class A048601 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048601() {
    super(1);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = 0;
  private int mM = 0;

  protected Z t(final int n, final int k) {
    Z prod = Binomial.binomial(n + k - 2, k - 1).multiply(mF.factorial(2 * n - k - 1).divide(mF.factorial(n - k)));
    for (int j = 0; j <= n - 2; ++j) {
      prod = prod.multiply(mF.factorial(3 * j + 1));
    }
    for (int j = 0; j <= n - 2; ++j) {
      prod = prod.divide(mF.factorial(n + j));
    }
    return prod;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}

#!queue	A048671	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048671 a(n) is the least common multiple of the proper divisors of n.
 * @author Sean A. Irvine
 */
public class A048671 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048671() {
    super(1);
  }

  private Z mN = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(1);
    Z lcm = Z.ONE;
    for (final Z d : Jaguar.factor(mN).divisors()) {
      if (!d.equals(mN)) {
        lcm = lcm.lcm(d);
      }
    }
    return lcm;
  }
}
#!queue	A048793	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048793 List giving all subsets of natural numbers arranged in standard statistical (or Yates) order.
 * @author Sean A. Irvine
 */
public class A048793 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048793() {
    super(0);
  }

  // After Alois P. Heinz

  private final ArrayList<Long> mA = new ArrayList<>();
  private long mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM >= mA.size()) {
      mA.clear();
      if (++mN == 0) {
        return Z.ZERO;
      } else {
        long k = 0;
        long m = mN;
        while (m != 0) {
          ++k;
          if ((m & 1) == 1) {
            mA.add(k);
          }
          m >>>= 1;
        }
      }
      mM = 0;
    }
    return Z.valueOf(mA.get(mM));
  }
}
#!queue	A048855	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048855 Number of integers up to n! relatively prime to n!.
 * @author Sean A. Irvine
 */
public class A048855 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048855() {
    super(0);
  }

  private final Fast mPrime = new Fast();
  private long mN = -1;
  private Z mA = Z.ONE;

  @Override
  public Z next() {
    if (++mN > 2) {
      mA = mPrime.isPrime(mN) ? mA.multiply(mN - 1) : mA.multiply(mN);
    }
    return mA;
  }
}

#!queue	A048887	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a048;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A048887 Array T read by antidiagonals, where T(m,n) = number of compositions of n into parts &lt;= m.
 * @author Sean A. Irvine
 */
public class A048887 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048887() {
    super(1);
  }

  // After Alois P. Heinz

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long m) {
    if (n == 0 || m == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= Math.min(n, m); ++k) {
      sum = sum.add(get(n - k, m));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mM, 1 + mN - mM);
  }
}

#!queue	A048996	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a048;

import java.util.Arrays;
import java.util.TreeSet;

import irvine.math.Comparators;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A048996 Irregular triangle read by rows. Preferred multisets: numbers refining A007318 using format described in A036038.
 * @author Sean A. Irvine
 */
public class A048996 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A048996() {
    super(0);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private final TreeSet<int[]> mA = new TreeSet<>(Comparators.ABRAHAM_STEGUN);
  protected int mN = -1;
  private int[] mC;

  @Override
  public Z next() {
    if (mA.isEmpty()) {
      if (++mN == 0) {
        return Z.ONE;
      }
      final IntegerPartition part = new IntegerPartition(mN);
      int[] p;
      while ((p = part.next()) != null) {
        mA.add(Arrays.copyOf(p, p.length));
      }
      mC = new int[mN + 1];
    }
    IntegerPartition.toCountForm(mA.pollFirst(), mC);
    Z prod = Z.ONE;
    Z sum = Z.ZERO;
    for (final int c : mC) {
      sum = sum.add(c);
      prod = prod.multiply(mF.factorial(c));
    }
    return mF.factorial(sum).divide(prod);
  }
}

#!queue	A049354	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Permutation;

/**
 * A049354 Digitally balanced numbers in base 3: equal numbers of 0's, 1's, 2's.
 * @author Sean A. Irvine
 */
public class A049354 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A049354() {
    super(1);
  }

  private Permutation mPerm = new Permutation(new int[]{0});
  private int mRep = 0;

  protected int base() {
    return 3;
  }

  @Override
  public Z next() {
    while (true) {
      final int[] p = mPerm.next();
      if (p == null) {
        ++mRep;
        final int[] perm = new int[base() * mRep];
        for (int d = 0, j = 0; d < base(); ++d) {
          for (int s = mRep; s > 0; --s, ++j) {
            perm[j] = d;
          }
        }
        mPerm = new Permutation(perm);
      } else if (p[0] != 0) {
        final StringBuilder sb = new StringBuilder();
        for (final int d : p) {
          sb.append(d);
        }
        return new Z(sb, base());
      }
    }
  }
}
#!queue	A049606	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049606 Largest odd divisor of n!.
 * @author Sean A. Irvine
 */
public class A049606 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A049606() {
    super(0);
  }

  private Z mF = Z.ONE;
  private long mN = -1;

  @Override
  public Z next() {
    if (++mN > 2) {
      long m = mN;
      while ((m & 1) == 0) {
        m >>>= 1;
      }
      mF = mF.multiply(m);
    }
    return mF;
  }
}

#!queue	A049690	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Euler;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049690 a(n) = Sum_{k=1..n} phi(2*k), where phi = Euler totient function, cf. A000010.
 * @author Sean A. Irvine
 */
public class A049690 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A049690() {
    super(0);
  }

  private Z mN = Z.valueOf(-2);
  private Z mSum = Z.ZERO;

  @Override
  public Z next() {
    mN = mN.add(2);
    if (!mN.isZero()) {
      mSum = mSum.add(Euler.phi(mN));
    }
    return mSum;
  }
}
#!queue	A049711	3	->	3	AbstractSequence	--------------------------------
package irvine.oeis.a049;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049711 a(n) = n - prevprime(n).
 * @author Sean A. Irvine
 */
public class A049711 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A049711() {
    super(3);
  }

  private final Fast mPrime = new Fast();
  private long mN = 2;

  @Override
  public Z next() {
    return Z.valueOf(++mN - mPrime.prevPrime(mN));
  }
}
#!queue	A049765	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049765 Triangular array T, read by rows: T(n,k) = (k mod n) + (n mod k), for k = 1..n and n &gt;= 1.
 * @author Sean A. Irvine
 */
public class A049765 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A049765() {
    super(1);
  }

  private long mN = 0;
  private long mM = 1;

  protected long t(final long n, final long m) {
    return n % m + m % n;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return Z.valueOf(t(mN, mM));
  }
}
#!queue	A049816	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a049;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049816 Triangular array T read by rows: T(n,k)=number of nonzero remainders when Euclidean algorithm acts on n and k, for k=1,2,...,n, n=1,2,...
 * @author Sean A. Irvine
 */
public class A049816 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A049816() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  private long r(final long n, final long m) {
    final long r = n % m;
    return r == 0 ? 1 : r(m, r) + 1;
  }

  protected long t(final long n, final long m) {
    return r(n, m) - 1;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return Z.valueOf(t(mN - mM, mM));
  }
}
#!queue	A049880	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a049;

import java.util.TreeSet;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A049880 a(n) is the number of distinct sums of 2 different primes chosen from the first n primes.
 * @author Sean A. Irvine
 */
public class A049880 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A049880() {
    super(2);
  }

  protected final TreeSet<Long> mSeen = new TreeSet<>();
  protected final Fast mPrime = new Fast();
  private long mP = 2;

  @Override
  public Z next() {
    mP = mPrime.nextPrime(mP);
    for (long q = 2; q != mP; q = mPrime.nextPrime(q)) {
      mSeen.add(mP + q);
    }
    return Z.valueOf(mSeen.size());
  }
}
#!queue	A050143	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A050143 A(n,k) = Sum_{h=0..n-1, m=0..k} A(h,m) for n &gt;= 1 and k &gt;= 1, with A(n,0) = 1 for n &gt;= 0 and A(0,k) = 0 for k &gt;= 1; square array A, read by descending antidiagonals.
 * @author Sean A. Irvine
 */
public class A050143 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050143() {
    super(1);
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 0) {
      return Z.ONE;
    }
    if (n == 0) {
      return Z.ZERO;
    }
    if (m == 1) {
      return Z.ONE.shiftLeft(n).subtract(1);
    }
    return get(n - 1, m).multiply2().add(get(n, m - 1)).subtract(get(n - 1, m - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN - mM);
  }
}
#!queue	A050186	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import irvine.factor.factor.Jaguar;
import irvine.math.LongUtils;
import irvine.math.Mobius;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A050186 Triangular array T read by rows: T(h,k) = number of binary words of k 1's and h-k 0's which are not a juxtaposition of 2 or more identical subwords.
 * @author Sean A. Irvine
 */
public class A050186 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050186() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  protected Z t(final long n, final long m) {
    if (m == 0) {
      return n <= 1 ? Z.ONE : Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(LongUtils.gcd(n, m)).divisors()) {
      final long d = dd.longValue();
      final int mobius = Mobius.mobius(d);
      if (mobius != 0) {
        sum = sum.signedAdd(mobius == 1, Binomial.binomial(n / d, m / d));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A050376	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import java.util.Map;

import irvine.math.PrimePowers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A050376 "Fermi-Dirac primes": numbers of the form p^(2^k) where p is prime and k &gt;= 0.
 * @author Sean A. Irvine
 */
public class A050376 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050376() {
    super(1);
  }

  private final PrimePowers mPP = new PrimePowers();

  {
    mPP.next(); // skip 1
  }

  @Override
  public Z next() {
    while (true) {
      final Map.Entry<Long, Pair<Long, Long>> e = mPP.next();
      final long exponent = e.getValue().right();
      if ((exponent & (exponent - 1)) == 0) {
        return Z.valueOf(e.getKey());
      }
    }
  }
}
#!queue	A050383	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A050383 Permutation rooted trees with n nodes.
 * @author Sean A. Irvine
 */
public class A050383 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050383() {
    super(1);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  protected int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Polynomial<Z> a = RING.onePlusXToTheN(1);
    for (int i = 1; i <= mN; ++i) {
      Polynomial<Z> b = RING.one();
      for (int k = 1; k <= mN; ++k) {
        b = RING.multiply(b, RING.subtract(RING.one(), a.substitutePower(k, mN).shift(k)), mN);
      }
      a = RING.series(RING.one(), b, mN);
    }
    return a.coeff(mN);
  }
}
#!queue	A050504	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import irvine.math.cr.CR;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A050504 Integer part of n*log(n).
 * @author Sean A. Irvine
 */
public class A050504 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050504() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    final CR n = CR.valueOf(++mN);
    return n.multiply(n.log()).floor();
  }
}
#!queue	A050674	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A050674 Inserting a digit '0' between adjacent digits of n makes a prime.
 * @author Sean A. Irvine
 */
public class A050674 extends AbstractSequence {

  private long mN = 9;
  private final char mInsert;

  protected A050674(final char insert) {
    super(insert == '6' ? 0 : 1);
    mInsert = insert;
  }

  /** Construct the sequence. */
  public A050674() {
    this('0');
  }

  @Override
  public Z next() {
    while (true) {
      mN += 2;
      final String s = String.valueOf(mN);
      if (s.charAt(s.length() - 1) != '5') {
        final StringBuilder sb = new StringBuilder();
        sb.append(s.charAt(0));
        for (int k = 1; k < s.length(); ++k) {
          sb.append(mInsert).append(s.charAt(k));
        }
        if (new Z(sb).isProbablePrime()) {
          return Z.valueOf(mN);
        }
      }
    }
  }
}
#!queue	A050703	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A050703 Numbers that when added to the sum of their prime factors (with multiplicity) become prime.
 * @author Sean A. Irvine
 */
public class A050703 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050703() {
    super(1);
  }

  private long mN = 1;

  protected Z f(final Z n) {
    return Jaguar.factor(n).sopfr().add(n);
  }

  protected int iterations() {
    return 1;
  }

  @Override
  public Z next() {
    outer:
    while (true) {
      final Z n = Z.valueOf(++mN);
      if (!n.isProbablePrime()) {
        Z t = n;
        for (int k = 1; k < iterations(); ++k) {
          t = f(t);
          if (t.isProbablePrime()) {
            continue outer;
          }
        }
        t = f(t);
        if (t.isProbablePrime()) {
          return n;
        }
      }
    }
  }
}
#!queue	A050724	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A050724 Numbers k such that the decimal expansion of 3^k contains no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050724 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050724() {
    super(1);
  }

  private long mN = -1;
  private Z mT = Z.ONE;

  protected long multiplier() {
    return 3;
  }

  @Override
  public Z next() {
    outer:
    while (true) {
      if (++mN > 0) {
        mT = mT.multiply(multiplier());
      }
      Z r = Z.NEG_ONE;
      Z t = mT;
      do {
        final Z[] qr = t.divideAndRemainder(Z.TEN);
        if (qr[1].equals(r)) {
          continue outer;
        }
        r = qr[1];
        t = qr[0];
      } while (!t.isZero());
      return Z.valueOf(mN);
    }
  }
}

#!queue	A050733	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A050733 Numbers of form 3^k (values of k see A050724) containing no pair of consecutive equal digits (probably finite).
 * @author Sean A. Irvine
 */
public class A050733 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050733() {
    super(0);
  }

  private Z mT = null;

  protected long multiplier() {
    return 3;
  }

  @Override
  public Z next() {
    outer:
    while (true) {
      mT = mT == null ? Z.ONE : mT.multiply(multiplier());
      Z r = Z.NEG_ONE;
      Z t = mT;
      do {
        final Z[] qr = t.divideAndRemainder(Z.TEN);
        if (qr[1].equals(r)) {
          continue outer;
        }
        r = qr[1];
        t = qr[0];
      } while (!t.isZero());
      return mT;
    }
  }
}

#!queue	A050946	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a050;

import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000045;

/**
 * A050946 "Stirling-Bernoulli transform" of Fibonacci numbers.
 * @author Sean A. Irvine
 */
public class A050946 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A050946() {
    super(0);
  }

  private final MemorySequence mFibo = MemorySequence.cachedSequence(new A000045());
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    Z f = Z.ONE;
    for (int k = 1; k <= mN; ++k, f = f.multiply(k)) {
      sum = sum.signedAdd(((mN - k) & 1) == 0, Stirling.secondKind(mN, k).multiply(f).multiply(mFibo.a(k)));
    }
    return sum;
  }
}

#!queue	A051168	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a051;

import irvine.factor.factor.Jaguar;
import irvine.math.LongUtils;
import irvine.math.Mobius;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A051168 Triangular array T(h,k) for 0 &lt;= k &lt;= h read by rows: T(h,k) = number of binary Lyndon words with k ones and h-k zeros.
 * @author Sean A. Irvine
 */
public class A051168 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A051168() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  protected Z t(final long n, final long k) {
    if (n == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(LongUtils.gcd(n, k)).divisors()) {
      final long d = dd.longValue();
      sum = sum.add(Binomial.binomial(n / d, k / d).multiply(Mobius.mobius(d)));
    }
    return sum.divide(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A051258	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a051;

import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.nt.cyclotomic.CyclotomicPolynomials;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;
import irvine.oeis.a000.A000045;

/**
 * A051258 Fibocyclotomic numbers: numbers formed from cyclotomic polynomials and Fibonacci numbers (A000045).
 * @author Sean A. Irvine
 */
public class A051258 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A051258() {
    super(0);
  }

  private final MemorySequence mF = MemorySequence.cachedSequence(new A000045());
  private final CyclotomicPolynomials mC = new CyclotomicPolynomials();
  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    final Polynomial<Z> c = mC.get(mN);
    for (int k = 1; k <= c.degree(); ++k) {
      sum = sum.add(c.coeff(k).multiply(mF.a(k)));
    }
    return sum;
  }
}
#!queue	A051424	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a051;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A051424 Number of partitions of n into pairwise relatively prime parts.
 * @author Sean A. Irvine
 */
public class A051424 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A051424() {
    super(0);
  }

  private long mN = -1;
  private final HashMap<Pair<Pair<Long, Long>, Set<Long>>, Z> mCache = new HashMap<>();

  private Set<Long> select(final Set<Long> s, final long i) {
    return s.stream().filter(x -> x < i).collect(Collectors.toSet());
  }

  private boolean isEmptyIntersection(final Set<Long> s, final Z[] f) {
    for (final Z p : f) {
      if (s.contains(p.longValue())) {
        return false;
      }
    }
    return true;
  }

  private Set<Long> union(final Set<Long> s, final Z[] f) {
    final Set<Long> res = new HashSet<>(s);
    for (final Z p : f) {
      res.add(p.longValue());
    }
    return res;
  }

  private Z computeB(final long n, final long i, final Set<Long> s) {
    if (n == 0 || i == 1) {
      return Z.ONE;
    }
    if (i < 2) {
      return Z.ZERO;
    }
    final Z res = b(n, i - 1, select(s, i));
    final Z[] f = Jaguar.factor(i).toZArray();
    if (i <= n && isEmptyIntersection(s, f)) {
      return res.add(b(n - i, i - 1, select(union(s, f), i)));
    } else {
      return res;
    }
  }

  protected Z b(final long n, final long i, final Set<Long> s) {
    final Pair<Pair<Long, Long>, Set<Long>> key = new Pair<>(new Pair<>(n, i), s);
    final Z res = mCache.get(key);
    if (res != null) {
      return res;
    }
    final Z b = computeB(n, i, s);
    mCache.put(key, b);
    return b;
  }

  @Override
  public Z next() {
    return b(++mN, mN, Collections.emptySet());
  }
}
#!queue	A051775	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a051;

import irvine.math.MemoryFunction2;
import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A051775 Table T(n,m) = Nim-product of n and m, read by antidiagonals, for n &gt;= 0, m &gt;= 0.
 * @author Sean A. Irvine
 */
public class A051775 extends MemoryFunction2Sequence<Z, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After R. J. Mathar

  protected static Z nimSum(final Z a, final Z b) {
    return a.xor(b);
  }

  private class NimProductPowerOf2 extends MemoryFunction2<Integer, Z> {

    @Override
    protected Z compute(final Integer nlog2, final Integer mlog2) {
      if ((nlog2 & mlog2) == 0) {
        return Z.ONE.shiftLeft(nlog2 + mlog2);
      }
      final int a2;
      final int b2;
      if (nlog2 >= mlog2) {
        a2 = nlog2;
        b2 = mlog2;
      } else {
        a2 = mlog2;
        b2 = nlog2;
      }
      Z a = Z.ONE.shiftLeft(nlog2 ^ mlog2);
      for (int j = 1; j <= b2; j <<= 1) {
        if ((a2 & j) != 0 && (b2 & j) != 0) {
          a = A051775.this.get(a, Z.THREE.shiftLeft(j - 1));
        }
      }
      return a;
    }
  }

  private final NimProductPowerOf2 mPower2 = new NimProductPowerOf2();

  @Override
  protected Z compute(final Z n, final Z m) {
    if (n.multiply(m).isZero()) {
      return Z.ZERO;
    } else if (Z.ONE.equals(n) || Z.ONE.equals(m)) {
      return n.multiply(m);
    }
    Z a = Z.ZERO;
    final String nbin = n.toString(2);
    final String mbin = m.toString(2);
    for (int nlog2 = 0; nlog2 < nbin.length(); ++nlog2) {
      if (nbin.charAt(nbin.length() - 1 - nlog2) == '1') {
        for (int mlog2 = 0; mlog2 < mbin.length(); ++mlog2) {
          if (mbin.charAt(mbin.length() - 1 - mlog2) == '1') {
            a = nimSum(a, mPower2.get(nlog2, mlog2));
          }
        }
      }
    }
    return a;
  }

  protected Z nimMultiply(final long n, final long m) {
    return get(Z.valueOf(n), Z.valueOf(m));
  }

  private Z mN = Z.NEG_ONE;
  private Z mM = Z.ZERO;

  @Override
  public Z next() {
    mM = mM.subtract(1);
    if (mM.signum() < 0) {
      mN = mN.add(1);
      mM = mN;
    }
    return get(mN.subtract(mM), mM);
  }
}
#!queue	A051924	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a051;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A051924 a(n) = binomial(2*n,n) - binomial(2*n-2,n-1); or (3n-2)*C(n-1), where C = Catalan numbers (A000108).
 * @author Sean A. Irvine
 */
public class A051924 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A051924() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    return Binomial.binomial(2 * mN, mN).subtract(Binomial.binomial(2 * mN - 2, mN - 1));
  }
}
#!queue	A052047	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a052;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A052047 Numbers k such that the digits of k^3 occur with the same frequency.
 * @author Sean A. Irvine
 */
public class A052047 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A052047() {
    super(1);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      final int[] cnts = ZUtils.digitCounts(mN.pow(3));
      if (IntegerUtils.isNonzeroConstant(cnts) > 0) {
        return mN;
      }
    }
  }
}

#!queue	A052061	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A052061 Numbers k such that decimal expansion of k^2 contains no palindromic substring except single digits.
 * @author Sean A. Irvine
 */
public class A052061 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A052061() {
    super(1);
  }

  private Z mN = Z.NEG_ONE;

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      if (A052057.isPalindromeFree(mN.square().toString())) {
        return mN;
      }
    }
  }
}

#!queue	A052107	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a052;

import irvine.math.IntegerUtils;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A052107 Number of self-complementary 3-multigraphs on n nodes.
 * @author Sean A. Irvine
 */
public class A052107 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A052107() {
    super(1);
  }

  // After Andrew Howroyd

  protected final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  protected int mN = 0;

  protected int edges(final int[] v) {
    int sum = 0;
    for (int i = 1; i < v.length; ++i) {
      for (int j = 0; j < i; ++j) {
        sum += IntegerUtils.gcd(v[i], v[j]);
      }
    }
    sum *= 4;
    for (final int j : v) {
      sum += 2L * j;
    }
    return sum;
  }

  @Override
  public Z next() {
    if ((++mN & 3) < 2) {
      if (mN == 1) {
        return Z.ONE;
      }
      Z sum = Z.ZERO;
      final IntegerPartition part = new IntegerPartition(mN / 4);
      int[] p;
      while ((p = part.next()) != null) {
        final Z t = IntegerPartition.permCount(p, 4).shiftLeft(2 * edges(p));
        sum = sum.add(t.multiply((mN & 1) == 1 ? Z.valueOf(mN).shiftLeft(2 * p.length) : Z.ONE));
      }
      return sum.divide(mF.factorial(mN));
    } else {
      return Z.ZERO;
    }
  }
}
#!queue	A052179	0	->	0	Triangle	--------------------------------
package irvine.oeis.a052;
// manually 2021-10-25

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A052179 Triangle of numbers arising in enumeration of walks on cubic lattice.
 * <code>T(0, 0)=1, T(n,k)=0 if k &lt; 0 or if k &gt; n;
 * T(n, 0) = x*T(n-1, 0) + T(n-1, 1), T(n,k) = T(n-1,k-1) + y*T(n-1,k) + T(n-1,k+1) for k &gt;= 1</code>.
 * @author Georg Fischer
 */
public class A052179 extends Triangle {

  protected Z mX;
  protected Z mY;

  /** Construct the sequence. */
  public A052179() {
    this(0, 4, 4);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param x first parameter in recurrence
   * @param y second parameter in recurrence
   */
  public A052179(final int offset, final long x, final long y) {
    super();
    mX = Z.valueOf(x);
    mY = Z.valueOf(y);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return n == 0 ? Z.ONE : (k == 0
        ? mX.multiply(get(n - 1, 0)).add(get(n - 1, 1))
        : get(n - 1, k - 1).add(mY.multiply(get(n - 1, k))).add(get(n - 1, k + 1))
      );
  }
}
#!queue	A052316	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a052;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A052316 Number of labeled rooted trees with n nodes and 2-colored internal (non-leaf) nodes.
 * @author Sean A. Irvine
 */
public class A052316 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A052316() {
    super(1);
  }

  private int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int j = 1; j <= mN; ++j) {
      sum = sum.signedAdd(((mN - j) & 1) == 0, Binomial.binomial(mN, j).multiply(Z.valueOf(j).pow(mN - 1).shiftLeft(j)));
    }
    return sum;
  }
}

#!queue	A053117	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a053;

import irvine.math.polynomial.ChebyshevPolynomials;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A053117 Triangle read by rows of coefficients of Chebyshev's U(n,x) polynomials (exponents in increasing order).
 * @author Sean A. Irvine
 */
public class A053117 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A053117() {
    super(0);
  }

  private final ChebyshevPolynomials mChebyshevPolynomials = new ChebyshevPolynomials(2);
  private Polynomial<Z> mPoly = mChebyshevPolynomials.getValue(0);
  private int mN = 0;
  private int mM = -1;

  @Override
  public Z next() {
    if (++mM > mPoly.degree()) {
      mPoly = mChebyshevPolynomials.getValue(++mN);
      mM = 0;
    }
    return mPoly.coeff(mM);
  }
}
#!queue	A053492	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a053;

import irvine.math.z.Binomial;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A053492 REVEGF transform of [1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, ...].
 * @author Sean A. Irvine
 */
public class A053492 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A053492() {
    super(1);
  }

  protected int mN = 0;

  @Override
  public Z next() {
    if (++mN == 1) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    Z f = Z.ONE;
    for (int k = 1; k < mN; ++k) {
      f = f.multiply(k);
      s = s.add(f.multiply(Stirling.secondKind(mN - 1, k)).multiply(Binomial.binomial(mN + k - 1, mN - 1)));
    }
    return s;
  }
}
#!queue	A053549	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a053;
// Generated by gen_seq4.pl deriv at 2021-06-28 18:44

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a001.A001187;

/**
 * A053549 Number of labeled rooted connected graphs.
 * @author Georg Fischer
 */
public class A053549 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  final Sequence mA001187 = new A001187();
  protected long mN;

  /** Construct the sequence. */
  public A053549() {
    super(0);
    mN = -1;
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(mN).multiply(mA001187.next());
  }

}
#!queue	A053676	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a053;

import java.util.Iterator;
import java.util.LinkedHashSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000330;
import irvine.oeis.a005.A005900;

/**
 * A053676 Let Oc(n) = A005900(n) = n-th octahedral number. Consider all integer triples (i,j,k), j &gt;= k &gt; 0, with Oc(i) = Oc(j)+Oc(k), ordered by increasing i; sequence gives i values.
 * @author Sean A. Irvine
 */
public class A053676 extends AbstractSequence {

  private final Sequence mUnder;
  protected final LinkedHashSet<Z> mA = new LinkedHashSet<>();
  private Z mPrev = Z.ONE;
  protected long mOffset = 0;

  protected A053676(final Sequence seq) {
    super((seq instanceof A000330) ? 0 : 1);
    mUnder = seq;
    mUnder.next(); // skip 0
    mA.add(mUnder.next());
  }

  /** Construct the sequence. */
  public A053676() {
    this(new A005900());
  }

  protected Z update() {
    // Drops low terms from memory when they will never be used again
    final Z t = mUnder.next();
    final Z delta = t.subtract(mPrev);
    for (final Iterator<Z> it = mA.iterator(); it.hasNext();) {
      final Z u = it.next();
      if (u.compareTo(delta) >= 0) {
        break;
      }
      it.remove();
      ++mOffset;
    }
    mA.add(t);
    mPrev = t;
    return t;
  }

  @Override
  public Z next() {
    while (true) {
      final Z t = update();
      for (final Z u : mA) {
        final Z v = t.subtract(u);
        if (v.compareTo(u) < 0) {
          break;
        }
        if (mA.contains(v)) {
          //StringUtils.message(mA.size() + " " + mOffset);
          return Z.valueOf(mOffset + mA.size());
        }
      }
    }
  }
}
#!queue	A053718	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a053;

import java.util.Map;

import irvine.math.api.Ring;
import irvine.math.group.GaloisField;
import irvine.math.group.GeneralLinearGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.MultivariateMonomial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A053718 Number of n X n binary matrices of order dividing 4 (also number of solutions to X^4=I in GL(n,2)).
 * @author Sean A. Irvine
 */
public class A053718 extends AbstractSequence {

  private int mN;
  private final Ring<Z> mFld;
  private final Z mMaxOrder;

  protected A053718(final long maxOrder, final GaloisField field, final int start) {
    super(start);
    mN = start - 1;
    mFld = field;
    mMaxOrder = Z.valueOf(maxOrder);
  }

  protected A053718(final long maxOrder, final GaloisField field) {
    this(maxOrder, field, 1);
  }

  /** Construct the sequence. */
  public A053718() {
    this(4, new GaloisField(2));
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    final GeneralLinearGroup<Z> group = new GeneralLinearGroup<>(mN, mFld);
    final CycleIndex ci = group.cycleIndex();
    Q sum = Q.ZERO;
    for (final MultivariateMonomial m : ci.values()) {
      Z order = Z.ONE;
      for (final Map.Entry<Pair<String, Integer>, Z> e : m.entrySet()) {
        order = order.lcm(Z.valueOf(e.getKey().right()));
      }
      if (mMaxOrder.mod(order).isZero()) {
        sum = sum.add(m.getCoefficient());
      }
    }
    sum = sum.multiply(group.size());
    return sum.toZ();
  }
}
#!queue	A054009	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a054;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A054009 n read modulo (number of proper divisors of n).
 * @author Sean A. Irvine
 */
public class A054009 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A054009() {
    super(2);
  }

  private long mN = 1;

  @Override
  public Z next() {
    return Z.valueOf(++mN % (Jaguar.factor(mN).sigma0AsLong() - 1));
  }
}
#!queue	A054110	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A054110 Triangular array T(n,k): in Pascal's triangle, draw vertical lines through binomial(n-1,k-1) (if present) and binomial(n-1,k) (if present); then T(n,k) is the sum of binomial(i,j) that lie on or between the lines and not below binomial(n,k).
 * @author Sean A. Irvine
 */
public class A054110 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A054110() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  protected Z t(final long n, final long k) {
    if (k == 0 || k == n) {
      // I think an argument can be made that this value should be 2 except for (0, 0)
      return Z.ONE; // one of the lines does not exist
    }
    Z sum = Z.ZERO;
    for (long j = n, i = k; i >= 0 && i <= j; j -= 2, --i) {
      sum = sum.add(Binomial.binomial(j, i));
    }
    for (long j = n - 1, i = k - 1; i >= 0 && i <= j; j -= 2, --i) {
      sum = sum.add(Binomial.binomial(j, i));
    }
    for (long j = n - 1, i = k; i >= 0 && i <= j; j -= 2, --i) {
      sum = sum.add(Binomial.binomial(j, i));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A054678	1	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a054;

/**
 * A054678 n consecutive primes differ by a multiple of 4 starting at a(n).
 * @author Sean A. Irvine
 */
public class A054678 extends A054681 {

  /** Construct the sequence. */
  public A054678() {
    super(2, 4);
    next();
  }
}

#!queue	A054679	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a054;

/**
 * A054679 First of n consecutive primes which differ by a multiple of 6.
 * @author Sean A. Irvine
 */
public class A054679 extends A054681 {

  /** Construct the sequence. */
  public A054679() {
    super(1, 6);
  }
}

#!queue	A054680	1	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a054;

/**
 * A054680 n consecutive primes differ by a multiple of 8 starting at a(n).
 * @author Sean A. Irvine
 */
public class A054680 extends A054681 {

  /** Construct the sequence. */
  public A054680() {
    super(2, 8);
    next();
  }
}

#!queue	A054681	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a054;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A054681 Start of a run of consecutive primes of length n each ending with the same digit.
 * @author Sean A. Irvine
 */
public class A054681 extends AbstractSequence {

  private final Fast mPrime = new Fast();
  private long mP = 2;
  private int mN = -1;
  private final long mGap;

  protected A054681(final int offset, final int gap) {
    super(offset);
    mGap = gap;
  }

  /** Construct the sequence. */
  public A054681() {
    this(1, 10);
  }

  private int cnt(long p) {
    if ((p - mPrime.prevPrime(p)) % mGap == 0) {
      return 0;
    }
    int cnt = 0;
    while (true) {
      final long q = p;
      p = mPrime.nextPrime(p);
      if ((p - q) % mGap != 0) {
        return cnt;
      }
      ++cnt;
    }
  }

  @Override
  public Z next() {
    ++mN;
    while (true) {
      final int cnt = cnt(mP);
      if (cnt >= mN) {
        return Z.valueOf(mP);
      }
      mP = mPrime.nextPrime(mP);
    }
  }
}

#!queue	A054690	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a054;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A054690 n consecutive primes differ by 4 or more starting at a(n), or n consecutive primes with no twin primes.
 * @author Sean A. Irvine
 */
public class A054690 extends AbstractSequence {

  protected final Fast mPrime = new Fast();
  private long mP = 2;
  protected int mN = 0;
  private final long mGap;

  protected A054690(final long gap) {
    super(2);
    mGap = gap;
  }

  /** Construct the sequence. */
  public A054690() {
    this(4);
  }

  private int cnt(long p) {
    if (p - mPrime.prevPrime(p) >= mGap) {
      return 0;
    }
    int cnt = 0;
    while (true) {
      final long q = p;
      p = mPrime.nextPrime(p);
      if (p - q < mGap) {
        return cnt;
      }
      ++cnt;
    }
  }

  @Override
  public Z next() {
    ++mN;
    while (cnt(mP) < mN) {
      mP = mPrime.nextPrime(mP);
    }
    return Z.valueOf(mP);
  }
}

#!queue	A054737	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a054;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A054737 Numbers n such that n^2 can be split into two nonzero squares (perhaps with leading zeros) in exactly two different ways.
 * @author Sean A. Irvine
 */
public class A054737 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A054737() {
    super(1);
  }

  private Z mN = Z.valueOf(252);

  @Override
  public Z next() {
    while (true) {
      mN = mN.add(1);
      final String s = mN.square().toString();
      int cnt = 0;
      for (int k = 1; k < s.length(); ++k) {
        final Z t = new Z(s.substring(k));
        if (!t.isZero() && t.isSquare() && new Z(s.substring(0, k)).isSquare() && ++cnt > 2) {
          break;
        }
      }
      if (cnt == 2) {
        return mN;
      }
    }
  }
}
#!queue	A055029	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a055;

import irvine.factor.prime.Fast;
import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A055029 Number of inequivalent Gaussian primes of norm n.
 * @author Sean A. Irvine
 */
public class A055029 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A055029() {
    super(0);
  }

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    if (mPrime.isPrime(++mN)) {
      if ((mN & 3) == 1) {
        return Z.TWO;
      } else if (mN == 2) {
        return Z.ONE;
      } else {
        return Z.ZERO;
      }
    } else {
      final long s = LongUtils.sqrt(mN);
      if (s * s == mN && (s & 3) == 3 && mPrime.isPrime(s)) {
        return Z.ONE;
      }
      return Z.ZERO;
    }
  }
}
#!queue	A055061	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a055;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import irvine.factor.factor.Jaguar;
import irvine.math.group.GaloisField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.IrreduciblePolynomials;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A055061 LCM of (2^d - 1) where d runs over the degrees of irreducible factors of x^n + x + 1 over GF(2), divided by A046932(n).
 * @author Sean A. Irvine
 */
public class A055061 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A055061() {
    super(2);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(new GaloisField(2));
  private static final Polynomial<Z> X1 = RING.onePlusXToTheN(1);
  private int mN = 1;

  protected List<Polynomial<Z>> factor(Polynomial<Z> f) {
    final List<Polynomial<Z>> res = new ArrayList<>();
    final Iterator<Polynomial<Z>> pi = IrreduciblePolynomials.iterator();
    while (true) {
      final Polynomial<Z> p = pi.next();
      while (IrreduciblePolynomials.exactlyDivides(f, p)) {
        f = RING.divide(f, p);
        res.add(p);
      }
      if (p.degree() > f.degree()) {
        break;
      }
    }
    return res;
  }

  protected Z periodIrreducible(final Polynomial<Z> p) {
    // p is assumed to be irreducible here
    final Z u = Z.ONE.shiftLeft(p.degree()).subtract(1);
    for (final Z d : Jaguar.factor(u).divisorsSorted()) {
      if (RING.zero().equals(RING.mod(RING.oneMinusXToTheN(d.intValueExact()), p))) {
        return d;
      }
    }
    throw new RuntimeException();
  }

  @Override
  public Z next() {
    final long[] c = new long[++mN + 1];
    c[0] = 1;
    c[1] = 1;
    c[mN] = 1;
    final Polynomial<Z> f = Polynomial.create(c);
    final List<Polynomial<Z>> factors = factor(f);
    Z per = Z.ONE;
    Z lcm = Z.ONE;
    for (final Polynomial<Z> p : factors) {
      lcm = lcm.lcm(Z.ONE.shiftLeft(p.degree()).subtract(1));
      per = per.lcm(periodIrreducible(p));
    }
    //System.out.println(factors.size() + " " + factors + " " + per);
    return lcm.divide(per);
  }
}
#!queue	A055096	2	->	2	Triangle	--------------------------------
package irvine.oeis.a055;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A055096 Triangle read by rows, sums of 2 distinct nonzero squares: T(n,k) = k^2+n^2, (n&gt;=2, 1 &lt;= k &lt;= n-1).
 * @author Georg Fischer
 */
public class A055096 extends Triangle {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A055096() {
    setOffset(2);
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n + 2).multiply(n + 2).add((k + 1) * (k + 1));
  }
}
#!queue	A055105	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a055;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A055105 Triangle read by rows: T(n,k) = number of noncommutative symmetric polynomials of degree n that have exactly k different variables appearing in each monomial and which generate the algebra of all noncommutative symmetric polynomials (n &gt;= 1, 1 &lt;= k &lt;= n).
 * @author Sean A. Irvine
 */
public class A055105 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A055105() {
    super(1);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = 0;
  protected int mM = 0;

  private Polynomial<Z> b(final int k, final int n) {
    final Z[] c = new Z[n + 1];
    c[0] = Z.ONE;
    for (int i = 1; i <= n; ++i) {
      c[i] = Z.ZERO;
      for (int j = 1; j <= k; ++j) {
        c[i] = c[i].add(Stirling.secondKind(i, j));
      }
    }
    return Polynomial.create(c);
  }

  protected Z a(final int k, final int n) {
    final Polynomial<Z> bk1 = b(k - 1, n);
    final Polynomial<Z> bk = b(k, n);
    return RING.coeff(RING.one(), bk1, n).subtract(RING.coeff(RING.one(), bk, n));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return a(mM, mN);
  }
}
#!queue	A055187	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a055;

import java.util.ArrayList;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;

/**
 * A055187 Cumulative counting sequence: method A (adjective-before-noun)-pairs with first term 1.
 * @author Georg Fischer
 */
public class A055187 extends AbstractSequence {

  // Generate OEIS A030707, A055187, A217760 && related
  // "cumulative counting" sequences as defined by Clark Kimberling.
  // http://faculty.evansville.edu/ck6/integer/unsolved.html, Problem 4
  // @(#) Id
  // 2022-01-13: debug=98 -> seq4 format
  // 2018-04-20, Georg Fischer (previosu version in cumulcount2.pl)
  //------------------------------------------------------
  // Comment from A217760:
  //   Write 0 followed by segments defined inductively as follows: each segment
  //   tells how many times each previously written integer occurs, in the order
  //   of first occurrence.  This is Method A (adjective-before-noun pairs); for
  //   Method B (noun-before-adjective), see A055168.
  // Example:
  //   Start with 0, followed by the adjective-noun pair 1, 0; followed by
  //   adjective-noun pairs 2, 0 then 1, 1; etc. Writing the pairs vertically,
  //   the initial segments are
  //   0.|.1.|.2 1.|.3 3 1.|.4 5 2 2.|.5 6 5 3 1 1.|.6 9 6 5 2 4 1.|.7 11 8 6 4 6 4 1
  //   ..|.0.|.0 1.|.0 1 2.|.0 1 2 3.|.0 1 2 3 4 5.|.0 1 2 3 4 5 6.|.0 1  2 3 4 5 6 9
  //
  // Usage:
  //   perl cumulcount.pl -m method -r row -n noeis -l len -a appear -o offset -s start -p parm -w with0 -d debug
  //       All parameters are optional && have a default value:
  //       method = "A" (attribute over noun; default)
  //                "B" (noun over attribute)
  //                "D" (new, distinct elements)
  //                "I" (inverse, first occurrence of a number) - no longer supported
  //                "J" (next term which is greater than all previous)
  //                "K" (next position where term is greater than all previous)
  //                "N" (number of new elements in segment)
  //                "P" (positions of small numbers (parm))
  //                "S" (sum of terms in segment n)
  //                "T" (number of terms in segment n)
  //       row =  3 (count in both rows,    output both; default)
  //                 1 (count in both rows,    output 1st)
  //                 2 (count in both rows,    output 2nd)
  //                 5 (count in 1st row only, output 1st)
  //                 6 (count in 1st row only, output 2nd)
  //       noeis = "030707|055187|217760 ..." (OEIS number without "A", default "030707")
  //       len = length of sequence to be generated (default: 256)
  //       appear = "io" (increasing order; default)
  //                "do" (decreasing order)
  //                "fa" (order of first appearance)
  //       first = 0, 2 (first index in segment[4095])
  //       offset = 0, 1 (index f 1st b-file entry, default: 1)
  //       start = starting value for a(1): 0, 1 (default), 3, 4, 5
  //       parm = 2nd parameter (for rule "P"): 1, 2, 3, 4
  //       with0 =  0 (0 is not counted for neither attr nor noun)
  //                 1 (0 is counted for attr only)
  //                 2 (0 is counted for noun only)
  //                 3 (0 is counted for both attr && noun)
  //       debug = 0 (none; default)
  //                1 (with segments)
  //--------------------------------------------------------
  private static int sDebug;
  private int mAppear;
  private int mFirst;
  private String mMethod;
  private int mOffset;
  private int mParm;
  private int mRow; // count in both rows,    output both; default
  private int mStart;
  private int mWith0;
  private int mSegNo;
  private ArrayList<Integer> mSegment;
  // mSegment[i+0] = attribute, how often (i = 1, 3, 5 ..)
  // mSegment[i+1] = noun, which number is counted,
  // always this order, increasing nouns, always complete with zero attributes
  private ArrayList<Integer> mCount;  // temporary copy of the attributes
  private ArrayList<Integer> mFirstApp; // 1st appearance of a noun
  private ArrayList<Integer> mSeqLen; // cumulative length of sequence so far, indexed with mSegNo
  private ArrayList<Integer> mResult; // buffer for next
  private int mResIx; // next index in mResult to be consumed by next()
  private int mCurMax; // for methods J, K
  private int mK;
  private int mK2;

  /** Construct the sequence. */
  public A055187() {
    this(1, "A", 1, 3, 3, 0, 2, 0);
  }

  protected A055187(final int offset, final String method, final int start,
                 final int appear, final int row, final int first, final int with0, final int parm) {
    super(offset);
    mOffset = offset;
    mMethod = method;
    mStart = start;
    mCurMax = mStart - 1;
    mAppear = appear;
    mRow = row;
    mFirst = first;
    mWith0 = with0;
    mParm = parm;
    mResIx = 0;
    mSegNo = 0;
    mFirstApp = new ArrayList<>();
    mCount = new ArrayList<>();
    mResult = new ArrayList<>();
    mSegment = new ArrayList<>();
    mSeqLen = new ArrayList<>();
    // first segment
    for (int noun = 0; noun < mStart; ++noun) { // fill before mStart
      mSegment.add(0);
      mSegment.add(noun);
    }
    mSegment.add(1);
    mSegment.add(mStart);

    // first b-file entry
    mK = mOffset;
    mK2 = mK; // copy of k, running as if it were rule A
    if (mMethod.matches("[ABIJKP]")) {
      if ((mRow & 1) != 0) {
        emit(mStart, -1);
      }
    } else if (mMethod.matches("[D]")) {
      // store(mStart); why ??
    } else if (mMethod.matches("[N]")) {
      mSeqLen.add(0);
    } else if (mMethod.matches("[S]")) {
    } else if (mMethod.matches("[T]")) {
      if (mParm == 240508) {
        store(1);
      }
    }
    mFirstApp.add(mStart);
    mSegNo++;
  }

  private void advance() { // count between 0 && nmax, && store in mCounts[4095]
    int attr;
    int noun;
    int amax = -1; // nmax is the current segment length / 2
    // compute length of current segment
    mSeqLen.add(0); // number of elements in segment
    for (int iseg = mFirst; iseg < mSegment.size(); iseg += 2) { // increment for valid entries
      attr = mSegment.get(iseg);
      noun = mSegment.get(iseg + 1);
      if (attr != 0 || (mWith0 & 1) != 0) {
        if (mSegNo >= mSeqLen.size()) {
          mSeqLen.add(1);
        } else {
          mSeqLen.set(mSegNo, mSeqLen.get(mSegNo) + 1);
        }
      }
    }
    if (sDebug >= 1) {
      System.out.print("seg# " + mSegNo + ":");
      for (int iseg = mFirst; iseg < mSegment.size(); iseg += 2) { // print the elements of this segment
        attr = mSegment.get(iseg);
        noun = mSegment.get(iseg + 1);
        System.out.print(" " + attr + "." + noun);
      }
      // System.out.print("   mSeqLen=mSeqLen[mSegNo]\n");
      // System.out.println("m1stApp:  . join(, m1stApp[4095]) .");
    }
    // now the b-file entries
    if (mMethod.matches("[ABIJKP]")) { // first || second row || both
      if (mAppear == 1) { // order of first appearance
        for (int iapp = 0; iapp < mFirstApp.size(); iapp++) {
          final int iseg = mFirstApp.get(iapp) << 1;
          attr = mSegment.get(iseg);
          noun = mSegment.get(iseg + 1);
          if (attr != 0 || (mWith0 & 1) != 0) {
            emit(attr, noun);
          }
        }
      } else if (mAppear == 2) { // decreasing order
        for (int iseg = mSegment.size() - 2; iseg >= mFirst; iseg -= 2) {
          attr = mSegment.get(iseg);
          noun = mSegment.get(iseg + 1);
          if (attr != 0 || (mWith0 & 1) != 0) {
            emit(attr, noun);
          }
        }
      } else if (mAppear == 3) { // increasing order
        for (int iseg = mFirst; iseg < mSegment.size(); iseg += 2) {
          attr = mSegment.get(iseg);
          noun = mSegment.get(iseg + 1);
          if (attr != 0 || (mWith0 & 1) != 0) {
            emit(attr, noun);
          }
        }
      } else {
        System.err.println("invalid parameter op=\"" + mAppear + "\"");
      }
    } else if (mMethod.matches("[D]")) { // new terms (for mAppear.equals("fa")
      for (int iapp = mSeqLen.get(mSegNo - 1); iapp < mSeqLen.get(mSegNo); iapp++) {
        final int iseg = mFirstApp.get(iapp) << 1;
        attr = mSegment.get(iseg);
        noun = mSegment.get(iseg + 1);
        if (attr != 0 || (mWith0 & 1) != 0) {
          emit(attr, noun);
        }
      }
    } else if (mMethod.matches("[N]")) { // no. of new terms in segment
      emit(mSeqLen.get(mSegNo) - mSeqLen.get(mSegNo - 1), -1);
    } else if (mMethod.matches("[T]")) { // no. of terms in segment
      emit(mSeqLen.get(mSegNo), -1);
    }
    noun = 0; // to avoid "not initialized" compiler message
    // compute following segment
    for (int iseg = mFirst; iseg < mSegment.size(); iseg += 2) { // copy attr && determine maximum attr
      attr = mSegment.get(iseg);
      noun = mSegment.get(iseg + 1);
      if (noun >= mCount.size()) { // copy old attr
        mCount.add(attr);
      } else {
        mCount.set(noun, attr);
      }
      if (attr > amax) {
        amax = attr;
      }
    }
    final int lastNoun = noun;
    noun = lastNoun + 1;
    while (noun <= amax) { // insert nouns with 0 attributes
      if (noun >= mCount.size()) { // copy old attr
        mCount.add(0);
      } else {
        mCount.set(noun, 0);
      }
      noun++;
    }
    final int ffCount = noun;
    // now add all (or row1, row2) to mCount[]
    if (mAppear == 1) {
      for (int iapp = 0; iapp < mSeqLen.get(mSegNo); iapp++) {
        assemble(mFirstApp.get(iapp) << 1);
      }
    } else { // "io", "do"
      for (int iseg = mFirst; iseg < mSegment.size(); iseg += 2) { // add
        assemble(iseg);
      } // for iseg
    }
    // copy it back to the segment
    int iseg = 0;
    for (noun = 0; noun < ffCount; noun++) { // add
      if (iseg >= mSegment.size()) {
        mSegment.add(mCount.get(noun));
        mSegment.add(noun);
      } else {
        mSegment.set(iseg, mCount.get(noun));
        mSegment.set(iseg + 1, noun);
      }
      iseg += 2;
    }
  }

  private void assemble(final int iseg) {
    final int attr = mSegment.get(iseg);
    final int noun = mSegment.get(iseg + 1);
    if ((attr != 0 || (mWith0 & 1) != 0) && (mRow != 6)) {
      if (mCount.get(attr) == null || mCount.get(attr) == 0) { // appears for the first time
        mFirstApp.add(attr);
      }
      mCount.set(attr, mCount.get(attr) + 1);
    }
    if ((attr != 0 || (mWith0 & 1) != 0) && (noun != 0 || (mWith0 & 2) != 0) && (mRow != 5)) {
      mCount.set(noun, mCount.get(noun) + 1);
    }
    if (attr == 0 && mParm == 79668) {
      mFirst = 0;
    }
  }

  private void emit(final int attr, final int noun) {
    if (mMethod.matches("P")) {
      if (attr == mParm) {
        store(mK2);
      }
      mK2++;
    } else if (mMethod.matches("I")) {
      System.err.print("cannot process method I");
    } else if (mMethod.matches("J")) {
      if (attr > mCurMax) {
        store(attr);
        mCurMax = attr;
      }
      mK2++;
    } else if (mMethod.matches("K")) {
      if (attr > mCurMax) {
        store(mK2);
        mCurMax = attr;
      }
      mK2++;
    } else if (noun < 0) {
      store(attr);
    } else if (mMethod.matches("N")) {
      store(attr);
    } else if (mMethod.matches("T")) {
      store(attr);
    } else if (mMethod.matches("[AD]")) { // attribute before noun
      if ((mRow & 1) != 0) {
        store(attr);
      }
      if ((mRow & 2) != 0) {
        store(noun);
      }
    } else if (mMethod.matches("[BD]")) { // noun before attribute
      if ((mRow & 1) != 0) {
        store(noun);
      }
      if ((mRow & 2) != 0) {
        store(attr);
      }
    }
  }

  private void store(final int val) {
    mResult.add(val);
    ++mK;
  }

  @Override
  public Z next() {
    while (mResIx >= mResult.size()) {
      advance();
      ++mSegNo;
    }
    return Z.valueOf(mResult.get(mResIx++));
  }

  /**
   *  Test method
   *  @param args command line arguments
   */
  public static void main(final String[] args) {
    int appear = 2;
    sDebug = 0;
    int first = 0;
    int noTerms = 256;
    String method = "A";
    int noeis = 55187;
    int offset = 1;
    int parm = 0;
    int row = 3; // count in both rows,    output both; default
    int start = 1;
    int with0 = 0;
    int iarg = 0;
    while (iarg < args.length) {
      final String opt = args[iarg++];
      try {
        switch (opt) {
          case "-a":
            final String appears = args[iarg++];
            if ("fa".equals(appears)) {
              appear = 1;
            } else if ("do".equals(appears)) {
              appear = 2;
            } else if ("io".equals(appears)) {
              appear = 3;
            } else {
              appear = Integer.parseInt(appears); // keep numeric appear
            }
            break;
          case "-d":
            sDebug = Integer.parseInt(args[iarg++]);
            break;
          case "-f":
            first = Integer.parseInt(args[iarg++]);
            break;
          case "-l":
            noTerms = Integer.parseInt(args[iarg++]);
            break;
          case "-m":
            method = args[iarg++];
            break;
          case "-n":
            noeis = Integer.parseInt(args[iarg++]);
            break;
          case "-o":
            offset = Integer.parseInt(args[iarg++]);
            break;
          case "-p":
            parm = Integer.parseInt(args[iarg++]);
            break;
          case "-r":
            row = Integer.parseInt(args[iarg++]);
            break;
          case "-s":
            start = Integer.parseInt(args[iarg++]);
            break;
          case "-w":
            with0 = Integer.parseInt(args[iarg++]);
            break;
          default:
            System.out.println("invalid option \"" + opt + "\"");
            break;
        }
      } catch (final RuntimeException exc) {
        // ignored
      }
    }
    final Sequence seq = new A055187(offset, method, start, appear, row, first, with0, parm);
    for (int n = offset; n <= noTerms; n++) {
      System.out.println("n " + seq.next());
    }
  }
}
#!queue	A055235	0	->	0	Triangle	--------------------------------
package irvine.oeis.a055;
// manually 2021-10-18

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A055235 Sums of two powers of 3.
 * @author Georg Fischer
 */
public class A055235 extends Triangle {

  protected Z mBase;

  /** Construct the sequence. */
  public A055235() {
    this(0, 3);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param base
   */
  public A055235(final int offset, final int base) {
    super(offset);
    hasRAM(true);
    mBase = Z.valueOf(base);
  }

  @Override
  protected Z compute(final int n, final int k) {
    return (k < 0 || k > n) ? Z.ZERO : mBase.pow(n).add(mBase.pow(k));
  }
}
#!queue	A055277	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a055;

import irvine.math.group.PolynomialRing;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A055277 Triangle T(n,k) of number of rooted trees with n nodes and k leaves, 1 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A055277 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A055277() {
    super(1);
  }

  protected static final PolynomialRingField<Q> RING_Y = new PolynomialRingField<>("y", Rationals.SINGLETON);
  protected static final PolynomialRing<Polynomial<Q>> RING_X = new PolynomialRing<>(RING_Y);
  protected static final Polynomial<Polynomial<Q>> XY = RING_X.monomial(RING_Y.x(), 1);
  private static final Polynomial<Polynomial<Q>> XY_MINUS_X = RING_X.subtract(XY, RING_X.x());

  private Polynomial<Polynomial<Q>> mGF = XY;
  private int mDeg = 1;

  protected static Polynomial<Polynomial<Q>> doubleSubstitute(final Polynomial<Polynomial<Q>> f, final int m) {
    Polynomial<Polynomial<Q>> res = RING_X.zero();
    for (int k = 0; k <= f.degree(); ++k) {
      final Polynomial<Q> c = f.coeff(k);
      if (!c.equals(RING_Y.zero())) {
        final Polynomial<Q> t = c.substitutePower(m);
        res = RING_X.add(res, RING_X.monomial(t, k * m));
      }
    }
    return res;
  }

  protected static Polynomial<Q> constant(final Q x) {
    return RING_Y.monomial(x, 0);
  }

  private Polynomial<Polynomial<Q>> exp(final Polynomial<Polynomial<Q>> p, final int n) {
    Polynomial<Polynomial<Q>> s = RING_X.one();
    if (!RING_X.zero().equals(p)) {
      Q invf = Q.ONE;
      for (int k = 1; k <= n; ++k) {
        invf = invf.divide(k);
        s = RING_X.add(s, RING_X.multiply(RING_X.pow(p, k, n), constant(invf)));
      }
    }
    return s;
  }

  protected Polynomial<Polynomial<Q>> gf(final int n) {
    while (mDeg < n) {
      final int m = ++mDeg;
      Polynomial<Polynomial<Q>> res = RING_X.zero();
      for (int k = 1; k <= m + 10; ++k) {
        res = RING_X.add(res, RING_X.multiply(doubleSubstitute(mGF, k), constant(new Q(1, k))));
      }
      res = RING_X.multiply(RING_X.x(), exp(res, m));
      mGF = RING_X.add(XY_MINUS_X, res);
    }
    return mGF;
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return gf(mN).coeff(mN).coeff(mM).toZ();
  }

}
#!queue	A055450	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a055;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A055450 Path-counting array T; each step of a path is (1 right) or (1 up) to a point below line y=x, else (1 right and 1 up) or (1 up) to a point on the line y=x, else (1 left) or (1 up) to a point above line y=x. T(i,j)=number of paths to point (i-j,j), for 1&lt;=j&lt;=i, i &gt;= 1.
 * @author Sean A. Irvine
 */
public class A055450 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  protected Z compute(final Long i, final Long j) {
    if (j == 0) {
      return Z.ONE;
    }
    if (2 * j < i) {
      return get(i - 1, j - 1).add(get(i - 1, j));
    }
    if (2 * j == i) {
      return get(2 * j - 2, j - 1).add(get(2 * j - 1, j - 1));
    }
    final long k = 2 * j - i;
    return get(2 * j - k + 1, j).add(get(2 * j - k - 1, j - 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A055773	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a055;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A055773 a(n) = Product_{p in P_n} where P_n = {p prime, n/2 &lt; p &lt;= n }.
 * @author Sean A. Irvine
 */
public class A055773 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A055773() {
    super(0);
  }

  private final Fast mPrime = new Fast();
  private long mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z prod = Z.ONE;
    for (long p = mPrime.nextPrime(mN / 2); p <= mN; p = mPrime.nextPrime(p)) {
      prod = prod.multiply(p);
    }
    return prod;
  }
}
#!queue	A055818	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a055;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A055818 Triangle T read by rows: T(i,j) = R(i-j,j), where R(i,0) = R(0,i) = 1 for i &gt;= 0, R(i,j) = Sum_{h=0..i-1} Sum_{m=0..j} R(h,m) for i &gt;= 1, j &gt;= 1.
 * @author Sean A. Irvine
 */
public class A055818 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (n == 0 || m == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k < n; ++k) {
      for (int j = 0; j <= m; ++j) {
        sum = sum.add(get(k, j));
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN - mM, mM);
  }
}
#!queue	A056004	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A056004 Initial step in Goodstein sequences: write n in hereditary representation base 2, bump to base 3, then subtract 1.
 * @author Sean A. Irvine
 */
public class A056004 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A056004() {
    super(1);
  }

  private long mN = 0;

  protected Z code(final Z n, final int base) {
    Z sum = Z.ZERO;
    Z m = n;
    int k = 0;
    while (!m.isZero()) {
      final long r = m.mod(base);
      if (r != 0) {
        final Z zk = Z.valueOf(k);
        sum = sum.add(Z.valueOf(base + 1).pow(k < base ? zk : code(zk, base).add(1)).multiply(r));
      }
      m = m.divide(base);
      ++k;
    }
    return sum.subtract(1);
  }

  @Override
  public Z next() {
    return code(Z.valueOf(++mN), 2);
  }
}
#!queue	A056476	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a056;
// manually A060164/summu1 at 2022-03-25 13:13

import irvine.math.Mobius;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A056476 Number of primitive (aperiodic) palindromic structures of length n using a maximum of two different symbols.
 * @author Georg Fischer
 */
public class A056476 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A056476() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    if (mN == 0) {
      return Z.ONE;
    }
    return Integers.SINGLETON.sumdiv(mN, d -> Z.ONE.shiftLeft((mN / d - 1) / 2).multiply(Mobius.mobius(d)));
  }

}
#!queue	A056477	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a056;
// manually A060164/parm2 at 2022-03-25 13:13

import irvine.math.Mobius;
import irvine.math.q.Q;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;
import irvine.oeis.a124.A124302;

/**
 * A056477 Number of primitive (aperiodic) palindromic structures using a maximum of three different symbols.
 * a(n) = Sum_{d|n} mu(d)*A124302(ceiling(n/(2*d))) for n &gt; 0.
 * @author Georg Fischer
 */
public class A056477 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  protected int mN;
  protected MemorySequence mSeq;

  /** Construct the sequence. */
  public A056477() {
    super(0);
    mN = -1;
    mSeq = MemorySequence.cachedSequence(new A124302());
  }

  @Override
  public Z next() {
    ++mN;
    if (mN == 0) {
      return Z.ONE;
    }
    return Integers.SINGLETON.sumdiv(mN, d -> mSeq.a(new Q(mN, 2L * d).ceiling().intValue()).multiply(Mobius.mobius(d)));
  }
}
#!queue	A056478	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a056;
// manually A060164/parm2 at 2022-03-25 13:13

import irvine.math.Mobius;
import irvine.math.q.Q;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;
import irvine.oeis.a124.A124303;

/**
 * A056478 Number of primitive (aperiodic) palindromic structures using a maximum of four different symbols.
 * a(n) = Sum_{d|n} mu(d)*A124303(ceiling(n/(2*d))) for n &gt; 0.
 * @author Georg Fischer
 */
public class A056478 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  protected int mN;
  protected MemorySequence mSeq;

  /** Construct the sequence. */
  public A056478() {
    super(0);
    mN = -1;
    mSeq = MemorySequence.cachedSequence(new A124303());
  }

  @Override
  public Z next() {
    ++mN;
    if (mN == 0) {
      return Z.ONE;
    }
    return Integers.SINGLETON.sumdiv(mN, d -> mSeq.a(new Q(mN, 2L * d).ceiling().intValue()).multiply(Mobius.mobius(d)));
  }
}
#!queue	A056525	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A056525 Palindromes with odd number of digits.
 * @author Sean A. Irvine
 */
public class A056525 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A056525() {
    super(1);
  }

  private String mForward = "";
  private StringBuilder mReverse = new StringBuilder();
  private long mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > 9) {
      mForward = String.valueOf(++mN);
      mReverse = new StringBuilder(mForward).reverse();
      mM = 0;
    }
    return new Z(mForward + mM + mReverse);
  }
}
#!queue	A056556	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A056556 First tetrahedral coordinate; repeat m (m+1)*(m+2)/2 times.
 * @author Sean A. Irvine
 */
public class A056556 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A056556() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  @Override
  public Z next() {
    if (--mM < 0) {
      ++mN;
      mM = (mN + 1) * (mN + 2) / 2 - 1;
    }
    return Z.valueOf(mN);
  }
}
#!queue	A056788	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a056;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A056788 a(n) = n^n + (n-1)^(n-1).
 * @author Georg Fischer
 */
public class A056788 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  protected int mN;

  /** Construct the sequence. */
  public A056788() {
    super(1);
    mN = 0;
  }

  @Override
  public Z next() {
    final Z pow1 = Z.valueOf(mN).pow(mN);
    ++mN;
    return pow1.add(Z.valueOf(mN).pow(mN));
  }
}
#!queue	A056896	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a056;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A056896 Smallest prime which can be written as k^2 + n for k &gt;= 0.
 * @author Sean A. Irvine
 */
public class A056896 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A056896() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  protected int mN = 0;

  @Override
  public Z next() {
    ++mN;
    long k = -1;
    while (!mPrime.isPrime(mN + ++k * k)) {
      // do nothing
    }
    return Z.valueOf(mN + k * k);
  }
}
#!queue	A057036	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a005.A005408;

/**
 * A057036 Let R(i,j) be the rectangle with antidiagonals 1; 2,3; 4,5,6; ...; each k is an R(i(k),j(k)) and A057036(n)=i(2n-1).
 * @author Georg Fischer
 */
public class A057036 extends AbstractSequence {

  protected Z mTri; // smallest triangular number >= mN
  protected long mTrix; // index of that largest triangular number
  protected Sequence mSeq; // underlying sequence
  protected int mMode; // 1: return <code>i</code>, 2: return <code>j</code>, 3: return antidiagonal's number

  /** Construct the sequence. */
  public A057036() {
    this(1, new A005408(), 1, 0); // odd numbers 1, 3, 5...
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param seq underlying sequence
   * @param mode 1: return <code>i</code>, 2: return <code>j</code>, 3: return antidiagonal's number
   * @param skip number of terms of the underlying sequence to be skipped initially
   */
  public A057036(final int offset, final Sequence seq, final int mode, int skip) {
    super(offset);
    mSeq = seq;
    while (skip > 0) {
      mSeq.next();
      --skip;
    }
    mMode = mode;
    mTri = Z.ONE;
    mTrix = 1;
  }

  @Override
  public Z next() {
    final Z k = mSeq.next();
    while (k.compareTo(mTri) > 0) {
      ++mTrix;
      mTri = mTri.add(mTrix);
    }
    // now k <= mTri
    final long dist = mTri.subtract(k).longValue();
    final long i = mTrix - dist;
    final long j = dist + 1;
    if (mMode == 1) {
      return Z.valueOf(i);
    } else if (mMode == 2) {
      return Z.valueOf(j);
    } else if (mMode == 3) {
      return Z.valueOf(mTrix);
    }
    return Z.ZERO;
  }
}
#!queue	A057149	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a057;

import irvine.math.MemoryFunction2;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.HararyMultiply;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057149 Triangle T(n,k) of n X n binary matrices with k ones, with no zero rows or columns, up to row and column permutation.
 * @author Sean A. Irvine
 */
public class A057149 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A057149() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;

  private final MemoryFunction2<Integer, Polynomial<Q>> mCycleIndexCache = new MemoryFunction2<>() {
    @Override
    protected Polynomial<Q> compute(final Integer n, final Integer m) {
      return SymmetricGroup.create(n).cycleIndex().op(HararyMultiply.OP, SymmetricGroup.create(m).cycleIndex()).applyOnePlusXToTheN();
    }
  };

  protected Z t(final int n, final int k) {
    if (k == 0) {
      return Z.ZERO;
    }
    if (n == 1) {
      return k == 1 ? Z.ONE : Z.ZERO;
    }
    final Q a = mCycleIndexCache.get(n, n).coeff(k);
    final Q b = mCycleIndexCache.get(n - 1, n - 1).coeff(k);
    final Q c = mCycleIndexCache.get(n, n - 1).coeff(k);
    return a.add(b).subtract(c.multiply(Q.TWO)).toZ();
  }

  @Override
  public Z next() {
    if (++mM > mN * mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A057277	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a057;

import java.util.List;

import irvine.math.graph.Edges;
import irvine.math.graph.GraphUtils;
import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057277 Triangle T(n,k) of number of digraphs with a source on n unlabeled nodes with k arcs, k=0..n*(n-1).
 * @author Sean A. Irvine
 */
public class A057277 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A057277() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;
  private Polynomial<Q> mRow = null;

  protected Polynomial<Q> gfRow(final int n, final int m) {
    final int t = Math.min(m, n * (n - 1));
    final DegreeLimitedPolynomialRingField<Q> fld = new DegreeLimitedPolynomialRingField<>("y", Rationals.SINGLETON, t);
    final List<List<Polynomial<Q>>> graphs = GraphUtils.graphCycleIndexData(fld, n, Edges.DIGRAPH_EDGES, e -> fld.onePlusXToTheN(e));
    final Polynomial<Polynomial<Q>> res = GraphUtils.initially(fld, graphs, e -> fld.onePlusXToTheN(e));
    return res.coeff(n);
  }

  @Override
  public Z next() {
    if (++mM > mN * (mN - 1)) {
      mM = 0;
      mRow = gfRow(++mN, mN * (mN - 1));
    }
    return mRow.coeff(mM).toZ();
  }
}
#!queue	A057278	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a057;

import java.util.List;

import irvine.math.graph.Edges;
import irvine.math.graph.GraphUtils;
import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057278 Triangle T(n,k) of number of digraphs with a source and a sink on n unlabeled nodes and k arcs, k=0..n*(n-1).
 * @author Sean A. Irvine
 */
public class A057278 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A057278() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;
  private Polynomial<Q> mRow = null;

  protected Polynomial<Q> gfRow(final int n, final int m) {
    final int t = Math.min(m, n * (n - 1));
    final DegreeLimitedPolynomialRingField<Q> fld = new DegreeLimitedPolynomialRingField<>("y", Rationals.SINGLETON, t);
    final List<List<Polynomial<Q>>> graphs = GraphUtils.graphCycleIndexData(fld, n, Edges.DIGRAPH_EDGES, e -> fld.onePlusXToTheN(e));
    final Polynomial<Polynomial<Q>> res = GraphUtils.initiallyFinally(fld, graphs, e -> fld.onePlusXToTheN(e));
    return res.coeff(n);
  }

  @Override
  public Z next() {
    if (++mM > mN * (mN - 1)) {
      mM = 0;
      mRow = gfRow(++mN, mN * (mN - 1));
    }
    return mRow.coeff(mM).toZ();
  }
}
#!queue	A057863	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a057;
// Generated by gen_seq4.pl prodsim/prodsif at 2021-11-19 23:43

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057863 a(n) = Product_{k=1..n} (2k-1)!!.
 * @author Georg Fischer
 */
public class A057863 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A057863() {
    super(0);
  }

  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Z prod = Z.ONE;
    for (int k = 1; k <= mN; ++k) {
      prod = prod.multiply(FACTORIAL.doubleFactorial(2 * k - 1));
    }
    return prod;
  }
}
#!queue	A057889	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a057;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057889 Bit-reverse of n, including as many leading as trailing zeros.
 * @author Georg Fischer
 */
public class A057889 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN;

  /** Construct the sequence. */
  public A057889() {
    super(0);
    mN = -1;
  }

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ZERO;
    }
    final int head0 = Long.numberOfLeadingZeros(mN);
    final int tail0 = Long.numberOfTrailingZeros(mN);
    final long nOrg = mN >> tail0;
    final long nRev = ((Long.reverse(nOrg) >> head0) & ((1 << (64 - head0)) - 1)) >> tail0;
    return Z.valueOf(nOrg != nRev ? (nRev << tail0) : mN);
  }
}
#!queue	A057968	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a057;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A057968 Triangle T(n,k) of numbers of minimal 5-covers of an unlabeled n+5-set that cover k points of that set uniquely (k=5,..,n+5).
 * @author Sean A. Irvine
 */
public class A057968 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A057968() {
    super(0);
  }

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> TWO = RING.monomial(Q.TWO, 0);
  private static final Polynomial<Q> THREE = RING.monomial(Q.THREE, 0);
  private static final Polynomial<Q> FOUR = RING.monomial(Q.FOUR, 0);
  private static final Polynomial<Q> SIX = RING.monomial(Q.SIX, 0);
  private static final Polynomial<Q> SEVEN = RING.monomial(Q.SEVEN, 0);
  private static final Polynomial<Q> P13 = RING.monomial(new Q(13), 0);
  private static final Polynomial<Q> P27 = RING.monomial(new Q(27), 0);
  private int mN = -1;
  private int mM = 0;

  protected Z b(final int n, final int k) {
    if (n == 0) {
      return k == 0 ? Z.ONE : Z.ZERO;
    }
    final CycleIndex zn = SymmetricGroup.create(n).cycleIndex();
    // Z(S_n; 27+5*x, 27+5*x^2, ...)
    final List<Polynomial<Q>> s1 = new ArrayList<>();
    for (int j = 1; j <= n; ++j) {
      s1.add(RING.add(P27, RING.monomial(Q.FIVE, j)));
    }
    final Q q1 = zn.apply(s1, Z.valueOf(k)).coeff(k);
    // 10*Z(S_n; 13+3*x, 27+5*x^2, 13+3*x^3, 27+5*x^4, ...)
    final List<Polynomial<Q>> s2 = new ArrayList<>();
    for (int j = 1; j <= n; ++j) {
      if ((j & 1) == 1) {
        s2.add(RING.add(P13, RING.monomial(Q.THREE, j)));
      } else {
        s2.add(RING.add(P27, RING.monomial(Q.FIVE, j)));
      }
    }
    final Q q2 = zn.apply(s2, Z.valueOf(k)).coeff(k).multiply(10);
    // 15*Z(S_n; 7+x, 27+5*x^2, 7+x^3, 27+5*x^4, ...)
    final List<Polynomial<Q>> s3 = new ArrayList<>();
    for (int j = 1; j <= n; ++j) {
      if ((j & 1) == 1) {
        s3.add(RING.add(SEVEN, RING.monomial(Q.ONE, j)));
      } else {
        s3.add(RING.add(P27, RING.monomial(Q.FIVE, j)));
      }
    }
    final Q q3 = zn.apply(s3, Z.valueOf(k)).coeff(k).multiply(15);
    // 20*Z(S_n; 6+2*x, 6+2*x^2, 27+5*x^3, 6+2*x^4, 6+2*x^5, 27+5*x^6, ...)
    final List<Polynomial<Q>> s4 = new ArrayList<>();
    for (int j = 1; j <= n; ++j) {
      if ((j % 3) != 0) {
        s4.add(RING.add(SIX, RING.monomial(Q.TWO, j)));
      } else {
        s4.add(RING.add(P27, RING.monomial(Q.FIVE, j)));
      }
    }
    final Q q4 = zn.apply(s4, Z.valueOf(k)).coeff(k).multiply(20);
    // 20*Z(S_n; 4, 6+2*x^2, 13+3*x^3, 6+2*x^4, 4, 27+5*x^6, 4, 6+2*x^8, 13+3*x^9, 6+2*x^10, 4, 27+5*x^12, ...)
    final List<Polynomial<Q>> s5 = new ArrayList<>();
    for (int j = 1; j <= n; ++j) {
      switch (j % 6) {
        case 1:
        case 5:
          s5.add(FOUR);
          break;
        case 2:
        case 4:
          s5.add(RING.add(SIX, RING.monomial(Q.TWO, j)));
          break;
        case 3:
          s5.add(RING.add(P13, RING.monomial(Q.THREE, j)));
          break;
        default: // 0
          s5.add(RING.add(P27, RING.monomial(Q.FIVE, j)));
          break;
      }
    }
    final Q q5 = zn.apply(s5, Z.valueOf(k)).coeff(k).multiply(20);
    // 30*Z(S_n; 3+x, 7+x^2, 3+x^3, 27+5*x^4, 3+x^5, 7+x^6, 3+x^7, 27+5*x^8, ...)
    final List<Polynomial<Q>> s6 = new ArrayList<>();
    for (int j = 1; j <= n; ++j) {
      switch (j & 3) {
        case 1:
        case 3:
          s6.add(RING.add(THREE, RING.monomial(Q.ONE, j)));
          break;
        case 2:
          s6.add(RING.add(SEVEN, RING.monomial(Q.ONE, j)));
          break;
        default: // 0
          s6.add(RING.add(P27, RING.monomial(Q.FIVE, j)));
          break;
      }
    }
    final Q q6 = zn.apply(s6, Z.valueOf(k)).coeff(k).multiply(30);
    // 24*Z(S_n; 2, 2, 2, 2, 27+5*x^5, 2, 2, 2, 2, 27+5*x^10, ...)
    final List<Polynomial<Q>> s7 = new ArrayList<>();
    for (int j = 1; j <= n; ++j) {
      if ((j % 5) != 0) {
        s7.add(TWO);
      } else {
        s7.add(RING.add(P27, RING.monomial(Q.FIVE, j)));
      }
    }
    final Q q7 = zn.apply(s7, Z.valueOf(k)).coeff(k).multiply(24);
    return q1.add(q2).add(q3).add(q4).add(q5).add(q6).add(q7).divide(120).toZ();
  }

  private Z t(final int n, final int k) {
    return b(n, k).subtract(b(n - 1, k));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      if (++mN == 0) {
        return Z.ONE;
      }
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A058057	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a058;

import java.util.ArrayList;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A058057 Triangle giving coefficients of m\u00e9nage hit polynomials.
 * @author Sean A. Irvine
 */
public class A058057 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A058057() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;
  private static final ArrayList<Polynomial<Z>> CACHE = new ArrayList<>();

  /**
   * Return an element from the triangle defining these menage polynomials.
   * @param n row
   * @param m column
   * @return value
   */
  public static Z t(final int n, final int m) {
    while (n >= CACHE.size()) {
      Polynomial<Z> s = RING.zero();
      final int nn = CACHE.size();
      for (int k = 0; k <= nn; ++k) {
        s = RING.add(s, RING.multiply(RING.pow(Polynomial.create(-1, 1), k),
                  FACTORIAL.factorial(nn - k).multiply(Binomial.binomial(2L * nn - k, k))));
      }
      CACHE.add(s);
    }
    return CACHE.get(n).coeff(n - m);
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  public Z next() {
    if (mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM++);
  }
}
#!queue	A058087	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a058;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A058087 Triangle read by rows, giving coefficients of the m\u00e9nage hit polynomials ordered by descending powers. T(n, k) for 0 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A058087 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A058087() {
    super(0);
  }

  private int mN = -1;
  private int mM = 0;

  protected Z t(final int n, final int k) {
    if (n == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (int j = 0; j <= k; ++j) {
      final Z t = Binomial.binomial(n - k + j, n - k).multiply(Binomial.binomial(n + k - j, n - k + j)).multiply(MemoryFactorial.SINGLETON.factorial(k - j)).multiply(2L * n).divide(n + k - j);
      sum = sum.signedAdd((j & 1) == 0, t);
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A058377	1	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt2Sequence;

/**
 * A058377 Number of solutions to 1 +- 2 +- 3 +- ... +- n = 0.
 * @author Sean A. Irvine
 */
public class A058377 extends MemoryFunctionInt2Sequence<Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A058377() {
    super(1);
  }

  // After Alois P. Heinz

  protected int mN = 0;

  @Override
  protected Z compute(final int n, final int i) {
    final int m = i * (i + 1) / 2;
    if (n > m) {
      return Z.ZERO;
    }
    if (n == m) {
      return Z.ONE;
    }
    return get(Math.abs(n - i), i - 1).add(get(n + i, i - 1));
  }

  @Override
  public Z next() {
    return (mN++ & 3) < 2 ? Z.ZERO : get(mN, mN - 1);
  }
}
#!queue	A058550	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a058;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A058550 Eisenstein series E_14(q) (alternate convention E_7(q)).
 * @author Sean A. Irvine
 */
public class A058550 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A058550() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    if (++mN == 0) {
      return Z.ONE;
    }
    return Jaguar.factor(mN).sigma(13).multiply(24).negate();
  }
}
#!queue	A058760	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a058;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A058760 Integers whose set of prime factors (taken with multiplicity) uses each digit exactly once (i.e., is pandigital) in some base b &gt; 1. Numbers are expressed in base 10.
 * @author Sean A. Irvine
 */
public class A058760 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A058760() {
    super(0);
  }

  private long mN = 1;

  protected boolean is(final long[] primes, final int b) {
    final int[] counts = new int[b];
    for (final long p : primes) {
      final int[] c = ZUtils.digitCounts(p, b);
      for (int k = 0; k < c.length; ++k) {
        counts[k] += c[k];
        if (counts[k] > 1) {
          return false;
        }
      }
    }
    for (final int c : counts) {
      if (c != 1) {
        return false;
      }
    }
    return true;
  }

  private boolean is(final long n) {
    final FactorSequence fs = Jaguar.factor(n);
    if (!fs.isSquareFree()) {
      return false;
    }
    // Work about approximate length of factorization in base b
    final long[] p = ZUtils.toLong(fs.toZArray());
    double logp = 0;
    for (final long q : p) {
      logp += Math.log(q) + 1; // +1 safety
    }
    for (int b = 2; (b - 1) * Math.log(b) <= logp; ++b) {
      if (is(p, b)) {
        return true;
      }
    }
    return false;
  }

  @Override
  public Z next() {
    while (true) {
      if (is(++mN)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A058876	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a058;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A058876 Triangle read by rows: T(n,k) = number of labeled acyclic digraphs with n nodes, containing exactly n+1-k points of in-degree zero (n &gt;= 1, 1&lt;=k&lt;=n).
 * @author Sean A. Irvine
 */
public class A058876 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A058876() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final Integer p, final Integer k) {
    if (p.equals(k)) {
      return Z.ONE;
    }
    final Z u = Z.ONE.shiftLeft(k).subtract(1);
    Z v = u;
    Z s = Z.ZERO;
    for (int j = 1; j <= p - k; ++j, v = v.multiply(u)) {
      s = s.add(Binomial.binomial(p, k).multiply(get(p - k, j)).multiply(v).shiftLeft(k * (p - j - k)));
    }
    return s;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mN - mM);
  }

}
#!queue	A059010	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059010 Natural numbers having an even number of nonleading zeros in their binary expansion.
 * @author Sean A. Irvine
 */
public class A059010 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A059010() {
    super(0);
  }

  private long mN = 0;
  private long mM = 0;
  private long mLim = 1;

  @Override
  public Z next() {
    while (true) {
      if (++mN == mLim) {
        mLim *= 2;
        ++mM;
      }
      if (((mM - Long.bitCount(mN)) & 1) == 0) {
        return Z.valueOf(mN);
      }
    }
  }
}

#!queue	A059219	0	->	0	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;

/**
 * A059219 Variation of Boustrophedon transform applied to sequence 1,0,0,0,...: fill an array by diagonals in alternating directions - 'up' and 'down'. The first element of each diagonal after the first is 0. When 'going up', add to the previous element the elements of the row the new element is in. When 'going down', add to the previous element the elements of the column the new element is in. The final element of the n-th diagonal is a(n).
 * @author Sean A. Irvine
 */
public class A059219 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mN = -1;

  @Override
  protected Z compute(final int n, final int m) {
    if (n == 0) {
      return Z.ONE;
    }
    if ((n & 1) == 0) {
      if (m == n) {
        return Z.ZERO;
      }
      Z sum = get(n, m + 1);
      for (int row = n - 1; row >= m; --row) {
        sum = sum.add(get(row, m));
      }
      return sum;
    } else {
      if (m == 0) {
        return Z.ZERO;
      }
      Z sum = get(n, m - 1);
      for (int row = n - 1; row >= 0 && m >= n - row; --row) {
        sum = sum.add(get(row, m - (n - row)));
      }
      return sum;
    }
  }

  @Override
  public Z next() {
    ++mN;
    return (mN & 1) == 0 ? get(mN, 0) : get(mN, mN);
  }
}
#!queue	A059226	0	->	0	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;

/**
 * A059226 Triangle T(n,k) (0 &lt;= k &lt;= n) read by rows: top entry is 1, all other rows begin with 0; typical entry is sum of entry to left plus sum of all entries above it in the triangle.
 * @author Sean A. Irvine
 */
public class A059226 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m) {
    if (n == 0) {
      return Z.ONE;
    }
    if (m == 0) {
      return Z.ZERO;
    }
    Z sum = get(n, m - 1);
    for (int row = 0; row <= n - m; ++row) {
      for (int col = 0; col <= m; ++col) {
        if (row + col != n) {
          sum = sum.add(get(row + col, col));
        }
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A059333	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a059;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059333 For 0&lt;=A, 0&lt;=B, n is an A-almost prime; m is a B-almost prime, k = n+m, k is a C-almost prime; a(n) = smallest number m such that A+B=C.
 * @author Sean A. Irvine
 */
public class A059333 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A059333() {
    super(1);
  }

  private long mN = 0;

  protected Z f(final Z n) {
    final long a = Jaguar.factor(n).bigOmega();
    long m = 0;
    while (true) {
      final long b = Jaguar.factor(++m).bigOmega();
      if (a + b == Jaguar.factor(n.add(m)).bigOmega()) {
        return Z.valueOf(m);
      }
    }
  }

  @Override
  public Z next() {
    return f(Z.valueOf(++mN));
  }
}
#!queue	A059419	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A059419 Triangle T(n,k) (1 &lt;= k &lt;= n) of tangent numbers, read by rows: T(n,k) = coefficient of x^n/n! in expansion of (tan x)^k/k!.
 * @author Sean A. Irvine
 */
public class A059419 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A059419() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n.equals(k)) {
      return Z.ONE;
    }
    if (k < 0 || k > n) {
      return Z.ZERO;
    }
    return get(n - 1, k - 1).add(get(n - 1, k + 1).multiply(k).multiply(k + 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059438	1	->	1	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.a003.A003319;
import irvine.oeis.memory.MemoryFunctionInt2Sequence;

/**
 * A059438 Triangle T(n,k) (1 &lt;= k &lt;= n) read by rows: T(n,k) is the number of permutations of [1..n] with k components.
 * @author Sean A. Irvine
 */
public class A059438 extends MemoryFunctionInt2Sequence<Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A059438() {
    super(1);
  }

  private final MemorySequence mP = new A003319();
  private int mN = 0;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m) {
    if (n < m) {
      return Z.ZERO;
    }
    if (m == 1) {
      return mP.a(n);
    }
    return Integers.SINGLETON.sum(1, n, k -> get(n - k, m - 1).multiply(mP.a(k)));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A059876	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a059;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059876 a(n) = bin_prime_sum(n).
 * @author Sean A. Irvine
 */
public class A059876 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A059876() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  protected long mN = 0;

  protected Z binPrimeSum(final Z n) {
    final long s = n.bitLength() - 1;
    long p = 1;
    Z sum = n.isOdd() ? Z.ONE : Z.NEG_ONE;
    Z m = n.divide2();
    for (int k = 1; k <= s; ++k, m = m.divide2()) {
      p = mPrime.nextPrime(p);
      sum = sum.signedAdd(m.isOdd(), Z.valueOf(p));
    }
    if (Z.ONE.equals(n)) {
      sum = sum.add(1);
    } else if ((s & 1) == 0) {
      sum = sum.add(p);
    }
    return sum;
  }

  @Override
  public Z next() {
    return binPrimeSum(Z.valueOf(++mN));
  }
}
#!queue	A059882	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a059;

import irvine.math.MemoryFunction2;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059882 As upper right triangle: ascending wiggly sums to n where first term is k (sums in which terms alternately increase and decrease; zigzag partitions).
 * @author Sean A. Irvine
 */
public class A059882 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A059882() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  protected MemoryFunction2<Long, Z> mT = new MemoryFunction2<Long, Z>() {
    @Override
    protected Z compute(final Long n, final Long k) {
      if (n > k && k > 0) {
        Z sum = Z.ZERO;
        for (long j = k + 1; j <= n; ++j) {
          sum = sum.add(mS.get(n - k, j));
        }
        return sum;
      }
      return n > 0 && n.equals(k) ? Z.ONE : Z.ZERO;
    }
  };

  protected MemoryFunction2<Long, Z> mS = new MemoryFunction2<Long, Z>() {
    @Override
    protected Z compute(final Long n, final Long k) {
      if (n > k && k > 0) {
        Z sum = Z.ZERO;
        for (long j = 1; j < k; ++j) {
          sum = sum.add(mT.get(n - k, j));
        }
        return sum;
      }
      return n > 0 && n.equals(k) ? Z.ONE : Z.ZERO;
    }
  };

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return mT.get(mN, mM);
  }
}
#!queue	A059884	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a059;

import irvine.factor.factor.Jaguar;
import irvine.factor.prime.Fast;
import irvine.factor.util.FactorSequence;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A059884 Prime factorization of n encoded by recursively interleaving bits of successive prime exponents.
 * @author Sean A. Irvine
 */
public class A059884 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A059884() {
    super(1);
  }

  private final Fast mPrime = new Fast();
  private long mN = 0;

  protected Z encode(final Z n) {
    final FactorSequence fs = Jaguar.factor(n);
    final Z last = fs.largestPrimeFactor();
    Z encoding = Z.ZERO;
    int k = 0;
    for (Z p = Z.TWO; p.compareTo(last) <= 0; p = mPrime.nextPrime(p)) {
      int e = fs.getExponent(p);
      int s = (1 << k) - 1;
      ++k;
      while (e != 0) {
        if ((e & 1) == 1) {
          encoding = encoding.setBit(s);
        }
        s += 1 << k;
        e >>>= 1;
      }
    }
    return encoding;
  }

  @Override
  public Z next() {
    return encode(Z.valueOf(++mN));
  }
}
#!queue	A059922	0	->	0	MemoryFunctionInt2Sequence	--------------------------------
package irvine.oeis.a059;

import irvine.oeis.memory.MemoryFunctionInt2Sequence;
import irvine.math.z.Z;

/**
 * A059922 Each term in the table is the product of the two terms above it + 1.
 * @author Sean A. Irvine
 */
public class A059922 extends MemoryFunctionInt2Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int m) {
    if (n > m || n < 0) {
      return Z.ZERO;
    }
    if (n == 0) {
      return Z.ONE;
    }
    return get(n - 1, m - 1).multiply(get(n, m - 1)).add(1);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mM, mN);
  }
}

#!queue	A060158	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a060;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A060158 Number of permutations of [n] with 4 sequences.
 * @author Sean A. Irvine
 */
public class A060158 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A060158() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    return ++mN <= 4 ? Z.ZERO
      : Z.valueOf(2L * mN).subtract(7)
      .add(Z.valueOf(6 - mN).shiftLeft(mN - 1))
      .subtract(Z.THREE.pow(mN))
      .add(Z.ONE.shiftLeft(2 * (mN - 1)));
  }
}

#!queue	A060240	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a060;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A060240 Triangle T(n,k) in which n-th row gives degrees of irreducible representations of symmetric group S_n.
 * @author Sean A. Irvine
 */
public class A060240 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A060240() {
    super(0);
  }

  protected final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = -1;
  private List<Z> mReps = Collections.emptyList();
  private int mM = 0;

  protected Z degree(final int n, final int[] a) {
    final int k = a.length;
    Z d = mF.factorial(n);
    for (int i = 0; i < k; ++i) {
      final int b = a[i] + k - i - 1;
      for (int j = i + 1; j < k; ++j) {
        d = d.multiply(b - a[j] - k + j + 1);
      }
    }
    for (int i = 0; i < k; ++i) {
      d = d.divide(mF.factorial(a[i] + k - i - 1));
    }
    return d;
  }

  protected List<Z> representations(final int n) {
    if (n == 0) {
      return Collections.singletonList(Z.ONE);
    }
    final ArrayList<Z> reps = new ArrayList<>();
    final IntegerPartition partition = new IntegerPartition(n);
    int[] p;
    while ((p = partition.next()) != null) {
      reps.add(degree(n, p));
    }
    return reps;
  }

  @Override
  public Z next() {
    if (++mM >= mReps.size()) {
      mReps = representations(++mN);
      Collections.sort(mReps);
      mM = 0;
    }
    return mReps.get(mM);
  }
}
#!queue	A061870	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a061;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A061870 Numbers such that |first digit - second digit + third digit - fourth digit ...| = 1.
 * @author Georg Fischer
 */
public class A061870 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private Z mK;
  private int mSum;
  private int mMode;

  /** Construct the sequence. */
  public A061870() {
    this(2, 1);
  }

  /**
   * Generic constructor with parameters
   * @param mode alternating, 1 = without abs, 2 = with abs.
   * @param sum required digit sum
   */
  public A061870(final int mode, final int sum) {
    super(1);
    mK = Z.ZERO;
    mSum = sum;
    mMode = mode;
  }

  /**
   * Computes the alternating sum of digits.
   * @param num String with digits
   * @return first digit - second digit + third digit and so on.
   */
  protected static int alternatingDigitSum(final String num) {
    int sum = 0;
    int sign = 1;
    for (int i = 0; i < num.length(); ++i) {
      sum += sign * Character.digit(num.charAt(i), 10);
      sign = -sign;
    }
    return sum;
  }

  @Override
  public Z next() {
    while (true) {
      mK = mK.add(1);
      final int sum = alternatingDigitSum(mK.toString());
      if ((sum > 0 || mMode == 1 ? sum : -sum) == mSum) {
        return mK;
      }
    }
  }
}
#!queue	A063115	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;
import irvine.util.array.DynamicIntArray;

/**
 * A063115 Smallest k such that 2^k has exactly n 1's in its decimal representation.
 * Cf. A063555.java
 * @author Georg Fischer
 */
public class A063115 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  protected final DynamicIntArray mSmallest = new DynamicIntArray();
  protected int mN = -1;
  protected Z mA = Z.ONE;
  protected int mM = 1; // actually one larger than power of 2, as 0 is "unknown" in array
  protected int mParm1;
  protected int mParm2;

  /** Construct the sequence. */
  public A063115() {
    this(2, 1);
  }

  /**
   * Generic constructor with parameters
   * @param parm1 base
   * @param parm2 desired digits
   */
  public A063115(final int parm1, final int parm2) {
    super(0);
    mParm1 = parm1;
    mParm2 = parm2;
  }

  @Override
  public Z next() {
    ++mN;
    while (mSmallest.get(mN) == 0) {
      ++mM;
      mA = mA.multiply(mParm1);
      final int count = ZUtils.digitCounts(mA, 10)[mParm2];
      if (mSmallest.get(count) == 0) {
        mSmallest.set(count, mM);
      }
    }
    return Z.valueOf(mSmallest.get(mN) - 1);
  }
}

#!queue	A063691	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a063;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.polynomial.ThetaFunctions;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A063691 Number of solutions to x^2 + y^2 + z^2 = n in positive integers.
 * @author Sean A. Irvine
 */
public class A063691 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A063691() {
    super(0);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private int mN = -1;

  @Override
  public Z next() {
    final Polynomial<Z> t3 = ThetaFunctions.theta3z(++mN);
    return RING.pow(RING.subtract(t3, RING.one()), 3, mN).coeff(mN).divide(8);
  }
}
#!queue	A063841	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a063;

import irvine.math.group.SymmetricGroup;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.PairMultiply;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A063841 Table T(n,k) giving number of k-multigraphs on n nodes (n &gt;= 1, k &gt;= 0) read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A063841 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A063841() {
    super(1);
  }

  protected Z t(final int n, final int k) {
    if (n == 0) {
      return Z.ONE;
    }
    final CycleIndex zn = SymmetricGroup.create(n).cycleIndex();
    final CycleIndex pair = zn.op(PairMultiply.OP, zn);
    return pair.eval(k + 1).toZ();
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (--mM < 0) {
      mM = mN;
      ++mN;
    }
    return t(mN - mM, mM);
  }
}

#!queue	A063884	1	->	1	MemorySequence	--------------------------------
package irvine.oeis.a063;

import java.util.HashSet;
import java.util.TreeSet;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.MemorySequence;

/**
 * A063884 a(1) = 2, a(2) = 3 and a(k+1) is the least prime not already chosen that divides some a(i)*a(j)+1, where 1&lt;=i&lt;=j&lt;=k.
 * @author Sean A. Irvine
 */
public class A063884 extends MemorySequence {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(1);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  protected final TreeSet<Z> mA = new TreeSet<>();
  protected final HashSet<Z> mUsed = new HashSet<>();
  {
    mA.add(Z.TWO);
    mA.add(Z.THREE);
  }

  protected void update(final Z n) {
    for (final Z p : Jaguar.factor(n).toZArray()) {
      if (!mUsed.contains(p)) {
        mA.add(p);
      }
    }
  }

  @Override
  protected Z computeNext() {
    final Z t = mA.pollFirst();
    mUsed.add(t);
    update(t.square().add(1)); // needed because we did not yet add to the sequence
    for (final Z v : this) {
      update(v.multiply(t).add(1));
    }
    return t;
  }
}
#!queue	A063904	0	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a063;

import irvine.math.z.Z;

/**
 * A063904 a(1) = 2, a(2) = 3 and a(k+1) is the least prime not already chosen that divides some a(i)*a(j)+1, where 1&lt;=i&lt;j&lt;=k.
 * @author Sean A. Irvine
 */
public class A063904 extends A063884 {

  /** Construct the sequence. */
  public A063904() {
    super(1);
  }

  @Override
  protected Z computeNext() {
    final Z t = mA.pollFirst();
    mUsed.add(t);
    for (final Z v : this) {
      update(v.multiply(t).add(1));
    }
    return t;
  }
}
#!queue	A067067	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a067;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000142;

/**
 * A067067 Product of nonzero digits of n! (A000142).
 * @author Georg Fischer
 */
public class A067067 extends AbstractSequence {

  private Sequence mSeq; // underlying sequence

  /** Construct the sequence. */
  public A067067() {
    this(0, new A000142());
  }

  /**
   * Generic constructor with parameter
   * @param offset first index of target sequence
   * @param seq underlying sequence
   */
  public A067067(final int offset, final Sequence seq) {
    super(offset);
    mSeq = seq;
  }

  @Override
  public Z next() {
    return ZUtils.digitNZProduct(mSeq.next(), 10);
  }
}
#!queue	A067480	1	->	1	A008952	--------------------------------
package irvine.oeis.a067;

import irvine.math.z.Z;
import irvine.oeis.a008.A008952;

/**
 * A067480 Powers of 2 with initial digit 2.
 * @author Georg Fischer
 */
public class A067480 extends A008952 {

  protected int mN;
  protected Z mDigit;

  /** Construct the sequence. */
  public A067480() {
    this(1, 2);
  }

  /**
   * Generic constructor with parameters
   * @param digit leading digit
   */
  public A067480(final int digit) {
    this(0, digit);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param digit leading digit
   */
  public A067480(final int offset, final int digit) {
    super(offset);
    mN = -1;
    mDigit = Z.valueOf(digit);
  }

  @Override
  public Z next() {
    ++mN;
    while (!super.next().equals(mDigit)) {
      ++mN;
    }
    return Z.ONE.shiftLeft(mN);
  }
}
#!queue	A067499	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a067;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A067499 Powers of 2 with digit sum also a power of 2.
 * @author Georg Fischer
 */
public class A067499 extends AbstractSequence {

  private int mBase;
  private Z mPow;

  /** Construct the sequence. */
  public A067499() {
    this(1, 2);
  }

  /**
   * Generic constructor with parameters
   * @param base base and divisor
   */
  public A067499(final int offset, final int base) {
    super(offset);
    mPow = Z.ONE;
    mBase = base;
  }

  /**
   * Test the condition.
   * @return true (false) if the condition is (not) fulfilled.
   */
  protected boolean condition() {
    final long sum = ZUtils.digitSum(mPow);
    long prod = 1;
    while (prod < sum) {
      prod *= mBase;
    }
    return prod == sum;
  }

  @Override
  public Z next() {
    while (!condition()) {
      mPow = mPow.multiply(mBase);
    }
    final Z result = mPow;
    mPow = mPow.multiply(mBase);
    return result;
  }
}
#!queue	A067508	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a067;

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A067508 Powers of 4 with digit sum divisible by 4.
 * @author Georg Fischer
 */
public class A067508 extends AbstractSequence {

  private int mBase;
  private Z mPow;

  /** Construct the sequence. */
  public A067508() {
    this(0, 4);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param base base and divisor
   */
  public A067508(final int offset, final int base) {
    super(offset);
    mPow = Z.ONE;
    mBase = base;
  }

  @Override
  public Z next() {
    mPow = mPow.multiply(mBase);
    while (ZUtils.digitSum(mPow) % mBase != 0) {
      mPow = mPow.multiply(mBase);
    }
    return mPow;
  }
}
#!queue	A067553	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a067;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A067553 Sum of products of terms in all partitions of n into odd parts.
 * @author Sean A. Irvine
 */
public class A067553 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A067553() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    Polynomial<Z> product = RING.one();
    for (int k = 1; k <= mN; k += 2) {
      product = RING.multiply(product, RING.series(RING.one(), RING.oneMinusXToTheN(Z.valueOf(k), k), mN), mN);
    }
    return product.coeff(mN);
  }
}

#!queue	A068943	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a068;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A068943 a(n) = f(n, n, n), where f is the generalized super falling factorial (see comments for definition.).
 * @author Sean A. Irvine
 */
public class A068943 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A068943() {
    super(1);
  }

  private long mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z prod = Z.ONE;
    for (long m = 1; m <= mN; ++m) {
      final Z b = Binomial.binomial(m + mN - 2, m - 1);
      if (b.bitLength() > 30) {
        throw new UnsupportedOperationException();
      }
      prod = prod.multiply(Z.valueOf(mN - m + 1).pow(b.intValue()));
    }
    return prod;
  }
}

#!queue	A069588	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a069;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A069588 Smallest prime in which the n-th significant digit is a 1.
 * @author Georg Fischer
 */
public class A069588 extends AbstractSequence {

  private int mN;
  private final int mDigit;
  private Z mPow10;

  /** Construct the sequence. */
  public A069588() {
    this(1, 1);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param digit the digit
   */
  public A069588(final int offset, final int digit) {
    super(offset);
    mN = 0;
    mDigit = digit;
    mPow10 = Z.valueOf(mDigit);
  }

  @Override
  public Z next() {
    if (++mN == 1) {
      switch (mDigit) {
        case 1:
          mPow10 = mPow10.multiply(10);
          return Z.valueOf(11);
        case 2:
          mPow10 = mPow10.multiply(10);
          return Z.TWO;
        case 4:
        case 6:
        case 8:
          mPow10 = mPow10.multiply(10);
          break;
        case 9:
          mPow10 = mPow10.multiply(10);
          return Z.valueOf(19);
        case 0:
          mPow10 = Z.valueOf(1000);
          return Z.valueOf(101);
        case 3:
        case 5:
        case 7:
        default:
          mPow10 = mPow10.multiply(10);
          return Z.valueOf(mDigit);
      }
    }
    Z prime = mPow10.add(1);
    while (!prime.isProbablePrime()) {
      prime = prime.add(Z.TWO);
    }
    mPow10 = mPow10.multiply(10);
    return prime;
  }
}
#!queue	A073617	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a073;

import irvine.math.z.Binomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A073617 Consider Pascal's triangle A007318; a(n) = product of terms at +45 degrees slope with the horizontal.
 * @author Georg Fischer
 */
public class A073617 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A073617() {
    super(0);
  }

  private int mN = -2;

  @Override
  public Z next() {
    ++mN;
    return mN <= 1 ? Z.ONE : Integers.SINGLETON.product(1, (mN + 1) / 2, k -> Binomial.binomial(mN + 1 - k, k));
  }
}
#!queue	A074147	1	->	1	Triangle	--------------------------------
package irvine.oeis.a074;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A074147 (2n-1) odd numbers followed by 2n even numbers.
 * @author Georg Fischer
 */
public class A074147 extends Triangle {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A074147() {
    setOffset(1);
    hasRAM(true);
  }

  @Override
  public Z compute(final int n, final int k) {
    return Z.valueOf(n).square().add(1).divide2().add(1 + 2 * k);
  }
}
#!queue	A074477	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a074;

import irvine.factor.factor.Jaguar;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A074477 Largest prime factor of 3^n - 1.
 * @author Georg Fischer
 */
public class A074477 extends AbstractSequence {

  private Z mN;
  private final int mBase;
  private final int mAdd;

  /** Construct the sequence. */
  public A074477() {
    this(3, -1);
  }

  /**
   * Generic constructor with parameters
   * @param base base to be raised to power <code>mN</code>
   * @param add add this to the expression
   */
  public A074477(final int base, final int add) {
    super((add < -1) ? 2 : 1);
    mBase = base;
    mAdd = add;
    mN = Z.valueOf(mBase);
  }

  @Override
  public Z next() {
    final Z result = Jaguar.factor(mN.add(mAdd)).largestPrimeFactor();
    mN = mN.multiply(mBase);
    return result;
  }
}
#!queue	A074728	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a074;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A074728 a(n) = Sum_{k=1..n} k^(n-k)*binomial(n,k-1).
 * @author Sean A. Irvine
 */
public class A074728 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A074728() {
    super(1);
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z s = Z.ZERO;
    for (int k = 1; k <= mN; ++k) {
      s = s.add(Z.valueOf(k).pow(mN - k).multiply(Binomial.binomial(mN, k - 1)));
    }
    return s;
  }

}
#!queue	A079126	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a079;

import java.util.ArrayList;

import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A079126 Triangle T(n,k) of numbers of partitions of n into distinct positive integers &lt;= k, 0&lt;=k&lt;=n.
 * @author Sean A. Irvine
 */
public class A079126 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A079126() {
    super(0);
  }

  private static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private final ArrayList<Polynomial<Z>> mCols = new ArrayList<>();
  private int mN = -1;
  private int mM = 0;

  protected Z t(final int n, final int m) {
    while (m >= mCols.size()) {
      Polynomial<Z> prod = RING.one();
      for (int k = 1; k <= mCols.size(); ++k) {
        prod = RING.multiply(prod, RING.onePlusXToTheN(k));
      }
      mCols.add(prod);
    }
    return mCols.get(m).coeff(n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A079267	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a079;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;

/**
 * A079267 d(n,s) = number of perfect matchings on {1, 2, ..., n} with s short pairs.
 * @author Sean A. Irvine
 */
public class A079267 extends MemoryFunction2Sequence<Integer, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer s) {
    Z sum = Z.ZERO;
    for (int h = s; h <= n; ++h) {
      sum = sum.signedAdd(((h - s) & 1) == 0, mF.factorial(2 * n - h).shiftRight(n - h).divide(mF.factorial(n - h)).divide(mF.factorial(h - s)));
    }
    return sum.divide(mF.factorial(s));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A079502	0	->	0	MemoryFunction1Sequence	--------------------------------
package irvine.oeis.a079;

import java.util.ArrayList;

import irvine.oeis.memory.MemoryFunction1Sequence;
import irvine.math.z.Z;
import irvine.oeis.DifferenceSequence;
import irvine.oeis.LookaheadSequence;
import irvine.oeis.Sequence0;
import irvine.oeis.a050.A050447;

/**
 * A079502 Triangle T(n,k) read by rows; related to number of preorders.
 * @author Sean A. Irvine
 */
public class A079502 extends MemoryFunction1Sequence<Z[]> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private final A050447 mP = new A050447();

  private final class ColumnSequence extends Sequence0 {
    private final long mN;
    private long mR = 0;

    private ColumnSequence(final long n) {
      mN = n;
    }

    @Override
    public Z next() {
      return ++mR <= 1 ? Z.ZERO : mP.get(mN, mR);
    }
  }

  // Using column labels of Kreweras
  @Override
  protected Z[] compute(final int n) {
    LookaheadSequence seq = new LookaheadSequence(new ColumnSequence(n));
    final ArrayList<Z> values = new ArrayList<>();
    for (long k = 0; k <= n; ++k) {
      values.add(seq.peek());
      seq = new LookaheadSequence(new DifferenceSequence(seq));
    }
    // ans is values u_0^n, u_1^n, ..., u_n^n
    final Z[] ans = new Z[values.size()];
    Z a = Z.ZERO;
    for (int k = n; k >= 0; --k) {
      a = values.get(k).subtract(a);
      ans[k] = a;
    }
    //System.out.println("Col: " + n + " -> " + Arrays.toString(ans));
    return ans;
  }

  protected Z u(final int n, final int r) {
    if (r > n) {
      return Z.ZERO;
    }
    return get(n)[r];
  }

  private int mR = 1;
  private int mN = 1;

  @Override
  public Z next() {
    if (++mR > mN) {
      ++mN;
      mR = 2;
    }
    return u(mN, mR);
  }
}

#!queue	A080032	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a080;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A080032 a(n) is taken to be the smallest positive integer not already present which is consistent with the condition "n is a member of the sequence if and only if a(n) is even".
 * <code>a(4m)=6m, a(4m+1)=4m+3, a(4m+2)=6m+2, a(4m+3)=6m+4</code>.
 * @author Georg Fischer
 */
public class A080032 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A080032() {
    super(0);
  }

  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    final long mod = mN / 4;
    switch (mN % 4) {
      case 0:
        return Z.valueOf(6 * mod);
      case 1:
        return mod == 0 ? Z.TWO : Z.valueOf(4 * mod + 3);
      case 2:
        return mod == 0 ? Z.FOUR : Z.valueOf(6 * mod + 2);
      case 3:
      default:
        return mod == 0 ? Z.ONE : Z.valueOf(6 * mod + 4);
    }
  }
}
#!queue	A080843	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a080;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A080843 Tribonacci word: limit S(infinity), where S(0) = 0, S(1) = 0,1, S(2) = 0,1,0,2 and for n &gt;= 0, S(n+3) = S(n+2) S(n+1) S(n).
 * @author Sean A. Irvine
 */
public class A080843 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A080843() {
    super(0);
  }

  private final StringBuilder mSeq = new StringBuilder("01");
  private int mN = -1;
  private int mExpandPos = 0;

  @Override
  public Z next() {
    if (++mN >= mSeq.length()) {
      final char c = mSeq.charAt(++mExpandPos);
      switch (c) {
        case '0':
          mSeq.append("01");
          break;
        case '1':
          mSeq.append("02");
          break;
        default:
          mSeq.append('0');
          break;
      }
    }
    return Z.valueOf(mSeq.charAt(mN) - '0');
  }

}
#!queue	A081054	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a081;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRing;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Binomial;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A081054 Crossing matchings: linear chord diagrams with 2n nodes and n arcs in which each arc crosses another arc.
 * @author Sean A. Irvine
 */
public class A081054 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A081054() {
    super(0);
  }

  protected static final PolynomialRing<Z> RING = new PolynomialRing<>(Integers.SINGLETON);
  private static final PolynomialRing<Polynomial<Z>> RING2 = new PolynomialRing<>(RING);
  protected final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private Polynomial<Z> mPsiBarCache = null;
  private int mPsiBarCacheIndex = -1;

  protected Z lambda(final int d, final int k) {
    return Binomial.binomial(2L * d + k - 1, 2L * d).multiply(mF.doubleFactorial(2 * d - 1));
  }

  private Polynomial<Polynomial<Z>> lambdaSeries(final int n) {
    // inner element is x, outer is y
    Polynomial<Polynomial<Z>> series = RING2.zero();
    for (int l = 0; l <= n; ++l) {
      final Z[] t = new Z[n + 1];
      for (int i = 0; i <= n; ++i) {
        t[i] = lambda(i, l + 1);
      }
      series = RING2.add(series, RING2.monomial(Polynomial.create(t), l));
    }
    return series;
  }

  protected Polynomial<Z> psiBarSeries(final int n) {
    // P(x) = L(x, -x * P(x))
    if (n < mPsiBarCacheIndex) {
      return mPsiBarCache;
    }
    final Polynomial<Polynomial<Z>> lamdaSeries = lambdaSeries(n);
    Polynomial<Z> s = RING.one();
    for (int k = 0; k <= n; ++k) {
      s = RING2.eval(lamdaSeries, RING.negate(s.shift(1))).truncate(n);
    }
    mPsiBarCacheIndex = n;
    mPsiBarCache = s;
    return s;
  }

  private int mN = -1;

  @Override
  public Z next() {
    return psiBarSeries(++mN).coeff(mN);
  }
}

#!queue	A084546	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a084;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A084546 Triangle read by rows: T(n,k) = C( C(n,2), k) for n &gt;= 0, 0 &lt;= k &lt;= C(n,2).
 * @author Sean A. Irvine
 */
public class A084546 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A084546() {
    super(0);
  }

  private int mN = 0;
  private int mM = -1;

  protected Z t(final int n, final int m) {
    return Binomial.binomial((long) n * (n - 1) / 2, m);
  }

  @Override
  public Z next() {
    if (++mM > mN * (mN - 1) / 2) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}

#!queue	A084894	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a084;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Permutation;

/**
 * A084894 Number of permutations of length n such that at least one absolute difference between consecutive elements has a distinct partner.
 * @author Sean A. Irvine
 */
public class A084894 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A084894() {
    super(1);
  }

  private int mN = 0;

  @Override
  public Z next() {
    long c = 0;
    long pn = 0;
    final Permutation perm = new Permutation(++mN);
    final long[] seen = new long[mN];
    int[] p;
    while ((p = perm.next()) != null) {
      ++pn;
      for (int j = 0; j < mN - 1; ++j) {
        final int abs = Math.abs(p[j + 1] - p[j]);
        if (seen[abs] == pn) {
          ++c;
          break;
        }
        seen[abs] = pn;
      }
    }
    return Z.valueOf(c);
  }
}
#!queue	A085244	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a085;

import irvine.math.LongUtils;
import irvine.math.api.Matrix;
import irvine.math.group.IntegerField;
import irvine.math.group.MatrixRing;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A085244 Permanent of the symmetric n X n matrix M defined by M(i,j) = gcd(i,j) for 1 &lt;= i,j &lt;= n.
 * @author Georg Fischer
 */
public class A085244 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private int mN;

  /** Construct the sequence. */
  public A085244() {
    super(1);
    mN = 0;
  }

  /**
   * Fill the elements of the n x n matrix.
   * @param n dimension of the matrix
   * @param mat matrix to be filled
   */
  protected void fillMatrix(final int n, final Matrix<Z> mat) {
    for (int i = 0; i < mN; ++i) {
      for (int j = 0; j < mN; ++j) {
        mat.set(i, j, Z.valueOf(LongUtils.gcd(i + 1, j + 1)));
      }
    }
  }

  @Override
  public Z next() {
    ++mN;
    final Matrix<Z> mat = new DefaultMatrix<>(mN, mN, Z.ZERO);
    fillMatrix(mN, mat);
    return new MatrixRing<Z>(mN, IntegerField.SINGLETON).permanent(mat);
  }
}
#!queue	A085587	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a085;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A085587 Eventual period of a single cell in rule 90 cellular automaton in a cyclic universe of width n.
 * @author Sean A. Irvine
 */
public class A085587 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A085587() {
    super(1);
  }

  protected int mN = 0;

  protected Z step(final Z state) {
    final Z a = state.divide2().or(state.and(Z.ONE).shiftLeft(mN - 1));
    final Z b = state.clearBit(mN - 1).multiply2().add(state.testBit(mN - 1) ? 1 : 0);
    return a.xor(b);
  }

  private long getPeriod() {
    // Find a starting state somewhere on a cycle
    Z state = Z.ONE;
    Z kangaroo = step(state);
    while (!kangaroo.equals(state)) {
      state = step(state);
      kangaroo = step(step(kangaroo));
    }
    // Count the length of the cycle
    long period = 0;
    do {
      kangaroo = step(kangaroo);
      ++period;
    } while (!kangaroo.equals(state));
    return period;
  }

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(getPeriod());
  }

}
#!queue	A088020	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a088;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A088020 a(n) = (n^2)!.
 * @author Georg Fischer
 */
public class A088020 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;
  private int mN;

  /** Construct the sequence. */
  public A088020() {
    super(0);
    mN = -1;
  }

  @Override
  public Z next() {
    ++mN;
    return FACTORIAL.factorial(mN * mN);
  }
}
#!queue	A089210	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a089;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A089210 a(n) = n^(n^(n-1)).
 * @author Georg Fischer
 */
public class A089210 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A089210() {
    super(1);
  }

  private int mN = 0;

  @Override
  public Z next() {
    final Z n = Z.valueOf(++mN);
    return n.pow(n.pow(mN - 1));
  }
}
#!queue	A090000	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a090;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000040;

/**
 * A090000 Length of longest contiguous block of 1's in binary expansion of n-th prime.
 * @author jmason
 * @author Sean A. Irvine
 */
public class A090000 extends AbstractSequence {

  private final Sequence mSeq;
  private final int mBit;
  private int mN;

  /** Construct the sequence. */
  public A090000() {
    this(1, new A000040(), 1);
  }

  /**
   * Generic constructor with parameters
   * @param seq underlying sequence
   * @param bit contiguous block of these bits
   */
  public A090000(final Sequence seq, final int bit) {
    this(1, seq, bit);
  }

  /**
   * Generic constructor with parameters.
   * @param offset first index of target sequence
   * @param seq underlying sequence
   * @param bit contiguous block of these bits
   */
  public A090000(final int offset, final Sequence seq, final int bit) {
    super(offset);
    mSeq = seq;
    mBit = bit;
    mN = -1;
  }

  /* Calculate the maximum length of the longest contiguous block of 1's in binary expansion of n */
  protected static int maxBitLength(final Z p, final int bit) {
    int currMax = 0;
    int currLen = 0;
    for (int k = 0; k < p.bitLength(); ++k) {
      if ((p.testBit(k) ? 1 : 0) == bit) {
        if (++currLen > currMax) {
          currMax = currLen;
        }
      } else {
        currLen = 0;
      }
    }
    return currMax;
  }

  @Override
  public Z next() {
    ++mN;
    if (mN == 0 && mBit == 0) {
      mSeq.next();
      return Z.ONE;
    }
    return Z.valueOf(maxBitLength(mSeq.next(), mBit));
  }
}
#!queue	A091018	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a091;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A091018 Numbers in n-th upward diagonal of triangle T : 0; 1, 2; 3, 4, 5; 6, 7, 8, 9; ...
 * @author Sean A. Irvine
 */
public class A091018 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A091018() {
    super(0);
  }

  private long mN = -1;
  private long mM = 0;

  private Z t(final long n, final long m) {
    return Z.valueOf(n - m).square().add(n + m).divide2();
  }

  @Override
  public Z next() {
    if (++mM > mN / 2) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A091599	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a091;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A091599 Triangle read by rows: T(n,k) is the number of nonseparable planar maps with r*n edges and a fixed outer face of r*k edges which are invariant under a rotation of 1/r for any r &gt;= 2 (independent of actual value of r).
 * @author Sean A. Irvine
 */
public class A091599 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A091599() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  protected Z t(final int n, final int k) {
    if (k > n) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = k; j <= Math.min(n, 2 * k); ++j) {
      final Z t = mF.factorial(j - 1)
        .multiply(mF.factorial(3 * n - j - k - 1))
        .multiply(2L * j - k)
        .divide(mF.factorial(j - k).square())
        .divide(mF.factorial(2 * k - j))
        .divide(mF.factorial(n - j));
      sum = sum.add(t);
    }
    return sum.multiply(k).divide(mF.factorial(2 * n - k));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}
#!queue	A091665	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a091;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A091665 Triangle read by rows: T(n,k) is the number of nonseparable planar maps with 2*n+1 edges and a fixed outer face of 2*k edges which are invariant under a rotation of a 1/2 turn.
 * @author Sean A. Irvine
 */
public class A091665 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A091665() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  protected Z t(final int n, final int k) {
    if (k > n) {
      return Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = k; j <= Math.min(n, 2 * k - 1); ++j) {
      final Z t = mF.factorial(j - 1)
        .multiply(mF.factorial(3 * n - j - k))
        .multiply(2L * j - k + 1)
        .divide(mF.factorial(j - k))
        .divide(mF.factorial(j - k + 1))
        .divide(mF.factorial(2 * k - j - 1))
        .divide(mF.factorial(n - j));
      sum = sum.add(t);
    }
    return sum.multiply(k).divide(mF.factorial(2 * n - k + 1));
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}
#!queue	A091836	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a091;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A091836 A triangle of Motzkin ballot numbers.
 * @author Sean A. Irvine
 */
public class A091836 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A091836() {
    super(0);
  }

  private long mN = 0;
  private long mM = 0;

  protected Z t(final long n, final long m) {
    if (n == m) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    for (long k = 1; k <= n - m; ++k) {
      Z s = Z.ZERO;
      for (long j = 0; j <= n - m; ++j) {
        s = s.add(Binomial.binomial(j, m - n - k + 2 * j).multiply(Binomial.binomial(n - m, j)));
      }
      sum = sum.signedAdd(((n + k) & 1) == 0, s.multiply(k).multiply(Binomial.binomial(n + k - 1, n - 1)));
    }
    return sum.multiply(m).divide(n).divide(n - m).abs();
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}
#!queue	A094040	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a094;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A094040 Triangle read by rows: T(n,k) is the number of noncrossing forests with n vertices and k edges.
 * @author Sean A. Irvine
 */
public class A094040 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A094040() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  protected Z t(final long n, final long m) {
    return Binomial.binomial(n, m + 1).multiply(Binomial.binomial(n + 2 * m - 1, m)).divide(n + m);
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A098941	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a098;
// manually 2021-06-26

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A098941 Numbers where 2 is the only even decimal digit.
 * @author Georg Fischer
 */
public class A098941 extends AbstractSequence {

  protected int mN;
  protected String mPattern;
  protected int mBase;

  /** Construct the sequence. */
  public A098941() {
    this(1, 10, "[123579]*2[123579]*");
  }

  /**
   * Generic constructor with parameter
   * @param offset first index
   * @param base base of number system
   * @param pattern pattern to be matched
   */
  public A098941(final int offset, final int base, final String pattern) {
    super(offset);
    mN = -1; // always try to start with 0
    mBase = base;
    mPattern = pattern;
  }

  @Override
  public Z next() {
    while (true) {
      ++mN;
      if (Integer.toString(mN, mBase).matches(mPattern)) {
        return Z.valueOf(mN);
      }
    }
  }
}
#!queue	A099054	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a099;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.LongDynamicByteArray;

/**
 * A099054 Arshon's sequence: start from 1 and replace the letters in odd positions using 1 -&gt; 123, 2 -&gt; 231, 3 -&gt; 312 and the letters in even positions using 1 -&gt; 321, 2-&gt; 132, 3 -&gt; 213.
 * @author Sean A. Irvine
 */
public class A099054 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A099054() {
    super(0);
  }

  private final LongDynamicByteArray mA = new LongDynamicByteArray();

  {
    mA.set(1, (byte) 1);
    mA.set(2, (byte) 2);
    mA.set(3, (byte) 3);
  }

  private int mN = 0;
  private int mExpandPos = 1;

  @Override
  public Z next() {
    final long n = mA.length();
    if (++mN >= n) {
      ++mExpandPos;
      if ((mExpandPos & 1) == 0) {
        switch (mA.get(mExpandPos)) {
          case 1:
            mA.set(n, (byte) 3);
            mA.set(n + 1, (byte) 2);
            mA.set(n + 2, (byte) 1);
            break;
          case 2:
            mA.set(n, (byte) 1);
            mA.set(n + 1, (byte) 3);
            mA.set(n + 2, (byte) 2);
            break;
          default:
            mA.set(n, (byte) 2);
            mA.set(n + 1, (byte) 1);
            mA.set(n + 2, (byte) 3);
            break;
        }
      } else {
        switch (mA.get(mExpandPos)) {
          case 1:
            mA.set(n, (byte) 1);
            mA.set(n + 1, (byte) 2);
            mA.set(n + 2, (byte) 3);
            break;
          case 2:
            mA.set(n, (byte) 2);
            mA.set(n + 1, (byte) 3);
            mA.set(n + 2, (byte) 1);
            break;
          default:
            mA.set(n, (byte) 3);
            mA.set(n + 1, (byte) 1);
            mA.set(n + 2, (byte) 2);
            break;
        }
      }
    }
    return Z.valueOf(mA.get(mN));
  }
}
#!queue	A104320	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a104;
// Generated by gen_seq4.pl num1dig at 2021-04-28 10:09

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;

/**
 * A104320 Number of zeros in ternary representation of 2^n.
 * @author Georg Fischer
 */
public class A104320 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A104320() {
    super(0);
  }

  protected int mN = -1;

  @Override
  public Z next() {
    ++mN;
    return Z.valueOf(ZUtils.digitCounts(Z.ONE.shiftLeft(mN), 3)[0]);
  }
}
#!queue	A105471	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a105;
// manually 2021-08-15

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A105471 a(n) = Fibonacci(n) mod 100.
 * @author Georg Fischer
 */
public class A105471 extends AbstractSequence {

  protected Z mA_1;
  protected Z mA_2;
  protected int mN;
  protected Z mParm;

  /** Construct the sequence. */
  public A105471() {
    this(0, 100);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param parm take fib(n) mod parm
   */
  public A105471(final int offset, final int parm) {
    super(offset);
    mParm = Z.valueOf(parm);
    mA_1 = Z.ONE;
    mA_2 = Z.ZERO;
    mN = -1;
  }

  @Override
  public Z next() {
    ++mN;
    if (mN == 0) {
      return mA_2;
    } else if (mN == 1) {
      return mA_1;
    } else {
      final Z result = mA_2.add(mA_1).mod(mParm);
      mA_2 = mA_1;
      mA_1 = result;
      return result;
    }
  }
}
#!queue	A111999	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a111;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A111999 T(n, k) = [x^k] (-1)^n*Sum_{k=0..n} E2(n, n-k)*(1+x)^(n-k) where E2(n, k) are the second-order Eulerian numbers. Triangle read by rows, T(n, k) for n &gt;= 1 and 0 &lt;= k &lt;= n.
 * @author Sean A. Irvine
 */
public class A111999 extends MemoryFunction2Sequence<Long, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A111999() {
    super(1);
  }

  private long mN = 0;
  private long mM = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    if (n < k + 1) {
      return Z.ZERO;
    }
    if (n == 1 && k == 0) {
      return Z.NEG_ONE;
    }
    if (k == -1) {
      return Z.ZERO;
    }
    return get(n - 1, k).add(get(n - 1, k - 1)).multiply(k + 1 - 2 * n);
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, mM);
  }
}
#!queue	A115004	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a115;

import irvine.math.LongUtils;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A115004 a(n) = Sum_{i=1..n, j=1..n, gcd(i,j)=1} (n+1-i)*(n+1-j).
 * @author Georg Fischer
 */
public class A115004 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A115004() {
    super(1);
  }

  private int mN = 0;

  @Override
  public Z next() {
    ++mN;
    Z sum = Z.ZERO;
    for (int i = 1; i <= mN; ++i) {
      for (int j = 1; j <= mN; ++j) {
        if (LongUtils.gcd(i, j) == 1) {
          sum = sum.add((mN + 1 - i) * (mN + 1 - j));
        }
      }
    }
    return sum;
  }
}
#!queue	A121357	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a121;

import java.util.Arrays;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A121357 Number of different, not necessarily connected, labeled trivalent diagrams of size n.
 * @author Sean A. Irvine
 */
public class A121357 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A121357() {
    super(0);
  }

  protected static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final Polynomial<Q> C2 = RING.create(Arrays.asList(Q.ZERO, Q.ONE, Q.HALF));
  private static final Polynomial<Q> C3 = RING.create(Arrays.asList(Q.ZERO, Q.ONE, Q.ZERO, Q.ONE_THIRD));
  protected int mN = -1;
  protected Z mF = Z.ONE;

  protected Q nextQ() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    final Polynomial<Q> exs2 = RING.exp(C2, mN);
    final Polynomial<Q> exs3 = RING.exp(C3, mN);
    return exs2.coeff(mN).multiply(exs3.coeff(mN)).multiply(mF);
  }

  @Override
  public Z next() {
    return nextQ().multiply(mF).toZ();
  }
}
#!queue	A122693	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a122;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A122693 Bishops on an n X n board (see Robinson paper for details).
 * @author Sean A. Irvine
 */
public class A122693 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A122693() {
    super(0);
  }

  private Z mF = Z.ONE;
  private int mN = -1;

  @Override
  public Z next() {
    ++mN;
    if ((mN & 1) == 0) {
      return Z.valueOf(mN).multiply(mF).shiftLeft(mN - 1);
    } else {
      final int u = (mN + 1) / 2;
      mF = mF.multiply(u).multiply(u);
      return mF.shiftLeft(mN);
    }
  }
}
#!queue	A122749	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a122;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A122749 Number of arrangements of n non-attacking bishops on an n X n board such that every square of the board is controlled by at least one bishop.
 * @author Sean A. Irvine
 */
public class A122749 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A122749() {
    super(2);
  }

  private Z mF = Z.ONE;
  private long mN = 1;

  @Override
  public Z next() {
    ++mN;
    final long k = mN / 2;
    if ((mN & 1) == 0) {
      if ((k & 1) == 0) {
        if (k > 1) {
          mF = mF.multiply(k).multiply(k - 1);
        }
        return mF.multiply(k + 2).divide2().square();
      } else {
        return mF.multiply(k + 1).multiply(k + 1).divide2().square();
      }
    } else {
      if ((k & 1) == 0) {
        return mF.square().multiply(Z.THREE.multiply(k).add(16).multiply(k).add(18).multiply(k).add(8)).divide(12);
      } else {
        return mF.square().multiply(k).multiply(k + 1).multiply(Z.THREE.multiply(k).add(13).multiply(k).subtract(1).multiply(k).subtract(3)).divide(12);
      }
    }
  }
}
#!queue	A123301	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a123;

import java.util.ArrayList;
import java.util.List;

import irvine.math.IntegerUtils;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A123301 Triangle read by rows: T(n,k) is the number of specially labeled bicolored nonseparable graphs with k points in one color class and n-k points in the other class. "Special" means there are separate labels 1,2,...,k and 1,2,...,n-k for the two color classes (n &gt;= 2, k = 1,...,n-1).
 * @author Sean A. Irvine
 */
public class A123301 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A123301() {
    super(2);
  }

  // After Andrew Howroyd

  private static final PolynomialRingField<Q> RING_Y = new PolynomialRingField<>("y", Rationals.SINGLETON);
  private static final PolynomialRingField<Polynomial<Q>> RING_X = new PolynomialRingField<>(RING_Y);

  private int mN = 0;
  private int mM = 0;

  private Polynomial<Polynomial<Q>> g(final int n) {
    final Polynomial<Polynomial<Q>> res = RING_X.empty();
    Z fi = Z.ONE;
    for (int i = 0; i <= n; fi = fi.multiply(++i)) {
      final Polynomial<Q> qp = RING_Y.empty();
      Z fj = Z.ONE;
      for (int j = 0; j <= n; fj = fj.multiply(++j)) {
        qp.add(new Q(Z.ONE.shiftLeft(i * j), fi.multiply(fj)));
      }
      res.add(qp);
    }
    return res;
  }

  private Polynomial<Polynomial<Q>> diffInner(final Polynomial<Polynomial<Q>> p) {
    final Polynomial<Polynomial<Q>> diff = RING_X.empty();
    for (final Polynomial<Q> t : p) {
      diff.add(RING_Y.diff(t));
    }
    return diff;
  }

  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  // This version of reversion supports non-unit [x^1] coefficient
  // See https://mathworld.wolfram.com/SeriesReversion.html Morse and Feshbach formula
  private Polynomial<Polynomial<Q>> reversion(final PolynomialRingField<Polynomial<Q>> ring, final Polynomial<Polynomial<Q>> a, final int degree) {
    final Polynomial<Q> c1 = a.coeff(1);
    final Polynomial<Q> inverseC1 = RING_Y.series(RING_Y.one(), c1, degree);
    final Polynomial<Polynomial<Q>> w = ring.empty();
    w.add(RING_Y.zero());
    w.add(inverseC1);
    final List<Polynomial<Q>> aa = new ArrayList<>();
    for (int k = 2; k <= degree; ++k) {
      aa.add(RING_Y.multiply(a.get(k), inverseC1, degree));
    }
    Polynomial<Q> invk = inverseC1;
    for (int k = 2; k <= degree; ++k) {
      invk = RING_Y.multiply(invk, inverseC1, degree);
      final IntegerPartition part = new IntegerPartition(k - 1);
      final int[] j = new int[k];
      int[] p;
      Polynomial<Q> term = RING_Y.zero();
      while ((p = part.next()) != null) {
        IntegerPartition.toCountForm(p, j);
        final int sum = (int) IntegerUtils.sum(j);
        Polynomial<Q> prod = RING_Y.one();
        for (int i = 1; i < j.length; ++i) {
          if (j[i] > 0) {
            prod = RING_Y.divide(RING_Y.multiply(prod, RING_Y.pow(aa.get(i - 1), j[i], degree), degree), new Q(mF.factorial(j[i])));
          }
        }
        Z pr = Z.ONE;
        for (int u = k; u < k + sum; ++u) {
          pr = pr.multiply(u);
        }
        prod = RING_Y.multiply(prod, new Q(pr));
        term = RING_Y.signedAdd((sum & 1) == 0, term, prod);
      }
      w.add(RING_Y.divide(RING_Y.multiply(term, invk, degree), new Q(k)));
    }
    return w;
  }

  private Polynomial<Polynomial<Q>> swapVariables(final Polynomial<Polynomial<Q>> p) {
    // x <--> y
    final int n = p.degree();
    final Polynomial<Polynomial<Q>> res = RING_X.empty();
    for (int k = 0; k <= n; ++k) {
      final Q[] coeff = new Q[n + 1];
      for (int j = 0; j <= n; ++j) {
        coeff[j] = p.coeff(j).coeff(k);
      }
      res.add(Polynomial.create(coeff));
    }
    return res;
  }

  private Polynomial<Polynomial<Q>> log(final PolynomialRingField<Polynomial<Q>> ring, final Polynomial<Polynomial<Q>> g, final int n) {
    //final Polynomial<Polynomial<Q>> p = ring.log(g, n); // This gets it wrong!, so ...
    final Polynomial<Q> g0 = g.coeff(0);
    final Polynomial<Q> g1 = RING_Y.series(RING_Y.one(), g0, n);
    return ring.add(ring.log(ring.multiply(g, g1), n), ring.monomial(RING_Y.log(g0, n), 0));
  }

  private Polynomial<Polynomial<Q>> b(final int n) {
    final PolynomialRingField<Polynomial<Q>> ring = new PolynomialRingField<>(new DegreeLimitedPolynomialRingField<>("y", Rationals.SINGLETON, n));
    final Polynomial<Polynomial<Q>> g = g(n);
    final Polynomial<Polynomial<Q>> p = log(ring, g, n);
    final Polynomial<Polynomial<Q>> pdy = diffInner(p);
    final Polynomial<Polynomial<Q>> xpdx = ring.diff(p).shift(1);
    final Polynomial<Polynomial<Q>> spdx = reversion(ring, xpdx, n);
    final Polynomial<Polynomial<Q>> swap = swapVariables(ring.substitute(pdy, spdx, n));
    final Polynomial<Polynomial<Q>> log = log(ring, ring.series(ring.x(), reversion(ring, swap.shift(1), n), n), n);
    return ring.integrate(log);
  }

  private Polynomial<Polynomial<Q>> mB = b(3);

  protected Z get(final int n, final int m) {
    if (mB.degree() <= n) {
      mB = b(n);
    }
    return mB.coeff(n).coeff(m).multiply(mF.factorial(n)).multiply(mF.factorial(m)).toZ();

  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return get(mN - mM + 1, mM);
  }
}
#!queue	A125790	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a125;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A125790 Rectangular table where column k equals row sums of matrix power A078121^k, read by antidiagonals.
 * @author Sean A. Irvine
 */
public class A125790 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private long mN = -1;
  private long mK = 0;

  @Override
  protected Z compute(final Long n, final Long k) {
    return n == 0 || k == 0 ? Z.ONE : get(n, k - 1).add(get(n - 1, 2 * k));
  }

  @Override
  public Z next() {
    if (mK > mN) {
      ++mN;
      mK = 0;
    }
    return get(mN - mK, mK++);
  }

}

#!queue	A126067	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a126;

import irvine.math.IntegerUtils;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.CycleIndex;
import irvine.math.polynomial.MultivariateMonomial;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a002.A002499;

/**
 * A126067 Triangle read by rows: T(n,k) is the number of unlabeled self-converse digraphs with n nodes and k arcs, k=0..n*(n-1).
 * @author Sean A. Irvine
 */
public class A126067 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A126067() {
    super(0);
  }

  // Compare with A002499.

  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;

  private int mN = -1;
  private int mM = 0;
  private Polynomial<Q> mPoly = RING.zero();

  private static boolean eta(final int k) {
    return (k & 3) == 2;
  }

  // See page 152 of "Graphical Enumeration". Note, however, the formula
  // in the book for I(alpha) should say "1<=r<t<=p".

  private static MultivariateMonomial i(final int p, final int[] j, final Z mult) {
    final MultivariateMonomial powers = new MultivariateMonomial();
    for (int k = 1; k <= p; ++k) {
      if (j[k] != 0) { // efficiency only
        final int lcm = IntegerUtils.lcm(2, k);
        final int gcd = IntegerUtils.gcd(2, k);
        powers.add(lcm, gcd * k * (j[k] * j[k] - j[k]) / 2);
      }
    }
    for (int r = 1; r <= p; ++r) {
      for (int t = r + 1; t <= p; ++t) {
        final int k = IntegerUtils.lcm(r, t);
        final int gcd = IntegerUtils.gcd(r, t);
        powers.add(IntegerUtils.lcm(2, k), IntegerUtils.gcd(2, k) * gcd * j[r] * j[t]);
      }
    }
    for (int k = 1; k <= p; k += 2) {
      powers.add(2 * k, ((k - 1) / 2) * j[k]);
    }
    for (int k = 2; k <= p; k += 2) {
      powers.add(k, (k - 2) * j[k]);
      if (eta(k)) {
        powers.add(k / 2, 2 * j[k]);
      } else {
        powers.add(k, j[k]);
      }
    }
    powers.setCoefficient(mult);
    //System.out.println(Arrays.toString(j) + " --> " + Arrays.toString(powers));
    return powers;
  }

  protected static CycleIndex i(final int n) {
    final IntegerPartition partition = new IntegerPartition(n);
    final int[] j = new int[n + 1];
    int[] p;
    final CycleIndex ci = new CycleIndex("F(S_{" + n + "}^{S_2^*}");
    while ((p = partition.next()) != null) {
      IntegerPartition.toCountForm(p, j);
      //System.out.println(Arrays.toString(j));
      ci.add(i(n, j, A002499.h(j)));
    }
    ci.multiply(new Q(Z.ONE, FACTORIAL.factorial(n)));
    return ci;
  }

  @Override
  public Z next() {
    if (++mM > mPoly.degree()) {
      mM = 0;
      if (++mN == 0) {
        return Z.ONE;
      }
      final CycleIndex ci = i(mN);
      mPoly = ci.applyOnePlusXToTheN();
      // Note mPoly.eval(1) is A002499(n)
    }
    return mPoly.coeff(mM).toZ();
  }
}
#!queue	A127223	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a127;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A127223 a(n) = (n^2)!/n!.
 * @author Georg Fischer
 */
public class A127223 extends AbstractSequence {

  private int mExpon;
  private int mN;
  private static final MemoryFactorial FACTORIAL = MemoryFactorial.SINGLETON;

  /** Construct the sequence. */
  public A127223() {
    this(0, 2);
  }

  /**
   * Generic constructor with parameters
   * @param expon
   */
  public A127223(final int offset, final int expon) {
    super(offset);
    mExpon = expon;
    mN = offset - 1;
  }

  @Override
  public Z next() {
    ++mN;
    int nPow = mN;
    for (int i = 2; i <= mExpon; ++i) {
      nPow *= mN;
    }
    return FACTORIAL.factorial(nPow).divide(FACTORIAL.factorial(mN));
  }
}
#!queue	A131541	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a131;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.array.DynamicByteArray;

/**
 * A131541 Least power of 2 having exactly n consecutive 7's in its decimal representation.
 * @author Sean A. Irvine
 */
public class A131541 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A131541() {
    super(1);
  }

  private long mN = start();
  private DynamicByteArray mBuf = null;

  protected int getSpecialDigit() {
    return 7;
  }

  protected long start() {
    return 0;
  }

  private void mul2() {
    // Base 10 multiply by 2 in mBuf, in place, lsb in byte 0
    int carry = 0;
    for (int k = 0; k < mBuf.length(); ++k) {
      int sum = 2 * mBuf.get(k) + carry;
      if (sum >= 10) {
        carry = 1;
        sum -= 10;
      } else {
        carry = 0;
      }
      mBuf.set(k, (byte) sum);
    }
    if (carry != 0) {
      mBuf.set(mBuf.length(), (byte) 1);
    }
  }

  private boolean bingo() {
    final int d = getSpecialDigit();
    int c = 0;
    for (int k = 0; k < mBuf.length(); ++k) {
      if (mBuf.get(k) == d) {
        ++c;
      } else if (c == mN) {
        return true;
      } else {
        c = 0;
      }
    }
    return c == mN;
  }

  @Override
  public Z next() {
    ++mN;
    int v = 0;
    mBuf = new DynamicByteArray();
    mBuf.set(0, (byte) 1);
    while (!bingo()) {
      mul2();
      ++v;
    }
    return Z.valueOf(v);
  }
}

#!queue	A137251	1	->	1	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a137;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A137251 Triangle T(n,k) read by rows: number of k X k triangular matrices with nonnegative integer entries and without zero rows or columns such that sum of all entries is equal to n, n&gt;=1, 1&lt;=k&lt;=n.
 * @author Sean A. Irvine
 */
public class A137251 extends MemoryFunctionInt3Sequence<Z[]> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A137251() {
    super(1);
  }

  // After Alois P. Heinz

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z[] compute(final int n, final int i, final int t) {
    if (n < 1) {
      final Z[] res = new Z[t + 1];
      Arrays.fill(res, Z.ZERO);
      res[t] = Z.ONE;
      return res;
    }
    List<Z> res = Collections.emptyList();
    for (int j = 0; j <= t + 1; ++j) {
      final Z[] row = get(n - 1, j, t + (j > i ? 1 : 0));
      final int lim = Math.max(res.size(), row.length);
      final List<Z> r = new ArrayList<>(lim);
      for (int k = 0; k < lim; ++k) {
        final Z x = k < res.size() ? res.get(k) : Z.ZERO;
        final Z y = k < row.length ? row[k] : Z.ZERO;
        r.add(x.add(y));
      }
      res = r;
    }
    return res.toArray(new Z[0]);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return get(mN, 0, 0)[mM];
  }
}
#!queue	A143491	2	->	2	Triangle	--------------------------------
package irvine.oeis.a143;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A143491 Unsigned 2-Stirling numbers of the first kind.
 * @author Georg Fischer
 */
public class A143491 extends Triangle {

  private int mStir;

  /** Construct the sequence. */
  public A143491() {
    this(2);
  }

  /**
   * Generic constructor with parameter.
   * @param stir unsigned <code>stir</code>-stirling numbers
   */
  public A143491(final int stir) {
    super(stir);
    hasRAM(false);
    mStir = stir;
  }

  @Override
  protected Z compute(int n, int k) {
    n += mStir;
    k += mStir;
    return n == mStir ? Z.ONE : get(n - 1 - mStir, k - 1 - mStir).add(get(n - 1 - mStir, k - mStir).multiply(n - 1));
  }
}

#!queue	A143494	2	->	2	Triangle	--------------------------------
package irvine.oeis.a143;
// manually trecpas/trecpas1

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A143494 Triangle read by rows: 2-Stirling numbers of the second kind.
 * @author Georg Fischer
 */
public class A143494 extends Triangle {

  private int mStir;

  /** Construct the sequence. */
  public A143494() {
    this(2);
  }

  /**
   * Generic constructor with parameter.
   * @param stir unsigned <code>stir</code>-stirling numbers
   */
  public A143494(final int stir) {
    super(stir);
    hasRAM(false);
    mStir = stir;
  }

  @Override
  protected Z compute(int n, int k) {
    n += mStir;
    k += mStir;
    return n == mStir ? Z.ONE : get(n - 1 - mStir, k - 1 - mStir).add(get(n - 1 - mStir, k - mStir).multiply(k));
  }
}
#!queue	A143497	2	->	2	Triangle	--------------------------------
package irvine.oeis.a143;

import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A143497 Triangle of unsigned 2-Lah numbers.
 * Recurrence: <code>T(n,k) = (n+k-1)*T(n-1,k) + T(n-1,k-1) for n,k &gt;= 2</code>.
 * @author Georg Fischer
 */
public class A143497 extends Triangle {

  protected int mLah2;

  /** Construct the sequence. */
  public A143497() {
    this(2);
  }

  /**
   * Generic constructor with parameter
   * @param lah Lah number
   */
  public A143497(final int lah) {
    super(lah);
    hasRAM(false);
    mLah2 = 2 * lah - 1;
  }

  @Override
  public Z compute(final int n, final int k) {
    return n == 0 ? Z.ONE : get(n - 1, k).multiply(n + k + mLah2).add(get(n - 1, k - 1));
  }
}
#!queue	A144164	0	->	0	RowSumSequence	--------------------------------
package irvine.oeis.a144;

import irvine.math.z.Z;
import irvine.oeis.a215.A215861;
import irvine.oeis.triangle.RowSumSequence;

/**
 * A144164 Number of simple graphs on n labeled nodes, where each maximally connected subgraph is either a tree or a cycle, also row sums of A144163, A215861.
 * @author Georg Fischer
 */
public class A144164 extends RowSumSequence {

  /** Construct the sequence. */
  public A144164() {
    super(0, new A215861());
  }
}

#!queue	A145768	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a145;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A145768 a(n) = the bitwise XOR of squares of first n natural numbers.
 * @author Sean A. Irvine
 */
public class A145768 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A145768() {
    super(0);
  }

  protected long mN = -1;
  private Z mXor = Z.ZERO;

  @Override
  public Z next() {
    ++mN;
    mXor = mXor.xor(Z.valueOf(mN).square());
    return mXor;
  }

}

#!queue	A152176	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a152;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a304.A304972;

/**
 * A152176 Triangle read by rows: T(n,k) is the number of k-block partitions of an n-set up to rotations and reflections.
 * @author Sean A. Irvine
 */
public class A152176 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A152176() {
    super(1);
  }

  private final A304972 mA = new A304972();
  private final A152175 mB = new A152175();
  private int mN = 0;
  private int mM = 0;

  protected Z t(final int n, final int k) {
    return mA.get(n, k).add(mB.t(n, k)).divide2();
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return t(mN, mM);
  }
}
#!queue	A153000	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a153;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A153000 Toothpick sequence in the first quadrant.
 * @author Sean A. Irvine
 */
public class A153000 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A153000() {
    super(0);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final Polynomial<Z> C1 = Polynomial.create(1, 1);
  private static final Polynomial<Z> DEN = Polynomial.create(1, 1, -2);
  private int mN = -1;
  private int mK = 2;
  private int mLim = 1;
  private Polynomial<Z> mInnerProduct = Polynomial.create(1, 1, 2, 1, 3, 4, 4);
  private Polynomial<Z> mG = Polynomial.create(0, 1, 2);

  @Override
  public Z next() {
    if (++mN > mLim) {
      ++mK;
      mLim *= 2;
      final Polynomial<Z> t = RING.add(RING.onePlusXToTheN((1 << mK) - 1), RING.monomial(Z.TWO, 1 << mK));
      mInnerProduct = RING.multiply(mInnerProduct, t);
      mG = RING.series(RING.multiply(RING.subtract(mInnerProduct, RING.one()), C1), DEN, mLim);

    }
    return mG.coeff(mN);
  }
}

#!queue	A160449	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a160;

import irvine.math.group.SymmetricGroup;
import irvine.math.partitions.IntegerPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A160449 Array read by antidiagonals: T(n,k) is the number of isomorphism classes of n-fold coverings of a connected graph with Betti number k (1 &lt;= n, 0 &lt;= k).
 * @author Sean A. Irvine
 */
public class A160449 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A160449() {
    super(0);
  }

  private int mN = 0;
  private int mM = 0;

  protected Z t(final int n, final int k) {
    if (n == 1 || k == 0) {
      return Z.ONE;
    }
    Z sum = Z.ZERO;
    final IntegerPartition part = new IntegerPartition(n);
    int[] p;
    final int[] c = new int[n + 1];
    while ((p = part.next()) != null) {
      IntegerPartition.toCountForm(p, c);
      sum = sum.add(SymmetricGroup.per(c).pow(k - 1));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return t(mN - mM, mM);
  }
}
#!queue	A160792	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a160;

import irvine.factor.prime.Fast;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A160792 Vertex number of a rectangular spiral related to prime numbers. The distances between nearest edges of the spiral that are parallel to the initial edge are the prime numbers, while the distances between nearest edges perpendicular to the initial edge are all one.
 * @author Sean A. Irvine
 */
public class A160792 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A160792() {
    super(0);
  }

  private final Fast mPrime = new Fast();
  private Z mPrimeSum = Z.ZERO;
  private Z mPrimeValue = Z.ONE;
  private Z mPrev = Z.ZERO;
  private long mN = -1;

  @Override
  public Z next() {
    final Z s;
    if ((++mN & 1) == 0) {
      if (mN > 0) {
        mPrimeValue = mPrime.nextPrime(mPrimeValue);
        mPrimeSum = mPrimeSum.add(mPrimeValue);
      }
      s = mPrev.add(mPrimeSum);
    } else {
      s = mPrev.add(mN / 2 + 1);
    }
    mPrev = s;
    return s;
  }
}

#!queue	A166470	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a166;
// Generated by gen_seq4.pl deriv at 2021-06-28 18:44

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000301;
import irvine.oeis.a010.A010098;

/**
 * A166470 a(n) = 2^F(n+1)*3^F(n), where F(n) is the n-th Fibonacci number, A000045(n).
 * @author Georg Fischer
 */
public class A166470 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  final Sequence mA000301 = new A000301();
  final Sequence mA010098 = new A010098();

  /** Construct the sequence. */
  public A166470() {
    super(0);
    mA000301.next();
  }

  @Override
  public Z next() {
    return mA000301.next().multiply(mA010098.next());
  }

}

#!queue	A169964	0	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a169;
// manually 2021-06-24

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.a007.A007088;

/**
 * A169964 Numbers whose decimal expansion contains only 0's and 5's.
 * @author Georg Fischer
 */
public class A169964 extends AbstractSequence {

  protected Z mDigit;
  private final A007088 mSeq = new A007088();

  /** Construct the sequence. */
  public A169964() {
    this(1, 5);
  }

  /**
   * Generic constructor with parameter
   * @param offset offset of the sequence
   * @param digit digit to multiply on A007088
   */
  public A169964(final int offset, final int digit) {
    super(offset);
    mDigit = Z.valueOf(digit);
  }

  @Override
  public Z next() {
    return mSeq.next().multiply(mDigit);
  }
}

#!queue	A170896	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a170;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Pair;

/**
 * A170896 Number of ON cells after n generations of the Schrandt-Ulam cellular automaton on the square grid that is described in the Comments.
 * @author Sean A. Irvine
 */
public class A170896 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A170896() {
    super(0);
  }

  private static final int[] DELTA = {1, -1, 0, 0};

  private Set<Pair<Integer, Integer>> mOn = null;
  protected Set<Pair<Integer, Integer>> mNewlyOn = new HashSet<>();
  //private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  //private int mStep = -1;

  protected boolean accept(final Pair<Integer, Integer> pt) {
    return true;
  }

  protected void reset() {
    mOn = null;
    mNewlyOn.clear();
  }

  @Override
  public Z next() {
    if (mOn == null) {
      mOn = new HashSet<>();
    } else {
      final HashMap<Pair<Integer, Integer>, Set<Pair<Integer, Integer>>> next = new HashMap<>();
      final HashSet<Pair<Integer, Integer>> outers = new HashSet<>();
      if (mOn.isEmpty()) {
        next.put(new Pair<>(0, 0), Collections.emptySet());
      } else {
        for (final Pair<Integer, Integer> pt : mNewlyOn) {
          final int x = pt.left();
          final int y = pt.right();
          for (int k = 0; k < DELTA.length; ++k) {
            final int nx = x + DELTA[k];
            final int ny = y + DELTA[DELTA.length - 1 - k];
            int c = 0;
            for (int j = 0; j < DELTA.length; ++j) {
              final int sx = nx + DELTA[j];
              final int sy = ny + DELTA[DELTA.length - 1 - j];
              if (mOn.contains(new Pair<>(sx, sy)) && ++c > 1) {
                break;
              }
            }
            assert c > 0;
            final Pair<Integer, Integer> n = new Pair<>(nx, ny);
            if (c == 1) {
              final int dx = nx - x;
              final int dy = ny - y;
              final int tx = nx + dx;
              final int ty = ny + dy;
              final HashSet<Pair<Integer, Integer>> o = new HashSet<>();
              o.add(new Pair<>(tx + dy, ty + dx));
              o.add(new Pair<>(tx - dy, ty + dx));
              o.add(new Pair<>(tx + dy, ty - dx));
              o.add(new Pair<>(tx - dy, ty - dx));
              assert o.size() == 2;
              boolean ok = true;
              for (final Pair<Integer, Integer> v : o) {
                if (mOn.contains(v)) {
                  ok = false;
                  break;
                }
              }
              if (ok) {
                outers.addAll(o);
                next.put(n, o);
              }
            }
          }
        }
      }
      mNewlyOn.clear();
      for (final Map.Entry<Pair<Integer, Integer>, Set<Pair<Integer, Integer>>> e : next.entrySet()) {
        final Pair<Integer, Integer> pt = e.getKey();
        if (!outers.contains(pt) && accept(pt)) {
          mNewlyOn.add(pt);
        }
      }
      mOn.addAll(mNewlyOn);
    }
//    if (mVerbose && ++mStep == 145) {
//      System.out.println(mNewlyOn.size() + " " + mNewlyOn);
//      try (final PrintStream out = new PrintStream(new FileOutputStream("A170896." + mStep + ".ppm"))) {
//        final int dim = mStep * 2;
//        out.println("P6 " + dim + " " + dim + " 1");
//        for (int y = 0; y < dim; ++y) {
//          for (int x = 0; x < dim; ++x) {
//            final Pair<Integer, Integer> point = new Pair<>(x - mStep, y - mStep);
//            if (mNewlyOn.contains(point)) {
//              out.print("\0\0\1");
//            } else if (mOn.contains(point)) {
//              out.print("\0\0\0");
//            } else {
//              out.print("\1\1\1");
//            }
//          }
//        }
//      } catch (final IOException e) {
//        throw new RuntimeException(e);
//      }
//    }
    return Z.valueOf(mOn.size());
  }
}
#!queue	A173380	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a173;

import irvine.math.lattice.Lattices;
import irvine.math.lattice.NonadjacentWalker;
import irvine.math.lattice.ParallelWalker;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A173380 Number of n-step walks on square lattice (no points repeated, no adjacent points unless consecutive in path).
 * @author Sean A. Irvine
 */
public class A173380 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A173380() {
    super(0);
  }

  private final ParallelWalker mWalker = new ParallelWalker(8, () -> new NonadjacentWalker(Lattices.Z2));
  private final long mX1 = Lattices.Z2.toPoint(1, 0);
  private int mN = -1;

  @Override
  public Z next() {
    return ++mN == 0 ? Z.ONE : Z.valueOf(mWalker.count(mN, 4, 1, Lattices.Z2.origin(), mX1));
  }
}
#!queue	A176772	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a176;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A176772 Smallest power of 13 whose decimal expansion contains n.
 * @author Sean A. Irvine
 */
public class A176772 extends AbstractSequence {

  private int mN;

  protected A176772(final int offset) {
    super(offset);
    mN = offset - 1;
  }

  /** Default constructor. */
  public A176772() {
    this(0);
  }

  protected Z base() {
    return Z.valueOf(13);
  }

  @Override
  public Z next() {
    final String v = String.valueOf(++mN);
    Z b = Z.ONE;
    while (true) {
      if (b.toString().contains(v)) {
        return b;
      }
      b = b.multiply(base());
    }
  }
}

#!queue	A178666	-1	->	-1	AbstractSequence	--------------------------------
package irvine.oeis.a178;

import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A178666 Irregular triangle read by rows in which row n gives expansion of the polynomial Product_{k=0..n} (1 + x^(2*k + 1)), n &gt;= -1.
 * @author Sean A. Irvine
 */
public class A178666 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A178666() {
    super(-1);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  protected Polynomial<Z> a178666(final int n) {
    Polynomial<Z> prod = RING.one();
    for (int k = 0; k <= n; ++k) {
      prod = RING.multiply(prod, RING.onePlusXToTheN(2 * k + 1));
    }
    return prod;
  }

  private int mN = -2;
  private int mM = 0;
  private Polynomial<Z> mRow = RING.zero();

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      mRow = a178666(++mN);
      mM = 0;
    }
    return mRow.coeff(mM);
  }
}
#!queue	A194543	0	->	0	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a194;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A194543 Triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows: T(n,k) is the number of partitions of n into parts p_i such that |p_i - p_j| &gt;= k for i != j.
 * @author Sean A. Irvine
 */
public class A194543 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // After Alois P. Heinz

  private int mN = -1;
  private int mM = 0;

  @Override
  protected Z compute(final int n, final int i, final int k) {
    if (n <= 0) {
      return n == 0 ? Z.ONE : Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int j = k; j <= n - i; ++j) {
      sum = sum.add(get(n - i - j, i + j, k));
    }
    return sum;
  }

  protected Z t(final int n, final int k) {
    Z sum = n == 0 ? Z.ONE : Z.ZERO;
    for (int i = 1; i <= n; ++i) {
      sum = sum.add(get(n - i, i, k));
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 0;
    }
    return t(mN, mM);
  }
}
#!queue	A198300	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a198;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A198300 Square array M(k,g), read by antidiagonals, of the Moore lower bound on the order of a (k,g)-cage.
 * @author Sean A. Irvine
 */
public class A198300 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A198300() {
    super(1);
  }

  protected int mN = 0;
  protected int mM = 0;

  @Override
  protected Z compute(final Integer n, final Integer m) {
    if (m == 3) {
      return Z.valueOf(n + 1);
    }
    return get(n, m - 1).add(Z.valueOf(n - 1).pow((m - 1) / 2));
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return get(mN + 1 - mM, mM + 3);
  }
}
#!queue	A203991	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a203;
// manually 2021-10-24

import irvine.math.api.Matrix;
import irvine.math.group.IntegerField;
import irvine.math.group.MatrixRing;
import irvine.math.matrix.DefaultMatrix;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;
import irvine.oeis.Sequence;
import irvine.oeis.triangle.UpperLeftTriangle;

/**
 * A203991 Array:  row n shows the coefficients of the characteristic polynomial of the n-th principal submatrix of {(i+j)*min(i,j)} (A203990).
 * @author Georg Fischer
 */
public class A203991 extends AbstractSequence {

  protected UpperLeftTriangle mULT;
  protected int mRow; // current row index n
  protected int mCol; // current column index k
  protected Z[] mLastRow; // = get(mRow)

  /** Construct the sequence. */
  public A203991() {
    this(1, new A203990());
  }

  /**
   * Generic constructor with parameter
   * @param seq underlying sequence.
   * @param offset number of first row: 0 or 1.
   */
  public A203991(final int offset, final Sequence seq) {
    super(offset);
    if (seq instanceof UpperLeftTriangle) {
      mULT = (UpperLeftTriangle) seq;
    } else {
      final MemorySequence mSeq = MemorySequence.cachedSequence(seq);
      mULT = new UpperLeftTriangle(1, 1, -1) {
          @Override
          public Z matrixElement(final int i, final int j) {
            return mSeq.a((i - mRow0) * (i - mRow0 + 1) / 2 + j - mCol0);
          }
        };
    }
    mRow = offset - 1;
    mCol = mRow;
  }

  protected void addRow() {
    ++mRow;
    mLastRow = new Z[mRow + 1];
    mCol = 0;
    final int n = mRow;
    // Construct a symmetric n-diagonal matrix
    final Matrix<Z> mat = new DefaultMatrix<>(n, n, Z.ZERO);
    for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j) {
        mat.set(i, j, mULT.matrixElement(i + 1, j + 1));
      }
    }
    // Compute the characteristic polynomial of the matrix
    final Polynomial<Z> charPoly = new MatrixRing<>(n, IntegerField.SINGLETON).characteristicPolynomial(mat);
    // System.out.println("n=" + n + ", charPoly=" + charPoly);
    final int deg = charPoly.degree();
    for (int k = 0; k <= deg; ++k) {
      mLastRow[k] = (mRow & 1) == 0 ? charPoly.coeff(k) : charPoly.coeff(k).negate();
    }
  }

  /**
   * Return next term, reading the triangle row by row from left to right, starting with T(0, 0).
   * @return the next term of the sequence.
   */
  @Override
  public Z next() {
    if (++mCol > mRow) {
      addRow();
    }
    return mLastRow[mCol];
  }
}
#!queue	A204890	1	->	1	Triangle	--------------------------------
package irvine.oeis.a204;

import irvine.math.z.Z;
import irvine.oeis.MemorySequence;
import irvine.oeis.Sequence;
import irvine.oeis.a000.A000040;
import irvine.oeis.triangle.Triangle;

/**
 * A204890 Ordered differences of primes.
 * @author Georg Fischer
 */
public class A204890 extends Triangle {

  private int mDist;
  private MemorySequence mSeq;

  /** Construct the sequence. */
  public A204890() {
    this(new A000040(), 1);
  }

  /**
   * Generic constructor with parameters
   * @param seq underlying sequence
   * @param dist number of zeros to be prepended to the underlying sequence
   */
  public A204890(final Sequence seq, final int dist) {
    setOffset(1);
    mSeq = MemorySequence.cachedSequence(seq);
    mDist = dist;
    hasRAM(true);
  }

  @Override
  public Z compute(int n, int k) {
    n += 2;
    ++k;
    // System.out.println("n=" + n + ", k=" + k + ", a(n)=" + mSeq.a(n - mDist) + ", a(k)=" + mSeq.a(k - mDist));
    return mSeq.a(n - mDist).subtract(mSeq.a(k - mDist));
  }
}
#!queue	A208575	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a208;
// manually 2022-02-28

import irvine.math.z.Z;
import irvine.math.z.ZUtils;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a007.A007623;

/**
 * A208575 Product of digits of n in factorial base.
 * @author Georg Fischer
 */
public class A208575 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private Sequence mSeq; // underlying sequence
  private int mBase;

  /** Construct the sequence. */
  public A208575() {
    this(0, new A007623(), 10);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index of target sequence
   * @param seq underlying sequence
   * @param base number base
   */
  public A208575(final int offset, final Sequence seq, final int base) {
    super(offset);
    mSeq = seq;
    mBase = base;
  }

  @Override
  public Z next() {
    return ZUtils.digitProduct(mSeq.next(), mBase);
  }
}
#!queue	A210025	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a210;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A210025 a(0)=1. Let S = string of digits of a(0),a(1),a(2),... To get a(n+1) (n&gt;=0), subtract next element of S from a(n) if that would give a positive number, otherwise add it to a(n).
 * @author Sean A. Irvine
 */
public class A210025 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A210025() {
    super(0);
  }

  private Z mA = null;
  private final StringBuilder mDigits = new StringBuilder();
  private int mN = -1;

  @Override
  public Z next() {
    if (mA == null) {
      mA = Z.ONE;
    } else {
      final int d = mDigits.charAt(++mN) - '0';
      final Z t = mA.subtract(d);
      if (t.signum() > 0) {
        mA = t;
      } else {
        mA = mA.add(d);
      }
    }
    mDigits.append(mA.toString());
    return mA;
  }
}
#!queue	A210286	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a210;

import java.util.function.Function;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A210286 Number of 2 X 2 matrices with all elements in {0,1,...,n} and determinant = trace.
 * @author Georg Fischer
 */
public class A210286 extends AbstractSequence {

  /**
   * Five longs.
   */
  @FunctionalInterface
  public interface Long5Cond {
    /**
     * Evaluate a function.
     * @param n parameter
     * @param w parameter
     * @param x parameter
     * @param y parameter
     * @param z parameter
     * @return evaluation
     */
    boolean evaluate(long n, long w, long x, long y, long z);
  }

  protected Function<Long, Long[]> mRange;
  protected Long5Cond mCond;
  private long mN;

  /** Construct the sequence. */
  public A210286() {
    this(0, n -> new Long[] {0L, n}, (n, w, x, y, z) -> w * z - x * y == w + z);
  }

  /**
   * Generic constructor with parameters
   * @param offset first index
   * @param range index range (low, high)
   * @param cond condition for the n and the 4 terms to be counted
   */
  public A210286(final int offset, final Function<Long, Long[]> range, final Long5Cond cond) {
    super(offset);
    mRange = range;
    mCond = cond;
    mN = offset - 1;
  }

  /**
   * Count the number of aggregated values fulfilling the condition in a range
   * @param n current index
   * @return count
   */
  protected Z count(final long n) {
    final Long[] ab = mRange.apply(n);
    final long a = ab[0];
    final long b = ab[1];
    long result = 0;
    for (long w = a; w <= b; ++w) {
      for (long x = a; x <= b; ++x) {
        for (long y = a; y <= b; ++y) {
          for (long z = a; z <= b; ++z) {
            if (mCond.evaluate(n, w, x, y, z)) {
              ++result;
            }
          }
        }
      }
    }
    return Z.valueOf(result);
  }

  @Override
  public Z next() {
    ++mN;
    return count(mN);
  }
}
#!queue	A211318	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a211;

import java.util.HashMap;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A211318 Triangle read by rows: number of permutations of 1..n by length l of longest run (n &gt;= 1, 1 &lt;= l &lt;= n).
 * @author Sean A. Irvine
 */
public class A211318 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A211318() {
    super(1);
  }

  private static final HashMap<String, Z> CACHE = new HashMap<>();

  /**
   * Useful recurrence to computing this type of sequence. Returns the number
   * of permutations of order <code>n</code> whose increasing runs length
   * does not exceed <code>k</code>, and the final increasing run (if it is
   * present) has length at most <code>j</code>.
   * @param n order of permutation
   * @param k maximal sequence length
   * @param i index
   * @param j index
   * @return number of permutations
   */
  public static Z b(final int n, final int k, final int i, final int j) {
    if (i < 1 || j < 1) {
      return Z.ZERO;
    }
    if (n == 1) {
      return Z.ONE;
    }
    final String key = n + "_" + k + "_" + i + "_" + j;
    final Z v = CACHE.get(key);
    if (v != null) {
      return v;
    }
    Z sum = b(n - 1, k, i - 1, j).add(b(n - 1, k, i, j - 1));
    for (int t = 2; t < n; ++t) {
      sum = sum.add(Binomial.binomial(n - 1, t - 1).multiply(b(t - 1, k, i, k - 1)).multiply(b(n - t, k, k - 1, j)));
    }
    CACHE.put(key, sum);
    return sum;
  }

  protected Z a(final int n, final int p) {
    return b(n, p, p, p).subtract(b(n, p - 1, p - 1, p - 1));
  }

  private int mN = 0;
  private int mP = 0;

  @Override
  public Z next() {
    if (mP >= mN) {
      ++mN;
      mP = 0;
    }
    return a(mN, ++mP);
  }

}

#!queue	A225171	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a225;

import java.util.ArrayList;

import irvine.math.z.Eulerian2;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.transform.BellMatrixTransformSequence;

/**
 * A225171 Triangle read by rows: T(n,k), 1 &lt;= k &lt;= n, is the number of non-degenerate fanout-free Boolean functions of n variables having AND rank k.
 * @author Sean A. Irvine
 */
public class A225171 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A225171() {
    super(1);
  }

  private final ArrayList<Z> mA = new ArrayList<>();
  private final BellMatrixTransformSequence mB = new BellMatrixTransformSequence(mA);
  private int mN = 0;
  private int mK = 0;

  private Z eulerian2Sum(final int n) {
    if (n == 0) {
      return Z.TWO;
    }
    Z sum = Z.ZERO;
    for (int k = 0; k < n; ++k) {
      sum = sum.add(Eulerian2.SINGLETON.get((long) n, (long) k).shiftLeft(2L * n - k));
    }
    return sum;
  }

  protected Z and(final int n, final int k) {
    while (n > mA.size()) {
      mA.add(eulerian2Sum(mA.size()));
    }
    return mB.get(n, k);
  }

  @Override
  public Z next() {
    if (++mK > mN) {
      ++mN;
      mK = 1;
    }
    return and(mN, mK);
  }
}
#!queue	A227061	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a227;

import irvine.math.IntegerUtils;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A227061 T(n,k) = Number of (n+k-1) X (n+k-1) binary arrays with k 1s in every row and column with rows and columns in lexicographically nondecreasing order.
 * @author Sean A. Irvine
 */
public class A227061 extends MemoryFunction2Sequence<Integer, Long> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A227061() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;

  private long mCount = 0;
  private int mMaxSum = 0;
  private int mLimit;

  private boolean isColSafe(final int[] colSums, final int element) {
    for (int k = 0, j = 1; k < colSums.length; ++k, j <<= 1) {
      if ((element & j) != 0 && colSums[k] >= mMaxSum) {
        return false;
      }
    }
    return true;
  }

  private static void incColSums(final int[] colSums, final int element) {
    for (int k = 0, j = 1; k < colSums.length; ++k, j <<= 1) {
      if ((element & j) != 0) {
        ++colSums[k];
      }
    }
  }

  private static void decColSum(final int[] colSums, final int element) {
    for (int k = 0, j = 1; k < colSums.length; ++k, j <<= 1) {
      if ((element & j) != 0) {
        --colSums[k];
      }
    }
  }

  private static int[] transpose(final int[] m) {
    final int[] r = new int[m.length];
    for (int v : m) {
      for (int j = m.length - 1; j >= 0; --j) {
        r[j] <<= 1;
        r[j] += v & 1;
        v >>= 1;
      }
    }
    return r;
  }

  private static boolean isSorted(final int[] m) {
    for (int k = 1; k < m.length; ++k) {
      if (m[k] < m[k - 1]) {
        return false;
      }
    }
    return true;
  }

  // Construct in a way that maintains both the matrix and transpose in lexicographic sorted order
  private void search(final int[] matrix, final int[] transpose, final int[] colSums, final int row, final int element) {
    if (row == matrix.length) {
      assert isSorted(matrix);
      assert isSorted(transpose);
      if (accept(matrix, transpose)) {
        ++mCount;
      }
      return;
    }
    if (element >= mLimit) {
      return;
    }
    final int bit = 1 << (matrix.length - row - 1);
    for (int e = element; e < mLimit; e = IntegerUtils.swizzle(e)) {
      // Place element in matrix[row] and move to next row
      if (isColSafe(colSums, e)) {
        incColSums(colSums, e);
        matrix[row] = e;
        for (int k = transpose.length - 1, j = e; k >= 0; --k, j >>>= 1) {
          transpose[k] |= bit * (j & 1);
        }
        if (isSorted(transpose)) {
          search(matrix, transpose, colSums, row + 1, e);
        }
        for (int k = 0; k < transpose.length; ++k) {
          transpose[k] &= ~bit;
        }
        //matrix[row] = 0;
        decColSum(colSums, e);
      }
    }
  }

  protected boolean accept(final int[] matrix, final int[] transpose) {
    return true;
  }

  @Override
  protected Long compute(final Integer n, final Integer m) {
    if (m > n) {
      return 0L;
    }
    if (m < 1) {
      return 1L;
    }
    mCount = 0;
    mMaxSum = m;
    mLimit = 1 << n;
    search(new int[n], new int[n], new int[n], 0, (1 << m) - 1);
    return mCount;
  }

  @Override
  public Z next() {
    if (++mM >= mN) {
      ++mN;
      mM = 0;
    }
    return Z.valueOf(get(mN, mN - mM));
  }
}
#!queue	A230627	2	->	2	AbstractSequence	--------------------------------
package irvine.oeis.a230;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.ConcatenatedPrimeFactorizationSequence;

/**
 * A230627 Prime reached in A230626, or -1 if no prime is reached.
 * @author Sean A. Irvine
 */
public class A230627 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A230627() {
    super(2);
  }

  private long mN = 1;

  @Override
  public Z next() {
    final ConcatenatedPrimeFactorizationSequence seq = new ConcatenatedPrimeFactorizationSequence(++mN, 2);
    Z u = null;
    Z t;
    while ((t = seq.next()) != null) {
      u = t;
    }
    if (u == null) {
      throw new RuntimeException();
    }
    return u.isProbablePrime(32) ? u : Z.NEG_ONE;
  }
}
#!queue	A244372	1	->	1	Triangle	--------------------------------
package irvine.oeis.a244;

import irvine.math.z.Z;
import irvine.oeis.a299.A299038;
import irvine.oeis.triangle.Triangle;

/**
 * A244372 Number T(n,k) of unlabeled rooted trees with n nodes and maximal outdegree (branching factor) k; triangle T(n,k), n&gt;=1, 0&lt;=k&lt;=n-1, read by rows.
 * @author Georg Fischer
 */
public class A244372 extends Triangle {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /* Maple:
    b:= proc(n, i, t, k) as in A299038:
    T:= (n, k)-> b(n-1$2, k$2) -`if`(k=0, 0, b(n-1$2, k-1$2)):
    seq(seq(T(n, k), k=0..n-1), n=1..14);
  */
  protected final A299038 mSeq = new A299038();

  /** Construct the sequence. */
  public A244372() {
    setOffset(1);
    hasRAM(true);
  }

  @Override
  public Z compute(int n, final int k) {
    ++n;
    Z result = mSeq.b(n - 1, n - 1, k, k);
    if (k > 0) {
      result = result.subtract(mSeq.b(n - 1, n - 1, k - 1, k - 1));
    }
    return result;
  }
}
#!queue	A255487	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a255;

import java.util.Arrays;
import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A255487 Number of polyhypercubes or 4-dimensional polyominoes with n cells (regarding mirror-images as distinct).
 * @author Don Reble
 * @author Sean A. Irvine
 */
public class A255487 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A255487() {
    super(0);
  }

  // Don Reble original C++ version
  // https://oeis.org/A068870/a068870.txt

  /*
    Count the 4-dimensional polyhypercubes, treating mirror-images as
    different (A255487); but also count the symmetric ones, to get A068870.

    Each Poly has a canonical form, such that two polys are equivalent
    if their canonical forms are identical. Compute it by examining all
    192 rotations of a form:
    - move each rotated Poly close to the origin (coordinates are
      non-negative and minimal),
    - sort the sequence of hypercube coordinates, and
    - take the least of the 192 (using an arbitrary but consistent
      ordering).
  */

  // Coordinate (w,x,y,z) is four 8-bit numbers packed into a int

  private static final int SHIFT1 = 8;
  private static final int SHIFT2 = 2 * SHIFT1;
  private static final int SHIFT3 = 3 * SHIFT1;
  private static final int W_COORD = 1;
  private static final int X_COORD = W_COORD << SHIFT1;
  private static final int Y_COORD = X_COORD << SHIFT1;
  private static final int Z_COORD = Y_COORD << SHIFT1;
  private static final int W_MASK = X_COORD - W_COORD;
  private static final int X_MASK = Y_COORD - X_COORD;
  private static final int Y_MASK = Z_COORD - Y_COORD;
  private static final int Z_MASK = -Z_COORD;

  protected static class PackedPolyomino {
    private final int[] mCoords;
    private int mMin;
    private int mMax;

    PackedPolyomino(final int size) {
      mCoords = new int[size];
    }

    PackedPolyomino copy() {
      final PackedPolyomino p = new PackedPolyomino(mCoords.length);
      System.arraycopy(mCoords, 0, p.mCoords, 0, mCoords.length);
      p.mMin = mMin;
      p.mMax = mMax;
      return p;
    }

    @Override
    public boolean equals(final Object obj) {
      return obj instanceof PackedPolyomino && Arrays.equals(mCoords, ((PackedPolyomino) obj).mCoords);
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(mCoords);
    }

    // Use comparators only on size-Size polys.
    /* set<Poly> and canonicalize() use operator<
       It's an arbitrary but consistent ordering. */
    boolean lt(final PackedPolyomino rhs) {
      for (int k = 0; k < mCoords.length; ++k) {
        final int c = Integer.compare(mCoords[k], rhs.mCoords[k]);
        if (c != 0) {
          return c > 0;
        }
      }
      return false;
    }

    private String coString(final int co) {
      return (co & W_MASK) + " " + ((co & X_MASK) >>> SHIFT1) + " " + ((co & Y_MASK) >>> SHIFT2) + " " + ((co & Z_MASK) >>> SHIFT3);
    }

    @Override
    public String toString() {
      final StringBuilder sb = new StringBuilder();
      for (final int co : mCoords) {
        sb.append(" [").append(coString(co)).append(']');
      }
      sb.append(" {").append(coString(mMin)).append("} {").append(coString(mMax)).append('}');
      return sb.toString();
    }

    private void move(final int displ) {
      for (int cx = 0; cx < mCoords.length; cx += 1) {
        mCoords[cx] += displ;
      }
      mMin += displ;
      mMax += displ;
    }

    private void updateExtrema(final int newco) {
      if ((newco & W_MASK) < (mMin & W_MASK)) {
        mMin = (mMin & ~W_MASK) | (newco & W_MASK);
      }
      if ((newco & W_MASK) > (mMax & W_MASK)) {
        mMax = (mMax & ~W_MASK) | (newco & W_MASK);
      }
      if ((newco & X_MASK) < (mMin & X_MASK)) {
        mMin = (mMin & ~X_MASK) | (newco & X_MASK);
      }
      if ((newco & X_MASK) > (mMax & X_MASK)) {
        mMax = (mMax & ~X_MASK) | (newco & X_MASK);
      }
      if ((newco & Y_MASK) < (mMin & Y_MASK)) {
        mMin = (mMin & ~Y_MASK) | (newco & Y_MASK);
      }
      if ((newco & Y_MASK) > (mMax & Y_MASK)) {
        mMax = (mMax & ~Y_MASK) | (newco & Y_MASK);
      }
      if ((newco & Z_MASK) < (mMin & Z_MASK)) {
        mMin = (mMin & ~Z_MASK) | (newco & Z_MASK);
      }
      if ((newco & Z_MASK) > (mMax & Z_MASK)) {
        mMax = (mMax & ~Z_MASK) | (newco & Z_MASK);
      }
    }

    private PackedPolyomino rotate(final PackedPolyomino canon, final int mask1, final int mask2, final int shift1) {
      final int wmax = mMax & mask1;
      for (int cx = 0; cx < mCoords.length; ++cx) {
        mCoords[cx] = (mCoords[cx] & (~mask1 & ~mask2))
          | ((wmax - (mCoords[cx] & mask1)) << shift1)
          | ((mCoords[cx] & mask2) >> shift1);
      }
      mMax = (mMax & (~mask1 & ~mask2))
        | (wmax << shift1)
        | ((mMax & mask2) >> shift1);
      Arrays.sort(mCoords);
      return lt(canon) ? copy() : canon;
    }

    private PackedPolyomino rotWtoX(final PackedPolyomino canon) {
      return rotate(canon, W_MASK, X_MASK, SHIFT1);
    }

    private PackedPolyomino rotWtoY(final PackedPolyomino canon) {
      return rotate(canon, W_MASK, Y_MASK, SHIFT2);
    }

    private PackedPolyomino rotWtoZ(final PackedPolyomino canon) {
      return rotate(canon, W_MASK, Z_MASK, SHIFT3);
    }

    private PackedPolyomino rotXtoY(final PackedPolyomino canon) {
      return rotate(canon, X_MASK, Y_MASK, SHIFT1);
    }

    private PackedPolyomino rotYtoX(final PackedPolyomino canon) {
      final int ymax = mMax & Y_MASK;
      for (int cx = 0; cx < mCoords.length; ++cx) {
        mCoords[cx] = (mCoords[cx] & (~X_MASK & ~Y_MASK))
          | ((ymax - (mCoords[cx] & Y_MASK)) >> SHIFT1)
          | ((mCoords[cx] & X_MASK) << SHIFT1);
      }
      mMax = (mMax & (~X_MASK & ~Y_MASK))
        | (ymax >> SHIFT1)
        | ((mMax & X_MASK) << SHIFT1);
      Arrays.sort(mCoords);
      return lt(canon) ? copy() : canon;
    }

    private PackedPolyomino rotXtoZ(final PackedPolyomino canon) {
      return rotate(canon, X_MASK, Z_MASK, SHIFT2);
    }

    private PackedPolyomino do2D(final PackedPolyomino canon) {
      return rotWtoX(rotWtoX(rotWtoX(canon)));
    }

    private PackedPolyomino do3D(final PackedPolyomino canon) {
      return do2D(rotWtoY(do2D(rotYtoX(do2D(rotXtoY(do2D(rotXtoY(do2D(rotWtoY(do2D(canon)))))))))));
    }

    private PackedPolyomino do4D(final PackedPolyomino canon) {
      return do3D(rotXtoZ(do3D(rotWtoZ(do3D(rotWtoZ(do3D(rotWtoZ(do3D(rotXtoZ(do3D(rotWtoZ(do3D(rotWtoZ(do3D(canon)))))))))))))));
    }

    private void flipW() {
      final int wmax = mMax & W_MASK;
      for (int cx = 0; cx < mCoords.length; ++cx) {
        mCoords[cx] = (mCoords[cx] & ~W_MASK) | (wmax - (mCoords[cx] & W_MASK));
      }
      Arrays.sort(mCoords);
    }

    PackedPolyomino canonicalize() {
      final PackedPolyomino po = copy();
      po.move(-po.mMin);
      Arrays.sort(po.mCoords);
      return po.do4D(po.copy());
    }

    /**
     * Test if the polyomino is symmetric
     * @return true if symmetric
     */
    public boolean isSymmetric() {
      PackedPolyomino fl = copy();
      fl.flipW();
      fl = fl.canonicalize();
      return equals(fl);
    }

    private void expandPoly(final HashSet<PackedPolyomino> polys) {
      final int prevSize = mCoords.length;
      move(W_COORD + X_COORD + Y_COORD + Z_COORD);
      // so that all adjacent cells exist
      final HashSet<Integer> cellset = new HashSet<>();
      for (final int p : mCoords) {
        cellset.add(p);
      }
      final PackedPolyomino expo = new PackedPolyomino(mCoords.length + 1);
      System.arraycopy(mCoords, 0, expo.mCoords, 0, mCoords.length);
      expo.mMin = mMin;
      expo.mMax = mMax;
      for (int cx = 0; cx < prevSize; cx += 1) {
        final int co = mCoords[cx];
        for (int delta = W_COORD; delta != 0; delta <<= SHIFT1) {
          int exco = co + delta;
          expo.mCoords[prevSize] = exco;
          if (cellset.add(exco)) {
            expo.updateExtrema(exco);
            final PackedPolyomino canon = expo.canonicalize();
            polys.add(canon);
            expo.mMin = mMin;
            expo.mMax = mMax;
          }
          exco = co - delta;
          expo.mCoords[prevSize] = exco;
          if (cellset.add(exco)) {
            expo.updateExtrema(exco);
            final PackedPolyomino canon = expo.canonicalize();
            polys.add(canon);
            expo.mMin = mMin;
            expo.mMax = mMax;
          }
        }
      }
    }

  }

  private HashSet<PackedPolyomino> mPolysA = null;
  protected HashSet<PackedPolyomino> mPolysB = null;

  private void expandPolys() {
    for (final PackedPolyomino poly : mPolysA) {
      poly.expandPoly(mPolysB);
    }
  }

  @Override
  public Z next() {
    if (mPolysB == null) {
      mPolysB = new HashSet<>();
      return Z.ONE;
    }
    if (mPolysB.isEmpty()) {
      final PackedPolyomino po = new PackedPolyomino(1);
      po.mCoords[0] = 0;
      po.mMin = 0;
      po.mMax = 0;
      mPolysB.add(po);
    } else {
      mPolysA = mPolysB;
      mPolysB = new HashSet<>();
      expandPolys();
    }
    return Z.valueOf(mPolysB.size());
  }

}
#!queue	A259095	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a259;

import irvine.math.partitions.DistinctPartsPartition;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A259095 Triangle read by rows: T(n,r) = number of arrangements of n pennies in rows, with r contiguous pennies in the bottom row, and each higher row consisting of contiguous pennies, each touching two pennies in the row below (1 &lt;= r &lt;= n).
 * @author Sean A. Irvine
 */
public class A259095 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A259095() {
    super(1);
  }

  private int mN = 0;
  private int mR = 0;

  private boolean isMaxPart(final int[] p, final int r) {
    return p[0] == r;
  }

  protected Z a259095(final int n, final int r) {
    Z sum = Z.ZERO;
    int[] p;
    final DistinctPartsPartition partition = new DistinctPartsPartition(n);
    while ((p = partition.next()) != null) {
      if (isMaxPart(p, r)) {
        Z t = Z.ONE;
        for (int k = 1; k < p.length; ++k) {
          t = t.multiply(p[k - 1] - p[k]);
        }
        sum = sum.add(t);
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mR > mN) {
      ++mN;
      mR = 1;
    }
    return a259095(mN, mR);
  }
}
#!queue	A259985	0	->	0	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a259;

import irvine.oeis.memory.MemoryFunction2Sequence;
import irvine.math.z.Z;

/**
 * A259985 Triangle read by rows: coefficients of rook polynomials.
 * @author Sean A. Irvine
 */
public class A259985 extends MemoryFunction2Sequence<Long, Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  // Rook polynomials

  private static final long[][] SMALL = {
    {1},
    {1, 1},
    {1, 4, 2},
    {1, 9, 18, 6},
    {1, 16, 72, 96, 24},
    {1, 20, 130, 320, 265, 44},
    {1, 24, 204, 752, 1185, 672, 80},
    {1, 28, 294, 1456, 3521, 3892, 1617, 144},
    {1, 32, 400, 2496, 8264, 14272, 11776, 3776, 264},
    {1, 36, 522, 3936, 16659, 39924, 52071, 33480, 8577, 484},
    {1, 40, 660, 5840, 30210, 93568, 171060, 175360, 90745, 19080, 888},
    {1, 44, 814, 8272, 50677, 193556, 461208, 667832, 554532, 236808, 41745, 1632}
  };

  @Override
  protected Z compute(final Long n, final Long k) {
    if (k > n || k < 0) {
      return Z.ZERO;
    }
    if (n < SMALL.length) {
      return Z.valueOf(SMALL[n.intValue()][k.intValue()]);
    }
    return get(n - 1, k)
      .add(get(n - 1, k - 1).multiply(4))
      .subtract(get(n - 2, k - 2).multiply(4))
      .subtract(get(n - 3, k - 2))
      .subtract(get(n - 4, k - 2))
      .subtract(get(n - 4, k - 3).multiply(4))
      .subtract(get(n - 4, k - 4).multiply2())
      .add(get(n - 5, k - 4).multiply(3))
      .add(get(n - 5, k - 5).multiply(4))
      .add(get(n - 7, k - 6))
      .subtract(get(n - 8, k - 8));
  }

  private long mN = -1;
  private long mR = 0;

  @Override
  public Z next() {
    if (++mR > mN) {
      ++mN;
      mR = 0;
    }
    return get(mN, mR);
  }
}
#!queue	A262554	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a262;

import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A262554 Triangle read by rows: coefficients in Bell's formula for number of ways of making change when coins have denominations which are powers of 2.
 * @author Sean A. Irvine
 */
public class A262554 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A262554() {
    super(1);
  }

  private Z a(final int i, final int j) {
    return Binomial.binomial(i, j - i).shiftLeft(2 * i - j).add(Binomial.binomial(i - 1, j - i + 1).shiftLeft(2 * i - j - 2));
  }

  @Override
  protected Z compute(final Integer m, final Integer i) {
    if (i >= m) {
      return Z.ZERO;
    }
    if (i == 0) {
      return Z.ONE;
    }
    Z s = Z.ZERO;
    for (int j = i - 1; j <= 2 * i; ++j) {
      s = s.add(a(i, j).multiply(get(m - 1, j)));
    }
    return s;
  }

  private int mN = 0;
  private int mI = 0;

  @Override
  public Z next() {
    if (++mI >= mN) {
      ++mN;
      mI = 0;
    }
    return get(mN, mI);
  }

}

#!queue	A265607	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a265;

import java.util.ArrayList;

import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.transform.BellTransform;

/**
 * A265607 Triangle read by rows, T(n,k) = n!*B(n,k) for n&gt;=0 and 0&lt;=k&lt;=n, where B(n,k) is the Bell matrix with generator 1/j for j&gt;=1.
 * @author Sean A. Irvine
 */
public class A265607 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A265607() {
    super(0);
  }

  private int mN = -1;
  private int mM = 0;
  private Z mF = Z.ONE;
  private BellTransform mBellTransform = null;

  @Override
  public Z next() {
    if (mN == -1) {
      ++mN;
      return Z.ONE;
    }
    if (++mM > mN) {
      ++mN;
      final ArrayList<Q> invNat = new ArrayList<>();
      invNat.add(Q.ZERO);
      for (int k = 1; k <= mN; ++k) {
        invNat.add(new Q(1, k));
      }
      mM = 0;
      mBellTransform = new BellTransform(invNat);
      mF = mF.multiply(mN);
    }
    return mBellTransform.get(mN, mM).multiply(mF).toZ();
  }
}
#!queue	A269920	0	->	0	MemoryFunctionInt3Sequence	--------------------------------
package irvine.oeis.a269;

import irvine.math.z.Z;
import irvine.oeis.memory.MemoryFunctionInt3Sequence;

/**
 * A269920 Triangle read by rows: T(n,f) is the number of rooted maps with n edges and f faces on an orientable surface of genus 0.
 * @author Sean A. Irvine
 */
public class A269920 extends MemoryFunctionInt3Sequence<Z> {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    this(0);
  }

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  @Override
  protected Z compute(final int n, final int g, final int f) {
    if (n < 0 || g < 0 || f < 0) {
      return Z.ZERO;
    }
    if (n == 0) {
      return g == 0 && f == 1 ? Z.ONE : Z.ZERO;
    }
    Z sum = Z.ZERO;
    for (int k = 1; k < n; ++k) {
      final int l = n - k;
      assert l >= 1;
      final long k2 = 2L * k - 1;
      final long l2 = 2L * l - 1;
      for (int u = 1; u < f; ++u) {
        final int v = f - u;
        assert v >= 1;
        for (int i = 0; i <= g; ++i) {
          final int j = g - i;
          assert j >= 0;
          sum = sum.add(get(l - 1, j, v).multiply(get(k - 1, i, u)).multiply(k2).multiply(l2));
        }
      }
    }
    sum = sum.multiply(3);
    final long n2 = 2L * n - 1;
    sum = sum.add(get(n - 1, g, f).multiply(n2).multiply2());
    sum = sum.add(get(n - 1, g, f - 1).multiply(n2).multiply2());
    sum = sum.add(get(n - 2, g - 1, f).multiply(2L * n - 3).multiply(2L * n - 2).multiply(n2).divide2());
    return sum.divide(n + 1);
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN + 1) {
      ++mN;
      mM = 1;
    }
    return get(mN, 0, mM);
  }

}
#!queue	A271423	0	->	0	Triangle	--------------------------------
package irvine.oeis.a271;

import irvine.math.MemoryFunctionInt3;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.z.Binomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A271423 Number T(n,k) of set partitions of [n] with maximal block length multiplicity equal to k; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A271423 extends Triangle {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A271423() {
    super(1, 1, -1);
    hasRAM(true);
  }

  /* Maple:
    with(combinat):
    b:= proc(n, i, k) option remember; `if`(n=0, 1,
          `if`(i<1, 0, add(multinomial(n, n-i*j, i$j)
            *b(n-i*j, i-1, k)/j!, j=0..min(k, n/i))))
        end:
    T:= (n, k)-> b(n$2, k)-`if`(k=0, 0, b(n$2, k-1)):
    seq(seq(T(n, k), k=0..n), n=0..12);
  */
  private final MemoryFunctionInt3<Z> mB = new MemoryFunctionInt3<Z>() {
    @Override
    protected Z compute(final int n, final int i, final int k) {
      if (n == 0) {
        return Z.ONE;
      }
      if (i < 1) {
        return Z.ZERO;
      }
      Z sum = Z.ZERO;
      final int ni = n / i;
      final int jmax = k < ni ? k : ni;
      for (int j = 0; j <= jmax; ++j) {
        final int[] list = new int[j + 1];
        list[0] = n - i * j;
        for (int l = 1; l <= j; ++l) {
          list[l] = i;
        }
        sum = sum.add(Binomial.multinomial(n, list).multiply(get(n - i * j, i - 1, k)).divide(MemoryFactorial.SINGLETON.factorial(j)));
      }
      return sum;
    }
  };

  @Override
  public Z compute(final int n, final int k) {
    Z result = mB.get(n, n, k);
    if (k != 0) {
      result = result.subtract(mB.get(n, n, k - 1));
    }
    return result;
  }
}
#!queue	A285037	1	->	1	MemoryFunction2Sequence	--------------------------------
package irvine.oeis.a285;

import irvine.factor.factor.Jaguar;
import irvine.math.Mobius;
import irvine.math.z.Stirling;
import irvine.math.z.Z;
import irvine.oeis.a304.A304972;
import irvine.oeis.memory.MemoryFunction2Sequence;

/**
 * A285037 Irregular triangle read by rows: T(n,k) is the number of primitive (period n) periodic palindromic structures using exactly k different symbols, 1 &lt;= k &lt;= n/2 + 1.
 * @author Sean A. Irvine
 */
public class A285037 extends MemoryFunction2Sequence<Integer, Z> {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A285037() {
    super(1);
  }

  // After Andrew Howroyd

  private final A304972 mAch = new A304972();
  private int mN = 0;
  private int mM = 1;

  @Override
  protected Z compute(final Integer n, final Integer k) {
    Z sum = Z.ZERO;
    for (final Z dd : Jaguar.factor(n).divisors()) {
      final int d = dd.intValue();
      final int m = Mobius.mobius(d);
      if (m != 0) {
        Z s = Stirling.secondKind((n / d + 1) / 2, k).add(Stirling.secondKind(n / d / 2 + 1, k));
        if (((n - d) & 1) == 1) {
          s = s.add(mAch.get((n / d + 1) / 2, k).add(mAch.get(n / d / 2 + 1, k)));
        }
        if ((d & 1) == 1) {
          s = s.divide2();
        }
        sum = sum.signedAdd(m == 1, s);
      }
    }
    return sum;
  }

  @Override
  public Z next() {
    if (++mM > mN / 2 + 1) {
      ++mN;
      mM = 1;
    }
    return get(mN, mM);
  }
}
#!queue	A290305	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a290;

import java.util.Arrays;
import java.util.HashSet;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A290305 Number of 5-dimensional polyominoes with n cells (regarding mirror-images as distinct).
 * @author Sean A. Irvine
 */
public class A290305 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A290305() {
    super(0);
  }

  // Cf. A255487 (4-dimensional case)
  // Coordinate (w,x,y,z,v) is five 6-bit numbers packed into a int

  private static final int SHIFT1 = 6;
  private static final int SHIFT2 = 2 * SHIFT1;
  private static final int SHIFT3 = 3 * SHIFT1;
  private static final int SHIFT4 = 4 * SHIFT1;
  private static final int W_COORD = 1;
  private static final int X_COORD = W_COORD << SHIFT1;
  private static final int Y_COORD = X_COORD << SHIFT1;
  private static final int Z_COORD = Y_COORD << SHIFT1;
  private static final int V_COORD = Z_COORD << SHIFT1;
  private static final int END_COORD = V_COORD << SHIFT1;
  private static final int W_MASK = X_COORD - W_COORD;
  private static final int X_MASK = Y_COORD - X_COORD;
  private static final int Y_MASK = Z_COORD - Y_COORD;
  private static final int Z_MASK = V_COORD - Z_COORD;
  private static final int V_MASK = END_COORD - V_COORD;

  protected static class FiveDPackedPolyomino {

    private final int[] mCoords;
    private int mMin;
    private int mMax;

    FiveDPackedPolyomino(final int size) {
      mCoords = new int[size];
    }

    FiveDPackedPolyomino copy() {
      final FiveDPackedPolyomino p = new FiveDPackedPolyomino(mCoords.length);
      System.arraycopy(mCoords, 0, p.mCoords, 0, mCoords.length);
      p.mMin = mMin;
      p.mMax = mMax;
      return p;
    }

    @Override
    public boolean equals(final Object obj) {
      return obj instanceof FiveDPackedPolyomino && Arrays.equals(mCoords, ((FiveDPackedPolyomino) obj).mCoords);
    }

    @Override
    public int hashCode() {
      return Arrays.hashCode(mCoords);
    }

    private void updateExtrema(final int newco) {
      if ((newco & W_MASK) < (mMin & W_MASK)) {
        mMin = (mMin & ~W_MASK) | (newco & W_MASK);
      }
      if ((newco & W_MASK) > (mMax & W_MASK)) {
        mMax = (mMax & ~W_MASK) | (newco & W_MASK);
      }
      if ((newco & X_MASK) < (mMin & X_MASK)) {
        mMin = (mMin & ~X_MASK) | (newco & X_MASK);
      }
      if ((newco & X_MASK) > (mMax & X_MASK)) {
        mMax = (mMax & ~X_MASK) | (newco & X_MASK);
      }
      if ((newco & V_MASK) < (mMin & V_MASK)) {
        mMin = (mMin & ~V_MASK) | (newco & V_MASK);
      }
      if ((newco & V_MASK) > (mMax & V_MASK)) {
        mMax = (mMax & ~V_MASK) | (newco & V_MASK);
      }
      if ((newco & Y_MASK) < (mMin & Y_MASK)) {
        mMin = (mMin & ~Y_MASK) | (newco & Y_MASK);
      }
      if ((newco & Y_MASK) > (mMax & Y_MASK)) {
        mMax = (mMax & ~Y_MASK) | (newco & Y_MASK);
      }
      if ((newco & Z_MASK) < (mMin & Z_MASK)) {
        mMin = (mMin & ~Z_MASK) | (newco & Z_MASK);
      }
      if ((newco & Z_MASK) > (mMax & Z_MASK)) {
        mMax = (mMax & ~Z_MASK) | (newco & Z_MASK);
      }
    }

    // Use comparators only on size-Size polys.
    /* set<Poly> and canonicalize() use operator<
       It's an arbitrary but consistent ordering. */
    boolean lt(final FiveDPackedPolyomino rhs) {
      for (int k = 0; k < mCoords.length; ++k) {
        final int c = Integer.compare(mCoords[k], rhs.mCoords[k]);
        if (c != 0) {
          return c > 0;
        }
      }
      return false;
    }

    private void move(final int displ) {
      for (int cx = 0; cx < mCoords.length; cx += 1) {
        mCoords[cx] += displ;
      }
      mMin += displ;
      mMax += displ;
    }

    private String co5String(final int co) {
      return (co & W_MASK) + " " + ((co & X_MASK) >>> SHIFT1) + " " + ((co & Y_MASK) >>> SHIFT2) + " " + ((co & Z_MASK) >>> SHIFT3) + " " + ((co & V_MASK) >>> SHIFT4);
    }

    @Override
    public String toString() {
      final StringBuilder sb = new StringBuilder();
      for (final int co : mCoords) {
        sb.append(" [").append(co5String(co)).append(']');
      }
      sb.append(" {").append(co5String(mMin)).append("} {").append(co5String(mMax)).append('}');
      return sb.toString();
    }

    private FiveDPackedPolyomino rotate(final FiveDPackedPolyomino canon, final int mask1, final int mask2, final int shift1) {
      final int wmax = mMax & mask1;
      for (int cx = 0; cx < mCoords.length; ++cx) {
        mCoords[cx] = (mCoords[cx] & (~mask1 & ~mask2))
          | ((wmax - (mCoords[cx] & mask1)) << shift1)
          | ((mCoords[cx] & mask2) >> shift1);
      }
      mMax = (mMax & (~mask1 & ~mask2))
        | (wmax << shift1)
        | ((mMax & mask2) >> shift1);
      Arrays.sort(mCoords);
      return lt(canon) ? copy() : canon;
    }

    private FiveDPackedPolyomino rotWtoX(final FiveDPackedPolyomino canon) {
      return rotate(canon, W_MASK, X_MASK, SHIFT1);
    }

    private FiveDPackedPolyomino rotWtoY(final FiveDPackedPolyomino canon) {
      return rotate(canon, W_MASK, Y_MASK, SHIFT2);
    }

    private FiveDPackedPolyomino rotWtoZ(final FiveDPackedPolyomino canon) {
      return rotate(canon, W_MASK, Z_MASK, SHIFT3);
    }

    private FiveDPackedPolyomino rotXtoY(final FiveDPackedPolyomino canon) {
      return rotate(canon, X_MASK, Y_MASK, SHIFT1);
    }

    private FiveDPackedPolyomino rotYtoX(final FiveDPackedPolyomino canon) {
      final int ymax = mMax & Y_MASK;
      for (int cx = 0; cx < mCoords.length; ++cx) {
        mCoords[cx] = (mCoords[cx] & (~X_MASK & ~Y_MASK))
          | ((ymax - (mCoords[cx] & Y_MASK)) >> SHIFT1)
          | ((mCoords[cx] & X_MASK) << SHIFT1);
      }
      mMax = (mMax & (~X_MASK & ~Y_MASK))
        | (ymax >> SHIFT1)
        | ((mMax & X_MASK) << SHIFT1);
      Arrays.sort(mCoords);
      return lt(canon) ? copy() : canon;
    }

    private FiveDPackedPolyomino rotXtoZ(final FiveDPackedPolyomino canon) {
      return rotate(canon, X_MASK, Z_MASK, SHIFT2);
    }

    private FiveDPackedPolyomino rotWtoV(final FiveDPackedPolyomino canon) {
      return rotate(canon, W_MASK, V_MASK, SHIFT4);
    }

    private FiveDPackedPolyomino rotXtoV(final FiveDPackedPolyomino canon) {
      return rotate(canon, X_MASK, V_MASK, SHIFT3);
    }

    private FiveDPackedPolyomino rotYtoV(final FiveDPackedPolyomino canon) {
      return rotate(canon, Y_MASK, V_MASK, SHIFT2);
    }

    private FiveDPackedPolyomino do2D(final FiveDPackedPolyomino canon) {
      return rotWtoX(rotWtoX(rotWtoX(canon)));
    }

    private FiveDPackedPolyomino do3D(final FiveDPackedPolyomino canon) {
      return do2D(rotWtoY(do2D(rotYtoX(do2D(rotXtoY(do2D(rotXtoY(do2D(rotWtoY(do2D(canon)))))))))));
    }

    private FiveDPackedPolyomino do4D(final FiveDPackedPolyomino canon) {
      return do3D(rotXtoZ(do3D(rotWtoZ(do3D(rotWtoZ(do3D(rotWtoZ(do3D(rotXtoZ(do3D(rotWtoZ(do3D(rotWtoZ(do3D(canon)))))))))))))));
    }

    private FiveDPackedPolyomino do5D(final FiveDPackedPolyomino canon) {
      return do4D(rotWtoV(do4D(rotWtoV(do4D(rotXtoV(do4D(rotXtoV(do4D(rotWtoV(do4D(rotWtoV(do4D(rotYtoV(do4D(rotXtoV(do4D(rotXtoV(do4D(canon)))))))))))))))))));
    }

    private void flipW() {
      final int wmax = mMax & W_MASK;
      for (int cx = 0; cx < mCoords.length; ++cx) {
        mCoords[cx] = (mCoords[cx] & ~W_MASK) | (wmax - (mCoords[cx] & W_MASK));
      }
      Arrays.sort(mCoords);
    }

    FiveDPackedPolyomino canonicalize() {
      final FiveDPackedPolyomino po = copy();
      po.move(-po.mMin);
      Arrays.sort(po.mCoords);
      return po.do5D(po.copy());
    }

    /**
     * Test if the polyomino is symmetric
     * @return true if symmetric
     */
    public boolean isSymmetric() {
      FiveDPackedPolyomino fl = copy();
      fl.flipW();
      fl = fl.canonicalize();
      return equals(fl);
    }

    private void expandPoly(final HashSet<FiveDPackedPolyomino> polys) {
      final int prevSize = mCoords.length;
      move(W_COORD + X_COORD + Y_COORD + Z_COORD + V_COORD);
      // so that all adjacent cells exist
      final HashSet<Integer> cellset = new HashSet<>();
      for (final int p : mCoords) {
        cellset.add(p);
      }
      final FiveDPackedPolyomino expo = new FiveDPackedPolyomino(mCoords.length + 1);
      System.arraycopy(mCoords, 0, expo.mCoords, 0, mCoords.length);
      expo.mMin = mMin;
      expo.mMax = mMax;
      for (int cx = 0; cx < prevSize; cx += 1) {
        final int co = mCoords[cx];
        for (int delta = W_COORD; delta != END_COORD; delta <<= SHIFT1) {
          int exco = co + delta;
          expo.mCoords[prevSize] = exco;
          if (cellset.add(exco)) {
            expo.updateExtrema(exco);
            final FiveDPackedPolyomino canon = expo.canonicalize();
            polys.add(canon);
            expo.mMin = mMin;
            expo.mMax = mMax;
          }
          exco = co - delta;
          expo.mCoords[prevSize] = exco;
          if (cellset.add(exco)) {
            expo.updateExtrema(exco);
            final FiveDPackedPolyomino canon = expo.canonicalize();
            polys.add(canon);
            expo.mMin = mMin;
            expo.mMax = mMax;
          }
        }
      }
    }
  }

  private HashSet<FiveDPackedPolyomino> mPolysA = null;
  protected HashSet<FiveDPackedPolyomino> mPolysB = null;

  private void expandPolys() {
    for (final FiveDPackedPolyomino poly : mPolysA) {
      poly.expandPoly(mPolysB);
    }
  }

  @Override
  public Z next() {
    if (mPolysB == null) {
      mPolysB = new HashSet<>();
      return Z.ONE;
    }
    if (mPolysB.isEmpty()) {
      final FiveDPackedPolyomino po = new FiveDPackedPolyomino(1);
      po.mCoords[0] = 0;
      po.mMin = 0;
      po.mMax = 0;
      mPolysB.add(po);
    } else {
      mPolysA = mPolysB;
      mPolysB = new HashSet<>();
      expandPolys();
    }
    return Z.valueOf(mPolysB.size());
  }
}
#!queue	A291789	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a291;

import irvine.factor.factor.Jaguar;
import irvine.factor.util.FactorSequence;
import irvine.math.q.Q;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A291789 Trajectory of 270 under repeated application of k -&gt; (phi(k)+sigma(k))/2.
 * @author Sean A. Irvine
 */
public class A291789 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A291789() {
    super(0);
  }

  private final boolean mVerbose = "true".equals(System.getProperty("oeis.verbose"));
  private Z mN = null;

  protected long start() {
    return 270;
  }

  @Override
  public Z next() {
    final Z prev = mN;
    if (mN == null) {
      mN = Z.valueOf(start());
    } else {
      final FactorSequence fs = Jaguar.factor(mN);
      final Z t = fs.phi().add(fs.sigma());
      if (t.isOdd()) {
        throw new UnsupportedOperationException("Unexpected odd value " + t);
      }
      mN = t.divide2();
      if (mVerbose) {
        System.out.println("# " + new Q(mN, prev).doubleValue() + " " + FactorSequence.toString(fs) + " " + fs.getExponent(Z.TWO) + " " + fs.getExponent(Z.THREE));
      }
    }
    return mN;
  }

  /**
   * Run the sequence with a particular start value.
   * @param args the start value
   */
  public static void main(final String[] args) {
    if (args.length == 0) {
      System.out.println("Usage: irvine.oeis.a291.A291789 start-value");
      return;
    }
    final A291789 seq = new A291789() {
      @Override
      protected long start() {
        return Long.parseLong(args[0]);
      }
    };
    Z t;
    while ((t = seq.next()) != null) {
      System.out.println(t);
    }
  }
}
#!queue	A296170	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a296;

import java.util.ArrayList;
import java.util.List;

import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A296170 E.g.f. A(x) satisfies: [x^(n-1)] A(x)^(n^2) = [x^n] A(x)^(n^2) for n&gt;=1.
 * @author Sean A. Irvine
 */
public class A296170 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A296170() {
    super(0);
  }

  protected static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  protected List<Q> mA = new ArrayList<>();

  {
    mA.add(Q.ONE);
  }

  private int mN = -1;
  private Z mF = Z.ONE;

  protected void stepEgf() {
    final int n = mA.size();
    final Polynomial<Q> v = RING.pow(RING.create(mA), n * n, n);
    mA.add(v.coeff(n - 1).subtract(v.coeff(n)).divide(n * n));
  }

  @Override
  public Z next() {
    if (++mN > 1) {
      mF = mF.multiply(mN);
    }
    stepEgf();
    return mA.get(mN).multiply(mF).toZ();
  }
}
#!queue	A318951	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a318;

import irvine.math.IntegerUtils;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A318951 Array read by rows: T(n,k) is the number of nonisomorphic n X n matrices with nonnegative integer entries and row sums k under row and column permutations, (n &gt;= 1, k &gt;= 0).
 * @author Sean A. Irvine
 */
public class A318951 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A318951() {
    super(1);
  }

  // After Andrew Howroyd

  private static final PolynomialRingField<Z> RINGZ = new PolynomialRingField<>(IntegerField.SINGLETON);
  private static final PolynomialRingField<Q> RING = new PolynomialRingField<>(Rationals.SINGLETON);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;

  private Z permCount(final int[] v) {
    Z m = Z.ONE;
    int s = 0;
    int k = 0;
    for (int i = 0; i < v.length; ++i) {
      final int t = v[i];
      k = i > 0 && t == v[i - 1] ? k + 1 : 1;
      m = m.multiply(t * (long) k);
      s += t;
    }
    return mF.factorial(s).divide(m);
  }

  private Z k(final int[] q, final int t, final int k) {
    Polynomial<Z> product = RINGZ.one();
    for (final int v : q) {
      final int g = IntegerUtils.gcd(t, v);
      product = RINGZ.multiply(product, RINGZ.pow(RINGZ.oneMinusXToTheN(v / g), g, k), k);
    }
    return RINGZ.coeff(RINGZ.one(), product, k);
  }

  protected Z rowSumMats(final int n, final int m, final int k) {
    Z sum = Z.ZERO;
    final IntegerPartition parts = new IntegerPartition(m);
    int[] q;
    while ((q = parts.next()) != null) {
      final Polynomial<Q> ks = RING.empty();
      ks.add(Q.ZERO);
      for (int t = 1; t <= n; ++t) {
        ks.add(new Q(k(q, t, k), Z.valueOf(t)));
      }
      sum = sum.add(RING.exp(ks, n).coeff(n).multiply(permCount(q)).toZ());
    }
    return sum.divide(mF.factorial(m));
  }

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return rowSumMats(mM, mM, mN - mM);
  }
}
#!queue	A319394	0	->	0	Triangle	--------------------------------
package irvine.oeis.a319;

import irvine.math.MemoryFunction1;
import irvine.math.MemoryFunctionInt2;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A319394 Number T(n,k) of partitions of n into exactly k positive Fibonacci numbers; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A319394 extends Triangle {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  /** Construct the sequence. */
  public A319394() {
    super(1, 1, -1);
    hasRAM(true);
  }

  /* Maple:
    h:= proc(n) option remember; `if`(n<1, 0, `if`((t->
          issqr(t+4) or issqr(t-4))(5*n^2), n, h(n-1)))
        end:
    b:= proc(n, i) option remember; `if`(n=0 or i=1, x^n,
          b(n, h(i-1))+expand(x*b(n-i, h(min(n-i, i)))))
        end:
    T:= n-> (p-> seq(coeff(p, x, i), i=0..n))(b(n, h(n))):
    seq(T(n), n=0..20);
  */
  private final MemoryFunction1<Integer> mH = new MemoryFunction1<Integer>() {
    @Override
    protected Integer compute(final int n) {
      if (n < 1) {
        return 0;
      }
      final int t = 5 * n * n;
      return Z.valueOf(t + 4).isSquare() || Z.valueOf(t - 4).isSquare() ? n : get(n - 1);
    }
  };

  private final MemoryFunctionInt2<Polynomial<Z>> mB = new MemoryFunctionInt2<Polynomial<Z>>() {
    @Override
    protected Polynomial<Z> compute(final int n, final int i) {
      if (n == 0 || i == 1) {
        return RING.monomial(Z.ONE, n);
      }
      return RING.add(get(n, mH.get(i - 1)), RING.shift(get(n - i, mH.get(Math.min(i, n - i))), 1));
    }
  };

  @Override
  protected Z compute(final int n, final int k) {
    return mB.get(n, mH.get(n)).coeff(k);
  }
}
#!queue	A319797	0	->	0	Triangle	--------------------------------
package irvine.oeis.a319;

import irvine.math.MemoryFunction1;
import irvine.math.MemoryFunctionInt2;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A319797 Number T(n,k) of partitions of n into exactly k positive triangular numbers; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A319797 extends Triangle {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  /** Construct the sequence. */
  public A319797() {
    super(1);
    hasRAM(true);
  }

  /* Maple:
    h:= proc(n) option remember; `if`(n<1, 0,
          `if`(issqr(8*n+1), n, h(n-1)))
        end:
    b:= proc(n, i) option remember; `if`(n=0 or i=1, x^n,
          b(n, h(i-1))+expand(x*b(n-i, h(min(n-i, i)))))
        end:
    T:= n-> (p-> seq(coeff(p, x, i), i=0..n))(b(n, h(n))):
    seq(T(n), n=0..20);
  */
  private final MemoryFunction1<Integer> mH = new MemoryFunction1<Integer>() {
    @Override
    protected Integer compute(final int n) {
      if (n < 1) {
        return 0;
      }
      return Z.valueOf(8 * n + 1).isSquare() ? n : get(n - 1);
    }
  };

  private final MemoryFunctionInt2<Polynomial<Z>> mB = new MemoryFunctionInt2<Polynomial<Z>>() {
    @Override
    protected Polynomial<Z> compute(final int n, final int i) {
      if (n == 0 || i == 1) {
        return RING.monomial(Z.ONE, n);
      }
      return RING.add(get(n, mH.get(i - 1)), RING.shift(get(n - i, mH.get(i < n - i ? i : n - i)), 1));
    }
  };

  @Override
  protected Z compute(final int n, final int k) {
    return mB.get(n, mH.get(n)).coeff(k);
  }
}
#!queue	A327371	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a327;

import irvine.math.IntegerUtils;
import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.partitions.IntegerPartition;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A327371 Triangle read by rows where T(n,k) is the number of unlabeled simple graphs with n vertices and exactly k endpoints (vertices of degree 1).
 * @author Sean A. Irvine
 */
public class A327371 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A327371() {
    super(0);
  }

  private static final Polynomial<Z> C1 = Polynomial.create(0, 0, 1);
  private final MemoryFactorial mF = MemoryFactorial.SINGLETON;
  private int mN = -1;
  private int mM = 0;
  private Polynomial<Polynomial<Z>> mGf = null;

  private static int edges(final int[] partition) {
    int cnt = 0;
    for (int i = 1; i < partition.length; ++i) {
      for (int j = 0; j < i; ++j) {
        cnt += IntegerUtils.gcd(partition[i], partition[j]);
      }
    }
    for (final int j : partition) {
      cnt += j / 2;
    }
    return cnt;
  }

  protected Polynomial<Polynomial<Z>> g(final int n) {
    final PolynomialRingField<Z> innerRing = new DegreeLimitedPolynomialRingField<>("y", IntegerField.SINGLETON, n);
    final PolynomialRingField<Polynomial<Z>> ring = new PolynomialRingField<>(innerRing);
    Polynomial<Polynomial<Z>> g = ring.zero();
    for (int k = 0; k <= n; ++k) {
      Polynomial<Polynomial<Z>> gp = ring.zero();
      final IntegerPartition part = new IntegerPartition(k);
      int[] p;
      while ((p = part.next()) != null) {
        Polynomial<Polynomial<Z>> num = ring.one();
        Polynomial<Polynomial<Z>> den = ring.one();
        for (final int v : p) {
          num = ring.multiply(num, ring.oneMinusXToTheN(v), n - k);
          den = ring.multiply(den, ring.oneMinusXToTheN(innerRing.monomial(Z.ONE, v), v), n - k);
        }
        final Polynomial<Polynomial<Z>> t = ring.multiply(ring.series(num, den, n - k), innerRing.monomial(IntegerPartition.permCount(p).shiftLeft(edges(p)), 0));
        gp = ring.add(gp, t);
      }
      g = ring.add(g, ring.divide(gp, innerRing.monomial(mF.factorial(k), 0)).shift(k));
    }
    g = ring.multiply(g, ring.oneMinusXToTheN(innerRing.x(), 2));
    return ring.series(g, ring.oneMinusXToTheN(C1, 2), n);
  }

  @Override
  public Z next() {
    if (++mM > mN) {
      mGf = g(++mN);
      mM = 0;
    }
    return mGf.coeff(mN).coeff(mM);
  }
}
#!queue	A337165	0	->	0	Triangle	--------------------------------
package irvine.oeis.a337;

import irvine.math.IntegerUtils;
import irvine.math.MemoryFunction1;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.z.Z;
import irvine.oeis.triangle.Triangle;

/**
 * A337165 Number T(n,k) of compositions of n into k nonzero squares; triangle T(n,k), n&gt;=0, 0&lt;=k&lt;=n, read by rows.
 * @author Georg Fischer
 */
public class A337165 extends Triangle {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  private static final PolynomialRingField<Z> RING = new PolynomialRingField<>(IntegerField.SINGLETON);

  /** Construct the sequence. */
  public A337165() {
    super(1);
    hasRAM(true);
  }

  /* Maple:
    b:= proc(n) option remember; `if`(n=0, 1, add((s->
         `if`(s>n, 0, expand(x*b(n-s))))(j^2), j=1..isqrt(n)))
        end:
    T:= n-> (p-> seq(coeff(p, x, i), i=0..n))(b(n)):
    seq(T(n), n=0..14);
  */
  private final MemoryFunction1<Polynomial<Z>> mB = new MemoryFunction1<Polynomial<Z>>() {
    @Override
    protected Polynomial<Z> compute(final int n) {
      if (n == 0) {
        return RING.one();
      }
      Polynomial<Z> sum = RING.zero();
      final int jmax = IntegerUtils.sqrt(n);
      for (int j = 1; j <= jmax; ++j) {
        final int s = j * j;
        if (s <= n) {
          sum = RING.add(sum, RING.shift(get(n - s), 1));
        }
      }
      return sum;
    }
  };

  @Override
  public Z compute(final int n, final int k) {
    return mB.get(n).coeff(k);
  }
}
#!queue	A339809	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a339;
// Generated by gen_seq4.pl deriv at 2021-06-28 18:44

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.Sequence;
import irvine.oeis.a019.A019565;

/**
 * A339809 a(n) = A019565(n) - 1.
 * @author Georg Fischer
 */
public class A339809 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A339809() {
    super(0);
  }

  final Sequence mA019565 = new A019565();

  @Override
  public Z next() {
    return mA019565.next().subtract(Z.ONE);
  }

}
#!queue	A342053	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a342;

import java.util.Arrays;
import java.util.function.BiFunction;

import irvine.math.factorial.MemoryFactorial;
import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.group.IntegerField;
import irvine.math.group.PolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.polynomial.PolynomialUtils;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Euler;
import irvine.math.z.Integers;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.oeis.MemorySequence;
import irvine.oeis.a002.A002712;

/**
 * A342053 Array read by antidiagonals: T(n,k) is the number of unrooted 3-connected triangulations of a disk with n interior nodes and k nodes on the boundary, n &gt;= 1, k &gt;= 3.
 * @author Sean A. Irvine
 */
public class A342053 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A342053() {
    super(1);
  }

  // After Andrew Howroyd

  // References
  // William G. Brown, Enumeration of Triangulations of the Disk, Proc. Lond. Math. Soc. s3-14 (1964) 746-768.
  // William T. Tutte, A census of planar triangulations, Canad. J. Math. 14 (1962), 21-38. See Eq. 5.12.

  // This script is for the arrays A341923 and A342053.

  // This script is for 3-connected triangulations of a disk. Brown's paper mostly covers the 2-connected case.
  // In the final section (section IV) he briefly describes how to extend the results to 3-connected, but is
  // short on detail. He also mentions that a direct route is probably much harder. The basic principle is
  // that to every 2-connected triangulation one can associate a 3-connected core. Substituting the edges on
  // the boundary of a 3-connected triangulation with possibly empty rooted 2-triangulations gives the
  // 2-connected triangulations associated with the 3-connected triangulation. Series reversion can be
  // used to reverse this process.

  // In the bivariate power series used here, x counts the external vertices (or edges) and y counts the
  // internal vertices. This is the opposite to the Brown paper. The reason for this is that PARI
  // does series reversion only on the primary series variable - in this case we are considering
  // substitutions on the external edges.

  // See also PARI script in A169808 which is the for the 2-connected case.

  private static final PolynomialRingField<Z> INNER = new PolynomialRingField<>("y", IntegerField.SINGLETON);
  static final PolynomialRingField<Polynomial<Z>> RING = new PolynomialRingField<>(INNER);
  private static final MemoryFactorial F = MemoryFactorial.SINGLETON;
  private static final Polynomial<Polynomial<Z>> X3 = RING.monomial(INNER.one(), 3);
  private static final Polynomial<Z> NEG_ONE = INNER.negate(INNER.one());
  private static final Polynomial<Z> TWO = INNER.monomial(Z.TWO, 0);
  private static final Polynomial<Z> Y2 = INNER.monomial(Z.ONE, 2);

  private static PolynomialRingField<Polynomial<Z>> r(final int n) {
    return new PolynomialRingField<>(new DegreeLimitedPolynomialRingField<>("y", IntegerField.SINGLETON, n));
  }

  // Rooted disk triangulations

  // A146305: Biconnected with n internal nodes and m+3 external nodes.
  final BiFunction<Integer, Integer, Z> mD = (n, m) -> F.factorial(2 * m + 3).multiply(F.factorial(4 * n + 2 * m + 1)).multiply2()
    .divide(F.factorial(m).multiply(F.factorial(m + 2)).multiply(F.factorial(n)).multiply(F.factorial(3 * n + 2 * m + 3)));

  // A341856: 3-connected
  final BiFunction<Integer, Integer, Z> mW = (n, m) -> m == 0
    ? F.factorial(4 * n + 1).multiply2().divide(F.factorial(3 * n + 2).multiply(F.factorial(n + 1)))
    : F.factorial(m + 2).multiply(F.factorial(m - 1).multiply(3))
    .multiply(Integers.SINGLETON.sum(0, Math.min(m, n - 1), j -> F.factorial(4 * n + 3 * m - j + 1).multiply(m + j + 2).multiply(m - 3L * j).divide(F.factorial(j).multiply(F.factorial(j + 1)).multiply(F.factorial(m - j)).multiply(F.factorial(m - j + 2)).multiply(F.factorial(n - j - 1))))).divide(F.factorial(3 * n + 3 * m + 3));

  // Triangulations with Rotational Symmetry
  final BiFunction<Integer, Integer, Z> mEr = (s, p) -> F.factorial(2 * p + 2).multiply(F.factorial(4 * s + 2 * p + 1))
    .divide(F.factorial(p).multiply(F.factorial(p + 1)).multiply(F.factorial(s)).multiply(F.factorial(3 * s + 2 * p + 2)));

  // E3(s,p)={(2*p+1)!*(4*s+2*p)!/(p!*p!*s!*(3*s+2*p+1)!)}
  final BiFunction<Integer, Integer, Z> mE3 = (s, p) -> F.factorial(2 * p + 1).multiply(F.factorial(4 * s + 2 * p))
    .divide(F.factorial(p).square().multiply(F.factorial(s)).multiply(F.factorial(3 * s + 2 * p + 1)));

  @FunctionalInterface
  interface TriFunction<A, B, C, R> {
    R apply(final A s, final B j, final C p);
  }

  // E2(s,j,p)=2*(2*p)!*(4*s+2*p+2*j-1)!/(p!*(p-1)!*s!*(3*s+2*p+2*j)!)
  final TriFunction<Integer, Integer, Integer, Z> mE2 = (s, j, p) -> F.factorial(2 * p).multiply(F.factorial(4 * s + 2 * p + 2 * j - 1)).multiply2()
    .divide(F.factorial(p).multiply(F.factorial(p - 1)).multiply(F.factorial(s)).multiply(F.factorial(3 * s + 2 * p + 2 * j)));

// // Oriented triangulations.
// // See 6.3 in Brown.
// // A262586: 2-connected
// OrientedTriangs(n,m)={(D(n,m) + if(m%2==1, E2(n\2, n%2, (m+1)/2)) + if(gcd(m,n)%3==0, 2*E3(n/3, m/3)) + sumdiv(gcd(m+3,n-1), d, if(d>2, eulerphi(d)*Er((n-1)/d, (m+3)/d-1))))/(m+3)}
//
// // Helper to make matrix from bivariate g.f.
// BgfToArray(gf, N, M)={matrix(N+1, M+1, n, m, polcoeff(polcoeff(gf, n-1, x), m-1, y))}

  // Helper to make bivariate g.f. from a function. Transposes function.
  Polynomial<Polynomial<Z>> makeSquareBgfTr(final BiFunction<Integer, Integer, Z> fun, final int n, final int m, final int yStep) {
    final Polynomial<Polynomial<Z>> sum = RING.empty();
    for (int k = 0; k <= n; ++k) {
      final Polynomial<Z> s = INNER.empty();
      for (int j = 0; j <= m; ++j) {
        s.add(fun.apply(j, k));
        for (int i = 1; i < yStep; ++i) {
          s.add(Z.ZERO);
        }
      }
      sum.add(s);
    }
    return sum;
  }

  // Substitutes x with x^e and y with y^e in s.
  private Polynomial<Polynomial<Z>> bgfRaise(final Polynomial<Polynomial<Z>> s, final int e) {
    return RING.deepSubstitute(s, e);
  }

  // Does an inversion for rotational symmetry.
  // The functional equation we are inverting is:
  //      P(x,y) = F'(x,y) * Z(F(x,y), y)
  // where P(x,y) give the number of 2-connected triangulations with some rotational symmetry
  // and Z(x,y) is the corresponding number of 3-connected triangulations that we wish to calculate.
  // Here F(x,y) gives the number of possibly empty triangulations rooted at an edge.
  // F(x,y) is in Brown's paper x*(1 + x*D(y,x)) = x*Dbar(y,x).
  // Note F'(x,y) is d/dx of F(x,y)
  // To invert this we integrate both sides applying the chain rule and then use Lagrangian inversion.
  // The method parameters are bgf=P(x,y) and Fi(x,y) the series reversion of F(x,y).
  Polynomial<Polynomial<Z>> invHelp(final int m, final Polynomial<Polynomial<Z>> bgf, final Polynomial<Polynomial<Z>> fi) {
    // Intermediate result here is rational, so need to promote to over Q
    final PolynomialRingField<Polynomial<Q>> ring = new PolynomialRingField<>(new DegreeLimitedPolynomialRingField<>("y", Rationals.SINGLETON, m));
    return PolynomialUtils.qxToZx(ring.diff(ring.substitute(ring.integrate(PolynomialUtils.zxToQx(bgf)), PolynomialUtils.zxToQx(fi), bgf.degree() + 1)));
  }

  // Main method for oriented triangulations - returns bivariate g.f.
  Polynomial<Polynomial<Z>> orientedStrongTriangsGf(final int m, final int n) {
    final PolynomialRingField<Polynomial<Z>> ring = r(n);
    final Polynomial<Polynomial<Z>> fi = bgfTrim(ring.reversion(ring.add(ring.x(), makeSquareBgfTr(mD, m / 2, n / 2, 1).shift(2)), m), m, n / 2);
    final Polynomial<Polynomial<Z>> gr = invHelp(n / 3, makeSquareBgfTr(mEr, m / 3, n / 3, 1), fi).shift(1);
    final Polynomial<Polynomial<Z>> a = makeSquareBgfTr(mW, m - 3, n, 1).shift(3);
    final Polynomial<Polynomial<Z>> b = bgfRaise(invHelp(n / 2, ring.add(ring.one(), makeSquareBgfTr((s, q) -> mE2.apply(s, 0, q + 1), m / 2, n / 2, 1).shift(1)), fi).shift(1), 2);
    final Polynomial<Polynomial<Z>> c = PolynomialUtils.innerShift(ring, bgfRaise(invHelp(n / 2, makeSquareBgfTr((s, q) -> mE2.apply(s, 1, q + 1), m / 2, n / 2, 1).shift(1), fi).shift(1), 2), 1);
    final Polynomial<Polynomial<Z>> d = ring.multiply(bgfRaise(invHelp(n / 3, makeSquareBgfTr(mE3, m / 3, n / 3, 1), fi).shift(1), 3), TWO);
    final Polynomial<Polynomial<Z>> e = PolynomialUtils.innerShift(ring, ring.sum(3, m, k -> ring.multiply(bgfRaise(bgfTrim(gr, m / k + 1, n / k + 1), k), Polynomial.create(Euler.phiAsLong((long) k)))), 1);
    final Polynomial<Polynomial<Z>> p = ring.add(a, b, c, d, e);
    return ring.integrate(ring.subtract(p.shift(-1), ring.x())).truncate(m);
  }

  // Sequences for OrientedStrongTriangsGf.
  // A341923Array(N,M)={BgfToArray(OrientedStrongTriangsGf(M+2,N)/(y*x^3), M-1, N-1)~}

  protected Z a341923(final int n, final int k) {
    return orientedStrongTriangsGf(k + 3, n).coeff(k + 3).coeff(n);
  }

  protected Polynomial<Z> a341923ColSeq(final int n, final int k) {
    return RING.subtract(orientedStrongTriangsGf(k, n), X3).coeff(k);
  }

// A341923RowSeq(N,k)={Vec(polcoeff(OrientedStrongTriangsGf(N,k), k, y))}
// A341923AntidiagonalSums(N)=Vec(subst(OrientedStrongTriangsGf(N+3,N), y, x)-x^3)

  // Triangles with Reflection symmetry.

  // Trims a bivariate g.f. to required precision (both x and y)
  private Polynomial<Polynomial<Z>> bgfTrim(final Polynomial<Polynomial<Z>> s, final int n, final int m) {
    final Polynomial<Polynomial<Z>> res = RING.empty();
    for (int k = 0; k < Math.min(s.size(), n); ++k) {
      res.add(s.coeff(k).truncate(m));
    }
    return res;
  }

  // J_0 function (sequence A002712 as g.f.)
  // See 13.10: Satisfies J = 1 + x*J + x^2*J*(1 + x*J/2)*(J^2 - D(x^2, 0)).
  // Compute by iteratively growing precision.
// Jgf(n,x='x)={my(q=Ser(vector(n+1, i, if(i%2, D(i\2, 0))), x), p=1+O(x)); for(n=1, n, p = 1 + x*p + x^2*p*(1 + x*p/2)*(p^2 - q)); p}

  private final MemorySequence mJ = MemorySequence.cachedSequence(new A002712());

  Polynomial<Z> jgf(final int n) {
    mJ.a(n); // Force enough terms
    return INNER.create(mJ.toList());
  }

  // Q1, Q2, Q3: The first is for an odd number of external vertices, the other two are for even.
  //   __        ___         __
  //  |   \     |   |      /    \
  //  |__ /     |___|      \ __ /
  // These have respectively 1, 0 and 2 external vertices on the symmetry line.
  // The relation of these to K(x,y) and L(x,y) given by Brown follows.
  // Let P1(x,y) be even terms of K(y,x) or even terms of L(y,x), P2(x,y) be odd terms of K(y,x) and P3(x,y) be odd terms of L(y,x).
  // More precisely 2*P1(x^2,y) = K(y,x) + K(y,-x) = L(y,x) + L(y,-x); 2*x*P2(x^2,y) = K(y,x) - K(y,-x); 2*x*P3(x^2,y) = L(y,x) - L(y,-x).
  // P1, P2, P3 enumerate 2-connected triangulations with reflection symmetry with the types shown above.
  // Q1, Q2, Q3 will enumerate the same triangulations but without edges that cross the symmetry line
  // or in the case of Q3 join the two external vertices on the symmetry line.
  // These are related to P1, P2, P3 by the following:
  //    Q1 = P1/(1 + x*P2); Q2 = P2/(1 + x*P2); Q3 = P3 - P1*Q1 - (D-1)/x.
  // The following functions give Q1, Q2, Q3 in terms of D,J,x,y (see Brown/A169808/below for meaning of D/J)
  // In the case of Q2 and Q3 we actually multiply by an extra x to keep denominators consistent.

  // Q1(D,J,x,y)={(y^3*J^2 + y^2*J - x)*D/(y*(y^2*J + x)*D + (-x + y^2))}
  Polynomial<Polynomial<Z>> q1(final Polynomial<Polynomial<Z>> d, final Polynomial<Z> j) {
    final Polynomial<Polynomial<Z>> t = RING.create(Arrays.asList(
      INNER.add(j.shift(2), INNER.multiply(j, j, j.degree()).shift(3)),
      NEG_ONE
    ));
    final Polynomial<Polynomial<Z>> num = RING.multiply(t, d);
    final Polynomial<Polynomial<Z>> u = RING.create(Arrays.asList(j.shift(3), INNER.x()));
    final Polynomial<Polynomial<Z>> v = RING.create(Arrays.asList(Y2, NEG_ONE));
    final Polynomial<Polynomial<Z>> den = RING.add(RING.multiply(u, d, d.degree()), v);
    final PolynomialRingField<Polynomial<Z>> ring = r(j.degree());
    return ring.series(num, den, d.degree());
  }

  // Q2(D,J,x,y)={(((-y^2*x + y^3)*J - y*x)*D + (y*x - y^3)*J) / (y*(y^2*J + x)*D + (-x + y^2))}
  Polynomial<Polynomial<Z>> q2(final Polynomial<Polynomial<Z>> d, final Polynomial<Z> j) {
    final Polynomial<Polynomial<Z>> t = RING.create(Arrays.asList(
      Polynomial.create(0, 0, 0, 1),
      INNER.negate(Y2)
    ));
    final Polynomial<Polynomial<Z>> t1 = RING.subtract(RING.multiply(t, j), RING.monomial(INNER.x(), 1));
    final Polynomial<Polynomial<Z>> w = RING.create(Arrays.asList(INNER.negate(j.shift(3)), j.shift(1)));
    final Polynomial<Polynomial<Z>> num = RING.add(RING.multiply(t1, d, d.degree()), w);
    final Polynomial<Polynomial<Z>> u = RING.create(Arrays.asList(j.shift(3), INNER.x()));
    final Polynomial<Polynomial<Z>> v = RING.create(Arrays.asList(Y2, NEG_ONE)); // todo constant
    final Polynomial<Polynomial<Z>> den = RING.add(RING.multiply(u, d, d.degree()), v);
    final PolynomialRingField<Polynomial<Z>> ring = r(j.degree());
    return ring.series(num, den, num.degree());
  }

  // Q3(D,J,x,y)={(((-y^2*x*J - x^2)*D + (y^2*x*J^2 + y*x*J - y*x))/(y*(y^2*J + x)*D + (-x + y^2)) - 1)*D + 1}
  Polynomial<Polynomial<Z>> q3(final Polynomial<Polynomial<Z>> d, final Polynomial<Z> j) {
    final Polynomial<Polynomial<Z>> t = RING.create(Arrays.asList(
      INNER.zero(),
      INNER.negate(j.shift(2)),
      NEG_ONE
    ));
    final Polynomial<Polynomial<Z>> w = RING.monomial(INNER.add(INNER.multiply(j, j, j.degree()).shift(2), j.shift(1), INNER.negate(INNER.x())), 1);
    final Polynomial<Polynomial<Z>> num = RING.add(RING.multiply(t, d, d.degree()), w);
    final Polynomial<Polynomial<Z>> u = RING.create(Arrays.asList(j.shift(3), INNER.x()));
    final Polynomial<Polynomial<Z>> v = RING.create(Arrays.asList(Y2, NEG_ONE)); // todo constant
    final Polynomial<Polynomial<Z>> den = RING.add(RING.multiply(u, d, d.degree()), v);
    final PolynomialRingField<Polynomial<Z>> ring = r(j.degree());
    return RING.add(RING.multiply(RING.subtract(ring.series(num, den, d.degree()), RING.one()), d, d.degree()), RING.one());
  }

  // Main method for achiral triangulations - returns bivariate g.f.
  Polynomial<Polynomial<Z>> achiralStrongTriangsGf(final int m, final int n) {
    final PolynomialRingField<Polynomial<Z>> ring = r(2 * n + 1);
    final Polynomial<Polynomial<Z>> ds = RING.add(RING.one(), makeSquareBgfTr(mD, m - 1, n + m - 1, 2).shift(1));
    final Polynomial<Polynomial<Z>> fi = bgfRaise(ring.reversion(RING.add(RING.x(), makeSquareBgfTr(mD, m, n, 1).shift(2)), m + 2), 2);
    final Polynomial<Z> j = jgf(2 * (n + m));
    final Polynomial<Polynomial<Z>> q1 = bgfTrim(q1(ds, j), m + 1, 2 * n + 1);
    final Polynomial<Polynomial<Z>> q2 = bgfTrim(RING.leftTruncate(q2(ds, j), 1), m + 1, 2 * n + 1);
    final Polynomial<Polynomial<Z>> q3 = bgfTrim(RING.leftTruncate(q3(ds, j), 1), m + 1, 2 * n + 1);
    final Polynomial<Polynomial<Z>> a = RING.subtract(RING.substitute(q1.shift(1), fi, Integer.MAX_VALUE).shift(1), X3);
    return RING.add(a, ring.divide(RING.add(
          RING.substitute(q2, fi, j.degree()).shift(2),
          RING.substitute(q3.shift(1), fi, j.degree())),
        TWO));
  }

  // Sequences for unrooted triangulations
// A342053Array(N,M)={(BgfToArray(AchiralStrongTriangsGf(M\2, (N+1)\2)/(y*x^3), M-1, N-1)~ + A341923Array(N,M))/2}

  protected Z a342053(final int n, final int kk) {
    final int k = kk + 3;
    return achiralStrongTriangsGf(Math.max(0, k / 2 - 1), (n + 1) / 2).coeff(k).coeff(n).add(a341923(n, kk)).divide2();
  }

// A342053ColSeq(N,k)={(Vec(O(y*y^N) + polcoeff(AchiralStrongTriangsGf(max(0,k\2-1),(N+1)\2),k), N) + A341923ColSeq(N,k))/2}

  protected Polynomial<Z> a342053ColSeq(final int n, final int k) {
    return INNER.divide(INNER.add(achiralStrongTriangsGf(Math.max(0, k / 2 - 1), (n + 1) / 2).coeff(k), a341923ColSeq(n, k)), Z.TWO);
  }

  // A342053RowSeq(N,k)={(Vec(O(x*x^N) + polcoeff(AchiralStrongTriangsGf(N\2-1, (k+1)\2), k, y)) + A341923RowSeq(N,k))/2}
// A342053AntidiagonalSums(N)={(Vec(O(x^(N+4)) + subst(AchiralStrongTriangsGf((N+1)\2,(N+1)\2), y, x)) + A341923AntidiagonalSums(N))/2}

  private int mN = 0;
  private int mM = 0;

  @Override
  public Z next() {
    if (++mM > mN) {
      ++mN;
      mM = 1;
    }
    return a342053(mM, mN - mM);
  }
}
#!queue	A343146	0	->	0	AbstractSequence	--------------------------------
package irvine.oeis.a343;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;
import irvine.util.Permutation;

/**
 * A343146 Number of move sequences of length 2n on the "8 Puzzle" which leave the final state unchanged when the empty cell starts in a corner.
 * @author Sean A. Irvine
 */
public class A343146 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A343146() {
    super(0);
  }

  // We use four bits per cell with 0 for the empty cell

  // Cell numbering:
  // +-+-+-+
  // |8|7|6|
  // +-+-+-+
  // |5|4|3|
  // +-+-+-+
  // |2|1|0|
  // +-+-+-+

  private static final int BITS_PER_CELL = 4;
  private static final long CELL_MASK = (1L << BITS_PER_CELL) - 1;
  protected static final long START_STATE = 0b0001_0010_0011_0100_0101_0110_0111_1000_0000L;
  private static final int[][] MOVE_DELTAS = {
    {1, 3},
    {-1, 1, 3},
    {-1, 3},
    {-3, 1, 3},
    {-3, -1, 1, 3},
    {-3, -1, 3},
    {-3, 1},
    {-3, -1, 1},
    {-3, -1}
  };

  private static int findEmpty(final long state) {
    int empty = 0;
    long mask = CELL_MASK;
    while ((state & mask) != 0) {
      mask <<= BITS_PER_CELL;
      ++empty;
    }
    assert empty <= 8;
    return empty;
  }

  protected final Map<Long, Integer> mStateToId = new HashMap<>();
  protected int[][] mTransitions = null;
  protected int mTargetId = 0;
  private Z[] mCounts;

  protected void init() {
    if (mTransitions == null) {
      // Precompute all possible transitions
      // Assign each possible state a unique id
      final Permutation perm = new Permutation(9);
      int[] p;
      while ((p = perm.next()) != null) {
        long s = 0;
        for (final int v : p) {
          s <<= BITS_PER_CELL;
          s += v;
        }
        mStateToId.put(s, mStateToId.size());
      }
      mTargetId = mStateToId.get(targetState());
      // Compute transition matrix between states
      mTransitions = new int[mStateToId.size()][];
      for (final Map.Entry<Long, Integer> e : mStateToId.entrySet()) {
        final long s = e.getKey();
        final int id = e.getValue();
        final int empty = findEmpty(s);
        mTransitions[id] = new int[MOVE_DELTAS[empty].length];
        for (int k = 0; k < MOVE_DELTAS[empty].length; ++k) {
          final long delta = MOVE_DELTAS[empty][k];
          final long dmask = CELL_MASK << (BITS_PER_CELL * (empty + delta));
          final long clear = s & ~dmask;
          final long set = s & dmask;
          final long shift = delta > 0 ? set >>> (BITS_PER_CELL * delta) : set << (BITS_PER_CELL * -delta);
          mTransitions[id][k] = mStateToId.get(clear + shift);
        }
      }
    }
  }

  protected long targetState() {
    return START_STATE;
  }

  private Z[] step(final Z[] counts) {
    final Z[] newCounts = new Z[counts.length];
    Arrays.fill(newCounts, Z.ZERO);
    for (int k = 0; k < counts.length; ++k) {
      final Z t = counts[k];
      for (final int j : mTransitions[k]) {
        newCounts[j] = newCounts[j].add(t);
      }
    }
    return newCounts;
  }

  @Override
  public Z next() {
    init();
    if (mCounts == null) {
      mCounts = new Z[mTransitions.length];
      Arrays.fill(mCounts, Z.ZERO);
      mCounts[mStateToId.get(START_STATE)] = Z.ONE;
    } else {
      mCounts = step(mCounts);
      mCounts = step(mCounts);
    }
    return mCounts[mTargetId];
  }
}
#!queue	A350795	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a350;

import java.util.List;

import irvine.math.graph.Edges;
import irvine.math.graph.GraphUtils;
import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A350795 Triangle read by rows: T(n,k) is the number of digraphs on n unlabeled nodes with k arcs and a global source and sink, n &gt;= 1, k = 0..max(1,n-1)*(n-2)+1.
 * @author Sean A. Irvine
 */
public class A350795 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A350795() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;
  private Polynomial<Q> mRow = Polynomial.create(Q.ZERO);

  protected Polynomial<Q> gfRow(final int n, final int m) {
    final int t = Math.min(m, n * (n - 1)) + 1;
    final DegreeLimitedPolynomialRingField<Q> fld = new DegreeLimitedPolynomialRingField<>("y", Rationals.SINGLETON, t);
    final List<List<Polynomial<Q>>> graphs = GraphUtils.graphCycleIndexData(fld, n, Edges.DIGRAPH_EDGES, e -> fld.onePlusXToTheN(e));
    final Polynomial<Polynomial<Q>> res = GraphUtils.initiallyFinallyV(fld, graphs, e -> fld.onePlusXToTheN(e));
    return res.coeff(n);
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      mRow = gfRow(++mN, mN * (mN - 1));
      mM = 0;
    }
    return mRow.coeff(mM).toZ();
  }
}
#!queue	A350797	1	->	1	AbstractSequence	--------------------------------
package irvine.oeis.a350;

import java.util.List;

import irvine.math.graph.Edges;
import irvine.math.graph.GraphUtils;
import irvine.math.group.DegreeLimitedPolynomialRingField;
import irvine.math.polynomial.Polynomial;
import irvine.math.q.Q;
import irvine.math.q.Rationals;
import irvine.math.z.Z;
import irvine.oeis.AbstractSequence;

/**
 * A350797 Triangle read by rows: T(n,k) is the number of digraphs on n unlabeled nodes with k arcs and a global source (or sink), n &gt;= 1, k = 0..(n-1)^2.
 * @author Sean A. Irvine
 */
public class A350797 extends AbstractSequence {

  /**
   * Constructor with offset.
   * @param offset first index
   */
  protected $(ASEQNO)(final int offset) {
    super(offset);
  }

  /** Construct the sequence. */
  public A350797() {
    super(1);
  }

  private int mN = 0;
  private int mM = 0;
  private Polynomial<Q> mRow = Polynomial.create(Q.ZERO);

  protected Polynomial<Q> gfRow(final int n, final int m) {
    final int t = Math.min(m, (n - 1) * (n - 1));
    final DegreeLimitedPolynomialRingField<Q> fld = new DegreeLimitedPolynomialRingField<>("y", Rationals.SINGLETON, t);
    final List<List<Polynomial<Q>>> graphs = GraphUtils.graphCycleIndexData(fld, n, Edges.DIGRAPH_EDGES, e -> fld.onePlusXToTheN(e));
    final Polynomial<Polynomial<Q>> res = GraphUtils.initiallyV(fld, graphs, e -> fld.onePlusXToTheN(e));
    return res.coeff(n);
  }

  @Override
  public Z next() {
    if (++mM > mRow.degree()) {
      mM = 0;
      mRow = gfRow(++mN, (mN - 1) * (mN - 1));
    }
    return mRow.coeff(mM).toZ();
  }
}
#!queue	A999999	0	0	0	0
