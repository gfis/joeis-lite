#!perl

# Extract parameters for nested sequences a(n) = A111111(A222222(n))
# 2023-09-07: *.jpat in ./pattern
# 2020-12-16, Georg Fischer: copied from genet.pl
#
#:# Usage:
#:#   grep ... $(COMMON)/cat25.txt | cut -b4-1 | sed ... \
#:#   | perl nest.pl [-d debug] [-f ofter_file] > output
#:#     -d  debugging level (0=none (default), 1=some, 2=more)
#:#     -f  file with aseqno, offset1, terms (default $(COMMON)/joeis_ofter.txt)
#:# Reads ofter_file for implemented jOEIS sequences with their offsets and first terms
#--------------------------------------------------------
use strict;
use integer;
use warnings;

my $line = "";
my ($aseqno, $callcode, $offset);
my $rseqno;
my $ofter_file = "../../../OEIS-mat/common/joeis_ofter.txt";
my $debug   = 0;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt = shift(@ARGV);
    if (0) {
    } elsif ($opt   =~ m{\-d}  ) {
        $debug      = shift(@ARGV);
    } elsif ($opt   =~ m{\-f}  ) {
        $ofter_file = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt
#----------------
my $terms;
my %ofters = ();
open (OFT, "<", $ofter_file) || die "cannot read $ofter_file\n";
while (<OFT>) {
    s{\s+\Z}{};
    ($aseqno, $offset, $terms) = split(/\t/);
    $terms = $terms || "";
    if ($offset < -1) { # offsets -2, -3: strange, skip these
    } else {
        $ofters{$aseqno} = "$offset\t$terms";
    }
} # while <OFT>
close(OFT);
print STDERR "# $0: " . scalar(%ofters) . " jOEIS offsets and some terms read from $ofter_file\n";
# A000001 0       0,1,1,1,2,1,2
# A000002 1       1,2,2,1,1,2,1
#----------------
my @parms;
my ($name);

$callcode = "nest";
while (<>) { # cat25 without type code, with 1 tab, author removed
    s/\s+\Z//; # chompr
    $line = $_;
    ($aseqno, $name) = split(/\t/, $line);
    $name =~ s{ }{}g; # remove spaces
    $name =~ s{\..*}{}; # remove all behind dot
    #                (1    1) (2 (3  3)  (4  4)      2)
    if ($name =~ m{\A(a\(n\))?(\=(A\d+)\((A\d+)\(n\)\))+\Z}) {
        $name =~ s{\A(a\(n\))\=}{};
        foreach my $pair (split(/\=/, $name)) {
            $pair =~ m{(A\d+)\((A\d+)};
            my ($rseqno1, $rseqno2) = ($1, $2);
            if (defined($ofters{$rseqno1}) and defined($ofters{$rseqno2})) {
                my $roffset1 = $ofters{$rseqno1};
                $roffset1 =~ s{\t.*}{}; # remove terms
                print join("\t", $aseqno, $callcode, 0, $rseqno1, $rseqno2, $roffset1, "", $name) . "\n";
            }
        } # foreach $pair
    } # if proper name
} # while <>
&write_jpats();
#================================
sub output { # global $line, @periods, $reason
#    print join("\t", $aseqno, $callcode, $offset, @parms, $kstart, $form) . "\n";
} # output
#================================
sub write_jpats {
#----
    my $pat_head = <<'GFis';
package irvine.oeis.$(PACK);
// Generated by $(GEN) $(CALLCODE) at $(DATE)
// DO NOT EDIT here!

import irvine.oeis.NestedSequence;

/**
 * $(ASEQNO) $(NAME)
 * Formula: <code>a(n) = $(PARM1)($(PARM2)(n)).</code>
 * @author $(AUTHOR)
 */
public class $(ASEQNO) extends NestedSequence {

  /** Construct the sequence. */
  public $(ASEQNO)() {
    super($(OFFSET), new $(PARM1)(), new $(PARM2)(), $(PARM3), $(PARM4)); 
  }

GFis
    my $pat_tail= <<'GFis';
}
GFis
#----
    foreach my $cc ("") {
        my $jpat_name = "nest$cc.jpat";
        open (JPAT, ">", "./pattern/$jpat_name") or die "cannot write \",/pattern/$jpat_name\"";
        print JPAT $pat_head;
        print JPAT $pat_tail;
        close(JPAT);
    } # foreach
} # sub write_jpats
#----
# old code:
sub write_jpats_99 {
#----
    my $pat_head = <<'GFis';
package irvine.oeis.$(PACK);
// Generated by $(GEN) $(CALLCODE) at $(DATE)
// DO NOT EDIT here!

import irvine.math.z.Z;

/**
 * $(ASEQNO) $(NAME)
 * Formula: <code>a(n) = $(PARM1)($(PARM2)(n)).</code>
 * @author $(AUTHOR)
 */
public class $(ASEQNO) extends $(PARM1) {

  protected Sequence mSeqB;
  protected int mNA;
  protected Z mTermA;
  protected int mTermB;

  /** Construct the sequence. */
  public $(ASEQNO)() {
    mSeqB = new $(PARM2)();
    mNA = $(PARM3) - 1;
    mTermB = mSeqB.next().intValue();
    mTermA = null;
  }

GFis
    my $pat_tail= <<'GFis';
  @Override
  public Z next() {
    while (mNA < mTermB || mTermA == null) {
      ++mNA;
      mTermA = super.next(); 
    }
    mTermB = mSeqB.next().intValue();
    return mTermA;
  }

}
GFis
#----
    foreach my $cc ("") {
        my $jpat_name = "nest$cc.jpat";
        open (JPAT, ">", $jpat_name) or die "cannot write \"$jpat_name\"";
        print JPAT $pat_head;
        print JPAT $pat_tail;
        close(JPAT);
    } # foreach
} # sub write_jpats
#================
__DATA__
