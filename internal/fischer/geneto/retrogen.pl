#!perl
# Regenerate genet.gen from the sources
# 2023-06-15, Georg Fischer
#
#:# Usage:
#:#   cat oldsrc/*.java \
#:#   | perl retrogen.pl > retrogen.gen
#----------------
use strict;
use integer;
use warnings;

my $debug  = 0;
my $cc     = "genet";
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt =     shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{cc}) {
        $cc     = shift(@ARGV);
    } elsif ($opt  =~ m{d}) {
        $debug  = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

my $state = 0;
my ($aseqno, $code, %parm, $offset, $kstart, $parmno, $callcode);
$parmno = 0;
$aseqno = "A000000";
while (<>) {
    my $line = $_;
    $line =~ s/\s+\Z//; # chompr
    if ($debug >= 1) {
        print STDERR "$state $parmno $line\n";
    }
    if (0) {
    } elsif (               ($line =~ m{\Apackage}                          )) {
        if ($state != 0) {
            print STDERR "# $aseqno not properly closed, state=$state\n";
        }
        $state       = 0;
    } elsif ($state == 0 && ($line =~ m{\Apublic class (A\d+) } )) {
        $state       = 1;
        $aseqno      = $1;
        $parmno      = 1;
        %parm = ()

    } elsif ($state == 1 && ($line =~ m{\A  public $aseqno\(}   )) { # start of constructor
        $state       = 2;
        $parm{$parmno} = "~~    ";
    } elsif ($state == 2 && ($line =~ m{\A  \}}                 )) { # end of constructor
        $state       = 3; 
    } elsif ($state == 2)                                          { # in body of contructor
        $line =~ s{\A *}{};
        if ($line =~ m{super\((\d+)\, *(\d+)\)}) {
          ($offset, $kstart) = ($1, $2);
        }
        $parm{$parmno} .= "~~$line";

    } elsif ($state == 3 && ($line =~ m{\A\}}                   )) { # end of class
        $callcode    = $cc;
        $callcode   .= "f" if defined($parm{2});
        $callcode   .= "g" if defined($parm{3});
        $callcode   .= "h" if defined($parm{4});
        $callcode    =~ s{fgh}{}; # "genet" only
        $state       = 0; # proper end of class
        $parmno      = 0;
        print join("\t", $aseqno, $callcode, $offset
            , $parm{1} || "", $parm{2} || "", $parm{3} || "", $parm{4} || ""
            , $kstart, "", "", "", "", "", "") . "\n"; # write the seq4 record

    } elsif ($state == 3 && ($line =~ m{\A  protected Z(\[\])? advance([FGH])} )) { #start of advanceX method
        $code        = lc($2);
        $parmno      = $code;
        $parmno      =~ tr{fgh}{234};
        if ($parmno !~ m{\A[234]\Z}) {
            print STDERR "# invalid parmno=$parmno in $aseqno\n";
        }
        $state       = 4;
    } elsif ($state == 4 && ($line =~ m{\A +return ([^\;]+)\;}  )) { # return in advanceX
        my $ret      = $1;
        $ret =~ s{( *new +Z\[\] *\{ *| *\})}{}g;
        $ret =~ s{FACTORIAL}{MemoryFactorial.SINGLETON}g;
        $parm{$parmno} = $ret;
    } elsif ($state == 4 && ($line =~ m{\A   *\}}               )) { # end of advanceX method
        $state       = 3;
    } else {
        # ignore
    }
} # while <>
__DATA__
A265833	genetgh	0	~~    ~~super($(OFFSET), 1);~~mNextH = advanceH(mKh);	Z.ONE	Z.valueOf((5*mKh-3))	Z.valueOf((5*k-3))	1	1/(1-(5*k-3)*x^(5*k-3))	1	1/(1-(5*k-3)*x^(5*k-3))	Expansion of Product_{k>=1} 1/(1 - (5*k-3)*x^(5*k-3)).

package irvine.oeis.a265;
// Generated by gen_seq4.pl genetgh at 2020-12-16 11:03
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.transform.GeneralizedEulerTransform;


/**
 * A265833 Expansion of Product_{k&gt;=1} 1/(1 - (5*k-3)*x^(5*k-3)).
 * G.f.: <code>Product_{k&gt;=1} (1/(1-(5*k-3)*x^(5*k-3)))</code>
 * @author Georg Fischer
 */
public class A265833 extends GeneralizedEulerTransform {

  /** Construct the sequence. */
  public A265833() {
    super(0, 1);
    mNextH = advanceH(mKh);
  }

  @Override
  protected Z advanceG(final long k) {
    return Z.valueOf(5 * mKh - 3);
  }

  @Override
  protected Z advanceH(final long k) {
    return Z.valueOf(5 * k - 3);
  }

}

# genet.jpat:
package irvine.oeis.$(PACK);
// Generated by $(GEN) $(CALLCODE) at $(DATE)

import irvine.math.z.Z;
import irvine.oeis.transform.GeneralizedEulerTransform;

/**
 * $(ASEQNO) $(NAME)
 * G.f.: <code>Product_{k&gt;=$(PARM5)} ($(PARM6))</code>
 * @author $(AUTHOR)
 */
public class $(ASEQNO) extends GeneralizedEulerTransform {

  /** Construct the sequence. */
  public $(ASEQNO)() {
$(PARM1)
  }

  @Override
  protected Z[] advanceF(final long k) {
    return new Z[] { $(PARM2) };
  }

  @Override
  protected Z advanceG(final long k) {
    return $(PARM3);
  }

  @Override
  protected Z advanceH(final long k) {
    return $(PARM4);
  }

}