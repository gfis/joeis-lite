#!perl
# Regenerate genet.gen from the sources
# 2023-06-15, Georg Fischer
#
#:# Usage:
#:#   cat oldsrc/*.java \
#:#   | perl retrogen.pl > retrogen.gen
#----------------
use strict;
use integer;
use warnings;

my $debug  = 0;
while (scalar(@ARGV) > 0 and ($ARGV[0] =~ m{\A[\-\+]})) {
    my $opt =     shift(@ARGV);
    if (0) {
    } elsif ($opt  =~ m{d}) {
        $debug  = shift(@ARGV);
    } else {
        die "invalid option \"$opt\"\n";
    }
} # while $opt

my $state = 0;
my ($aseqno, $code, %parm, $offset, $kstart, $parmno);
$aseqno = "A000000";
while (<>) {
    my $line = $_;
    $line =~ s/\s+\Z//; # chompr
    if ($debug >= 1) {
    	print STDERR "$state $line\n";
    }
    if (0) {
    } elsif (               ($line =~ m{\Apackage}                          )) {
    	if ($state != 0) {
    	    print STDERR "# $aseqno not properly closed, state=$state\n";
    	}
        $state       = 0;
    } elsif ($state == 0 && ($line =~ m{\Apublic class (A\d+) }             )) {
        $state       = 1;
        $aseqno      = $1;
        %parm = ()

    } elsif ($state == 1 && ($line =~ m{\A  public $aseqno\(}               )) {
        $state       = 2;
        $parm{1}     = "~~    ";
    } elsif ($state == 2 && ($line =~ m{\A  \}}                             )) {
        $state       = 3;
    } elsif ($state == 2) { # append to body of contructor
        $line =~ s{\A *}{};
        if ($line =~ m{super\((\d+)\, *(\d+)\)}) {
          ($offset, $kstart) = ($1, $2);
        }
        $parm{1}    .= "~~$line";

    } elsif ($state == 3 && ($line =~ m{\A\}}                               )) {
    	my $callcode = "genet";
    	$callcode .= "f" if defined($parm{2});
    	$callcode .= "g" if defined($parm{3});
    	$callcode .= "h" if defined($parm{4});
    	$callcode =~ s{fgh}{}; # "genet" only
        $state       = 0; # proper end of class
        print join("\t", $aseqno, $callcode, $offset
            , $parm{1} || "", $parm{2} || "", $parm{3} || "", $parm{3} || ""
            , $kstart) . "\n"; # write the seq4 record

    } elsif ($state == 3 && ($line =~ m{\A  protected Z(\[\])? advance(\w)} )) {
        $state       = 4;
        $code        = $2;
        $parmno      = ($code =~ tr{fgh}{234});
    } elsif ($state == 4 && ($line =~ m{\A +return([^\;]+)}                 )) {
        my $ret      = $1;
        $ret =~ s{( new Z\[\] \{ | *\})}{}g;
        $parm{$parmno} = $ret;
    } elsif ($state == 4 && ($line =~ m{\A +\}}                             )) {
        $state       = 3;
    } else {
        # ignore
    }
} # while <>
__DATA__
A265833	genetgh	0	~~    ~~super($(OFFSET), 1);~~mNextH = advanceH(mKh);	Z.ONE	Z.valueOf((5*mKh-3))	Z.valueOf((5*k-3))	1	1/(1-(5*k-3)*x^(5*k-3))	1	1/(1-(5*k-3)*x^(5*k-3))	Expansion of Product_{k>=1} 1/(1 - (5*k-3)*x^(5*k-3)).

package irvine.oeis.a265;
// Generated by gen_seq4.pl genetgh at 2020-12-16 11:03
// DO NOT EDIT here!

import irvine.math.z.Z;
import irvine.oeis.transform.GeneralizedEulerTransform;


/**
 * A265833 Expansion of Product_{k&gt;=1} 1/(1 - (5*k-3)*x^(5*k-3)).
 * G.f.: <code>Product_{k&gt;=1} (1/(1-(5*k-3)*x^(5*k-3)))</code>
 * @author Georg Fischer
 */
public class A265833 extends GeneralizedEulerTransform {

  /** Construct the sequence. */
  public A265833() {
    super(0, 1);
    mNextH = advanceH(mKh);
  }

  @Override
  protected Z advanceG(final long k) {
    return Z.valueOf(5 * mKh - 3);
  }

  @Override
  protected Z advanceH(final long k) {
    return Z.valueOf(5 * k - 3);
  }

}

# genet.jpat:
package irvine.oeis.$(PACK);
// Generated by $(GEN) $(CALLCODE) at $(DATE)

import irvine.math.z.Z;
import irvine.oeis.transform.GeneralizedEulerTransform;

/**
 * $(ASEQNO) $(NAME)
 * G.f.: <code>Product_{k&gt;=$(PARM5)} ($(PARM6))</code>
 * @author $(AUTHOR)
 */
public class $(ASEQNO) extends GeneralizedEulerTransform {

  /** Construct the sequence. */
  public $(ASEQNO)() {
$(PARM1)
  }

  @Override
  protected Z[] advanceF(final long k) {
    return new Z[] { $(PARM2) };
  }

  @Override
  protected Z advanceG(final long k) {
    return $(PARM3);
  }

  @Override
  protected Z advanceH(final long k) {
    return $(PARM4);
  }

}